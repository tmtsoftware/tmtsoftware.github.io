{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Gateway UI Application Tutorial"},{"location":"/index.html#gateway-ui-application-tutorial","text":"For TMT, many highly functional user interfaces can be written that do not require their own backend logic; that is, while running, they only need to access existing HTTP services, such as CSW Services like the Location Service and the Configuration Service, and the ESW UI Gateway, which provides HTTP access to components and other CSW Services.\nThe services which are provided by the UI Gateway include:\nCommand Service (sending commands to Assemblies and HCDs) Sequencer Service (sending sequences to a Sequencer) Event Service Alarm Service Admin Service Logger Service\nThese applications are called “Gateway UI Apps” and are contrasted with “Web Apps”, which in our context implies custom backend logic. Despite the name, Gateway UI Apps may interact with other existing HTTP services along with the UI Gateway. The distinction is that is does not require its own HTTP service to operate, other that something to serve the pages. In fact, the ESW Gateway UI template can be used to create UI apps that do not use the Gateway, although that is the intention, as the template will set up the necessary wiring for it.","title":"Gateway UI Application Tutorial"},{"location":"/index.html#tutorial-welcome","text":"This tutorial uses a set of smaller tutorials to create a UI Application using the ESW Gateway UI template. The application created in this tutorial has 2 example features.\nCreating a command in the UI using a form, and submitting the command to an assembly/HCD. Subscribing to an event and displaying the event content on the UI when the event is received.\nThe tutorial has been divided into 3 main flows. First, you will create the application using the tutorial, set up a simple login component, and run the bare-bones version of the app. Next, the form for creating a command is added, and you will learn how to send the command to a component through the gateway. Lastly, it will be demonstrated how to subscribe to an Event via the Gateway and display the result in the UI.\nAn additional flow is provided to show how to add documentation to your UI.\nIf at any point in time you want to see the completed tutorial, you can view the final code here.\nCreating Gateway UI Application Adding a Submit Command Adding Event Subscription Adding Paradox Documentation","title":"Tutorial Welcome"},{"location":"/flows/base-flow.html","text":"","title":"Creating Gateway UI Application"},{"location":"/flows/base-flow.html#creating-gateway-ui-application","text":"This flow demonstrates how to use the template to create our project, how to add UI components for adding particular features, and how to build and test it.","title":"Creating Gateway UI Application"},{"location":"/flows/base-flow.html#generate-application","text":"First we need to generate a scaffolding application using our giter8 template:\ng8 tmtsoftware/esw-gateway-ui-template.g8 --project_name=sample\nThis will generate a sample folder with docs and src folders. For a sanity check, let’s go ahead and build the frontend created by the template. This will also help ensure you have the necessary tools installed.","title":"Generate Application"},{"location":"/flows/base-flow.html#compile-the-frontend","text":"The sample/src sub-folder is where your frontend application is located. It uses Typescript, React and node. Make sure node version v16.0.0 or higher is installed in your machine. Let’s compile our generated application.\ncd sample\nnpm install\nnpm start\nYou will be greeted with the following screen.\nNote This tutorial uses the current ESW.UISTD selections for user interface languages, libraries, and tools. These selections will be reviewed and updated once again as part of ESW Phase 2.","title":"Compile the Frontend"},{"location":"/flows/base-flow.html#open-in-development-environment","text":"At this point, you may want to open the project in an Integrated Development Environment (IDE), such as Intellij, if you are using one. The template creates a Typescript/npm-based frontend. We recommend VS Code or Intellij.\nTo open the UI project in VS Code, click on File->Open. To open the UI project in Intellij, click on File->New Project from Existing Sources\nThen browse to the UI directory, open the sample project. It should have a package.json file in it.","title":"Open in Development Environment"},{"location":"/flows/base-flow.html#create-the-ui","text":"In this section, we will begin constructing our browser-based UI using React components in Typescript. We will start by adding a login component.\nNote The frontend tutorial uses functionality from the ESW-TS library. The documentation for ESW-TS can be useful when building your UI. ESW-TS documentation can be found here.","title":"Create the UI"},{"location":"/flows/base-flow.html#create-login-component","text":"Use of the TMT Command Service via the UI Gateway requires authentication. The user must login via the TMT AAS login page, so we will add a login component from the ESW-TS library. Create a Login.tsx file in the src/components folder which will redirect the user to the TMT login page. Later we will use this Login Component in Main.tsx.\nCopy the full snippet shown below & paste it in Login.tsx\nTypescript copysourceimport React, { useEffect } from 'react'\nimport { useAuth } from '../hooks/useAuth'\n\nexport const Login = (): JSX.Element => {\n  const { login } = useAuth()\n\n  useEffect(login, [login])\n\n  return <div>Loading...</div>\n}","title":"Create login component"},{"location":"/flows/base-flow.html#update-main-app-component-with-authentication","text":"First, add the component to our UI by updating the Main.tsx component in /src/components.\nCopy the full snippet shown below and replace the contents in Main.tsx.\nTypescript copysourceimport * as React from 'react'\nimport { useAuth } from '../hooks/useAuth'\nimport { Login } from './Login'\nexport const Main = (): JSX.Element => {\n  const { auth } = useAuth()\n  if (!auth) return <div>Loading</div>\n  const isAuthenticated = auth?.isAuthenticated() ?? false\n\n  return isAuthenticated ? (\n    <div\n      style={{\n        display: 'flex',\n        placeContent: 'space-around',\n        paddingTop: '2rem'\n      }}>\n      Hello world\n    </div>\n  ) : (\n    <Login />\n  )\n}\nHere, you will see that there is a check to see if the user is authenticated, and if not, the login component will be shown. If the user is authenticated, the normal functionality of the app is presented, which right now, is just the Hello World page.\nIn order for our main component to have access to authentication logic from ESW-TS, we need to add a context provider to the component. We do this when the component is constructed at the top level. We will wrap our Main application with AuthContextProvider from esw-ts in App.tsx as shown below\nCopy the snippet within the return statement from the following & update App.tsx.\nTypescript copysourceimport {\n  AuthContextProvider,\n  LocationService,\n  loadGlobalConfig\n} from '@tmtsoftware/esw-ts'\nconst App = (): JSX.Element => {\n  // ..\n  // ..\n  const { error, data: initialised } = useQuery(() =>\n    loadGlobalConfig().then(() => true)\n  )\n  return initialised ? (\n    <div>\n      <LocationServiceProvider locationService={locationService}>\n        <Router basename={basename}>\n          <AuthContextProvider>\n            <Main />\n          </AuthContextProvider>\n        </Router>\n      </LocationServiceProvider>\n    </div>\n  ) : (\n    <div>Loading...</div>\n  )\n}\nAfter adding this section, run the following command to see the progress that we made till now.\nnpm start\nYou should now see Loading... on the browser screen.\nThis is because the UI is now trying to find the AAS authorization server, but we have not yet started CSW services. We will start them now, as well as the UI Gateway which will be needed for our subsequent flows.","title":"Update Main & App component with authentication"},{"location":"/flows/base-flow.html#starting-backend-services","text":"Start the Location Service with the Authorization and Authentication Service, Config Service & the Event Service.\ncs install csw-services\ncsw-services start -k -c -e\nStart the UI Gateway Service using esw-services.\ncs install esw-services\nesw-services start -g\nNow try reloading the front end in browser. If the page is still up, refresh the page. If you closed it, restart the server using:\nnpm start\nYou should be getting redirected to keycloak login page.\nTry logging in with one of predefined users in csw-services.\nVisit here to find the predefined users.\nVisit here to know more about users & the roles.\nOnce you are logged in, you would be greeted again with Hello world.\nNow, we can make use of authorization data to send a request to a protected route of the Gateway server.","title":"Starting backend services"},{"location":"/flows/base-flow.html#cleanup","text":"We can get rid of the unwanted css generated from the template:\nGo to the components folder in src and delete Main.module.css file in this directory","title":"Cleanup"},{"location":"/flows/base-flow.html#next-steps","text":"Follow the tutorial here to add the Submit Command functionality. Follow the tutorial here to add the Subscribe Event functionality.","title":"Next Steps"},{"location":"/flows/submit-commands.html","text":"","title":"Adding a Submit Command"},{"location":"/flows/submit-commands.html#adding-a-submit-command","text":"In this part of the tutorial, we want to send a Setup Command to an Assembly from the UI application via Gateway server.\nVisit here to learn more about commands.\nVisit here to learn more about components.","title":"Adding a Submit Command"},{"location":"/flows/submit-commands.html#start-an-assembly-using-esw-shell","text":"We will use the esw-shell utility to create and start a simple Assembly. The esw-shell is a REPL application that provides numerous tools for TMT programming. Visit here to learn more about the esw-shell utility.\ncs install esw-shell\nesw-shell start \n@                 // you are inside ammonite repl now\nWe will use an esw-shell feature that allows the dynamic creation of component by specifying command handler functionality when spawning the component.\nOur assembly will take a sleep command with sleepInSeconds (LongKey) parameter. This is a long-running command which will return a Started response immediately and then a Completed response after sleeping the time provided in the parameter. Any other command other than sleep immediately returns a Completed response.\nRun this command inside esw-shell’s ammonite shell:\nspawnAssemblyWithHandler(\n      \"ESW.defaultAssembly\",\n      (ctx, cswCtx) =>\n        new DefaultComponentHandlers(ctx, cswCtx) {\n          override def onSubmit(runId: Id, controlCommand: ControlCommand): CommandResponse.SubmitResponse = {\n            controlCommand.commandName.name match {\n              case \"sleep\" =>\n                val defaultSleepParam = LongKey.make(\"sleepInSeconds\").set(5)\n                val sleepParam = controlCommand.paramType.get(\"sleepInSeconds\", LongKey).getOrElse(defaultSleepParam)\n                cswCtx.timeServiceScheduler.scheduleOnce(UTCTime(UTCTime.now().value.plusSeconds(sleepParam.value(0)))) {\n                  cswCtx.commandResponseManager.updateCommand(CommandResponse.Completed(runId))\n                }\n                CommandResponse.Started(runId)\n              case _ => CommandResponse.Completed(runId)\n            }\n          }\n        }\n    )\nThis should start an assembly with prefix ESW.defaultAssembly.","title":"Start an Assembly using esw-shell"},{"location":"/flows/submit-commands.html#add-submit-command-component","text":"Assuming that you have followed the basic flow, we can go further and add functionality to the UI to submit a command to our assembly.\nCreate the file SubmitCommand.tsx in the src/components folder.\nCopy the following code into SubmitCommand.tsx:\nTypescript copysourceimport {\n  CommandService,\n  ComponentId,\n  longKey,\n  Observe,\n  Prefix,\n  Setup\n} from '@tmtsoftware/esw-ts'\nimport type { SubmitResponse } from '@tmtsoftware/esw-ts'\nimport {\n  Badge,\n  Button,\n  Card,\n  Divider,\n  Form,\n  Input,\n  message,\n  Select,\n  Typography\n} from 'antd'\nimport type { PresetColorType } from 'antd/lib/_util/colors'\nimport React, { useState } from 'react'\nimport { useAuth } from '../hooks/useAuth'\n\nconst getResultType = (\n  resultType: SubmitResponse['_type']\n): PresetColorType => {\n  switch (resultType) {\n    case 'Started':\n      return 'yellow'\n    case 'Completed':\n      return 'green'\n    case 'Cancelled':\n      return 'yellow'\n    default:\n      return 'red'\n  }\n}\n\nexport const SubmitCommand = ({\n  _commandService\n}: {\n  _commandService?: CommandService\n}): JSX.Element => {\n  const { auth } = useAuth()\n  const authData = { tokenFactory: () => auth?.token() }\n\n  const [prefix, setPrefix] = useState<string>('')\n  const [command, setCommand] = useState<string>('')\n  const [sleepTime, setSleepTime] = useState<number>()\n  const [result, setResult] = useState<SubmitResponse>()\n  const [commandType, setCommandType] = useState<'Setup' | 'Observe'>('Setup')\n  const [componentType, setComponentType] = useState<'HCD' | 'Assembly'>(\n    'Assembly'\n  )\n\n  const submit = async () => {\n    try {\n      const sleepInMs = longKey('sleepInSeconds').set([\n        sleepTime ? sleepTime : 0\n      ])\n      const commandService = _commandService\n        ? _commandService\n        : await CommandService(\n            new ComponentId(Prefix.fromString(prefix), componentType),\n            authData\n          )\n\n      const _command =\n        commandType === 'Observe'\n          ? new Observe(Prefix.fromString(prefix), command, [sleepInMs])\n          : new Setup(Prefix.fromString(prefix), command, [sleepInMs])\n\n      const result = await commandService.submit(_command)\n\n      switch (result._type) {\n        case 'Started':\n          setResult(result)\n          const res = await commandService.queryFinal(result.runId, 5)\n          setResult(res)\n          break\n        default:\n          setResult(result)\n          break\n      }\n    } catch (e) {\n      message.error((e as Error).message)\n      setResult(undefined)\n    }\n  }\n\n  return (\n    <Card\n      style={{\n        maxWidth: '30rem',\n        maxHeight: '45rem'\n      }}\n      title={\n        <Typography.Title level={2}>Submit Command Example</Typography.Title>\n      }>\n      <Form>\n        <Form.Item label='Command Type' required>\n          <Select\n            id='commandType'\n            value={commandType}\n            onChange={(e) => setCommandType(e)}>\n            <Select.Option value='Setup'>Setup</Select.Option>\n            <Select.Option value='Observe'>Observe</Select.Option>\n          </Select>\n        </Form.Item>\n        <Form.Item label='Component Type' required>\n          <Select\n            id='componentType'\n            value={componentType}\n            onChange={(e) => setComponentType(e)}>\n            <Select.Option value='HCD'>HCD</Select.Option>\n            <Select.Option value='Assembly'>Assembly</Select.Option>\n          </Select>\n        </Form.Item>\n        <Form.Item label='Prefix' required>\n          <Input\n            role='Prefix'\n            value={prefix}\n            placeholder='ESW.defaultAssembly'\n            onChange={(e) => setPrefix(e.target.value)}\n          />\n        </Form.Item>\n        <Form.Item label='Command Name' required>\n          <Input\n            role='commandName'\n            value={command}\n            placeholder='noop'\n            onChange={(e) => setCommand(e.target.value)}\n          />\n        </Form.Item>\n        <Form.Item label='Sleep' hidden={command !== 'sleep'}>\n          <Input\n            role='sleep'\n            value={sleepTime}\n            placeholder='Enter value in terms of milliseconds'\n            type='number'\n            onChange={(e) => setSleepTime(Number(e.target.value))}\n          />\n        </Form.Item>\n        <Form.Item wrapperCol={{ offset: 16, span: 16 }}>\n          <Button\n            role='Submit'\n            type='primary'\n            onClick={submit}\n            disabled={prefix === '' || command === ''}>\n            Submit\n          </Button>\n        </Form.Item>\n      </Form>\n      <Divider />\n      <Typography.Title level={2}>Result</Typography.Title>\n      <Typography.Paragraph>\n        {result && (\n          <Badge.Ribbon\n            color={getResultType(result._type)}\n            style={{ width: '0.75rem', height: '0.75rem' }}>\n            <pre role='result'>{JSON.stringify(result, null, 4)}</pre>\n          </Badge.Ribbon>\n        )}\n      </Typography.Paragraph>\n    </Card>\n  )\n}\nThere is a lot to unpack here, so we will describe the code in sections.\nWithin the return statement, we specify a <Card> component to be the root component of our form. Here we provide some styling as well as titles for our sections, and a section at the bottom to display the result. The form for composing the command in encoded in a <Form> component. Within it, we have the following components:\nCommandType - A Selectable with Options(Setup/Observe) ComponentType - A Selectable with Options(Assembly/HCD) Prefix - A Text Input (user to put Appropriate Prefix of our Assembly) Command - A Text Input (user to put command sleep or anything else) Sleep - A Optional field visible only when command is sleep (Time to sleep in seconds). Submit - A Button to submit command.\nIn the definition of the SubmitCommand object near the top of the file, we define React state hooks to store the values specified in our form.\nTypescript copysourceconst [prefix, setPrefix] = useState<string>('')\nconst [command, setCommand] = useState<string>('')\nconst [sleepTime, setSleepTime] = useState<number>()\nconst [result, setResult] = useState<SubmitResponse>()\nconst [commandType, setCommandType] = useState<'Setup' | 'Observe'>('Setup')\nconst [componentType, setComponentType] = useState<'HCD' | 'Assembly'>(\n  'Assembly'\n)\nThe definition of each state specifies a tuple that gives the name of variable to hold the value, and the name of the setter method for that state variable. These are used in each corresponding Form component in the value and onChange attributes.\nNext, note the submit method defined after the command state hooks. This defines the action to be called when the Submit button is clicked. This is linked to the Button component in the onFinish attribute.\nTypescript copysourceconst submit = async () => {\n  try {\n    const sleepInMs = longKey('sleepInSeconds').set([\n      sleepTime ? sleepTime : 0\n    ])\n    const commandService = _commandService\n      ? _commandService\n      : await CommandService(\n          new ComponentId(Prefix.fromString(prefix), componentType),\n          authData\n        )\n\n    const _command =\n      commandType === 'Observe'\n        ? new Observe(Prefix.fromString(prefix), command, [sleepInMs])\n        : new Setup(Prefix.fromString(prefix), command, [sleepInMs])\n\n    const result = await commandService.submit(_command)\n\n    switch (result._type) {\n      case 'Started':\n        setResult(result)\n        const res = await commandService.queryFinal(result.runId, 5)\n        setResult(res)\n        break\n      default:\n        setResult(result)\n        break\n    }\n  } catch (e) {\n    message.error((e as Error).message)\n    setResult(undefined)\n  }\nThis method makes use of the Command Service Typescript client which provides access to the Command Service routes in the Gateway. It constructs the appropriate command from the form and submits it to the Assembly as specified by the Prefix field. It then gets the results and calls the SetResult state hook setter. This causes the result to be displayed in the result component, which we defined at the bottom of the Card component:\nTypescript copysource<Typography.Title level={2}>Result</Typography.Title>\n<Typography.Paragraph>\n  {result && (\n    <Badge.Ribbon\n      color={getResultType(result._type)}\n      style={{ width: '0.75rem', height: '0.75rem' }}>\n      <pre role='result'>{JSON.stringify(result, null, 4)}</pre>\n    </Badge.Ribbon>\n  )}\n</Typography.Paragraph>\nWe provide additional functionality to help track result status by color coding a small flag in result component based on its type. Note that the color of the flag depends on the evaluation of a method we define at the top of the file, which returns the appropriate color based on the result type. This function goes outside of the component because it is independent of React component’s state.\nTypescript copysourceconst getResultType = (\n  resultType: SubmitResponse['_type']\n): PresetColorType => {\n  switch (resultType) {\n    case 'Started':\n      return 'yellow'\n    case 'Completed':\n      return 'green'\n    case 'Cancelled':\n      return 'yellow'\n    default:\n      return 'red'\n  }\n}","title":"Add Submit Command Component"},{"location":"/flows/submit-commands.html#integrate-submitcommand-component","text":"Finally, update Main.tsx to include SubmitCommand component.\nReplace the Hello World text with our component, <SubmitCommand />, below div’s style tag, and add the necessary import.\nTypescript copysourceexport const Main = (): JSX.Element => {\n  const { auth } = useAuth()\n  if (!auth) return <div>Loading</div>\n  const isAuthenticated = auth?.isAuthenticated() ?? false\n\n  return isAuthenticated ? (\n    <div\n      style={{\n        display: 'flex',\n        placeContent: 'space-around',\n        paddingTop: '2rem'\n      }}>\n      <SubmitCommand />\n    </div>\n  ) : (\n    <Login />\n  )\n}\nUI should render the following view at this moment.\nFill in the values for all input fields and submit.\nprefix : ESW.defaultAssembly\ncommand : sleep\nsleep : 2\nThe UI should be updated with the following results.\nFirst the UI receives Started response.\nAnd after 2 seconds, the Completed response is received.\nFollow the tutorial here to add the Subscribe Event functionality.","title":"Integrate SubmitCommand Component"},{"location":"/flows/subscribe-event.html","text":"","title":"Adding Event Subscription"},{"location":"/flows/subscribe-event.html#adding-event-subscription","text":"In this part of the tutorial, we want to add the ability to subscribe to an Event published through the Event Service and display the results. We will be using the esw-shell utility to publish a SystemEvent every 2 seconds to the Event Service.\nThis section of the app will display a form at the top to specify which event to subscribe to and a table below it showing a list of received values.\nVisit here to learn more about events.","title":"Adding Event Subscription"},{"location":"/flows/subscribe-event.html#add-a-subscribe-event-component","text":"Create a SubscribeEvent.tsx file in src/components folder.\nIn this tutorial, we will build up the SubscribeEvent component gradually.\nNote You can refer the source code of the completed application at any point in the course of this tutorial. You can find it here\nStart with the following code, which defines the component, enables authorization, and creates a base Card component to put our other components in.\nTypescript copysourceexport const SubscribeEvent = ({\n  _eventService\n}: {\n  _eventService?: EventService\n}): JSX.Element => {\n  const { auth } = useAuth()\n  const authData = { tokenFactory: () => auth?.token() }\n  return (\n    <Card\n      style={{\n        maxWidth: '30rem',\n        maxHeight: '45rem'\n      }}\n      title={\n        <Typography.Title level={2}>Subscribe Event Example</Typography.Title>\n      }>\n    </Card>\n  )\n}\nNext, we will add a form to take input from the user.\nAdd the following in the SubscribeEvent component inside the <Card> component just below the title attribute.\nTypescript copysource<Form\n  onFinish={() => {\n    subscription ? unSubscribe() : subscribe()\n  }}>\n  <Form.Item label='Source Prefix'>\n    <Input\n      role='SourcePrefix'\n      value={prefix}\n      placeholder='ESW.assembly123'\n      onChange={(e) => setPrefix(e.target.value)}\n    />\n  </Form.Item>\n  <Form.Item label='Event Keyname'>\n    <Input\n      role='keyName'\n      value={keyName}\n      placeholder='counterEvent'\n      onChange={(e) => setKeyName(e.target.value)}\n    />\n  </Form.Item>\n  <Form.Item wrapperCol={{ offset: 16, span: 16 }}>\n    <Button\n      role='subscribe'\n      onClick={() => (subscription ? unSubscribe() : subscribe())}\n      type='primary'\n      disabled={keyName === ''}>\n      {subscription ? 'UnSubscribe' : 'Subscribe'}\n    </Button>\n  </Form.Item>\n</Form>\nThis Form includes the following items:\nSourcePrefix - A free text input box for putting Source Prefix of the desired subscription. Event KeyName - A free text input box for putting Event’s keyname of the desired subscription. Subscribe - A button for creating subscription. It gets toggled to UnSubscribe on when the subscription is successfully started.\nNext, we will add the React state hooks for storing and setting the values of these components:\nAdd the following snippet in the SubscribeEvent component below the authData react state, above the return statement.\nTypescript copysourceconst [prefix, setPrefix] = useState('')\nconst [keyName, setKeyName] = useState('')\nconst [events, setEvents] = useState<Event[]>([])\nconst [subscription, setSubscription] = useState<Subscription>()\nThe onFinish attribute of the form component specifies the method to be called when the form is submitted. We have specified this to be the subscribe method. We will implement this now.\nThis method makes use of the ESW-TS Event Service Typescript client which provides access to the Event Service through the Event Service routes of the Gateway. In this method, we call the subscribe API of the Event Service to create a subscription using a callback. The callback method handleEvent, defined at the top of this block, gets triggered whenever an event is received on that subscription.\nWe also define an unsubscribe function which cancels the subscription through the ESW-TS client.\nDefine these functions following the React state hooks inside component.\nTypescript copysourceconst handleEvent = (event: Event) => {\n  if (event.eventId !== '-1') {\n    setEvents((events) => [...events, event])\n  } else {\n    message.error(`Event: ${event.eventName.name} is invalid`)\n  }\n}\nconst unSubscribe = () => {\n  subscription?.cancel()\n  setSubscription(undefined)\n}\nconst subscribe = async () => {\n  const eventServices = _eventService\n    ? _eventService\n    : await EventService(authData)\n\n  const subscription = eventServices.subscribe(\n    new Set([\n      new EventKey(Prefix.fromString(prefix), new EventName(keyName))\n    ]),\n    1\n  )(handleEvent)\n  setSubscription(subscription)\n}\nNow we have fully added the functionality of subscribing to an event. The events state variable maintains a list of all received events, so events received in the callback are added to this list.\nWe will use an Antd Table component to display the values in the event state variable.\nFirst, we will define the columns in the table. Add the following code above the return statement:\nTypescript copysourceconst columns = [\n  {\n    title: 'Event Name',\n    dataIndex: 'eventName',\n    render: (eventName: EventName) => eventName.name\n  },\n  {\n    title: 'Values',\n    // eslint-disable-next-line react/display-name\n    render: (_: string, event: Event) => {\n      const counterParam = event.get(intKey('counter')) ?? { values: [] }\n      return <span>{counterParam.values.join(',')}</span>\n    }\n  }\n]\nAdd this final piece to our UI component below the Form component to visualize the received events.\nTypescript copysource<Table\n  scroll={{ y: 240 }}\n  pagination={false}\n  rowKey={(e) => e.eventId}\n  dataSource={events}\n  columns={columns}\n/>\nAt this point, make sure to add appropriate imports to the file. The should look something like this:\nTypescript copysourceimport {\n  EventKey,\n  EventName,\n  EventService,\n  intKey,\n  Prefix\n} from '@tmtsoftware/esw-ts'\nimport type { Event, Subscription } from '@tmtsoftware/esw-ts'\nimport {\n  Button,\n  Card,\n  Divider,\n  Form,\n  Input,\n  message,\n  Table,\n  Typography\n} from 'antd'\nimport React, { useState } from 'react'\nimport { useAuth } from '../hooks/useAuth'","title":"Add a Subscribe Event Component"},{"location":"/flows/subscribe-event.html#integrate-subscribeevent-component","text":"Finally, update Main.tsx to include SubscribeEvent component.\nAdd the following <SubscribeEvent /> immediately after the <SubmitCommand /> component inside <div>. Update imports as needed.\nTypescript copysourceimport { SubscribeEvent } from './SubscribeEvent'\nexport const Main = (): JSX.Element => {\n  const { auth } = useAuth()\n  if (!auth) return <div>Loading</div>\n  const isAuthenticated = auth?.isAuthenticated() ?? false\n\n  return isAuthenticated ? (\n    <div\n      style={{\n        display: 'flex',\n        placeContent: 'space-around',\n        paddingTop: '2rem'\n      }}>\n      <SubmitCommand />\n      <SubscribeEvent />\n    </div>\n  ) : (\n    <Login />\n  )\n}\nThe UI should now render the following view.\nFill in the values for the input fields and hit subscribe.\nSource Prefix : ESW.assembly123\nEvent KeyName : counterEvent\nYou may see an Invalid Event warning the first time you run this. This is expected because the Event has not yet been published with valid data. This can be ignored.\nNow, let’s simulate a component publishing some events and see them reflected in the UI in real-time.","title":"Integrate SubscribeEvent Component"},{"location":"/flows/subscribe-event.html#publish-events-using-esw-shell","text":"If necessary, start the esw-shell utility.\ncs install esw-shell\nesw-shell start \n@                 // you are inside ammonite repl now\nVisit here to learn more about the esw-shell utility.\nWe are using the Event Service defaultPublisher API provided in the shell to publish events.\n@ var counter = 0\n@ def eventGenerator = Option{\n    counter+=1\n    SystemEvent(Prefix(\"ESW.assembly123\"), EventName(\"counterEvent\"), Set(IntKey.make(\"counter\").set(counter)))\n  }\n@ eventService.defaultPublisher.publish(eventGenerator, 2.seconds)\nThis should start publishing events every 2 seconds from the source prefix ESW.assembly123.\nUI should now start showing events. You may need to scroll down to see new events.","title":"Publish events using esw-shell"},{"location":"/flows/docs-flow.html","text":"","title":"Adding Paradox Documentation"},{"location":"/flows/docs-flow.html#adding-paradox-documentation","text":"The section of the tutorial describes how to write documentation for your application using paradox. Documentation is written in GitHub-flavored markdown, which is documented here","title":"Adding Paradox Documentation"},{"location":"/flows/docs-flow.html#pre-requisite","text":"Your application code is checked in some repo in your organization GitHub account.","title":"Pre-requisite"},{"location":"/flows/docs-flow.html#documentation-development-flow","text":"The sample application generated from the template contains a docs folder. This is where you will write the documentation files for your project. The build.sbt file contains the setup for this docs sbt project.\nLaunch sbt from your console and run command makeSite to construct the documentation pages. Then run the command openSite to open the generated docs in your default browser.\nsbt\nsbt:sample> makeSite\nsbt:sample> openSite\nYou can modify the various .md files present in docs folder and repeat the steps above and verify your generated documentation. Refer to the Paradox documentation to learn more about the documentation system.","title":"Documentation Development Flow"},{"location":"/flows/docs-flow.html#documentation-publish-flow","text":"The template sets your project up to publish your documentation to GitHub using GitHub Pages. You need to specify the URL of your GitHub repo in the variable githubRepoUrl in your top-level build.sbt file. This allows Paradox to use a special branch, gh-pages, in your GitHub repository to keep track of your documentation.\nExecute reload in sbt so that updated URL is available in sbt.\nsbt:sample> reload\nCreate the gh_pages branch in your repo following these quick steps. Verify that you see a new branch gh_pages in your GitHub repository with an empty commit.\nThen, you can run the command ghpagesPushSite, to publish your documentation.\nsbt:sample> ghpagesPushSite\nVerify that you see a new commit in branch gh_pages, and branch should contain a folder with name 0.1.0-SNAPSHOT\nOpen your published site using URL, http://{your-username}.github.io/{your-project}/0.1.0-SNAPSHOT/","title":"Documentation Publish Flow"}]}