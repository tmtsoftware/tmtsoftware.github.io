{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"ESW UI Application Tutorial"},{"location":"/index.html#esw-ui-application-tutorial","text":"In the ESW user interface design, a Gateway-UI template is used when the user interface has to make use of the interfaces of the control system provided by the User Interface Gateway. For instance, a UI application should be used if Services behind Gateway server needs to be accessed.\nServices which are behind the Gateway server are among these :\nCommand Service Sequencer Service Event Service Alarm Service Admin Service Logger Service\nCreating a UI application is not trivial and requires the programmer to understand several technologies as well as the ESW authentication and authorization system. Therefore, it is recommended that this approach be taken only when necessary.","title":"ESW UI Application Tutorial"},{"location":"/index.html#tutorial-welcome","text":"This tutorial uses a set of smaller tutorials to create a UI Application using the ESW Gateway UI template. This template is meant to be used when developers want to create application’s which talks with gateway server only.\nThe application created in this tutorial has 2 example features.\nSubmmiting a command to an assembly/HCD by giving appropriate values in the UI form. Subscribing to an event and display the event’s content on the UI as soon as the event is received.\nThe tutorial has been divided into 3 main flows that incrementally demonstrate the addition of both the above 2 features using the interfaces of Gateway server.\nThe basic flow in “Creating a UI Application” will show you how to add a route to the backend application and consume them in your frontend. The flows following the basic flow are incremental steps to make the application more complete.\nIf at any point in time you want to see the completed tutorial, you can view the final code here.\nCreating a Web Application Adding Submit Command Example Adding Subscribing An Event Example Adding Paradox Documentation","title":"Tutorial Welcome"},{"location":"/flows/base-flow.html","text":"","title":"Creating a Web Application"},{"location":"/flows/base-flow.html#creating-a-web-application","text":"This flow demonstrates how to use the template to create our project, how to add UI components for adding particular features, and how to build and test it.\nIn this tutorial, we will first generate the application from the template, and build it to ensure tools are in place. Then, we will delete the default implementation and replace it with our own implementation of a Submit command to an assembly & Subscribe to an event UI component. To do this, we will delete much of the template code and rewrite our own components custom to our implementation.","title":"Creating a Web Application"},{"location":"/flows/base-flow.html#generate-application","text":"First we need to generate a scaffolding application using our giter8 template:\ng8 tmtsoftware/esw-ui-template.g8 --name=sample\nThis will generate a sample folder with docs and src folders. For a sanity check, let’s go ahead and build the frontend created by the template. This will also help ensure you have the necessary tools installed.\nYou are welcome to try out the generated sample project, which is basically a “Hello World” application, by following the instructions in the READMEs in each sub-folder.","title":"Generate Application"},{"location":"/flows/base-flow.html#compile-the-frontend","text":"The sample/src sub-folder is where your frontend application is located. It uses Typescript, React and node. Make sure node version v16.0.0 or higher is installed in your machine. Let’s compile our generated application.\ncd sample\nnpm install\nnpm run build\nNote This tutorial uses the current ESW.UISTD selections for user interface languages, libraries, and tools. These are the current selections. They will be reviewed and updated once again as part of ESW Phase 2.","title":"Compile the Frontend"},{"location":"/flows/base-flow.html#open-in-development-environment","text":"At this point, you may want to open the project in an Integrated Development Environment (IDE), such as Intellij, if you are using one. The template creates a Typescript/npm-based frontend. We recommend VS Code or Intellij for the frontend applications.\nTo open the UI project in VS Code, click on File->Open Or To open the UI project in Intellij, click on File->New Project from Existing Sources\nThen browsing to the UI directory, open the sample project. It should have a package.json file in it.","title":"Open in Development Environment"},{"location":"/flows/base-flow.html#create-the-frontend","text":"In this section, we will be constructing a browser-based UI using React components in Typescript. We will create components that allow the user to specify various inputs in a form (e.g Setup/Observe command to be sent an Assembly or an HCD via select html tags), and then the a Submit button that will send the data to our backend. The response will then be rendered in UI components. We will also provide components to get and display the list of stored coordinates. This section of the tutorial will show how to add and render custom components within the application that act as clients to consume our gateway backend routes.\nNote The frontend tutorial uses functionality from the ESW-TS library. Be sure and look at the documentation for ESW-TS once you start working on your own UI. ESW-TS documentation can be found here.","title":"Create the Frontend"},{"location":"/flows/base-flow.html#create-login-component","text":"We need the user to login via keycloak’s login page. So we need to have a way to redirect the user. hence, Add the Login.tsx in components folder which will redirect the user to keycloak’s login page. Later we will use this Login Component in Main.tsx.\nTypescript copysourceimport React, { useEffect } from 'react'\nimport { useAuth } from '../hooks/useAuth'\n\nexport const Login = (): JSX.Element => {\n  const { login } = useAuth()\n\n  useEffect(login, [login])\n\n  return <div>Loading...</div>\n}","title":"Create login component"},{"location":"/flows/base-flow.html#update-main-app-component-with-authentication","text":"First lets wrap our Main application with AuthContextProvider from esw-ts in App.tsx as shown below\nTypescript copysourceimport { AuthContextProvider, LocationService } from '@tmtsoftware/esw-ts'\nconst App = (): JSX.Element => {\n  // ..\n  // ..\n  return (\n    <div>\n      <LocationServiceProvider locationService={locationService}>\n        <Router basename={basename}>\n          <AuthContextProvider>\n            <Main />\n          </AuthContextProvider>\n        </Router>\n      </LocationServiceProvider>\n    </div>\n  )\n}\nNow, lets update the Main.tsx component in our frontend UI to have login functionality.\nTypescript copysourceimport * as React from 'react'\nimport { useAuth } from '../hooks/useAuth'\nimport { Login } from './Login'\nexport const Main = (): JSX.Element => {\n  const { auth } = useAuth()\n  if (!auth) return <div>Loading</div>\n  const isAuthenticated = auth?.isAuthenticated() ?? false\n\n  return isAuthenticated ? (\n    <div\n      style={{\n        display: 'flex',\n        placeContent: 'space-around',\n        paddingTop: '2rem'\n      }}>\n      Hello world\n    </div>\n  ) : (\n    <Login /> // <- add this line\n  )\n}\nAfter adding this section, run the following command to see the progress that we made till now.\nnpm start\nyou must be getting Loading... on the browser screen. Because, The UI is now trying to find the Auth server & we have not yet started any of the required backend services.\nLet’s start the required backend services along with Auth server for further use cases.","title":"Update Main & App component with authentication"},{"location":"/flows/base-flow.html#starting-backend-services","text":"Start the Location Service with the Authorization and Authentication Service, Config Service & Event Service(we will use event service in the next section of the tutorial).\ncs install csw-services:v4.0.0-RC1\ncsw-services start -k -c -e\nStart Gateway Service using esw-services.\ncs install esw-services:0.3.0-RC1\nesw-services start -g\nTry reloading the front end in browser,\nnpm start\nYou should be getting redirected to keycloak login page. Try logging in with one of predefined users in csw-services.\nVisit here to find the predefined users.\nVisit here to know more about users & the roles.\nOnce you are logged in, you would be greeted again with Hello world.\nNow, we can make use of Auth data to send request on the protected route of Gateway server.","title":"Starting backend services"},{"location":"/flows/base-flow.html#cleanup","text":"We can get rid of the unwanted css generated from the template:\nGo to the components folder in src and delete Main.module.css file under this directory","title":"Cleanup"},{"location":"/flows/base-flow.html#next-steps","text":"Follow the tutorial here to add Submit Command Example. Follow the tutorial here to add Subscribe Event Example.","title":"Next Steps"},{"location":"/flows/submit-commands.html","text":"","title":"Adding Submit Command Example"},{"location":"/flows/submit-commands.html#adding-submit-command-example","text":"In this use case, we want to send a command (Setup/Observe) to an Assembly/HCD from the UI application via Gateway server.\nVisit here to learn more about commands.\nVisit here to learn more about Assembly / HCD components.","title":"Adding Submit Command Example"},{"location":"/flows/submit-commands.html#start-an-assembly-using-esw-shell","text":"Before moving ahead, if you have not started backend services. Then let’s start backend services by following this steps.\nNow, lets setup an assembly using esw-shell utility. It starts an ammonite repl with basic api’s for us to orchestrate the backend services.\ncs install esw-shell:0.3.0-RC1\nesw-shell start \n@                 // you are inside ammonite repl now\nVisit here to learn more about the esw-shell utility.\nwe are using this API to start our assembly with our custom handlers.\nThis assembly takes sleep command with sleepInSeconds (LongKey) parameter and returns Started Response immediately and then Completed response after the given sleep value. Any other command other than sleep returns Completed Response.\nRun this command inside esw-shell’s ammonite shell:\nspawnAssemblyWithHandler(\n      \"ESW.defaultAssembly\",\n      (ctx, cswCtx) =>\n        new DefaultComponentHandlers(ctx, cswCtx) {\n          override def onSubmit(runId: Id, controlCommand: ControlCommand): CommandResponse.SubmitResponse = {\n            controlCommand.commandName.name match {\n              case \"sleep\" =>\n                val defaultSleepParam = LongKey.make(\"sleepInSeconds\").set(5)\n                val sleepParam = controlCommand.paramType.get(\"sleepInSeconds\", LongKey).getOrElse(defaultSleepParam)\n                cswCtx.timeServiceScheduler.scheduleOnce(UTCTime(UTCTime.now().value.plusSeconds(sleepParam.value(0)))) {\n                  cswCtx.commandResponseManager.updateCommand(CommandResponse.Completed(runId))\n                }\n                CommandResponse.Started(runId)\n              case _ => CommandResponse.Completed(runId)\n            }\n          }\n        }\n    )\nThis should start an assembly with prefix ESW.defaultAssembly.","title":"Start an Assembly using esw-shell"},{"location":"/flows/submit-commands.html#add-submit-command-component","text":"Assuming that you have followed atleast the basic flow, we can go further and add submiting an command to an assembly feature in our UI.\nAdd SubmitCommand.tsx in src/components folder.\nSubmitCommand.tsx looks like following:\nNote You can refer the source code of the completed application at any point in the course of this tutorial. You can find it here\nTypescript copysourceexport const SubmitCommand = ({\n  _commandService\n}: {\n  _commandService?: CommandService\n}): JSX.Element => {\n  const { auth } = useAuth()\n  const authData = { tokenFactory: () => auth?.token() }\n  return (\n    <Card\n      style={{\n        maxWidth: '30rem',\n        maxHeight: '45rem'\n      }}\n      title={\n        <Typography.Title level={2}>Submit Command Example</Typography.Title>\n      }>\n      <Divider />\n      <Typography.Title level={2}>Result</Typography.Title>\n      <Typography.Paragraph>\n        {result && (\n          <Badge.Ribbon\n            color={getResultType(result._type)}\n            style={{ width: '0.75rem', height: '0.75rem' }}>\n            <pre role='result'>{JSON.stringify(result, null, 4)}</pre>\n          </Badge.Ribbon>\n        )}\n      </Typography.Paragraph>\n    </Card>\n  )\n}\nAdd appropriate imports to the file.\nTypescript copysourceimport {\n  CommandService,\n  ComponentId,\n  longKey,\n  Observe,\n  Prefix,\n  Setup,\n  SubmitResponse\n} from '@tmtsoftware/esw-ts'\nimport {\n  Badge,\n  Button,\n  Card,\n  Divider,\n  Form,\n  Input,\n  message,\n  Select,\n  Typography\n} from 'antd'\nimport type { PresetColorType } from 'antd/lib/_util/colors'\nimport React, { useState } from 'react'\nimport { useAuth } from '../hooks/useAuth'\nLet’s add the Form component’s for the input fields.\nCommandType - A Selectable with Options(Setup/Observe) ComponentType - A Selectable with Options(Assembly/HCD) Prefix - A Text Input (user to put Appropriate Prefix of earlier Started Assembly) Command - A Text Input (user to put command sleep or anything else) Sleep - A Optional field visible only when command is sleep. Submit - A Button to submit command.\nTypescript copysource<Card\n  style={{\n    maxWidth: '30rem',\n    maxHeight: '45rem'\n  }}\n  title={\n    <Typography.Title level={2}>Submit Command Example</Typography.Title>\n  }>\n  <Form>\n    <Form.Item label='Command Type' required>\n      <Select\n        id='commandType'\n        value={commandType}\n        onChange={(e) => setCommandType(e)}>\n        <Select.Option value='Setup'>Setup</Select.Option>\n        <Select.Option value='Observe'>Observe</Select.Option>\n      </Select>\n    </Form.Item>\n    <Form.Item label='Component Type' required>\n      <Select\n        id='componentType'\n        value={componentType}\n        onChange={(e) => setComponentType(e)}>\n        <Select.Option value='HCD'>HCD</Select.Option>\n        <Select.Option value='Assembly'>Assembly</Select.Option>\n      </Select>\n    </Form.Item>\n    <Form.Item label='Prefix' required>\n      <Input\n        role='Prefix'\n        value={prefix}\n        placeholder='ESW.defaultAssembly'\n        onChange={(e) => setPrefix(e.target.value)}\n      />\n    </Form.Item>\n    <Form.Item label='Command Name' required>\n      <Input\n        role='commandName'\n        value={command}\n        placeholder='noop'\n        onChange={(e) => setCommand(e.target.value)}\n      />\n    </Form.Item>\n    <Form.Item label='Sleep' hidden={command !== 'sleep'}>\n      <Input\n        role='sleep'\n        value={sleepTime}\n        placeholder='Enter value in terms of milliseconds'\n        type='number'\n        onChange={(e) => setSleepTime(Number(e.target.value))}\n      />\n    </Form.Item>\n    <Form.Item wrapperCol={{ offset: 16, span: 16 }}>\n      <Button\n        role='Submit'\n        type='primary'\n        onClick={submit}\n        disabled={prefix === '' || command === ''}>\n        Submit\n      </Button>\n    </Form.Item>\n  </Form>\n  <Divider />\n  <Typography.Title level={2}>Result</Typography.Title>\n  <Typography.Paragraph>\n    {result && (\n      <Badge.Ribbon\n        color={getResultType(result._type)}\n        style={{ width: '0.75rem', height: '0.75rem' }}>\n        <pre role='result'>{JSON.stringify(result, null, 4)}</pre>\n      </Badge.Ribbon>\n    )}\n  </Typography.Paragraph>\nAdd the following react states to hold the information of their corresponding user inputs.\nTypescript copysourceexport const SubmitCommand = ({\n  _commandService\n}: {\n  _commandService?: CommandService\n}): JSX.Element => {\n  const { auth } = useAuth()\n  const authData = { tokenFactory: () => auth?.token() }\n\n  const [prefix, setPrefix] = useState<string>('')\n  const [command, setCommand] = useState<string>('')\n  const [sleepTime, setSleepTime] = useState<number>()\n  const [result, setResult] = useState<SubmitResponse>()\n  const [commandType, setCommandType] = useState<'Setup' | 'Observe'>('Setup')\n  const [componentType, setComponentType] = useState<'HCD' | 'Assembly'>(\n    'Assembly'\n  )\nNow finally, add the submit action to be called on Submit button click(i.e. onFinish handle of Form component)\nThis method makes use of command service typescript client which sits on top of the gateway server Command Service routes.\nTypescript copysourceconst [componentType, setComponentType] = useState<'HCD' | 'Assembly'>(\n  'Assembly'\n)\n\nconst submit = async () => {\n  try {\n    const sleepInMs = longKey('sleepInSeconds').set([\n      sleepTime ? sleepTime : 0\n    ])\n    const commandService = _commandService\n      ? _commandService\n      : await CommandService(\n          new ComponentId(Prefix.fromString(prefix), componentType),\n          authData\n        )\n\n    const _command =\n      commandType === 'Observe'\n        ? new Observe(Prefix.fromString(prefix), command, [sleepInMs])\n        : new Setup(Prefix.fromString(prefix), command, [sleepInMs])\n\n    const result = await commandService.submit(_command)\n\n    switch (result._type) {\n      case 'Started':\n        setResult(result)\n        const res = await commandService.queryFinal(result.runId, 5)\n        setResult(res)\n        break\n      default:\n        setResult(result)\n        break\n    }\n  } catch (e) {\n    message.error((e as Error).message)\n    setResult(undefined)\n  }\n}","title":"Add Submit Command Component"},{"location":"/flows/submit-commands.html#render-submitcommand-results","text":"Add this helper function to render color corresponding to the SubmitResponse’s type.\nTip: this function can be defined outside component because it is independent of any component state.\nTypescript copysourceconst getResultType = (\n  resultType: SubmitResponse['_type']\n): PresetColorType => {\n  switch (resultType) {\n    case 'Started':\n      return 'yellow'\n    case 'Completed':\n      return 'green'\n    case 'Cancelled':\n      return 'yellow'\n    default:\n      return 'red'\n  }\n}","title":"Render SubmitCommand result’s"},{"location":"/flows/submit-commands.html#integrate-submitcommand-component","text":"Finally, update Main.tsx to include SubmitCommand component.\nTypescript copysourceexport const Main = (): JSX.Element => {\n  const { auth } = useAuth()\n  if (!auth) return <div>Loading</div>\n  const isAuthenticated = auth?.isAuthenticated() ?? false\n\n  return isAuthenticated ? (\n    <div\n      style={{\n        display: 'flex',\n        placeContent: 'space-around',\n        paddingTop: '2rem'\n      }}>\n      <SubmitCommand />\n    </div>\n  ) : (\n    <Login />\n  )\n}\nUI should render the following view at this moment.\nFill in the values for all input fields and submit.\nprefix : ESW.defaultAssembly\ncommand : sleep\nsleep : 2\nThat’s all we needed to do for adding an Submit command feature!!!\nFollow the tutorial here to add Subscribe Event Example.","title":"Integrate SubmitCommand Component"},{"location":"/flows/subscribe-event.html","text":"","title":"Adding Subscribing An Event Example"},{"location":"/flows/subscribe-event.html#adding-subscribing-an-event-example","text":"In this use case, we want to Subscribe to an event which will be published by an Backend Component. We will be using EventService to publish a SystemEvent(counterEvent) every 2 seconds inside esw-shell utility.\nVisit here to learn more about events.","title":"Adding Subscribing An Event Example"},{"location":"/flows/subscribe-event.html#add-subscribe-event-component","text":"Assuming that you have followed atleast the basic flow, we can go further and add subscribing to an event feature in our UI.\nAdd SubscribeEvent.tsx file in src/components folder.\nSubscribeEvent component looks like following:\nNote You can refer the source code of the completed application at any point in the course of this tutorial. You can find it here\nTypescript copysourceexport const SubscribeEvent = ({\n  _eventService\n}: {\n  _eventService?: EventService\n}): JSX.Element => {\n  const { auth } = useAuth()\n  const authData = { tokenFactory: () => auth?.token() }\n  return (\n    <Card\n      style={{\n        maxWidth: '30rem',\n        maxHeight: '45rem'\n      }}\n      title={\n        <Typography.Title level={2}>Subscribe Event Example</Typography.Title>\n      }>\n    </Card>\n  )\n}\nWe need to add form element to take input from the user. This Form includes two input fields\nSourcePrefix - A free text input box for putting Source Prefix of the desired subscription. Event KeyName - A free text input box for putting Event’s keyname of the desired subscription. Subscribe - A button for creating subscription. It gets toggled to UnSubscribe on success.\nAdd the following in the SubscribeEvent component\nTypescript copysourceexport const SubscribeEvent = ({\n  _eventService\n}: {\n  _eventService?: EventService\n}): JSX.Element => {\n  const { auth } = useAuth()\n  const authData = { tokenFactory: () => auth?.token() }\n  return (\n    <Card\n      style={{\n        maxWidth: '30rem',\n        maxHeight: '45rem'\n      }}\n      title={\n        <Typography.Title level={2}>Subscribe Event Example</Typography.Title>\n      }>\n      <Form\n        onFinish={() => {\n          subscription ? unSubscribe() : subscribe()\n        }}>\n        <Form.Item label='Source Prefix'>\n          <Input\n            role='SourcePrefix'\n            value={prefix}\n            placeholder='ESW.assembly123'\n            onChange={(e) => setPrefix(e.target.value)}\n          />\n        </Form.Item>\n        <Form.Item label='Event Keyname'>\n          <Input\n            role='keyName'\n            value={keyName}\n            placeholder='counterEvent'\n            onChange={(e) => setKeyName(e.target.value)}\n          />\n        </Form.Item>\n        <Form.Item wrapperCol={{ offset: 16, span: 16 }}>\n          <Button\n            role='subscribe'\n            onClick={() => (subscription ? unSubscribe() : subscribe())}\n            type='primary'\n            disabled={keyName === ''}>\n            {subscription ? 'UnSubscribe' : 'Subscribe'}\n          </Button>\n        </Form.Item>\n      </Form>\n    </Card>\n  )\n}\nAdd the following react states to hold the information of their corresponding user inputs.\nTypescript copysourceexport const SubscribeEvent = ({\n  _eventService\n}: {\n  _eventService?: EventService\n}): JSX.Element => {\n  const { auth } = useAuth()\n  const authData = { tokenFactory: () => auth?.token() }\n  const [prefix, setPrefix] = useState('')\n  const [keyName, setKeyName] = useState('')\n  const [events, setEvents] = useState<Event[]>([])\n  const [subscription, setSubscription] = useState<Subscription>()\n  return (\n    <Card\n      style={{\n        maxWidth: '30rem',\n        maxHeight: '45rem'\n      }}\n      title={\n        <Typography.Title level={2}>Subscribe Event Example</Typography.Title>\n      }>\n      <Form\n        onFinish={() => {\n          subscription ? unSubscribe() : subscribe()\n        }}>\n        <Form.Item label='Source Prefix'>\n          <Input\n            role='SourcePrefix'\n            value={prefix}\n            placeholder='ESW.assembly123'\n            onChange={(e) => setPrefix(e.target.value)}\n          />\n        </Form.Item>\n        <Form.Item label='Event Keyname'>\n          <Input\n            role='keyName'\n            value={keyName}\n            placeholder='counterEvent'\n            onChange={(e) => setKeyName(e.target.value)}\n          />\n        </Form.Item>\n        <Form.Item wrapperCol={{ offset: 16, span: 16 }}>\n          <Button\n            role='subscribe'\n            onClick={() => (subscription ? unSubscribe() : subscribe())}\n            type='primary'\n            disabled={keyName === ''}>\n            {subscription ? 'UnSubscribe' : 'Subscribe'}\n          </Button>\n        </Form.Item>\n      </Form>\n    </Card>\n  )\n}\nNow, lets add subscribe method which gets called onFinish of the form component.\nThis method makes use of event service typescript client which sits on top of the gateway server EventServer routes. In this method, We call subscribe api of eventService to create subscription in a callback based fashion. the callback named handleEvent gets triggered when ever an event is recieved on that subscription.\nTypescript copysourceconst [events, setEvents] = useState<Event[]>([])\nconst [subscription, setSubscription] = useState<Subscription>()\n\nconst handleEvent = (event: Event) => {\n  if (event.eventId !== '-1') {\n    setEvents((events) => [...events, event])\n  } else {\n    message.error(`Event: ${event.eventName.name} is invalid`)\n  }\n}\nconst unSubscribe = () => {\n  subscription?.cancel()\n  setSubscription(undefined)\n}\nconst subscribe = async () => {\n  const eventServices = _eventService\n    ? _eventService\n    : await EventService(authData)\n\n  const subscription = eventServices.subscribe(\n    new Set([\n      new EventKey(Prefix.fromString(prefix), new EventName(keyName))\n    ]),\n    1\n  )(handleEvent)\n  setSubscription(subscription)\n}\nreturn (\n  <Card\n    style={{\n      maxWidth: '30rem',\n      maxHeight: '45rem'\n    }}\nNow we have fully added the functionality of susbcribing to an event. all the events received on that subscription are added to list of events which is a react state. we can use this events react state to render event however we want to show them.\nIn this tutorial, we will make use of Table Antd component.\nLets add this final piece to our UI component below the Form component to visualize the recieved events.\nTypescript copysourceexport const SubscribeEvent = ({\n  _eventService\n}: {\n  _eventService?: EventService\n}): JSX.Element => {\n  const { auth } = useAuth()\n  const authData = { tokenFactory: () => auth?.token() }\n  const columns = [\n    {\n      title: 'Event Name',\n      dataIndex: 'eventName',\n      render: (eventName: EventName) => eventName.name\n    },\n    {\n      title: 'Values',\n      // eslint-disable-next-line react/display-name\n      render: (_: string, event: Event) => {\n        const counterParam = event.get(intKey('counter')) ?? { values: [] }\n        return <span>{counterParam.values.join(',')}</span>\n      }\n    }\n  ]\n  return (\n    <Card\n      style={{\n        maxWidth: '30rem',\n        maxHeight: '45rem'\n      }}\n      title={\n        <Typography.Title level={2}>Subscribe Event Example</Typography.Title>\n      }>\n      <Form\n        onFinish={() => {\n          subscription ? unSubscribe() : subscribe()\n        }}>\n      </Form>\n      <Divider />\n      <Table\n        scroll={{ y: 240 }}\n        pagination={false}\n        rowKey={(e) => e.eventId}\n        dataSource={events}\n        columns={columns}\n      />\n    </Card>\n  )\n}\nAlso, Make sure to add appropriate imports to the file.\nTypescript copysourceimport {\n  Event,\n  EventKey,\n  EventName,\n  EventService,\n  intKey,\n  Prefix,\n  Subscription\n} from '@tmtsoftware/esw-ts'\nimport {\n  Button,\n  Card,\n  Divider,\n  Form,\n  Input,\n  message,\n  Table,\n  Typography\n} from 'antd'\nimport React, { useState } from 'react'\nimport { useAuth } from '../hooks/useAuth'","title":"Add Subscribe Event Component"},{"location":"/flows/subscribe-event.html#integrate-subscribeevent-component","text":"Finally, update Main.tsx to include SubscribeEvent component.\nTypescript copysourceimport { SubscribeEvent } from './SubscribeEvent'\nexport const Main = (): JSX.Element => {\n  const { auth } = useAuth()\n  if (!auth) return <div>Loading</div>\n  const isAuthenticated = auth?.isAuthenticated() ?? false\n\n  return isAuthenticated ? (\n    <div\n      style={{\n        display: 'flex',\n        placeContent: 'space-around',\n        paddingTop: '2rem'\n      }}>\n      <SubmitCommand />\n      <SubscribeEvent />\n    </div>\n  ) : (\n    <Login />\n  )\n}\nUI should render the following view at this moment.\nFill in the values for all input fields and subscribe.\nSource Prefix : ESW.assembly123\nEvent KeyName : counterEvent\nThat’s all we needed to do for adding an Subscribe Event feature!!!\nNot, let’s simulate an backend publishing some events and see them reflecting on UI in real-time.","title":"Integrate SubscribeEvent Component"},{"location":"/flows/subscribe-event.html#publish-events-using-esw-shell","text":"Before moving ahead, if you have not started backend services. Then let’s start backend services by following this steps.\nNow, lets start esw-shell utility. It starts an ammonite repl with basic api’s for us to publish events.\ncs install esw-shell:0.3.0-RC1\nesw-shell start \n@                 // you are inside ammonite repl now\nVisit here to learn more about the esw-shell utility.\nWe are using eventService’s defaultPublisher API to publish events.\n@ val counter = 0\n@ def eventGenerator = Option{\n    counter+=1\n    SystemEvent(Prefix(\"ESW.assembly123\"), EventName(\"counterEvent\"), Set(IntKey.make(\"counter\").set(counter)))\n  }\n@ eventService.defaultPublisher.publish(eventGenerator, 2.seconds)\nThis should start publishing events every 2 seconds from the source prefix ESW.assembly123.","title":"Publish events using esw-shell"},{"location":"/flows/docs-flow.html","text":"","title":"Adding Paradox Documentation"},{"location":"/flows/docs-flow.html#adding-paradox-documentation","text":"The section of the tutorial describes how to write documentation for your application using paradox. Documentation is written in GitHub-flavored markdown, which is documented here","title":"Adding Paradox Documentation"},{"location":"/flows/docs-flow.html#pre-requisite","text":"Your application code is checked in some repo in your organization GitHub account.","title":"Pre-requisite"},{"location":"/flows/docs-flow.html#documentation-development-flow","text":"The sample application generated from the template contains a docs folder. This is where you will write the documentation files for your project. The build.sbt file contains the setup for this docs sbt project.\nLaunch sbt from your console and run command makeSite to construct the documentation pages. Then run the command openSite to open the generated docs in your default browser.\nsbt\nsbt:sample> makeSite\nsbt:sample> openSite\nYou can modify the various .md files present in docs folder and repeat above steps and verify your generated documentation. Refer to the Paradox documentation to learn more about the documentation system.","title":"Documentation Development Flow"},{"location":"/flows/docs-flow.html#documentation-publish-flow","text":"The template sets your project up to publish your documentation to GitHub using GitHub Pages. You need to specify the URL of your GitHub repo in the variable githubRepoUrl in your top-level build.sbt file. This allows Paradox to use a special branch, gh-pages, in your GitHub repository to keep track of your documentation.\nExecute reload in sbt so that updated URL is available in sbt.\nsbt:sample> reload\nCreate the gh_pages branch in your repo following these quick steps. Verify that you see a new branch gh_pages in your GitHub repository with an empty commit.\nThen, you can run the command ghpagesPushSite, to publish your documentation.\nsbt:sample> ghpagesPushSite\nVerify that you see a new commit in branch gh_pages, and branch should contain a folder with name 0.1.0-SNAPSHOT\nOpen your published site using URL, http://{your-username}.github.io/{your-project}/0.1.0-SNAPSHOT/","title":"Documentation Publish Flow"}]}