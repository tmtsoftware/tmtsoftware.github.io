{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Interface Database System (IDBS)"},{"location":"/index.html#interface-database-system-idbs-","text":"Introduction Background Design Background Overview icd-db icdwebserver icd-git icd-viz icd-fits Implementation Details IDBS Workflow and Creating ICDs Installing IDBS Installing the Binary Release Installing the Source Release Installing MongoDB Model Files Markdown Support, Math, UML, Dot Inner-Document Links Reusing Definitions for Events, Commands, Parameters (refs) Using Jsonnet for Model Files Subsystem-model Optional $subsystem-icd-model file Component-model Parameters, Types and Units FITS Keywords Parameter Types Units Parameter Examples Publish-model Events Observe Events Images Other Event Types Service Model File Alarms Subscribe-model Command-model Using the icd-db command line app Generating Documents and Code from the ICD Database Using the icd-fits command line app FITS Keywords Generating a Document listing the FITS Keywords Using the Web Interface Starting the icd web app Upload Files Procedure for Uploading Files View a Subsystem API Check for Missing Items Generate Source Code from the ICD Database View API History Create and View an ICD View ICD History Print an ICD or API View a Graph of Component Relationships","title":"Interface Database System (IDBS)"},{"location":"/idbs/introduction.html","text":"","title":"Introduction"},{"location":"/idbs/introduction.html#introduction","text":"The Interface Database System (IDBS) was created to help component builders and system engineering understand the programming interfaces of software components created with the TIO Common Software.","title":"Introduction"},{"location":"/idbs/introduction.html#background","text":"The project was started for the following purposes:\nTo document the interfaces of components based on TIO Common Software in the TIO Software System. To support a more agile development process by tracking changes to component interfaces over the course of TMT construction. To understand how events are used in the software system. To support the Systems Engineering change control process by understanding how planned interface changes influence the software system. To understand the software interfaces between subsystems and components in the software system. To decrease the workload of developers by generating API and ICD documentation that can be used for reviews. Provide a platform for understanding and modeling the interactions of components during observing. This might include adding additional information to the models.","title":"Background"},{"location":"/idbs/introduction.html#design-background","text":"There might be several ways to solve the problems IDBS is addressing. One approach might be to use/extend a source code documentation markup tool such as Doxygen or the 15+ other products a Google search on software documentation shows. The reason this approach wasn’t taken is that the problem is not about documenting source code, it is modeling components and interfaces and delivering a database that provides a basis for understanding and tracking interfaces and their changes. The models need to drive the source, not the other way around. Documentation tools can generate documents but extracting information and putting it into a database is not the scope of these tools. The primary need is to have a database of interfaces and delivering interface documentation is a second, although important, side effect. Ultimately, it is a question of how to best describe a component and its interfaces.","title":"Design Background"},{"location":"/idbs/overview.html","text":"","title":"Overview"},{"location":"/idbs/overview.html#overview","text":"The IDBS software currently consists of the following programs:\nicd-db icd-git icd-viz icd-fits icdwebserver\nThe components of the Interface Database System are shown below. They are briefly described here, with more details provided in subsequent sections.\nThe workflow proceeds from left to right.\nThe TIO developer, using Common Software for his/her components, creates component model files. These files are validated and ingested into the ICD Model File Database using either the icd-db command or a web application called icdwebserver. These were developed to work with the ICD Model File Database and provide the functionality the users of the system need. The model files are stored and published in Git repositories on GitHub. The icd-git application can be used to sync the local database with the published versions on GitHub. The icd web app also gets its information from the published versions on GitHub, in addition to any unpublished versions that a developer is working with locally. The icd-viz command line application can be used to generate a graph of component or subsystem relationships. This feature requires that graphviz is installed and is also available in the icd web app. The icd-fits command can be used to view information about FITS keywords and their source events.","title":"Overview"},{"location":"/idbs/overview.html#icd-db","text":"The icd-db program exists to validate and ingest model files into a local ICD Model File Database. When creating or modifying the models, this feature can be used to incorporate working versions of the files into the database system. The icd-db program also allows some informative queries to be performed directly on the database, showing what subsystem and components exist in the database, and information about them such as data rates, data types, and units used. Note that these operations only work on the models that exist in the local version of the database, and do not access the released models on the GitHub repository.","title":"icd-db"},{"location":"/idbs/overview.html#icdwebserver","text":"The icdwebserver web application provides the IDBS user application interface. The browser-based user interface allows the ingesting of model files, publishing them, and displaying versioned APIs for each component. An API is defined as all the functionality of a component or subsystem including inputs and outputs. An ICD is produced by taking the intersection of two subsystem API documents.\nThe IDBS browser provides the ability to browse the APIs for both published and unpublished models. The published APIs are constructed from models obtained from the git repository which stores the released versions, and the unpublished APIs are constructed by accessing the models stored in the local database that have been ingested using the icd-db program or the web app.\nThe current version of the IDBS browser user interface includes the following features:\nAllows browsing all the subsystems and their components (including previously published versions as well as unpublished working versions). View the API for a subsystem or an individual component. Browse interfaces between subsystems, or components within subsystems. Upload directories containing the model files for a subsystem API Publish APIs and ICDs (if enabled, for TIO SE use only) Print ICD or API information from the browser (using browser print). Export an API or ICD as a PDF document. Show the publish history of an API or ICD and compare the differences between versions Generate a PDF document that shows the amount of storage required for all archived events Generate a graph of component or subsystem relationships\nA public (password-protected) ICD web service has been set up that allows users to view the APIs and ICDs of all TIO subsystems and components. The uploading functionality of this web service has been disabled; new model files must be committed to the GitHub repository to add new versions to this system, which are automatically added to the web service whenever the system is refreshed. Log-in credentials can be obtained from Systems Engineering. This web service is located at: https://sdb.tmt.org/.","title":"icdwebserver"},{"location":"/idbs/overview.html#icd-git","text":"The icd-git application is a command line tool that can be used to update your local icd database with the published versions from GitHub (Use: icd-git --ingest). Otherwise, this application is primarily meant to be used by systems engineering to manage official releases of APIs and ICDs by interacting directly with versions of subsystem model files as maintained by the official GitHub repository (http://github.com/tmt-icd). Since this tool is mainly intended to be used by the Systems Engineering group, it is not documented here.\nIt is also possible to publish APIs and ICDs using the web app (icdwebserver) and this is now the preferred way to do it. The API publishing features of the web app are protected by password and only enabled for use by those with permission to push to the GitHub repository that holds that information.","title":"icd-git"},{"location":"/idbs/overview.html#icd-viz","text":"The icd-viz command line application generates a graph of the relationships of given components or subsystems. There are a number of options for controlling what is displayed and the format of the image produced.\nThis application relies on graphviz to generate the graph from a description generated in the dot graph description language. Run icd-viz –help to see the command line options (These are also listed in the README.md file for the icd-viz subproject on GitHub). Note that the icd web app also provides a user interface for most of these features. See Using the Web Interface for more information on that.\nThe icd-viz command lets you specify one or more TIO components or subsystems (in which case all components in the subsystem are used). These are the primary nodes of the graph, drawn as solid ovals. Then, all of the components that publish events for these components or subscribe to events from these components are added to the graph (as dashed ovals). The graph edges indicate the flow of events and commands between the components and optionally show any errors, such as events subscribed from publishers that do not exist, or published events with no subscribers.\nThe default colors used for the graph can be found in icd/icd-viz/src/main/resources/reference.conf and can also be overridden with a command line option like -Dicd.viz.color.IRIS=darkgreen (replace IRIS with the subsystem). The colors should be valid Graphviz colors.\nNote The design of the icd-viz application is based on previous work (NIC/scripts/icdRelationships.py) from Ed Chapin of the NRC.\nExample icd-viz command line usage:\nPlot all interfaces for a particular component to the screen, label events and commands, and show missing events and commands:\nicd-viz --components iris.oiwfs.poa --missingcommands true --missingevents true --commandlabels true --eventlabels true\nBelow is the resulting image from the above command:","title":"icd-viz"},{"location":"/idbs/overview.html#icd-fits","text":"The icd-fits command line application can be used to manually ingest FITS dictionary files into the icd database and produce tables in PDF and other format containing information about all the FITS keywords and the subsystem events that are the source of the keyword values. There are command line options that allow you to filter the list of keywords by source subsystem and component as well as by tag.\nThe command can also be used to merge the FITS keyword definitions found in the publish model files with the current FITS dictionary stored in the icd database to produce a new FITS dictionary, where the keyword definitions in the publish model files override the ones previously in the FITS dictionary. This can be used to update the FITS-Dictionary.json file in the tmt-icd DMS-Model-Files GitHub repository, which is loaded automatically whenever the DMS model files are ingested into the icd database.\nThe main source for the FITS dictionary files is in the FITS-Dictionary directory in the tmt-icd DMS-Model-Files GitHub repository. One file there, FITS-Dictionary.json, lists information about the FITS keywords and related subsystem, component, event, and parameter. Another file, FITS-Channels.conf, lists the available channel names for FITS keywords that have multiple source events or parameters. The third file, FITS-Tags.conf, assigns tags to the keywords, such as SL (Seeing-Limited), DL (Diffraction-Limited), or the WFOS, IRIS or MODHIS instruments.\nSome keywords can come from multiple sources or channels, such as imaging or IFS. This information is also included in the FITS Dictionary JSON file above. When you specify the FITS keyword in an event’s parameter description in publish-model.conf, in most cases it is enough to just list the keyword name with keyword = keyname. If the same FITS keyword has multiple different source events/parameters, it needs to be assigned a channel as well. For example: channel = IFS. The channel name needs to be one of the predefined names for that subsystem listed in FITS-Channels.conf.\nFor more details, see Using the icd-fits command line app.\nNote that at the time of writing these files are still in development and may contain incorrect information.","title":"icd-fits"},{"location":"/idbs/overview.html#implementation-details","text":"The IDBS is implemented in Scala, a JVM-based language (http://www.scala-lang.org). The web application is developed using Play (https://www.playframework.com). These are tools selected for OSW and CSW. The ICD information is stored in a document database called MongoDB (https://www.mongodb.org).\nThe code is available on GitHub at: https://github.com/tmtsoftware/icd.","title":"Implementation Details"},{"location":"/workflow/workflow.html","text":"","title":"IDBS Workflow and Creating ICDs"},{"location":"/workflow/workflow.html#idbs-workflow-and-creating-icds","text":"This section describes how the IDBS fits into the software development process at TMT. This workflow is shown in the context of the TMT Software Quality Assurance Plan and Software Development Process (SQUAP and SDP) [RD01], which describes the entire software development process.\nOMOA components consist of HCDs, Assemblies, Sequencers, and Applications. The components are developed incrementally and independently of other subsystem’s components.\nEach component has a public interface or application programming interface (API). The API is based on the services provided by common software. The API shows all the available functionality of a component and subsystem.\nEach TIO software ICD consists of a framework part and a detailed part. The framework part is written in Word according to the TIO Systems Engineering template. The detailed part is generated from the ICD-DB and can change more frequently without requiring updates to the framework document - at least in the case where the framework information does not change.\nA component developer creates a set of model files for each component that describes the component and its interfaces (see the section on model files). These model files are text files. When the component interface changes, the developer updates the model files, validates them, and when ready, checks them into a dedicated repository for model files at the GitHub site: (https://github.com/tmt-icd).\nWhen working on or changing an interface used by another TIO subsystem that will be part of an ICD, the component developer should work with the other subsystem developers to determine the correct functionality and API.\nOnce the model files are checked in, TIO Systems Engineering determines when the new version of a subsystem’s API can be published and given a new incremental version number. Systems Engineering will review any changes that impact other subsystems and ensure they are aware of and agree with changes that will be part of an ICD. New releases of the API documents can be published and will be seen as published in the ICD-DB web user interface.\nTIO Systems Engineering also determines when a new ICD can be generated based on the APIs of the constituent subsystems and manages the publication of a new detailed ICD release. When published, the new ICD is also shown as published in the ICD-DB web user interface.\nNote It may be necessary to click the browser refresh button to see a newly published API or ICD that is not yet in the local icd database (The icd web app then automatically ingests any newly published APIs and ICDs into the local database). The command icd-git –ingest will also update the local database from the released versions on GitHub.","title":"IDBS Workflow and Creating ICDs"},{"location":"/installing/installing.html","text":"","title":"Installing IDBS"},{"location":"/installing/installing.html#installing-idbs","text":"While the public ICD web service can be useful for browsing existing APIs, it can be easier to develop model files by using the IDBS system locally. The icd-db and icdwebserver programs are useful for the developer in order to validate and ingest model files into the local ICD database. The ICD software can be installed on any machine with a Java JDK version of 17 or greater. The details of installing Java on a system are not covered here (Java 17 was used for testing).\nThe following external applications are also required at runtime: * graphviz – The dot command is required to generate graphs and for inline UML support. * swagger-codegen – Required for documenting HTTP services (at least version 3.0.36, install with cs install --contrib swagger-codegen) * mongodb – Required for the database that stores the API information (see below) * jsonnet - Required to process model files written in the jsonnet language\nThe following applications are optional and used if present to fomat generated source code: * scalafmt - Used to format generated Scala source files (Install with cs install scalafmt) * google-java-format - Used to format generated Java source files * black - Used to format generated Python source files * prettier - Used to format generated Typescript source files","title":"Installing IDBS"},{"location":"/installing/installing.html#installing-the-binary-release","text":"Binary releases of IDBS are available on GitHub at:\nhttps://github.com/tmtsoftware/icd/releases\nPlease download the most recent release. The file is available as a zip file. It can be unpacked on Mac or Linux with:\nunzip idbs-$version.zip\nwhere $version is the release version.\nOnce the installation is unpacked it creates a directory named idbs-$version that contains three subdirectories: bin, conf, and lib. Inside bin are the application scripts: icd-db, icd-git, icd-viz, icd-fits and `icdwebserver.\nThe image below shows the basic directory structure of the IDBS binary distribution downloaded from GitHub:\nThe icd-db or icdwebserver program is needed to validate and ingest the directories containing your model files. You might want to put the idbs-$version/bin directory in your shell path.","title":"Installing the Binary Release"},{"location":"/installing/installing.html#installing-the-source-release","text":"The source for the IDBS programs can be downloaded from the tmtsoftware GitHub repository with the command:\ngit clone https://github.com/tmtsoftware/icd.git\nThe git clone command will result in a local directly called icd. An install.sh script is provided that builds and installs all the subprojects into a directory called install_icd in the parent directory of the download directory (the ../install_icd directory). The install_icd directory contains the directories: bin, conf, and lib. Inside the bin directory are Linux/Mac friendly scripts to start the components of IDBS.\nThe code is built with the sbt build program, which must be downloaded and installed (see http://www.scala-sbt.org). That task is not covered here. The “All Platforms” or “Manual installation” is quick, which is the suggested approach.\nThe icdwebserver application starts the web application (by default on localhost:9000).","title":"Installing the Source Release"},{"location":"/installing/installing.html#installing-mongodb","text":"In order to run the icd applications locally, it is necessary to install the database MongoDB, which is available at https://www.mongodb.org. The community edition is sufficient for our needs and instructions for installation can be found for a variety of platforms at\nhttps://docs.mongodb.com/manual/administration/install-community/.\nNote that it may be necessary to adjust system limits in order for mongod to run correctly. See\nhttps://docs.mongodb.com/manual/reference/ulimit/.\nNote: If you wish to “start over” with no database entries, you can use the command icd-db –drop db. Run icd-git –ingest to get the published APIs and ICDs from the released versions on GitHub.","title":"Installing MongoDB"},{"location":"/modelFiles/modelFiles.html","text":"","title":"Model Files"},{"location":"/modelFiles/modelFiles.html#model-files","text":"In the OMOA, subsystem software consists of components: Hardware Control Daemons, Assemblies, Sequencers, and Applications. Model files that provide information about the component and its interfaces are created for each of the components. This section describes the model files. The model files are named: component-model, command-model, publish-model, alarm-model, and subscribe-model. In addition, each subsystem has a single subsystem-model file and may have one or more $subsystem-icd-model files that contain additional information about the interface between two subsystems. Separate files were created (rather than one larger file) in order to keep the configuration files simpler and easier to type.\nThe following table shows the different types of model files and what they describe:\nModel File Description subsystem-model.conf Contains high-level information about the subsystem that contains a group of components. There is one subsystem-model.conf file per subsystem. component-model.conf Contains high-level component information. There is one component-model.conf file per component. command-model.conf Describes the configuration commands the component supports. Also describes components and commands the component may send to other components. There is at most one command-model.conf file per component. publish-model.conf Describes events the component publishes using Event Services. There is at most one publish-model.conf file per component. service-model.conf Describes HTTP services provided or consumed by the component. The HTTP services themselves are described in OpenAPI files. alarm-model.conf Describes alarms the component publishes using the Alarm Service. There is at most one alarm-model.conf file per component. subscribe-model.conf Describes events the component subscribes to using Event Services. There is at most one subscribe-model.conf file per component. $subsystem-icd-model.conf Where $subsystem is the name of one of the other TMT subsystems, for example: IRIS-icd-model.conf. These files may contain additional information about the interface between the subsystem being defined and another subsystem (IRIS in this example).\nThe component is only required to create a command-model.conf, publish-model.conf, alarm-model.conf, or subscribe-model.conf if it provides or uses the features described in the model files (i.e. if the component does not subscribe to events, then a subscribe-model.conf file is not needed).\nModel files are text files written in a superset of JSON called HOCON, which provides syntactic sugar for writing JSON, but can be exported as pure JSON. In addition, most fields support GitHub style MarkDown as well as HTML tags. LaTeX math markup and UML are also supported (see below). In addition, it is possible to reuse certain repetitive definitions, such as those for events, commands and parameters by using the ref keyword in the model files to refer to another definition. The syntax is described below. Each type of model file has a schema which specifies the allowed structure of the contents within, including specifying the optional and required items, item types, allowed ranges, etc. The following sections describe each of the model files including necessary fields.","title":"Model Files"},{"location":"/modelFiles/modelFiles.html#markdown-support-math-uml-dot","text":"In addition to using standard GitHub style MarkDown in descriptions, you can also insert LaTeX math formulas: Here is an example description text containing an inline math formula:\ndescription = \"\"\"\nHere is an example using LaTeX math: $`\\frac{d}{dx}\\left( \\int_{0}^{x} f(u)\\,du\\right)=f(x)`$.\nAnd here is another: $`[x^n + y^n = z^n]`$.\n“””\nAnd this is the inline math formula displayed from the above input:\nBlock math formulas are delimited by\n```math\n\n```\nFor example:\nDescription = “””\nHere is an example using LaTeX math: $`\\frac{d}{dx}\\left( \\int_{0}^{x} f(u)\\,du\\right)=f(x)`$.\nAnd here is another: $`[x^n + y^n = z^n]`$.\n\nThis is a math block:\n\n```math\n$$\\idotsint_V \\mu(u_1,\\dots,u_k) \\,du_1 \\dots du_k$$\n```\n\nand another:\n\n```math\n\\frac{n!}{k!(n-k)!} = \\binom{n}{k}\n```\n\nand a matrix:\n\n```math\nA_{m,n} =\n \\begin{pmatrix}\n  a_{1,1} & a_{1,2} & \\cdots & a_{1,n} \\\\\n  a_{2,1} & a_{2,2} & \\cdots & a_{2,n} \\\\\n  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\\n  a_{m,1} & a_{m,2} & \\cdots & a_{m,n}\n \\end{pmatrix}\n```\n“””\nThe display for the above description is shown below:\nUML (PlantUML) and Graphviz Dot are also supported, delimited by\n```uml\n```\nFor example, below are some embedded UML blocks in a model file description text:\nDescription = “””\n\nand a small one:\n\n```uml\nBob -[#red]> Alice : hello\nAlice -[#0000FF]->Bob : ok\n```\n\nNote that according to https://plantuml.com/dot you can also use Graphviz/Dot diagrams instead of UML:\n\n```uml\ndigraph foo {\n  node [style=rounded]\n  node1 [shape=box]\n  node2 [fillcolor=yellow, style=\"rounded,filled\", shape=diamond]\n  node3 [shape=record, label=\"{ a | b | c }\"]\n\n  node1 -> node2 -> node3\n}\n```\n\"\"\"\nBelow is the display produced from the above description text:","title":"Markdown Support, Math, UML, Dot"},{"location":"/modelFiles/modelFiles.html#inner-document-links","text":"It is possible to make inner-document links to existing anchors using Markdown syntax. The easiest way to see the syntax for the ids is to look at the generated HTML. For example, the output of:\nicd-db -s NFIRAOS -o NFIRAOS.html\nNote that the name attribute is used in the generated HTML instead of id, since the PDF generator required that. Many of the anchors have the following syntax:\nthisComponent-action-itemType-subsystem.component.name\nwhere\nthisComponent is the component being described action is one of {publishes, subscribes, sends, receives} itemType is one of {Event, ObserveEvent, Alarm, Command} subsystem is the subsystem for the item component is the component for the item name is the name of the item being published, subscribed to, or the command being sent or received\nFor example, to link to the description of a published event named heartbeat in the lgsWfs component in the TEST subsystem:\nSee: [here](#lgsWfs-publishes-Event-TEST.lgsWfs.heartbeat).","title":"Inner-Document Links"},{"location":"/modelFiles/modelFiles.html#reusing-definitions-for-events-commands-parameters-refs-","text":"It is possible to reuse similar parts of event, command and parameter definitions by using the ref keyword. The example below uses a reference to an event (engMode) in another event (engMode2):\nevents = [\n    {\n      name = engMode\n      description = \"LGS WFS engineering mode enabled\"\n      archive = false\n      parameters = [\n        ...\n      ]\n    }\n    {\n      name = engMode2\n      description = \"LGS WFS engineering mode 2 enabled\"\n      archive = true\n      ref = engMode\n    }\nIn the above example, the event engMode2 will have the same settings and parameters as engMode, except for description and archive, which are overridden. Any fields, which are not set, are inherited from the referenced event. This works for events, commands and parameters, as shown in the parameter reference example below:\nparameters = [\n        {\n          name = mode3\n          ref = engMode/parameters/mode\n        }\nIn the above example, the parameter mode3 will be exactly the same as the mode parameter in the engMode event in the same component. You could also specify a different description field or any other parameter fields that should override the ones defined for mode.\nThe syntax of the ref value is flexible and allows you to reference any event, command or parameter in any component within the same subsystem. You can use a full path to specify a reference to an item in another component, or an abbreviated path for items in the same scope. The full syntax of a ref is something like this:\ncomponentName/section/eventName[/parametersSection/paramName]\nFor example, to reference an event, observe event or current state, use:\ncomponentName/events/eventName or componentName/observeEvents/eventName or componentName/currentState/eventName or events/eventName, … (if in the same component) or just eventName (if in the same component and event type section) For commands received, the syntax is similar: componentName/receive/commandName or just commandName (if in the same component)\nThe syntax for references to parameters of events adds the parameters keyword and the parameter name:\ncomponentName/events/eventName/parameters/paramName\nor abbreviated as described above for events:\nobserveEvents/eventName/parameters/paramName (in same component) or eventName/parameters/paramName (in same component and events section)\nOr just paramName (if in the same parameters section)\nThe syntax for parameters of commands is similar. Here you need to specify if the parameters appear in the “parameters” section or in the “resultType”.\ncomponentName/receive/commandName/parameters/paramName or componentName/receive/commandName/resultType/paramName\nOr abbreviated as described above.\nSee the example model files in the icd sources for some examples of the ref keyword.\nNote If there is an error in the reference, the error message is displayed in the log output of the icd-db command, if it is used, and also inserted in the generated HTML or PDF document (in the details section).\nBelow is an example that demonstrates some of the ref syntax for event parameters:\nevents = [\n    {\n      name = engMode3\n      description = \"LGS WFS engineering mode enabled 3\"\n      archive = true\n      parameters = [\n        {\n          // Example reference to a parameter in this component\n          name = mode3\n          ref = engMode/parameters/mode\n        }\n        {\n          // Example reference to a parameter in this component (using wrong ref to produce error in HTML/PDF output)\n          name = mode3Error\n          ref = engMode/parameters/modeXXX\n        }\nNote Note: An earlier version of the icd software used the terms “attributes” for events parameters and “args” for command parameters. These have been renamed to “parameters” for compatibility with CSW, however for backward compatibility the previous names are also allowed in refs.","title":"Reusing Definitions for Events, Commands, Parameters (refs)"},{"location":"/modelFiles/modelFiles.html#using-jsonnet-for-model-files","text":"Normally, the icd model files are written in HOCON format, a simplified JSON format, and have a .conf suffix. In some cases, you may want to have more features available, for example to refer to similar definitions in may different places. The icd software also supports model files using the jsonnet data templating language, which lets you define variables and functions and reuse them. To do this, replace the .conf suffix with .jsonnet (or .libsonnet for jsonnet files you want to import) and follow the syntax rules for jsonnet, so that the resulting JSON, after being processed by jsonnet conforms to the icd JSON schema. The icd software will automatically preprocess the jsonnet model files when they are imported into the icd database.\nFor example, you can add some common, reusable, top level definitions in a file utils.libsonnet:\n// Define a common event\n{\n  heartbeat: {\n    name: 'heartbeat',\n    description: 'Heartbeat event description...',\n    parameters: [\n      {\n        name: 'heartbeat',\n        description: 'software heartbeat',\n        type: 'integer',\n      },\n    ],\n  },\n\n  // Defines a function to generate a common event model based on the given arguments\n  commonEventFunc(eventName, paramName, typeName):: {\n    name: eventName,\n    description: eventName + ' description.',\n    archive: false,\n    parameters: [\n      {\n        name: paramName,\n        description: 'Description for ' + paramName,\n        type: typeName,\n      },\n    ],\n  },\n}\nAnd then reference these definition in a publish-model.jsonnet file for a different component. Below is an example publish-model.jsonnet file that imports reusable jsonnet code:\n// Import common function defined in another file\nlocal utils = import '../utils.libsonnet';\n\n{\n  subsystem: 'TEST',\n  component: 'jsonnet.example',\n\n  // comments can use // or #\n  publish: {\n    description: |||\n      Multi-line descriptions\n      use this syntax in jsonnet\n    |||,\n\n    events: [\n      // define two similar events using imported function\n      utils.commonEventFunc('myEvent1', 'param1', 'boolean'),\n      utils.commonEventFunc('myEvent2', 'param2', 'string'),\n\n      // Insert an imported event definition\n      utils.heartbeat,\n\n      // define another event\n      {\n        name: 'state',\n        // Import the description text\n        description: importstr '../importRaw.txt'\n,\n        archive: false,\n        parameters: [\n          {\n            name: 'state',\n            description: 'Detector state',\n            enum: ['EXPOSING', 'READING', 'IDLE', 'ERROR'],\n          },\n        ],\n      },\n    ],\n  },\n}\nThe above example defines two events (myEvent1 and myEvent2) that are similar, but configured based on the given function arguments. The heartbeat event is used as is. The state event is defined in the usual way (for JSON), but imports the description text from a file.","title":"Using Jsonnet for Model Files"},{"location":"/modelFiles/modelFiles.html#subsystem-model","text":"The subsystem model describes the overall subsystem. There is one subsystem-model.conf file for each subsystem.\nEach subsystem may consist of several components. The IDBS merges them to create a subsystem API or ICD.\nAs an example, the subsystem-model.conf JSON schema file is shown below. This schema file is being shown for reference. Users are not expected to interact with the schema files directly, but rather use this manual to understand how to structure their model files.\nsubsystem-model.conf JSON schema:\nid: \"http://csw.tmt.org/subsystem-schema#\"\n\"$schema\": \"http://json-schema.org/draft-07/schema#\"\n\ndescription = \"Defines the model describing a top level subsystem\"\ntype = object\nadditionalProperties: false\nrequired = [modelVersion, subsystem, title, description]\nproperties {\n  _id {\n    description = \"Optional unique id (automatically generated)\"\n    type = string\n  }\n  _version {\n    description = \"Optional version (automatically generated)\"\n    type = integer\n  }\n  modelVersion {\n    description = \"The version of the model file as Major.Minor version\"\n    type = string\n    pattern = \"^[0-9]+\\\\.[0-9]+$\"\n  }\n  subsystem {\n    description = \"The name of this Subsystem\"\n    include classpath(\"3.0/subsystem.conf\")\n  }\n  title {\n    description = \"The title of this subsystem, for display\"\n    type = string\n  }\n  description {\n    description = \"A description of this subsystem\"\n    type = string\n  }\n}\nThe line starting with required = shows the required fields in the subsystem.conf file are: modelVersion, subsystem, title, and description. The following lines in the schema file describe each of the fields. Note also that modelVersion requires a pattern given by a regular expression. The modelVersion must be a value like Major.Minor with at least 1 digit on each side of the period such as 3.0 (The latest version).\nThe fields for subsystem.conf are shown in the table below. The field name, whether it is required, and any special notes for the field are shown. Notes include required formats or conventions for a value.\nRequired and optional fields for subsystem.conf:\nField Required? Notes modelVersion yes Must be a Major.Minor version with Major and Minor digits. Currently these values are supported: 1.0, 2.0, 3.0 (the latest version). subsystem yes Name of the subsystem. Must be the same as SE subsystem name. title yes The title of the subsystem. Will be displayed in generated documents. The title can contain spaces and other marks but should be one line. description yes A description of the subsystem. The description is in triple quotes for multi-lined text. Note that spaces between paragraphs are retained and the text can contain GitHub flavored Markdown as well as HTML markup.\nThe modelVersion is the model version for the entire subsystem. Each component also has a modelVersion field. This allows each component to be updated independently and then the subsystem to be updated as a whole.\nThe subsystem field is the subsystem name. It must be one of the subsystem abbreviations from the SE N2 document. The list is shown below.\n// Enumeration including all available subsystems\nenum = [\n  ENC, // Enclosure\n  SUM, // Summit Facilities\n  STR, // Structure\n  M2S, // M2 System\n  M3S, // M3 System\n  CLN, // Mirror Cleaning System\n  TINS, // Test Instruments\n  TCS, // Telescope Control System\n  M1CS, // M1 Control System\n  APS, // Alignment and Phasing System\n  OSS, // Observatory Safety System\n  ESEN, // Engineering Sensor System\n  NFIRAOS, // Narrow Field Infrared AO System\n  NSCU, // NFIRAOS Science Calibration Unit\n  LGSF, // Lasert Guide Star Facility\n  AOESW, // AO Executive Software\n  CRYO, // Cryogenic Cooling System\n  IRIS, // InfraRed Imaging Spectrometer\n  MODHIS, // Multi-Object Diffraction-limited High-resolution Infrared Spectrograph\n  REFR, // Refrigeration Control System\n  WFOS, // Wide Field Optical Spectrometer\n  CIS, // Communications and Information Systems\n  CSW, // Common Software\n  DMS, // Data Management System\n  ESW, // Executive Software System\n  SOSS, // Science Operations Support System\n  DPS, // Data Processing System\n  SCMS // Site Conditions Monitoring System\n]\nThe example below will create a TCS subsystem. The description comes from the text of the TCS CoDR software design document. Triple quotes allow multi-line entries.\nsubsystem=TCS\ntitle=\"TELESCOPE CONTROL SYSTEM (TCS)\"\nmodelVersion=\"3.0\"\ndescription=\"\"\"\nThe main functions of the TCS are: \n1) Points and tracks targets in various reference frames by generating position demands for subsystems and instruments. Generates pointing models to remove repeatable mechanical errors and applies pointing models terms to correct mount demands.\n2) Implements a key part in acquisition, guiding and wavefront sensing \n…\n\"\"\"","title":"Subsystem-model"},{"location":"/modelFiles/modelFiles.html#optional-icd-model-file","text":"There may be zero or more of these model files in the top level directory (which also contains subsystem-model.conf). Replace $subsystem with the name of the other subsystem that has an interface with the one being defined. For example, if you are defining the NFIRAOS subsystem model files and want to include extra information about the ICD between IRIS and NFIRAOS, you could add a file named IRIS-icd-model.conf:\nsubsystem = NFIRAOS\ntitle = \"Interface between NFIRAOS and IRIS\"\ndescription = \"\"\"\nThe communication, software and control interfaces between NFIRAOS and IRIS consist of the following:\n* Transfer of pixel compression gain and offset coefficients from the OIWFS detector controller to the NRTC.\n* Transfer of pixel compression gain and offset coefficients from the IRIS Imager detector controller to the NRTC.\n* Transfer of residual field rotation angle OIWFS from the NFIRAOS RTC to the IRIS SRO.\n* Transfer of the IRIS OIWFS ADC ellipticity correction streams from the NFIRAOS RTC to the IRIS SRO. The corrections include the widths of the elliptical Gaussian image and angle between the ellipse axis and the local X axis.\n* Transfer of the IRIS OIWFS pixels from the IRIS OIWFS detector controllers to the NFIRAOS RTC.\n* Transfer of the IRIS ODGW pixels from the IRIS detector controllers to the NFIRAOS RTC.\n* Transfer of probe position errors due to TT offloading from the NFIRAOS RTC to the IRIS SRO.\n* Transfer of the NFIRAOS Optical Enclosure state to the OIWFS Enclosure.\n* Bi-directional sharing of respective temperatures of NFIRAOS and OIWFS enclosures\n* Transfer of NFIRAOS configuration, state, and performance information to the IRIS Data Reduction System (DRS).\n\"\"\"\nThe fields in the $subsystem-icd-model.conf file are shown below:\nField Required? Notes subsystem yes Name of the subsystem being defined (same as in subsystem-model.conf) title no Optional title to be displayed before the description (If missing, a default title will be used) description yes Text describing the interface between the two subsystems (may include Markdown, HTML) targetSubsystem no Name of the other subsystem that has an interface with this one (Defaults to the one in the file name)","title":"Optional $subsystem-icd-model file"},{"location":"/modelFiles/modelFiles.html#component-model","text":"There is one component-model.conf file for each component in the subsystem. The component model file provides high level information about the component. The fields of the component-model.conf are shown in the following table:\nField Required? Notes modelVersion yes This is the modelVersion for a single component. It must be a Major.Minor version with Major and Minor digits (1.0, 2.0 and 3.0 are currently supported). subsystem yes Name of the subsystem the component belongs to. It must be an entry from the SE subsystem list. wbsId no The WBS element from the cost book this component belongs to such as: TMT.TEL.CONT.TCS. componentType yes Must be: Assembly, HCD, Sequencer, Application, or Container component yes The name of the component. Will be displayed in documents. The component name may contain spaces and dots, but, as of modelVersion 2.0, not a dash “-“. The prefix for a component, which is needed to subscribe to events, is defined as subsystem.component. title yes The title of the component. Will be displayed in documents. The title can include spaces but should be one line. description yes A description of the component (may contain Markdown or HTML markup). The description is in triple quotes for multi-lined text. Note that spaces between paragraphs are retained.\nAn example component-model.conf file (for the TCS Pointing Kernel Assembly, described in the TCS CoDR WBS) is shown below:\nsubsystem = TCS\ncomponent = TCS PK Assembly\nmodelVersion = \"3.0\"\nwbsId = tmt.tel.cont.tcs.tpk\ntitle = \"Telescope Pointing Kernel Assembly\"\ncomponentType = Assembly\n\ndescription = \"\"\"\nPointing Kernel Assembly is responsible for receiving target and offset commands. Based on targets received assembly will produce stream of target demands that will be used by\ntracking mechanism in Mount,Enclouser,Rotator,Guiders,Probes etc. Pointing Kernel Assembly utilizes C++ based third party libraries like tpk,slalib,tcspk.\n\"\"\"\nThe icd-db program can output a document in PDF or HTML format with the –o option. The figure below shows a portion of the PDF output related to the above component-model.conf file:","title":"Component-model"},{"location":"/modelFiles/modelFiles.html#parameters-types-and-units","text":"The following two sections describe events and commands, both of which can have sets of parameters. A parameter can have a number of fields defined in the file parameter-schema.json. Minimally, it must be a name, description, and type or a name, description, and enum (enumeration). Parameter fields are described in the table below. Parameter field names must be unique within an event item.\nThe table below lists the set of required fields for parameters. Note that yes/no here means that one of type or enum is required, but both are not possible in the same parameter.\nField Required? Notes name yes The name of a parameter in the enclosing item. description yes A text description of the parameter. type yes/no The type of a value or array. Can be one of: array, boolean, integer, string, byte, short, long, float, double, taiTime, utcTime, eqCoord, solarSystemCoord, minorPlanetCoord, cometCoord, altAzCoord, coord (corresponding to supported types in the CSW software: See below). enum yes/no An enum as in enum = {A, B}\nOther fields can be optionally added to the parameter as needed, depending on the type of parameter. For values that have units, the units must be one of the allowed CSW units (see below).\nField Required? Notes units yes if possible The units of a value in a parameter. See below for allowed values. minItems no If the parameter is a one-dimensional array, this specifies the minimum number of items in the array. Can also be specified using the dimensions field for arrays types (see below). maxItems no If the parameter is a one-dimensional array, this specifies the maximum number of items in the array. Can also be specified using the dimensions field for arrays types (see below). minLength no For string parameters, the minimum expected string length. maxLength no For string parameters, the maximum expected string length. dimensions no If the parameter value is a multi-dimensional array, this is an array of dimension sizes for the value. minimum no When a value can be a range, this is the minimum possible (a number or -inf). maximum no When a value can be a range, this is the maximum possible (a number or inf). exclusiveMinimum no When a value can be a range, this is the minimum possible, exclusive of this value (a number or –inf). exclusiveMaximum no When a value can be a range, this is the maximum possible, exclusive of this value (a number or inf). default no This is the default value for the parameter, if there is one. allowNaN no Set to true if the parameter value can be NaN (default: false)","title":"Parameters, Types and Units"},{"location":"/modelFiles/modelFiles.html#fits-keywords","text":"In addition to the above fields, event parameters may contain fields with information about the FITS keywords for which the parameter is the source:\nField Required? Notes keyword no This is the name of the FITS keyword generated from the parameter value. channel no If the FITS keyword has multiple source parameters, this specifies the channel name for this source. keywords no Use if multiple FITS keywords are produced from this event parameter (See below).\nFor the keywords field in the above table: If multiple keywords are produced from an event parameter (from different parts of an array or matrix), this form can be used:\nkeywords: [\n  {\n    keyword = OIWFS1PS\n    rowIndex = 0\n  }\n  {\n    keyword = OIWFS2PS\n    rowIndex = 1\n  }\n  {\n    keyword = OIWFS3PS\n    rowIndex = 2\n  }\n]\nIn this format, rowIndex refers to a row in a matrix parameter value, while index refers to an index in the parameter value array.","title":"FITS Keywords"},{"location":"/modelFiles/modelFiles.html#parameter-types","text":"The table below lists the available types for parameters, which correspond to the supported parameter types in the CSW framework. Note that a parameter in CSW can always have multiple values. It is not necessary (or supported) to define an array of strings or booleans, since a string or boolean parameter can already have multiple values.\nType Description boolean,integer, string, byte, short, long, float, double Values have the corresponding primitive types in Scala, Java, Typescript, etc. array An array or matrix of (lists of) numerical values (not string or boolean) taiTime, utcTime Holds TAI or UTC time values EqCoord, solarSystemCoord, minorPlanetCoord, cometCoord, altAzCoord, coord See the CSW source for details of these coordinate parameter types. Note that coord (CSW Coord) is a base type that can be used for any of the coordinate types.\nIf the parameter type is an array, there are some special tags for describing it. The minItems and maxItems parameters can be used for 1-Dimensional arrays and is especially useful for arrays with a variable length. However, for other arrays, including higher dimensional arrays, a dimensions tag can be used, with a syntax of [x,y,z,…] where x, y, and z are positive integers specifying the size of each dimension. Note that the CSW framework only supports numerical array and matrix types, although each item of the array or matrix can be a list of one or more values.\nTo describe the items in an array, an “items” block is used. Within it, the type is set using the type field. The mimimum, maximum, exclusiveMinimum, and exclusiveMaximum fields may be used as well.\nIn the CSW framework, only numerical array parameter types are supported, however since every parameter may have multiple values, it is usually not necessary to declare the type as an array.\nNote that the value of the mimimum, maximum, exclusiveMinimum, and exclusiveMaximum fields may be numeric or “inf” or “-inf” (for +/- infinity).","title":"Parameter Types"},{"location":"/modelFiles/modelFiles.html#units","text":"The CSW software defines a list of standard units that are accepted. If not in this list, please add it to the description field and/or request that it be added to the standard list.\nNote: This list can be found in the icd source tree under icd-db/src/main/resources/3.0/units.conf\n// Enumeration including all available CSW units\n\nenum = [\n  // SI units\n  angstrom    // angstrom\n  alpha       // alpha: fine structure constant\n  ampere      // ampere: unit of electric current\n  arcmin      // arc minute; angular measurement\n  arcsec      // arc second: angular measurement\n  bar         // bar: metric ton of pressure\n  candela     // candela(lumen/sr)\n  day         // day\n  degree      // degree: angular measurement 1/360 of full rotation\n  degC        // Degree Celsius K\n  degF        // Fahrenheit\n  elvolt      // electron volt\n  gauss       // gauss\n  gram        // gram\n  hertz       // frequency\n  henry       // Henry\n  hour        // hour\n  joule       // Joule: energy\n  kelvin      // Kelvin: temperature with a null point at absolute zero\n  kilogram    // kilogram, base unit of mass in SI\n  kilometer   // kilometers\n  liter       // liter, metric unit of volume\n  lm          // lumen\n  lsun        // solar luminosity\n  lx          // lux(lm/m2)\n  mas         // milli arc second\n  me          // me(electron_mass)\n  meter       // meter: base unit of length in SI\n  microarcsec // micro arcsec: angular measurement\n  millimeter  // millimeters\n  millisecond // milliseconds\n  micron      // micron: alias for micrometer\n  micrometer  // micron\n  minute      // minute\n  MJD         // Mod. Julian Date\n  mol         // mole- unit of substance\n  month       // Month name or number\n  mmyy        // mmyy: Month/Year\n  mu0         // mu0: magnetic constant\n  muB         // Bohr magneton\n  nanometer   // nanometers\n  newton      // Newton: force\n  ohm         // Ohm\n  pascal      // Pascal: pressure\n  pi          // pi\n  pc          // parsec\n  ppm         // part per million\n  radian // radian: angular measurement of the ratio between the length of an arc and its radius\n  second // second: base unit of time in SI\n  sday   // sidereal day is the time of one rotation of the Earth\n  steradian // steradian: unit of solid angle in SI\n  volt      // Volt: electric potential or electromotive force\n  watt      // Watt: power\n  Wb        // Weber\n  week      // week\n  year      // year\n\n  // CGS units\n  coulomb    // coulomb: electric charge\n  centimeter // centimeter\n  D          // Debye(dipole) A electric dipole moment\n  dyn        // dyne: Unit of force\n  erg        // erg: CGS unit of energy\n\n  // Astropyhsics units\n  au        // astronomical unit: approximately the mean Earth-Sun distance\n  a0        // bohr radius: probable distance between the nucleus and the electron in a hydrogen atom in its ground state\n  c         // c: speed of light\n  cKayser   // cKayser\n  crab      // Crab: astrophotometrical unit for measurement of the intensity of Astrophysical X-ray sources\n  damas     // damas: degree arcminute arcsecond (sexagesimal angle from degree)\n  e         // electron charge\n  earth     // earth (geo) unit\n  F         // Farad: F\n  G         // gravitation constant\n  geoMass   // Earth Mass\n  hm        // hour minutes (sexagesimal time from hours)\n  hms       // hour minutes seconds (sexagesimal time from hours)\n  hhmmss    // hour minutes seconds (sexagesimal time)\n  jansky    // Jansky: spectral flux density\n  jd        // Julian Day\n  jovmass   // Jupiter mass\n  lightyear // light year\n  mag       // stellar magnitude\n  mjup      // Jupiter mass\n  mp        // proton_mass\n  minsec    // minutes seconds (sexagesimal time from minutes)\n  msun      // solar mass\n  photon    // photon\n  rgeo      // Earth radius (eq)\n  rjup      // Jupiter Radius(eq)\n  rsun      // solar radius\n  rydberg   // energy of the photon whose wavenumber is the Rydberg constant\n  seimens   // Seimens\n  tesla     // Tesla\n  u         // atomic mass unit\n\n  // Imperial units\n  barn  // barn: metric unit of area\n  cal   // thermochemical calorie: pre-SI metric unit of energy\n  foot  // international foot\n  inch  // international inch\n  pound // international avoirdupois pound\n  mile  // international mile\n  ounce // international avoirdupois ounce\n  yard  // international yard\n\n  // Others - engineering\n  NoUnits // scalar - no units specified\n  bit     // bit: binary value of 0 or 1\n  encoder // encoder counts\n  count   // counts as for an encoder or detector\n  mmhg    // millimetre of mercury is a manometric unit of pressure\n  percent // percentage\n  pix     // pixel\n\n  // Datetime units\n  tai      // TAI time unit\n  utc      // UTC time unit\n  date     // date\n  datetime // date/time\n]","title":"Units"},{"location":"/modelFiles/modelFiles.html#parameter-examples","text":"Below are some examples of parameter definitions:\nparameters = [\n        {\n          name = temp_ngsWfs\n          description = \"NGS WFS temperature\"\n          type = float\n          units = kelvin\n          exclusiveMinimum: -inf\n          exclusiveMaximum: inf\n          allowNaN: true\n\t    keyword = IMGTMPXX\n        }\n        {\n          name = temp_lgsWfs\n          description = \"LGS WFS temperature\"\n          type = float\n          units = kelvin\n          exclusiveMinimum: 0\n          exclusiveMaximum: 100\n          allowNaN: true\n        }\n        {\n          name = temp_ndme\n          description = \"NDME crate temperatures\"\n          type = array\n          dimensions: [7]\n          items = {\n            type = float\n            units = kelvin\n          }\n        }\n        {\n          name = temp_actuator\n          description = \"motor & piezo actuator temperatures\"\n          type = array\n          dimensions: [30]\n          items = {\n            type = float\n            minimum = 1.234\n            units = kelvin\n          }\n        }\n      ]","title":"Parameter Examples"},{"location":"/modelFiles/modelFiles.html#publish-model","text":"Each component can publish events, observe events, images and current state. Other systems can subscribe or get these. A component’s published events and images are described in the publish-model.conf file. The file consists of some high-level content and then sections for events, observeEvents, images and currentState.\nNote As per Change Request 261, the telemetry and event services have been merged into one unified service, and telemetry items distinct from events have been eliminated. Furthermore, events and event streams have also been consolidated into a single event type.\nThe table below lists the required and optional fields for publish-model.conf:\nField Required? Notes subsystem yes Name of the subsystem. Must be the same as SE subsystem name. Should be the same as the component-model.conf and subsystem-model.conf component yes The name of the component. publish yes This is a container for the kinds of data the system publishes. It is required.\nThe publish block contains a description and then containers for the different kinds of publishable events. The table below lists the fields for the required publish block:\nField Required? Notes description no Optional overview or notes on items published by the component. events no Block for events that are published by the component observeEvents no Block for observe events that are published by the component. There is a list of predefined observe events (see below). images no Block for images that are published by the component. currentStates no Block for current states that are published by the component. alarms no Block for alarms published by the component (Deprecated: See alarm-model.conf below).\nNote that the publish-model.conf file is not required if the container does not publish any events or . Note also that none of the fields of the publish container are required. Adding a publish-model.conf file to the component model that is empty will create an empty section in the documentation (In that case it would be preferable to leave out the publish-model.conf file). The following tables discuss each of the different kinds of events.","title":"Publish-model"},{"location":"/modelFiles/modelFiles.html#events","text":"The event container is an array containing one or more event items.\nEvents fall into the following categories. The purpose of the categories is to easily find events of different categories without a catalog.\nCategory Description DEMAND An event that is used to transmit a desired position. These events are high frequency/periodic and should not be archived long-term or should be seriously curated into a smaller representative collection. CONTROL Similar to a DEMAND, but probably not periodic and considerably less frequent. CONTROL events are events driving other devices, but may be internal to a system. These also may be curated. EVENT An event that is used to indicate that something has happened. Observe Events are one EVENT type. STATUS (Default) Used primarily to update a user interface. These events are archived. They are not high frequency and are not periodic.\nThe fields of an event item are shown in the table below:\nField Required? Notes name yes The name of the event item. This should be a simple name like “zenithAngle”. The prefix for all events is subsystem.component. category no The event category (One of: DEMAND, CONTROL, EVENT, STATUS). description no An optional description of a single event item (may contain Markdown and HTML). The description is in triple quotes for multi-lined text. Note that spaces between paragraphs are retained. requirements no List of requirements that flow to this item. maxRate no Maximum publishing rate in Hz. archive no A Boolean (true/false) stating whether the component recommends archiving this eventitem. archiveDuration if archive is true Lifetime of the archiving (for example ‘2 years’ or ‘6 months’) parameters yes A container of parameters that belong to this event item.\nUnlike an EPICS channel, a CSW event can contain several associated keys and values (called parameters in the schema).\nAn excerpt from an example publish-model.conf file for the TCS pk Assembly is shown below. It shows part of the definition of the zenithAngle event.\npublish {\n    event = [\n    {\n      name = zenithAngle\n      description = \"\"\"\n       |The zenith angle is the distance in degrees of the telescope's optical axis from the zenith.\n       |\n       |The zenithAngle event item includes both the zenith angle for the current position of the\n       |telescope\n       |as well as the demanded zenith angle. When the telescope is tracking, the error between \n       |demand and current should be zero.\n       |\"\"\"\n      requirements = [“REQ-2-TCS-4270”]\n      maxRate = 20\n      archive = true\n      archiveDuration = 1 year\n      parameters = [\n        {\n          name = current\n          description = \"Actual or current zenith angle of the telescope\"\n          type = float\n          minimum = 0\n          maximum = 90\n          units = degree\n        }\n        {\n          name = demand\n          description = \"The demanded zenith angle of the telescope\"\n          type = float\n          minimum = 0\n          maximum = 90\n          units = degree\n        }\n      ]\n    }\nThe annotated screenshot below shows the portion of the file generated by the command: icd-db -s TCS –o TCS.pdf, which generates a PDF file for the TCS subsystem. The figure shows where each of the fields ends up on the final product.","title":"Events"},{"location":"/modelFiles/modelFiles.html#observe-events","text":"Observe events are different from other events in that they are predefined. For this reason you only need to list the name of the observe event in the publish model file under observeEvents. For example:\nobserveEvents = [\n    ObserveStart\n    ObserveEnd\n]\nThe predefined observe event names are references to the tmt-icd/ESW-Model-Files definitions on GitHub.\nBelow is an example that references all the predefined observe events:\nobserveEvents = [\n    ObserveStart\n    ObserveEnd\n    ExposureStart\n    ExposureEnd\n    ReadoutEnd\n    ReadoutFailed\n    DataWriteStart\n    DataWriteEnd\n    ExposureAborted\n    PrepareStart\n\n    // IRDetector specific\n    IRDetectorExposureData\n    IRDetectorExposureState\n\n    // OpticalDetector specific\n    OpticalDetectorExposureData\n    OpticalDetectorExposureState\n\n    // WFSDetector specific\n    WfsDetectorExposureState\n    PublishSuccess\n    PublishFail\n\n    // Sequencer specific\n    PresetStart\n    PresetEnd\n    GuidestarAcqStart\n    GuidestarAcqEnd\n    ScitargetAcqStart\n    ScitargetAcqEnd\n    ObservationStart\n    ObservationEnd\n    ObservePaused\n    ObserveResumed\n    DowntimeStart\n\n    // DMS specific\n    MetadataAvailable\n    ExposureAvailable\n  ]","title":"Observe Events"},{"location":"/modelFiles/modelFiles.html#images","text":"The images section of the publish-model.conf file is used to declare that a component publishes images that other components can subscribe to (via the TMT VIZ APIs that are to be defined).\nThe images container is an array containing one or more image description items. The fields of an image item are shown in the following table:\nField Required? Notes name yes The name of the image item. This should be a simple name like “guider1”. The prefix for all images is subsystem.component. description yes A description of a single image item (may contain Markdown and HTML). The description is in triple quotes for multi-lined text. channel yes The VIZ image channel (for example: viz.wfos.agwfs1) format no The image format (default: FITS) size yes An array of two numbers: the image dimensions (for example: [2048, 2048]]) pixelSize yes Number of bytes per pixel maxRate no Maximum rate the image is published metadata yes A container of one or more metadata items that belong to this image.\nThe format of a single metadata item for an image is shown in the table below:\nField Required? Notes name yes Name of the image metadata description yes A description of this metadata type yes The data type of the keyword value (One of: [boolean, integer, string, byte, short, long, float, double]) keyword no FITS keyword (for example: SCALE, ITIME)\nBelow is an example section of a publish-model.conf file that shows two published images. Other components can then reference these images in the subscribe-model.conf file to indicate that they will subscribe to the published images.\nimages = [\n    {\n      name = guider1\n      description = \"Images from the WFOS AGWFS 1\"\n      channel = viz.wfos.agwfs1\n      format = FITS\n      size = [2048, 2048]\n      pixelSize = 2\n      maxRate = 5.0\n      metadata = [\n        {\n          name = platescale\n          type = float\n          description = \"platescale of image in arcsec/pixel\"\n          keyword = SCALE\n        }\n        {\n          name = integrationTime\n          type = integer\n          description = \"integration time of image in ms\"\n          keyword = ITIME\n        }\n      ]\n    }\n    {\n      name = guider3\n      description = \"Images from the WFOS AGWFS 3\"\n      channel = viz.wfos.agwfs1\n      format = FITS\n      size = [2048, 2048]\n      pixelSize = 2\n      maxRate = 5.0\n      metadata = [\n        {\n          name = platescale\n          type = float\n          description = \"platescale of image in arcsec/pixel\"\n          keyword = SCALE\n        }\n        {\n          name = integrationTime\n          type = integer\n          description = \"integration time of image in ms\"\n          keyword = ITIME\n        }\n      ]\n    }\n  ]","title":"Images"},{"location":"/modelFiles/modelFiles.html#other-event-types","text":"Some events signal an occurrence of an activity in a component that other systems use to synchronize actions. Some, like observe events, are system defined. They are not periodic, so a rate is not necessary. The publish-model.conf file has a container for events the component publishes that includes an array of one or more events.\nCurrent states, which are published by HCDs for assemblies, are not actually events, but are structured the same, and written in the currentStates block instead of the events block.\nEvents and current states have the same schema, with a name, description, and parameters describing the event data. Below is an example current state event described in the publish-model.conf file:\ncurrentStates = [\n    {\n      name = \"nacqUnarchived\"\n      archive = false\n      parameters = [\n        {\n          name = nacq_detector_state\n          description = \"current state of the NACQ detector\"\n          enum = [EXPOSING, READING, IDLE, ERROR]\n        }\n        {\n          name = nacq_period\n          description = \"NACQ continuous read period\"\n          type = float\n          units = seconds\n        }\n        {\n          name = nacq_contRead\n          description = \"NACQ continuous read state enabled\"\n          type = boolean\n        }\n        {\n          name = nacq_mag_position\n          description = \"NACQ magnifier stage motor position\"\n          type = float\n          // units = TBD\n        }\n        {\n          name = nacq_position\n          description = \"nominal position of the NACQ/NHRWFS stage for the NACQ \"\n          // array of 3 floating point numbers in mm\n          type = array\n          dimensions: [3]\n          items = {\n            type = float\n          }\n          units = mm\n        }\n      ]\n    }\nThe screenshot below shows part of the PDF display for the above CurrentStates example:","title":"Other Event Types"},{"location":"/modelFiles/modelFiles.html#service-model-file","text":"Another optional icd model file is service-model.conf. It is used to describe HTTP services provided by or consumed by a component. The actual HTTP services are described in OpenAPI files that are also stored in the icd database.\nOn the consumer side, the file can indicate which routes of the HTTP service it uses.\nHere is an example consumer service-model.conf:\nsubsystem = TEST\ncomponent = env.ctrl\n\nrequires = [\n  {\n    subsystem = TEST2\n    component = SegmentService\n    name = esw-segment-db\n    // Optional routes / paths used\n    paths = [\n      {\n        path = /setPosition\n        method = post\n      },\n      {\n        path = /currentPositions\n        method = get\n      }\n    ]\n  }\n]\nThe above example states that the component uses the HTTP methods POST /setPosition and GET /currentPositions from the service. The paths are optional and just for information. The generated documentation for an ICD between two subsystems or components will only display the parts of HTTP services that are declared as being used (in the paths array). By default, if the paths are not specified, the complete service API will be included in the ICD documentation.\nIn the example service-model.conf file from a service provider below, the line:\nopenApi = esw-segment-db.json\npoints to the OpenAPI definition for the HTTP service that is being provided (The OpenAPI file should be in the same directory as the service-model.conf file and can be in JSON or YAML format and have the suffix .json, .yaml or .yml). Both the service-model information and the contents of the OpenAPI file are stored in the icd database where they are used to produce documentation (YAML files are first converted to JSON).\nservice-model.conf:\nsubsystem = TEST2\ncomponent = SegmentService\n\nprovides = [\n  {\n    name = esw-segment-db\n    description = \"HTTP API to ESW Segment DB service, used for keeping track of TMT mirror segments\"\n    openApi = esw-segment-db.json\n  }\n]\nThe screenshot below shows how the above service provider info is displayed in the icd web app:\nIf you click on the small button in the Name column, the detailed display is toggled open or closed. If you click on the link next to it, the documentation for the HTTP service is opened in a new tab. The format of the documentation for HTTP services is different from that of events, since it is provided by the swagger-ui library. The PDF version is somewhat simpler and is provided by the swagger-codegen command line application.\nNote that each component can declare multiple services consumed and/or provided in the service-model.conf file. You can find example service-model.conf files and OpenAPI files in the examples/3.0 directory in the icd sources.","title":"Service Model File"},{"location":"/modelFiles/modelFiles.html#alarms","text":"An alarm is published to mark an abnormal condition that requires attention. Alarms are not errors; they are conditions that occur asynchronously while components are executing or inactive.\nThe alarm feature has been redesigned for the CSW PDR in response to CoDR comments. The structure of the model follows the design of the Alarm Configuration file, which provides a listing of all possible alarms within the Observatory, as well as information for the operator to respond to the alarm.\nThe table below lists the required and optional fields for an alarm definition in alarm-model.conf:\nField Required? Notes name yes Name of the alarm, which should be one word. description yes A description of the alarm including what is the cause and possible response. The description is in triple quotes for multi-lined text. Note that spaces between paragraphs are retained. requirements no List of requirements that flow to this alarm severityLevels yes An array of severity levels that the alarm can have (besides Disconnected, Indeterminate, Okay): Default is any severity. Possible values are: Warning, Major, Critical. location yes A text description of where the alarming condition is located alarmType yes The general category for the alarm: One of: Absolute, BitPattern, Calculated, Deviation, Discrepancy, Instrument, RateChange, RecipeDriven, Safety, Statistical, System probableCause yes The probable cause for each level or for all levels operatorResponse yes Instructions or information to help the operator respond to the alarm autoAck yes Does this alarm automatically acknowledge without operator? latched yes Does this alarm latch?\nBelow is an example alarm-model.conf file:\nsubsystem = TEST\ncomponent = env.ctrl\n\nalarms = [\n    {\n      name = limit\n      description = \"The NGS FSM stage has reached a limit. It is not possible to position the FSM.\"\n      requirements = [TBD]\n      severityLevels = [Major]\n      location = \"NGS FSM stage\"\n      alarmType = System\n    probableCause = \"The PFSM HCD was commanded without the knowledge of the assembly, or the configured soft limits are incorrect\"\n      operatorResponse = \"Execute the datum command\"\n      autoAck = false\n      latched = true\n    }\n  ]\nThe PDF output generated from this part of the alarm-model.conf file is shown below:\nNote In previous icd versions, the alarms were listed in the publish-model.conf file and this is still supported for backward compatibility.","title":"Alarms"},{"location":"/modelFiles/modelFiles.html#subscribe-model","text":"The subscribe-model.conf file lists the event information a component subscribes to from other components. The subscribe-model.conf file is simpler than the publish-model.conf file, containing only references to the published items.\nLike publish-model.conf, the subscribe-model.conf file includes sections for each of the kinds of events or images that are available: events, observeEvents, images and currentStates. Each section is an array of items with the same fields as shown in the table below. Only the subsystem, component, and name fields are required.\nField Required? Notes subsystem yes Name of the publisher’s subsystem. component yes Name of the component publishing the item. name yes The simple name of the item such as: zenithAngle. usage no Describes how the item is being used by the subscriber requiredRate no The rate the subscriber needs updates of the item in order to operate properly (in Hz). This may not be the rate that the publisher publishes. maxRate no The maximum rate at which the subscriber can process the item (in Hz).\nBelow is an example subscribe-model.conf file for an IRIS component called oiwfs_adc_assembly that uses the published data of the TCS.\nsubsystem = IRIS\ncomponent = oiwfs_adc_assembly\n\nsubscribe {\n  events = [\n    {\n      subsystem = TCS\n      component = cmIRIS\n      name = oiwfs1AtmDispersion\n      usage = \"Atmospheric dispersion stream\"\n      requiredRate = 1\n    }\n    {\n      subsystem = TCS\n      component = cmIRIS\n      name = oiwfs2AtmDispersion\n      usage = \"Atmospheric dispersion stream\"\n      requiredRate = 1\n    }\n    {\n      subsystem = TCS\n      component = cmIRIS\n      name = oiwfs3AtmDispersion\n      usage = \"Atmospheric dispersion stream\"\n      requiredRate = 1\n    }\n    {\n      subsystem = IRIS\n      component = oiwfs_poa_assembly\n      name = POS_current\n      usage = \"Current OIWFS probe rotations needed to set correct ADC orientations\"\n    }\n    {\n      subsystem = NFIRAOS\n      component = rtc\n      name = oiwfsImage\n      usage = \"OIWFS ellipticity correction stream for ADCs\"\n    }\n  ]\n}\nHere is another example subscribe-model.conf that also subscribes to a published image stream:\nsubscribe {\n\n  events = [\n    {\n      subsystem = TEST\n      component = lgsWfs\n      name = engMode\n    }\n  ]\n\n  // Components can also subscribe to VIZ image streams\n  images = [\n    {\n      subsystem = TEST\n      component = lgsWfs\n      name = guider1\n      usage = \"WFOS guider images use for acquisition\"\n    }\n  ]\n}\nEvents have been redesigned for the CSW PDR. Components write their data and other systems sample it at the rate they need. requiredRate allows a component to state a rate they require to operate properly. It’s up to the publisher to make sure that they can provide that rate. This is part of checking interfaces.\nThere is minimal documentation for subscribe items. The full description of an item belongs with the publisher, not the subscriber. The subscriber is only referencing its use of information published by another component.\nThe name field must match the name of published item in another component. It must be spelled correctly. The best way is to browse the API of the source system and copy the full path.\nBy default, subscribed events are not displayed in API documents. To include them, pass the –clientApi option to icd-db, or select the Include client API information check box in the web app.\nThe figure below shows a section of the display of the icd web app for the above subscribe-model.conf file. The descriptions are looked up in the database (originally from publish-model.conf files in other components).\nSee also the example subsystems in the icd GitHub repo that show the different types of events and images used in the subscribe-model.conf files.","title":"Subscribe-model"},{"location":"/modelFiles/modelFiles.html#command-model","text":"The command-model.conf file describes the submit commands the component accepts (receive) and the submit commands it sends to other components it depends on (send). As in other sections, there is a block for the send and receive entries. The required and optional fields of command-model.conf are shown in the table below:\nField Required? Notes subsystem yes Name of the subsystem. Must be the same as SE subsystem name. component yes Name of the component that uses this command-model.conf file. Should match name used elsewhere. receive yes The block for commands this component supports. description no An optional overall description of the commands received by the component. The description is in triple quotes for multi-lined text. send no The block for commands this component sends to other components.\nThe receive block holds an array of items that are descriptions of commands the component receives or accepts.\nThe required and optional fields of the receive block are shown in table below.\nField Required? Notes name yes Name of the command (appended to prefix). description yes A description of the command. requirements no A list of one or more TMT requirements that are associated with this command. preconditions no List of preconditions for this command, including safety.precautions. Unless otherwise documented, it is assumed that the conditions ALL need to be met. postconditions no List of postconditions for this command, including safety precautions. Unless otherwise documented, it is assumed that the conditions ALL need to be met. requiredArgs no A list of command arguments (parameters) that are required. parameters no The block for arguments the command supports. Parameters are as described for events. completionType no Indicates the completion type of a command: See CSW CommandService API for details. Possible values: immediate, longRunning, oneway (default: immediate). resultType no Defines a list of parameters in the result (For commands that return a result) in the same format as the command parameters. completionCondition no For oneway commands, a list of conditions (string text) for determining command completion (if applicable). Unless otherwise documented, it is assumed that the conditions ALL need to be met. role no The user role required in order to execute this command (one of: eng, admin or user). Some commands may be protected and only allowed for engineering or admin users. The default required role is a regular user role.\nThe contents of the parameters and resultType containers are parameters as described for events in a previous section.\nThe send block contains a list of commands this component sends to other components. The required fields for each item in the list are shown in the following table.\nField Required? Notes subsystem yes The TMT subsystem for the component that receives the command component yes Name of the component that receives the command. Should match name used elsewhere. name yes name of the command\nAn example of the beginning and the receive block from a command-model.conf file for is shown below.\nsubsystem = TEST\ncomponent = lgsWfs\n\ndescription = \"Example Commands …\"\n\nreceive = [\n  {\n    name = LGS_WFS_INITIALIZE\n    description = \"\"\"\n       |LGS_WFS_INITIALIZE command will:\n       |* disable the LGS WFS engineering continuous read mode (if required)\n       |* (re)connect to the LGS WFS HCD\n       |* set LGS WFS exposure parameters to default values\n    \"\"\"\n    requirements = [\"INT-TEST-AOESW-1000\"]\n    parameters = [\n      {\n        name = wfsUsed\n        description = \"OIWFS used\"\n        type = string\n      }\n    ]\n    completionType = oneway\n    completionCondition = [\n      \"List of conditions to meet for oneway command to be complete...\",\n      \"condition two\",\n      \"condition three\"\n    ]\n  }\n]\nThe resulting PDF display for the above model file is shown in the screenshot below.\nThe send container documents the configuration commands one component sends to another. This allows mapping the command flow in the system and dependencies between components. The name of the configuration command, the component and the subsystem are enough to identify the destination of the configuration command.\nThe example send container section of the command-model.conf file for the TCS Corrections assembly is shown below.\nsend = [\n  //*******\n  // cabinet-environment assembly\n  {\n    name = GLY_init\n    subsystem = IRIS\n    component = cabinet_environment_assembly\n  }\n  {\n    name = GLY_test\n    subsystem = IRIS\n    component = cabinet_environment_assembly\n  }\n  {\n    name = TEMP_init\n    subsystem = IRIS\n    component = cabinet_environment_assembly\n  }\n  {\n    name = TEMP_test\n    subsystem = IRIS\n    component = cabinet_environment_assembly\nThe generated HTML output from the above send section of the command-model.conf file is shown below. The description and other details are taken from the publish information in the database.\nNote By default, sent commands are not displayed in API documents. To include them, pass the –clientApi option to icd-db, or select the Include client API information check box in the web app.","title":"Command-model"},{"location":"/icd-db/icd-db.html","text":"","title":"Using the icd-db command line app"},{"location":"/icd-db/icd-db.html#using-the-icd-db-command-line-app","text":"The icd-db program can be used to validate and ingest model files into the database. In order to use the icd-db program, the MongoDB server must be running (see Installing MongoDB). Most of what icd-db command provides can also be done using the web interface, so it’s possible to skip this step.\nThe figure above shows the usage of the icd-db program. Its primary purpose is to validate and ingest model files into the ICD Model File Database. If any of the model files under the given directory don’t pass validation, then nothing is changed in the database. Error messages indicate where the validation errors occurred, including a file name and a position in JSONPath format.\nBelow you see the options for the icd-db command, which are listed with the –help option. Some of the options are basic querying of the database, to see what subsystems and components are currently in the local database, and information about them, such as data rates and units used. This can be useful when developing and browsing APIs without bringing up the full system.\nicd-db 3.0.0\nUsage: icd-db [options]\n\n  --db <name>              The name of the database to use (default: icds4)\n  -h, --host <hostname>    The host name where the database is running (default: localhost)\n  -p, --port <number>      The port number to use for the database (default: 27017)\n  -i, --ingest <dir>       Top level directory containing files to ingest into the database\n  -l, --list [subsystems|assemblies|hcds|all]\n                           Prints a list of ICD subsystems, assemblies, HCDs or all components\n  --listData <subsystem>   Prints a list of event sizes and yearly accumulation of archived data for \n\t\t\t   components of the specified subsystem.\n  -u, --allUnits           Prints the set of unique units used in all received commands and published events \n\t\t\t   for all components in DB.\n  -c, --component <name>   Specifies the component to be used by any following options \n\t\t\t   (subsystem must also be specified)\n  -s, --subsystem <subsystem>[:version]\n                           Specifies the subsystem (and optional version) to be used by any following options\n  -t, --subsystem2 <subsystem>[:version]\n                           Specifies the second subsystem (and optional version) in an ICD to be used by \n\t\t\t   any following options\n  --component2 <name>      Specifies the subsytem2 component to be used by any following options \n\t\t\t   (subsystem2 must also be specified)\n  --icdversion <icd-version>\n                           Specifies the version to be used by any following options (overrides subsystem \n\t\t\t   and subsystem2 versions)\n  -o, --out <outputFile>   Saves the selected API (or ICD) to the given file in a format based on the file's\n \t\t\t   suffix (html, pdf) or generates code for the given API in a language based on the\n \t\t\t   suffix ('scala', 'java', 'ts' (typescript), py (python))\n  --drop [db|subsystem|component]\n                           Drops the specified component, subsystem, or the entire icd database \n\t\t\t   (requires restart of icd web app)\n  --versions <subsystem>   List the version history of the given subsystem\n  --diff <subsystem>:<version1>[,version2]\n                           For the given subsystem, list the differences between <version1> and <version2> \n\t\t\t   (or the current version)\n  -m, --missing <outputFile>\n                           Generates a 'Missing Items' report to the given file (dir for csv) in a format \n\t\t\t   based on the file's suffix (html, pdf, otherwise text/csv formatted files are\n \t\t\t   generated in given dir)\n  -a, --archived <outputFile>\n                           Generates an 'Archived Items' report for all subsystems (or the given one) to the\n \t\t\t   given file in a format based on the file's suffix (html, pdf, csv)\n  --allSubsystems          Include all subsystems in searches for publishers, subscribers, etc. while \n\t\t\t   generating API doc (Default: only consider the one subsystem)\n  --clientApi              Include subscribed events and sent commands in the API dic (Default: only include\n\t\t\t   published events and received commands)\n  --orientation [portrait|landscape]\n                           For PDF output: The page orientation (default: landscape)\n  --fontSize <size>        For PDF or HTML file output: The base font size in px for body text (default: 10)\n  --lineHeight <height>    For PDF or HTML file output: The line height (default: 1.6)\n  --paperSize [Letter|Legal|A4|A3]\n                           For PDF output: The paper size (default: Letter)\n  --documentNumber text    For PDF output: An optional document number to display after the title/subtitle\n  --package package.name   Package name for generated Scala files (default: no package)\n  --help\n  --version\nSome example commands are shown below.\nTo ingest the directory of model files created in the last section use the -i or --ingest option:\nicd-db --ingest directoryName\nThe –l or --list option with a value of subsystems, assemblies, HCDs, or all will list the components in the database that meet the criteria:\n$ icd-db –list all\nTo list just assemblies:\n$ icd-db –list assemblies\nList only HCDs:\n$ icd-db –list hcds\nList the existing subsystems in the local database:\n$ icd-db –list subsystems\nSeveral other commands are available and are not documented here.","title":"Using the icd-db command line app"},{"location":"/icd-db/icd-db.html#generating-documents-and-code-from-the-icd-database","text":"The icd-db –o option can be used to output a file in a format based on the file’s suffix (.pdf and .html are supported for generating documentation and .scala, .java, .py (python) and .ts (typescript) are supported for generating code containing the event, command and parameter keys for the given subsystem and/or component:\n$ icd-db –s TCS -o TcsApi.pdf    // Generate a PDF for TCS\n$ icd-db –s TCS -o TcsApi.scala  // Generate Scala code for TCS\n$ icd-db –s TCS -o TcsApi.java   // Generate Java code for TCS\n$ icd-db –s TCS -o TcsApi.py     // Generate Python code for TCS\n$ icd-db –s TCS -o TcsApi.ts     // Generate Typescript code for TCS\nYou can also generate documentation and code for a specific component of a subsystem and specify the package name (required for Java):\n$ icd-db –s IRIS -c ifs.scale -o IrisApi.pdf                     // Generate a PDF for IRIS.ifs.scale\n$ icd-db –s IRIS -c ifs.scale –package iris.api -o IrisApi.scala // Generate Scala code for IRIS.ifs.scale\n$ icd-db –s IRIS -c ifs.scale –package iris.api -o IrisApi.java  // Generate Java code for IRIS.ifs.scale\n$ icd-db –s IRIS -c ifs.scale -o IrisApi.py                      // Generate Python code for IRIS.ifs.scale\n$ icd-db –s IRIS -c ifs.scale -o IrisApi.ts                      // Generate Typescript code for IRIS.ifs.scale\nThe generated code always contains a top level object (scala), class (java, python) or namespace (typescript) with the base name of the file. Then there are nested objects for each component, and in each component, nested objects for each event and command, containing constants for all the event keys, command names and parameter keys.\nNote After generating the code, icd-db attempts to format it using a command line formatter application in your shell path. It uses scalafmt for Scala, prettier for TypeScript, black for Python and google-java-format for Java. If it doesn’t find those it will print a message, but still generate the file. You can install scalafmt and google-java-format with cs (coursier), black with pip (pip3), and prettier with npm.\nYou can also generate code using the web interface, as described later.","title":"Generating Documents and Code from the ICD Database"},{"location":"/icd-fits/icd-fits.html","text":"","title":"Using the icd-fits command line app"},{"location":"/icd-fits/icd-fits.html#using-the-icd-fits-command-line-app","text":"The icd-fits command line application can be used to view and update the FITS Dictionary and related files or to generate a PDF or other type of file displaying the FITS keywords for a given subsystem or component.\nIn normal operations, the FITS Dictionary is loaded automatically from the published DMS-Model-Files GitHub repository. At the time of writing this has not yet been published.\nBelow are the available options for the icd-fits program, which you can list with the icd-fits --help option:\nicd-fits 3.0.0\nUsage: icd-fits [options]\n\n  -d, --db <name>          The name of the database to use (for the --ingest option, default: icds4)\n  --host <hostname>        The host name where the database is running (for the --ingest option, default: localhost)\n  --port <number>          The port number to use for the database (for the --ingest option, default: 27017)\n  -c, --component <name>   Specifies the component to be used by any following options (subsystem must also be specified)\n  -s, --subsystem <subsystem>[:version]\n                           Specifies the subsystem (and optional version) to be used by any following options\n  -t, --tag <tag>          Filters the list of FITS keywords to those with the given tag\n  -l, --list               Prints the list of known FITS keywords\n  --validate <file>        Validates a JSON formatted file containing the FITS Keyword dictionary and prints out any errors\n  -g, --generate <file>    Generates an updated FITS dictionary JSON file by merging the one currently in the\n                        icd database with the FITS keyword information defined for event parameters in the\n \t\t\t\t    publish model files. If a subsystem is specified (with optional version), the\n \t\t\t\t    merging is limited to that subsystem.\n  -i, --ingest <file>      Ingest a JSON formatted file containing a FITS Keyword dictionary into the icd database\n  --ingestTags <file>      Ingest a JSON or HOCON formatted file defining tags for the FITS dictionary into the icd database\n  --ingestChannels <file>  Ingest a JSON or HOCON formatted file defining the available FITS channels for each subsystem into the icd database\n  -o, --out <outputFile>   Generates a document containing a table of FITS keyword information in a format \n\t\t\t   based on the file's suffix (html, pdf, json, csv, conf (HOCON))\n  --orientation [portrait|landscape]\n                           For PDF output: The page orientation (default: landscape)\n  --fontSize <size>        For PDF or HTML file output: The base font size in px for body text (default: 10)\n  --lineHeight <height>    For PDF or HTML file output: The line height (default: 1.6)\n  --paperSize [Letter|Legal|A4|A3]\n                           For PDF output: The paper size (default: Letter)\n  --help\n  --version\n --version","title":"Using the icd-fits command line app"},{"location":"/icd-fits/icd-fits.html#fits-keywords","text":"The generated subsystem APIs contain infomation about FITS keywords whose values come from event parameters. That is, an event’s parameter value is the source of the FITS keyword’s value.\nFITS keyword data is stored in three files under DMS-Model-Files on GitHub. Once DMS is published, the file should be automatically loaded by the icdwebserver or icd-git --ingest commands. Until then, the FITS keywords, channels and tags can be manually loaded into the icd database once by running (from the icd source directory):\nicd-fits -i examples/3.0/FITS-Dictionary.json --ingestChannels examples/3.0/FITS-Channels.conf --ingestTags examples/3.0/FITS-Tags.conf\nAlternatively you can check out and manually ingest DMS-Model-Files into the local icd database by using the Upload feature in the icd web app or with the command line:\nicd-db -i DMS-Model-Files\nThe contents of the files are as follows: * * FITS-Dictionary.json - This is the FITS dictionary and contains an entry for each FITS keyword, mapping it to source event parameters. If a keyword has multiple sources, named channels are used, each containing one source. * FITS-Channels.conf - This defines which channels are available for each subsystem (Channels are used when a FITS keyword has multiple source event parameters). * FITS-Tags.conf - Assigns tags to FITS keywords, which can be used in the web app to filter and display the FITS keyword information.\nBesides the three above files, FITS keyword information can be defined in the publish-model.conf files for each subsystem component. Event parameters can define the associated keyword as follows:\nkeyword = IMGDISWV\nIf the keyword has multiple source parameters, you can specify the channel:\nkeyword = IMGDISWV\nchannel = ATM\nIn some more complicated cases, you can also specify multiple keywords whose values are taken from an index (or rowIndex for matrix/2d arrays) in the parameter’s array values:\nkeywords: [\n     {\n       keyword = OIWFS1PS\n       rowIndex = 0\n     }\n     {\n       keyword = OIWFS2PS\n       rowIndex = 1\n     }\n     {\n       keyword = OIWFS3PS\n       rowIndex = 2\n     }\n]\nThe FITS keyword definitions in a subsystem’s model files can be used to generate a new FITS dictionary by merging the existing FITS dictionary with the definitions in the publish model files. In this case the information from the published events overrides the information in the existing FITS dictionary:\nicd-fits --subsystem IRIS --generate FITS-Dictionary.json\nOr using the short form options and with a subsystem version:\nicd-fits -s IRIS:1.7 -g FITS-Dictionary.json\nThe generated FITS dictionary JSON file can then be copied to the DMS-Model-Files repository and published, so that it will be automatically used by the icd web app and command line apps (Note that Publishing DMS-Model-files requires special permission).\nYou can also manually load the new FITS dictionary into your local icd database using the command line:\nicd-fits -i FITS-Dictionary.json","title":"FITS Keywords"},{"location":"/icd-fits/icd-fits.html#generating-a-document-listing-the-fits-keywords","text":"You can use icd-fits to print a list of keywords coming from a subsystem or component to stdout. For example, the following command lists the keywords for IRIS:\nicd-fits --subsystem IRIS --list\nOr you can use the short form options and restrict the output to a component:\nicd-fits -s IRIS -c pupilview -l\nYou can create a PDF of the IRIS FITS keywords like this:\nicd-fits -s IRIS -o IRIS-Keywords.pdf\nThe format of the output file depends on the suffix. You can also generate csv, html, json and conf (HCON) formatted files with the same information.","title":"Generating a Document listing the FITS Keywords"},{"location":"/webapp/webapp.html","text":"","title":"Using the Web Interface"},{"location":"/webapp/webapp.html#using-the-web-interface","text":"This section describes the web interface for IDBS. The idea is to show each of the possible steps.\nThe browser-based user interface allows ingesting model files and displaying versioned “API”s for each component. An API is defined as all the public functionality of a component and subsystem including inputs and outputs. An ICD is produced by taking the intersection of two published subsystem API documents. ICDs are then also published as versioned documents that depend on published subsystem API versions. The publishing of APIs and ICDs is a role of Systems Engineering and is therefore password protected. It can be performed using the icd web app (requires special command line option to icdwebserver). The web interface can be used to produce draft ICD and API documents that can be shared prior to the official publishing by Systems Engineering.","title":"Using the Web Interface"},{"location":"/webapp/webapp.html#starting-the-icd-web-app","text":"To start the icd web app, run:\nicdwebserver\nBy default, this starts the web app on port 9000 on localhost (http://localhost:9000). You can override this with options. For example:\nicdwebserver -Dhttp.port=9898 -Dhttp.host=192.168.178.77","title":"Starting the icd web app"},{"location":"/webapp/webapp.html#upload-files","text":"Installing the web app and uploading through the web app is not a bad way to check the content of model files because it also allows checking to see if the links are entered correctly. icd-db will only check that the files are syntactically correct.\nUploading with the browser works best with recent browser versions that support uploading a directory including all files in the directory. By using this feature, you can upload an entire subsystem of model files in one click. If your browser does not support uploading directories, try using Chrome.\nIf the web server is running on your own machine, go to http://localhost:9000. The empty website is shown in the following figure. The upload button is shown circled in red (the red circle does not appear in the UI!)\nNote The icd web app automatically ingests any released APIs and ICDs on startup by downloading any missing versions from the GitHub repos under https://github.com/tmt-icd. Then you can upload any directories containing model files that you are working on. These will be the considered the “working version” or “*” in the subsystem version menu.","title":"Upload Files"},{"location":"/webapp/webapp.html#procedure-for-uploading-files","text":"Select the upload button in the web app. The following figure shows the web page after selecting the upload button:\nSelect the Choose Files button and navigate to the directory of your model files. It can be a directory holding a single component or a directory containing other directories where each contained directory includes one component as shown in the following figure. The parent directory should be imported at least once to get the subsystem-model.conf file, which is a sibling of the component directories.\nSelecting the directory will cause the web service to upload all the contained files and import them into the model file database. The program shows progress and the status area shows any problems. The following figure shows the result of uploading the APS-Model-Files directory. It shows a progress bar in blue at 100%. Files other than icd model files are ignored and a warning is displayed (in case the file name was misspelled).\nThat’s all for uploading. This can be done over and over and nothing is permanent until the API is published.","title":"Procedure for Uploading Files"},{"location":"/webapp/webapp.html#view-a-subsystem-api","text":"The next example shows how to view a subsystem API.\nWith the subsystem uploaded, its API can be viewed in the browser by selecting the subsystem in the subsystem pull-down menu at the top of the screen. The menu shows all the subsystems found in the local database. The browser content area will redraw with the contents of the selected subsystem. The result of selecting APS is shown in the following figure.\nA couple of things to note: The area to the left shows a number of links. This area has one link for each component in the subsystem.\nThe content area displays all the components for the subsystem. Clicking on one of the component links jumps to the given component’s information.\nThe displayed API is constructed from the current versions of the models in the database, and is therefore considered an unpublished working version. Although APIs are published by Systems Engineering, the system allows the viewing of all versions of published APIs as well as the working version as shown above (Note: the published versions of the APIs are ingested directly from the GitHub repository, whereas the unpublished models are obtained only from the local database). To do this, select the desired version number in the dropdown menu next to the subsystem name.\nNote that “master” also appears in the list of versions and is linked to the contents of the master branch of a subsystem on GitHub. The contents of the master branch are automatically uploaded to the icd database (if there was a change) whenever you refresh the web app or when running the command: icd-git --ingestMissing.\nThere are two checkboxes in the Select dialog that are only enabled for APIs (when only one subsystem is selected).\nInclude client API information (subscribed events, sent commands) Search all TMT subsystems for API dependencies\nSelecting the first checkbox will include sections for subscribed events and sent commands in the API document, as well as columns for subscribers of published events and senders of received commands. By default, these are not displayed in API documents.\nSelecting the second checkbox will enable searching the entire database for subscribers of published commands and senders of received commands. By default, only the selected subsystem is searched for this information.","title":"View a Subsystem API"},{"location":"/webapp/webapp.html#check-for-missing-items","text":"A recent addition to the icd web app is the Missing button that generates a PDF report displaying subscribed events that have no known publisher, or sent commands that are not defined anywhere or component names that refer to nonexisting components.\nThe Missing report is based on the selected subsystem or subsystems. If no subsystem is selected, it reports on all subsystems. If two subsystems are selected (an ICD), the report only lists the missing items directly related to the two subsystems. If you select a single subsystem, the report will list all references that it makes to undefined items (commands, events, components).\nIt is a good ideas to view this report before publishing a subsystem API to find invalid references.","title":"Check for Missing Items"},{"location":"/webapp/webapp.html#generate-source-code-from-the-icd-database","text":"The Generate button lists the languages for which you can generate source code from the ICD database: Scala, Java, Python and TypeScript.\nFirst select a subsystem and, optionally, a version and component. Then select Generate → Scala, for example. The generated source code containing event and command names and keys for the selected subsystem and component(s) is downloaded automatically to a file named *Subsystem*Api.scala in your Downloads directory: For example: TcsApi.scala. The keys can be found in nested objects (namespaces or static classes) starting with the top level object.","title":"Generate Source Code from the ICD Database"},{"location":"/webapp/webapp.html#view-api-history","text":"The history of every published API can also be viewed, including an entry for every time the API is published. Selecting two different version checkboxes enables the Compare button, which shows the changes made between the versions in a JSON based format. Note that you can also compare versions of released APIs on GitHub under https://github.com/tmt-icd, since a version tag is added for each published version. There are also tools for comparing PDF files, which might be useful.\nTo view the API history, select a subsystem, and press the History button. The content area changes as shown in the following:","title":"View API History"},{"location":"/webapp/webapp.html#create-and-view-an-icd","text":"An ICD is formed by taking the intersection of the APIs of two TMT subsystems. That means in order to create an ICD there must be at least two subsystems in the database. The TCS API is created from various subsystem to TCS ICDs that exist and the TCS CODR SDD. The definitive TCS API will be a product of the TCS work packages.\nIt is possible to view ICDs with working/unpublished versions, with one unpublished version and one published version, or two published versions. ICDs can only be published between two published APIs.\nThis example will show how to view a working ICD between the published version 1.12 of the TCS API and the unpublished M1CS subsystem API.\nUpload all the working versions of the APIs needed to form an ICD. First select the version of the subsystem for the ICD. In the figure below the menu to the right of the subsystem shows the available versions. Version 1.12, the version published previously is selected. (To get back to the working version, select the asterisk in the menu.) Note that the content area says API for TCS 1.12 rather than the unpublished label.\nNext, select a second subsystem in the second subsystem menu as shown in the figure to below the Subsystem menu. The figure shows the available subsystems (some may be only local and others automatically ingested from the ICD GitHub repositories). TCS is also selectable since one subsystem component can have an ICD with another in the same subsystem. Selecting M1CS shows the following screenshot (without the red arrow). To get out of ICD mode and back to browsing APIs, select the top item (Select Subsystem) in the second subsystem menu on the Select tab.\nNote that the title shows ICD from TCS to M1CS (unpublished). This means that the displayed ICD is not published by Systems Engineering — it is a draft version.\nAlso note the circle on the screenshot below. The section “Events published by GLC” shows items published by the GLC component. The Subscriber column is a link to the component that subscribes to the event stream. The link can be selected to jump to the subscribing component, regardless of which of the two subsystems it is in.\nThe same is true for commands: There are links to the command senders for received commands.\nThe ability to see and display these links is one of the highest priority features for this project. This is one feature that is not possible with simpler documentation tools.","title":"Create and View an ICD"},{"location":"/webapp/webapp.html#view-icd-history","text":"Like an API, it’s possible to view the history of an ICD between two subsystems.\nWith a published ICD is selected, select the History button as was done in the about viewing an API history. The following screenshot shows the history for the IRIS to TCS ICD. The versions of the APIs are shown as well as the ICD version.","title":"View ICD History"},{"location":"/webapp/webapp.html#print-an-icd-or-api","text":"The last supported feature is to print an API document or save it as a PDF for inclusion as a review deliverable. Ideally, we will just provide a link to the IDBS that reproduces the referenced ICD, but the PDF option in the toolbar allows outputting a PDF version with a table of contents and front page. The figure below shows a portion of the PDF output for our TCS to M1CS ICD Version 1.1.","title":"Print an ICD or API"},{"location":"/webapp/webapp.html#view-a-graph-of-component-relationships","text":"The Graph button in the Select tab displays a dialog for creating a graph of component and subsystem relationships. The graph is based on the selected subsystems and components, which we call the primary components. These are displayed as solid ovals. All the components that the primary components talk (via events or commands) to are then included as dashed ovals. The edges of the graph indicate the flow of events and commands between the components. References to events or commands that were never defined are displayed in red, as are components that do not exist.\nThe figure below shows the Select dialog with the Graph toolbar button and the IRIS.oiwfs.poa component selected:\nPressing the Graph button opens a dialog with options for the graph:\nNote that the graph is created using the GraphViz Dot language. See https://graphviz.org/ for an explanation of layouts and overlap handling. You can also use the icd-viz command line application to produce the same graph. The command line version lets you choose more than two primary components and save the Dot file.\nPressing Apply in the Graph dialog creates this graph for the selected IRIS component:\nThe default colors used for the graph can be found in the icd-viz reference.conf file and can also be overridden with a command line option like -Dicd.viz.color.IRIS=darkgreen (Replace IRIS with the subsystem and the color with a valid Graphviz color). A future version of the icd web app may include a tab in the graph options dialog for configuring the colors.\nHere is a legend for the generated graph:\nIn the above graph, you can see that oiwfs.poa is the primary component (represented as a solid oval). It publishes events to other components, such as IRIS.oiwfs.detector and AOESW.aosq and subscribes to events from NFIRAOS.rtc and TCS.cmIRIS. AOESW.aosq also sends commands to oiwfs.poa, however the command names are not listed, since that option was not selected in the graph dialog. The red question mark in IRIS indicates that oiwfs.poa publishes events that have no known subscribers. The other red arrows indicate that it also subscribes to some events that are not published anywhere (perhaps an error). Displaying these errors is optional. The figure below shows the same graph with the missing events option turned off and command labels turned on.","title":"View a Graph of Component Relationships"}]}