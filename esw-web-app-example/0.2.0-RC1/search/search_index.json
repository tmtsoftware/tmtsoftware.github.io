{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"ESW Web Application Tutorial"},{"location":"/index.html#esw-web-application-tutorial","text":"In the ESW user interface design a web application is used when the user interface has special requirements that are not met by the interfaces to the control system provided by the User Interface Gateway. For instance, a web application should be used if specific application processing is needed or the UI needs results from a database using CSW Database Service.\nCreating a web application is not trivial and requires the programmer to understand several technologies as well as the ESW authentication and authorization system. Therefore, it is recommended that this approach be taken only when necessary.","title":"ESW Web Application Tutorial"},{"location":"/index.html#tutorial-welcome","text":"This tutorial uses a set of smaller tutorials to create a Web Application using the ESW Web Application template.\nThe application created in this tutorial is a coordinate formatter and application-specific backend service. The browser-based user interface (UI) has a form for inputting the right ascension and declination of an astronomical coordinate in decimal form. The coordinate is then submitted to a backend HTTP service (also created in this tutorial), using an application-specific route, where it is processed and returned as a formatted sexagesimal position. The returned result is then displayed in the UI.\nThe tutorial has been divided into 4 main flows that incrementally demonstrate the construction of a full web application consisting of an HTTP service backend and a React-based user interface.\nThe basic flow in “Creating a Web Application” will show you how to add a route to the backend application and consume them in your frontend. The flows following the basic flow are optional but demonstrate additional features that may be needed to make an application more complete.\nIf at any point in time you want to see the completed tutorial, you can view the final code here.\nCreating a Web Application Adding Authentication Adding Database Persistence Adding Paradox Documentation","title":"Tutorial Welcome"},{"location":"/flows/base-flow.html","text":"","title":"Creating a Web Application"},{"location":"/flows/base-flow.html#creating-a-web-application","text":"This flow demonstrates how to use the template to create our project, how to add simple routes, UI components, and how to build and test it.\nIn this tutorial, we will first generate the application from the template, and build it to ensure tools are in place. Then, we will delete the default implementation and replace it with our own implementation of a coordinate formatter. To do this, we will delete much of the template code and rewrite our own classes custom to our implementation.","title":"Creating a Web Application"},{"location":"/flows/base-flow.html#generate-application","text":"First we need to generate a scaffolding application using our giter8 template:\ng8 tmtsoftware/esw-web-app-template.g8 --name=sample\nThis will generate a sample folder with two sub-folders, sample-frontend and sample-backend. For a sanity check, let’s go ahead and build the front and back ends created by the template. This will also help ensure you have the necessary tools installed.\nYou are welcome to try out the generated sample project, which is basically a “Hello World” application, by following the instructions in the READMEs in each sub-folder.","title":"Generate Application"},{"location":"/flows/base-flow.html#compile-the-frontend","text":"The sample-frontend sub-folder is where your frontend application is located. It uses Typescript, React and node. Make sure node version v16.0.0 or higher is installed in your machine. Let’s compile our generated application.\ncd sample/sample-frontend\nnpm install\nnpm run build\nNote This tutorial uses the current ESW.UISTD selections for user interface languages, libraries, and tools. These are the current selections. They will be reviewed and updated once again as part of ESW Phase 2.","title":"Compile the Frontend"},{"location":"/flows/base-flow.html#compile-the-backend","text":"The sample-backend sub-folder is where your backend application is located. It uses the Scala ecosystem, which uses sbt as its build tool. Make sure coursier, Adopt OpenJDK 11, and the latest version of sbt are installed in your machine.\nNote For a very smooth setup experience, the coursier tool can be used to do all of these installations in one step as described here.\nLet’s compile our generated application.\ncd sample/sample-backend\nsbt\nsbt:sample-backend> compile","title":"Compile the Backend"},{"location":"/flows/base-flow.html#open-in-development-environment","text":"At this point, you may want to open the project in an Integrated Development Environment (IDE), such as Intellij, if you are using one. The template creates two projects, a Scala/sbt-based backend amd a Typescript/npm-based frontend, and because the two projects have different build systems, it is better to open each part, the frontend and backend, in separate IDE projects. We recommend Intellij for the backend, and VS Code or Intellij for the frontend.\nTo open the backend in Intellij, click on File->New Project from Existing Sources… and then browsing to the backend directory, sample/sample-backend. It should have a build.sbt file in it. Create an sbt-based project, and then accept the defaults, making sure the JDK is set to your installation of OpenJDK 11.","title":"Open in Development Environment"},{"location":"/flows/base-flow.html#develop-backend","text":"We will start with the backend HTTP service first. We will start by deleting the existing application and then create our custom code. Our backend will be written in Scala, so all Java code will be removed.\nIn ESW, a specialized backend service is only needed in the cases where the application has complicated or compute-expensive tasks that can not be satisfied by CSW-based components. In this case, an application-specific backend is created that is dedicated to the application UI and only provides the needed application functionality.\nNote Many web application frontend user interfaces will also send commands to control system CSW components through the User Interface Gateway.","title":"Develop Backend"},{"location":"/flows/base-flow.html#cleanup-existing-sample","text":"To remove the generated code from the template sample application, go to the sample-backend folder and:\nDelete the folders src/main/java ,src/test\nBrowse to src/main/scala/org/tmt/sample and\nDelete the existing files from core/models Delete the existing files from service Delete the file SampleImpl.scala from impl Delete the file JSampleImplWrapper.scala from http","title":"Cleanup existing sample"},{"location":"/flows/base-flow.html#add-our-models-classes","text":"We will now create the models used by our application. The first model is our request, the values that are sent to the backend, in which we will take a RA/Dec pair as decimals. The other model is the response from the backend, which returns the pair as formatted Strings. It also includes a UUID String for the request.\nThe request and response models must be put into a format that can be included in an HTTP request, which is this case is JSON. These model classes will be used to serialize and deserialize requests and responses to and from JSON.\nGo to core/models in src Add RaDecRequest.scala model class\nScala copysourcepackage org.tmt.sample.core.models\n\ncase class RaDecRequest(raInDecimals: Double, decInDecimals: Double)\nAdd the RaDecResponse.scala model class\nScala copysourcepackage org.tmt.sample.core.models\n\ncase class RaDecResponse(id: String, formattedRa: String, formattedDec: String)","title":"Add our Models classes"},{"location":"/flows/base-flow.html#add-our-implementation","text":"Now we will create our backend logic. First, we create the service API as a Scala trait. Our service will have two methods. The first method will take the RA/Dec request, format it, and then return the response. Our server will also maintain a list of all requests, so the first method will also store this pair as formatted strings in backend-side state.\nThe second method returns this stored list of all processed RA/Dec pairs.\nGo to service in src Create a RaDecService.scala file and add our raDecToString contract to our API, RaDecService, using our request and response models Add the getRaDecValues contract in the service RaDecService.scala\nScala copysourcepackage org.tmt.sample.service\n\nimport org.tmt.sample.core.models.{RaDecRequest, RaDecResponse}\n\nimport scala.concurrent.Future\n\ntrait RaDecService {\n  def raDecToString(raDecRequest: RaDecRequest): Future[RaDecResponse]\n  def getRaDecValues: Future[List[RaDecResponse]]\n}\nNow we will create the implementation class of this service. We use the Angle class from CSW to create the sexagesimal string values.\nGo to the impl package in src Add RaDecImpl.scala Extend RaDecService.scala to implement raDecToString Implement getRaDecValues contract in RaDecImpl.scala\nScala copysourcepackage org.tmt.sample.impl\n\nimport csw.params.core.models.Angle\nimport org.tmt.sample.core.models.{RaDecRequest, RaDecResponse}\nimport org.tmt.sample.service.RaDecService\n\nimport java.util.UUID\nimport scala.collection.mutable\nimport scala.concurrent.Future\n\nclass RaDecImpl extends RaDecService {\n\n  private val raDecValues = mutable.ListBuffer[RaDecResponse]()\n\n  override def raDecToString(raDecRequest: RaDecRequest): Future[RaDecResponse] = {\n    val formattedRa   = Angle.raToString(Math.toRadians(raDecRequest.raInDecimals*15))\n    val formattedDec  = Angle.deToString(Math.toRadians(raDecRequest.decInDecimals))\n    val raDecResponse = RaDecResponse(UUID.randomUUID().toString, formattedRa, formattedDec)\n    raDecValues.append(raDecResponse)\n    Future.successful(raDecResponse)\n  }\n  override def getRaDecValues: Future[List[RaDecResponse]] = Future.successful(raDecValues.toList)\n}\nNow, lets try to compile our code\nsbt:sample-backend> compile\nYou will notice it will give some compilation errors here. To fix these:\nDelete references to the classes we deleted earlier from src/main/org/tmt/sample/impl/SampleWiring.scala Add a placeholder for route\noverride lazy val routes: Route = ???\nGo to src/main/org/tmt/sample/http/SampleRoute.scala Delete references to the previously deleted classes from the Scala files Delete existing route Add a placeholder for route\nval route: Route = ???\nDelete references to the previously deleted classes from the Scala files in src/main/org/tmt/sample/http/HttpCodecs\nBe sure to delete references to deleted classes from import statements as well.\nTry compiling code again, this time it should compile successfully.\nsbt:sample-backend> compile","title":"Add our implementation"},{"location":"/flows/base-flow.html#add-a-route-for-our-implementation","text":"Next, we will provide the routing that links our HTTP request methods or endpoints to backend server processing created in our implementation class RaDecImpl.\nFirst, we need to inject a reference to an implementation of our service API to the routes, so that the appropriate method will be called for the matching endpoint and request method. Change the constructor of the route to take such an instance, and add an import for RaDecService:\nScala copysourceclass SampleRoute(raDecService: RaDecService, securityDirectives: SecurityDirectives)(implicit\n    ec: ExecutionContext\n) extends HttpCodecs {\nNext, we will add our routes. We will have a single endpoint raDecValues that supports two methods: POST and GET. The POST method will cause our backend service method raDecToString to be called, and GET will call getRaDecValues. We are using the Akka routing DSL to compose our HTTP routes. Visit here to learn more about the routing DSL.\nBe sure to add an import for our model RaDecRequest.\nScala copysourceval route: Route = {\n  path(\"raDecValues\") {\n    post {\n      entity(as[RaDecRequest]) { raDecRequest =>\n        complete(raDecService.raDecToString(raDecRequest))\n      }\n    } ~\n    get {\n      complete(raDecService.getRaDecValues)\n    }\n  } ~\n}\nNote The tilda (~) at the end, is used to concatenate paths in the Akka DSL. You can safely remove it for now. However, in the following section of this tutorial we are going to add new routes to this file. At that point, you would want to add it again to concatenate multiple routes.\nNext, let’s connect our routes to our service implementation in the wiring.\nGo to SampleWiring.scala Add a raDecImpl reference\nScala copysourcelazy val raDecImpl = new RaDecImpl()\nReplace the route placeholder with our route, injecting our service API implementation, and add an import for SampleRoute.\nScala copysourceimport actorRuntime.ec\noverride lazy val routes: Route = new SampleRoute(raDecImpl, securityDirectives).route\nAfter we add the route, it will show some compilation errors, to fix that we need to add the codec to serialize/deserialize our request/response","title":"Add a Route for our implementation"},{"location":"/flows/base-flow.html#add-codecs","text":"We are using borer to serialize/deserialize. It has support for two formats: JSON and CBOR(binary format)\nAdd the codecs in HttpCodecs.scala, along with imports for our models.\nScala copysourceimplicit lazy val raDecResponseCodec: Codec[RaDecResponse] = deriveCodec\nimplicit lazy val raDecRequestCodec: Codec[RaDecRequest]   = deriveCodec\nSampleRoute should now compile successfully and is ready to use.","title":"Add Codecs"},{"location":"/flows/base-flow.html#manually-test-our-application","text":"Start the Location Service with the Authorization and Authentication Service (we will use auth in the next section of the tutorial).\ncs install csw-services\ncsw-services start -k\nSet INTERFACE_NAME and AAS_INTERFACE_NAME environment variables with the Network interface of your machine. These are needed during startup of the application, so that it is able to connect to Location Service and register its IP address and location information.\nDuring development in your local machine, these can point to same Network interface. During production deployment, these will point to a outside (AAS_INTERFACE_NAME) and inside (INTERFACE_NAME) Network interface.\nFor more details, refer CSW environment variables and network topology.\nTry running our backend application\nsbt:sample-backend> run start\nIf the application starts successfully, it will show log messages with the server_ip and app_port registered to the Location Service.\nThe template includes a file, apptest.http, that can be used to run HTTP requests in Intellij. Update apptest.http with the code below, replacing the <server_ip>:<app_port> with the ones for your server as displayed in the log messages. Then run the request by clicking the green arrow next to the request to test your raDecValues POST route:\n#### Request to test raDecValues endpoint\nPOST http://<server_ip>:<app_port>/raDecValues\nContent-Type: application/json\n\n{\n  \"raInDecimals\": 2.13,\n  \"decInDecimals\": 2.18\n}\nThe successful response contains the formattedRa and formattedDec values with a unique id.\n{\n  \"id\": \"80ab3f42-a4cf-4249-b9a0-2b209aab48e8\",\n  \"formattedRa\": \"8h 8m 9.602487087684134s\",\n  \"formattedDec\": \"124°54'17.277618670114634\\\"\"\n}\nAdd this to your apptest.http, again replacing the server IP and port number, and test your raDecValues GET route\n####\nGET http://<server_ip>:<app_port>/raDecValues\nA successful response contains a list with the previous formatted RA/DEC entry.\n[\n  {\n    \"id\": \"d6a16719-72bf-4928-8bf3-abb125186f49\",\n    \"formattedRa\": \"8h 8m 9.602487087684134s\",\n    \"formattedDec\": \"124°54'17.277618670114634\\\"\"\n  }\n]\nChange the numbers in the POST test and run it again. Then, run the GET test again, and you will see both entries displayed in the list.\nSuccess!","title":"Manually test our application"},{"location":"/flows/base-flow.html#create-the-frontend","text":"In this section, we will be constructing a browser-based UI using React components in Typescript. We will create components that allow the user to specify an RA/Dec pair, and then a Submit button that will send the data to our backend. The response will then be rendered in UI components. We will also provide components to get and display the list of stored coordinates. This section of the tutorial will show how to add and render custom components within the application that act as clients to consume our backend routes.\nNote The frontend tutorial uses functionality from the ESW-TS library. Be sure and look at the documentation for ESW-TS once you start working on your own UI. ESW-TS documentation can be found here.\nFirst, cleanup unwanted code from the template:\nGo to the components/pages folder in src and delete all component files under this directory Delete the folder components/form Go to the utils folder and remove the contents of the api.ts file Go to the pages folder in test and delete all test files under this directory","title":"Create the Frontend"},{"location":"/flows/base-flow.html#add-models","text":"Now, we need to add Typescript models for the data we will send to and receive from our backend:\nGo to Models.ts in src/models Delete existing model interfaces Add our request and response models\nTypescript copysourceexport interface RaDecRequest {\n  raInDecimals: number\n  decInDecimals: number\n}\n\nexport interface RaDecResponse {\n  id: string\n  formattedRa: string\n  formattedDec: string\n}\nNote Now we are in the Javascript world. Serializing as JSON allows information to be communicated from the JVM and Scala-based backend to the Javascript/Typescript browser environment.","title":"Add models"},{"location":"/flows/base-flow.html#add-fetch","text":"Implement the following methods to consume data from our POST and GET routes in the api.ts file. These methods will be called by our React components and perform HTTP requests to the backend. The post and get methods are defined in Http.ts and handle the formatting of the request method and arguments into a proper HTTP request, as well as formatting the response.\nFor POST Route\nTypescript copysourceexport const postRaDecValues = async (\n  baseUrl: string,\n  raDecRequest: RaDecRequest\n): Promise<RaDecResponse | undefined> =>\n  (\n    await post<RaDecRequest, RaDecResponse>(\n      baseUrl + 'raDecValues',\n      raDecRequest\n    )\n  ).parsedBody\nFor GET Route\nTypescript copysourceexport const getRaDecValues = async (\n  baseUrl: string\n): Promise<RaDecResponse[] | undefined> =>\n  (await get<RaDecResponse[]>(baseUrl + 'raDecValues')).parsedBody\nYou will need the following imports:\nTypescript copysourceimport type { RaDecRequest, RaDecResponse } from '../models/Models'\nimport { get, post } from './Http'","title":"Add Fetch"},{"location":"/flows/base-flow.html#create-a-react-component","text":"The first component we will create is the form for entering a coordinate and submitting it to the backend server. We are using the Ant Design UI component library for our components, so here we use an Ant.d Form.\nNote Ant Design is the current ESW selection for a React-based UI component library.\nIn the pages folder, create RaDecInput.tsx Add a simple input form to the RaDecInput React component\nTypescript copysourceexport const RaDecInput = ({\n  reload = true,\n  setReload = () => ({})\n}: {\n  reload?: boolean\n  setReload?: (s: boolean) => void\n}): JSX.Element => {\n  const locationService = useLocationService()\n  return (\n    <Form\n      onFinish={onFinish}\n      style={{ padding: '1rem' }}\n      wrapperCol={{\n        span: 1\n      }}>\n      <Form.Item label='RaInDecimals' name='raInDecimals'>\n        <Input role='RaInDecimals' style={{ marginLeft: '0.5rem' }} />\n      </Form.Item>\n      <Form.Item label='DecInDecimals' name='decInDecimals'>\n        <Input role='DecInDecimals' />\n      </Form.Item>\n      <Form.Item>\n        <Button type='primary' htmlType='submit' role='Submit'>\n          Submit\n        </Button>\n      </Form.Item>\n    </Form>\n  )\n}\nIt will be necessary to add the appropriate imports.\nNote the first line after the constructor stores a reference to the Location Service in the component.\nTypescript copysourceconst locationService = useLocationService()\nThis instance is required to get the URL of the backend service. It is part of a React context named LocationServiceProvider, defined in the contexts folder. This is made available to our component when we put the components together in App.tsx.\nFinally, add an onFinish handler to specify the behavior when the submit button is pressed. It will use the postRaDecValues method in our component. Insert this code above the return statement defined above.\nTypescript copysourceconst onFinish = async (values: RaDecRequest) => {\n  const backendUrl = await getBackendUrl(locationService)\n  const valueInDecimal = {\n    raInDecimals: Number(values.raInDecimals),\n    decInDecimals: Number(values.decInDecimals)\n  }\n  if (backendUrl) {\n    const response = await postRaDecValues(backendUrl, valueInDecimal)\n    setReload(!reload)\n    if (response?.formattedRa && response?.formattedDec) {\n      console.log(response.formattedRa)\n      console.log(response.formattedDec)\n    } else {\n      console.error(response)\n      throw new Error(\n        'Invalid response, formattedRa or formattedDec field is missing'\n      )\n    }\n  }\n}\nBe sure to add the necessary imports. It should look something like this:\nTypescript copysourceimport { Button, Form, Input } from 'antd'\nimport React from 'react'\nimport { useLocationService } from '../../contexts/LocationServiceContext'\nimport type { RaDecRequest } from '../../models/Models'\nimport { postRaDecValues } from '../../utils/api'\nimport { getBackendUrl } from '../../utils/resolveBackend'","title":"Create a React component"},{"location":"/flows/base-flow.html#create-a-table-component","text":"In the pages folder, add a new component RaDecTable.tsx to display the RA/Dec values table. Again, we are using an Ant.d component, Table:\nTypescript copysourceexport const RaDecTable = ({ reload }: { reload: boolean }): JSX.Element => {\n  return (\n    <Table\n      rowKey={(record) => record.id}\n      pagination={false}\n      dataSource={raDecValues}\n      columns={columns}\n      bordered\n    />\n  )\n}\nThe table will display a list of RaDecResponses obtained from the backend server, described below. In this table, the key for rows will come from the id field of the response model.\nThe columns will be defined in a constant value outside of this class. Insert the following code above the RaDecTable declaration:\nTypescript copysourceconst HeaderTitle = ({ title }: { title: string }): JSX.Element => (\n  <Typography.Title level={5} style={{ marginBottom: 0 }}>\n    {title}\n  </Typography.Title>\n)\n\nconst columns: ColumnsType<RaDecResponse> = [\n  {\n    title: <HeaderTitle title={'Formatted Ra Value'} />,\n    dataIndex: 'formattedRa',\n    key: 'formattedRa'\n  },\n  {\n    title: <HeaderTitle title={'Formatted Dec Value'} />,\n    dataIndex: 'formattedDec',\n    key: 'formattedDec'\n  }\n]\nThe data for the table will come from an raDecValues constant that gets populated using a React Hook. The useEffect hook is called whenever the component is rendered. In our hook we call the method getRaDecValues, which does the GET request to the backend, whose URL is obtained using the Location Service obtained from the context.\nTypescript copysourceexport const RaDecTable = ({ reload }: { reload: boolean }): JSX.Element => {\n  const locationService = useLocationService()\n  const [raDecValues, setRaValues] = useState<RaDecResponse[]>()\n\n  useEffect(() => {\n    async function fetchRaValues() {\n      const backendUrl = await getBackendUrl(locationService)\n      if (backendUrl) {\n        const raDecValues = await getRaDecValues(backendUrl)\n        console.log('raDecValues', raDecValues)\n        setRaValues(raDecValues)\n      } else {\n        errorMessage('Failed to fetch ra values')\n      }\n    }\n\n    fetchRaValues()\n  }, [reload, locationService])\n\n  return (\n    <Table\n      rowKey={(record) => record.id}\n      pagination={false}\n      dataSource={raDecValues}\n      columns={columns}\n      bordered\n    />\n  )\n}\nImports for this file will look something like this:\nTypescript copysourceimport { Table, Typography } from 'antd'\nimport type { ColumnsType } from 'antd/lib/table'\nimport React, { useEffect, useState } from 'react'\nimport { useLocationService } from '../../contexts/LocationServiceContext'\nimport type { RaDecResponse } from '../../models/Models'\nimport { getRaDecValues } from '../../utils/api'\nimport { errorMessage } from '../../utils/message'\nimport { getBackendUrl } from '../../utils/resolveBackend'","title":"Create a table component"},{"location":"/flows/base-flow.html#putting-our-components-together","text":"In the pages folder, add a new component RaDec.tsx to compose the components created above and display in a page\nTypescript copysourceexport const RaDec = (): JSX.Element => {\n  const [reload, setReload] = useState<boolean>(false)\n  return (\n    <>\n      <RaDecInput reload={reload} setReload={setReload} />\n      <RaDecTable reload={reload} />\n    </>\n  )\n}\nNext, we need to show our newly created RaDec component.\nUpdate the Routes.tsx file and delete references to deleted files and their routes, and map our newly created RaDec component to the / path.\nTypescript copysource<Route path='/' element={<RaDec />} />\nNow, we need a link to let the user navigate to the RA/Dec form from different parts of the application.\nUpdate MenuBar.tsx and delete the existing Menu and its Menu.Item. Add our menu item.\nTypescript copysource<Menu mode='horizontal'>\n  <Menu.Item key='raDec'>\n    <Link to='/'>RaDec</Link>\n  </Menu.Item>\n</Menu>\nNow, we have linked all pieces of our frontend application.\n$:sample-frontend> npm start\nIt will launch application in your default browser with an input form.\nAdd a value like ‘2.13’ and ‘2.18’ and click Submit. You will see the formatted RA and Dec values in the table below the input form.\nTo build the application for its production deployment, use the npm command:\n$:sample-frontend> npm run build\nThis will create a dist folder with all the necessary class files to run the application, which can be copied to the production web server for deployment.","title":"Putting our components together"},{"location":"/flows/auth-flow.html","text":"","title":"Adding Authentication"},{"location":"/flows/auth-flow.html#adding-authentication","text":"Like the User Interface Gateway, a web application backend is a boundary between the public side of the observatory software system and the authenticated, protected control system. Because of this, a web application developer must be conscious of and support the authentication and authorization of its users according to the observatory security approach.\nIt’s okay to have unprotected routes that are read-only and can not cause any changes, but any route that can change the control system must be protected with the correct level of authorization. This flow describes how to integrate authentication and authorization through the use of CSW AAS Service.","title":"Adding Authentication"},{"location":"/flows/auth-flow.html#add-a-protected-route-in-backend","text":"To demonstrate authorization, we will need to create a “protected” route, that is, an endpoint that requires a valid authorization token to access.","title":"Add a Protected Route in Backend"},{"location":"/flows/auth-flow.html#add-new-route-with-protection","text":"We will add a new route to our server which is protected. To access this route, the request should contain a token containing the role esw-user. We have set up some sample users when we start csw-services with the Authentication and Authorization Service enabled, and we will use one of these users for our tutorial.\nNote In the text above, esw-user is not a login or individual name; it is a role in the AAS security model. During operations, AAS will be configured to give individuals or logins specific roles. For now, we have created a few logins that have the same role as their login names.\nAdd the route code below to SampleRoute.scala from the basic flow. Note the route requires the user to have the esw-user role to access the endpoint.\nIf you deleted the tilde (~) at the end of your route in the last tutorial, be sure to put it back, and then append the following:\nScala copysourcepath(\"securedRaDecValues\") {\n  post {\n    securityDirectives.sPost(RealmRolePolicy(\"Esw-user\")) { _ =>\n      entity(as[RaDecRequest]) { raDecRequest =>\n        complete(raDecService.raDecToString(raDecRequest))\n      }\n    }\n  }\n}","title":"Add new route with protection"},{"location":"/flows/auth-flow.html#consume-a-protected-route-in-the-frontend","text":"Now, we will create a component in our frontend UI that uses our protected route.","title":"Consume a Protected Route in the Frontend"},{"location":"/flows/auth-flow.html#add-secured-post","text":"Add the following method in api.ts, which sends a request to our /securedRaValues backend route.\nTypescript copysourceexport const securedPostRaDecValues = async (\n  baseUrl: string,\n  raDecRequest: RaDecRequest,\n  token: string\n): Promise<RaDecResponse | undefined> =>\n  (\n    await post<RaDecRequest, RaDecResponse>(\n      baseUrl + 'securedRaDecValues',\n      raDecRequest,\n      {\n        Authorization: `Bearer ${token}`\n      }\n    )\n  ).parsedBody\nNote that this method requires an AAS authorization token, which is then passed to the server with the request.","title":"Add secured Post"},{"location":"/flows/auth-flow.html#create-a-react-component-to-consume-our-secured-route","text":"In the pages folder, create a file named SecuredRaDecInput.tsx. Then create a SecuredRaDecInput React component with the following form.\nTypescript copysourceexport const SecuredRaDecInput = (): JSX.Element => {\n  return (\n    <Form\n      onFinish={onFinish}\n      style={{ padding: '1rem' }}\n      wrapperCol={{\n        span: 1\n      }}>\n      <Form.Item label='RaInDecimals (secured)' name='raInDecimals'>\n        <Input role='RaInDecimals' style={{ marginLeft: '0.5rem' }} />\n      </Form.Item>\n      <Form.Item label='DecInDecimals (secured)' name='decInDecimals'>\n        <Input role='DecInDecimals' />\n      </Form.Item>\n      <Form.Item>\n        <Button type='primary' htmlType='submit' role='Submit'>\n          Submit\n        </Button>\n      </Form.Item>\n    </Form>\n  )\n}","title":"Create a React component to consume our secured route"},{"location":"/flows/auth-flow.html#use-secured-post-in-our-component","text":"Again, a reference to the Location Service is obtained via a context named LocationServiceProvider. Since this component requires authorization, we use another context to get a reference to the authorization system.\nAdd the following as first lines inside the SecuredRaDecInput component.\nTypescript copysourceexport const SecuredRaDecInput = (): JSX.Element => {\n  const locationService = useLocationService()\n  const { auth } = useAuth()\nThe useAuth method is a hook provided in hooks/useAuth.tsx that accesses the context. Like LocationServiceProvider, the AuthContextProvider context is made available to the component during construction in App.tsx.\nNow, add an onFinish handler above the return statement, similar to our non-secured component. Note that this time we will obtain the token from the authorization context and pass that to our API method.\nTypescript copysourceconst onFinish = async (values: RaDecRequest) => {\n  const backendUrl = await getBackendUrl(locationService)\n  const valueInDecimal = {\n    raInDecimals: Number(values.raInDecimals),\n    decInDecimals: Number(values.decInDecimals)\n  }\n\n  if (backendUrl) {\n    const token = auth?.token()\n    if (!token) {\n      errorMessage('Failed to greet user: Unauthenticated request')\n    } else {\n      const response = await securedPostRaDecValues(\n        backendUrl,\n        valueInDecimal,\n        token\n      )\n      if (response?.formattedRa && response?.formattedDec) {\n        console.log(response.formattedRa)\n        console.log(response.formattedDec)\n      } else {\n        console.error(response)\n        throw new Error(\n          'Invalid response, formattedRa or formattedDec field is missing'\n        )\n      }\n    }\n  }\n}\nDon’t forget to add the necessary imports!","title":"Use secured Post in our component"},{"location":"/flows/auth-flow.html#connect-our-new-component","text":"Next, we will add the protected route in Routes.tsx within the <Switch> block, before the catch-all * route.\nTypescript copysource<ProtectedRoute path='/securedRaDec' element={<SecuredRaDecInput />} />\nAdd an action for our new route in MenuBar.tsx below the previously added RaDec Menu.Item\nTypescript copysource<Menu mode='horizontal'>\n  <Menu.Item key='raDec'>\n    <Link to='/'>RaDec</Link>\n  </Menu.Item>\n  <Menu.Item key='securedRaDec'>\n    <Link to='/securedRaDec'>SecuredRaDec</Link>\n  </Menu.Item>\n</Menu>","title":"Connect our new component"},{"location":"/flows/auth-flow.html#add-login-logout-functionality","text":"To get the authorization token the user needs to log in. To provide login and logout capabilities, we will make use of the generated Login and Logout components.\nAdd menu item actions for logging in and logging out in MenuBar.tsx below the previously added SecuredRaDec Menu.Item The menu item will change depending on whether the user is logged in or not to show protected functionality.\nTypescript copysource<Menu.Item key='securedRaDec'>\n  <Link to='/securedRaDec'>SecuredRaDec</Link>\n</Menu.Item>\n{isAuthenticated ? <Logout logout={logout} /> : <Login login={login} />}\nNote the authorization hook is used again here to get a handle to the authorization store.\nTypescript copysourceexport const MenuBar = (): JSX.Element => {\n  const { auth, login, logout } = useAuth()\n  const isAuthenticated = auth?.isAuthenticated() ?? false","title":"Add Login & Logout functionality"},{"location":"/flows/auth-flow.html#try-it-out-","text":"Compile the backend and restart it. Then run the UI as before and try it out.\nNotice the menu bar shows a “Login” item, since we haven’t logged in\nClicking on the “Login” (or “SecuredRaDec”) menu item will take you to the login page. Be sure to log in with theesw-user1 user with the password esw-user1.\nYou may note the “Login” menu item has changed to “Logout”.\nOnce logged in, you will be able to use the SecuredRaDec form. The behavior is the same as the non-secured version, but it gives you the idea of how pages and routes can be protected.\nNice Work!","title":"Try It Out!"},{"location":"/flows/db-flow.html","text":"","title":"Adding Database Persistence"},{"location":"/flows/db-flow.html#adding-database-persistence","text":"In this section of the tutorial, we will add a database to our backend application to store the RA/Dec coordinates entered through the UI instead of the state variable in the backend. With this change our coordinates will be stored between observing runs, and we won’t lose all our precious coordinates.\nThis flow also shows how to use the CSW Database Service in a backend and how to pass database query results back to the UI. We will be using the CSW Database Service’s Jooq DSL to write our queries. Under the covers CSW Database Service is using the PostgreSQL relational database to persist our data.\nFirst, we will update our backend server to use the database, then we will set up the database itself, and then we will run the application.","title":"Adding Database Persistence"},{"location":"/flows/db-flow.html#update-the-backend-implementation","text":"First, we have to make the CSW Database Service accessible in our project. Add a csw-database dependency in project/Libs.scala\nScala copysourceval `csw-database` = \"com.github.tmtsoftware.csw\" %% \"csw-database\" % \"4.0.1-RC1\"\nNote In this example, we use version 3.0.1 of CSW, but any later version will work as well.\nUse the csw-database dependency in your build.sbt file and reload the project in your IDE (in IntelliJ, this can be done from the sbt tab, typically on the right side of the IDE). Or type reload at the sbt prompt.\nScala copysourcelibraryDependencies ++= Seq(\n  Libs.`esw-http-template-wiring` % \"compile->compile;test->test\",\n  Libs.`csw-database`, // <---\n  Libs.`embedded-keycloak` % Test,","title":"Update the Backend Implementation"},{"location":"/flows/db-flow.html#create-a-database-access-class","text":"Now we can implement our database access code. Go to the impl package in the backend and add a repository class RaDecRepository.scala using the DSL context provided by JOOQ as part of the CSW Database Service. This will be constructed and injected later in our wiring.\nScala copysourceclass RaDecRepository(dsl: DSLContext)(implicit ec: ExecutionContext) {\n}\nAdd a method to this class to insert data into the DB. The query method of the DSLContext is used to construct an SQL INSERT statement to insert our formatted RA/Dec strings along with a UUID. The CSW Database Service provides an asynchronous execute method, which returns a negative value on error. Since the insert is done asynchronously, this method returns a Future.\nScala copysourcedef insertRaDec(formattedRa: String, formattedDec: String): Future[String] = {\n  val id = UUID.randomUUID().toString\n  dsl\n    .query(s\"INSERT INTO RaDecValues (id,formattedRa,formattedDec) values (?,?,?)\", id, formattedRa, formattedDec)\n    .executeAsyncScala()\n    .map {\n      case x if x < 0 => throw new RuntimeException(s\"Failed to insert the (ra ,dec) value ($formattedRa, $formattedDec )\")\n      case _          => id\n    }\n}\nWe will similarly add a method to get data from the DB:\nScala copysourcedef getRaDecValues: Future[scala.List[RaDecResponse]] =\n  dsl.resultQuery(\"SELECT * from RaDecValues\").fetchAsyncScala[RaDecResponse]\nAdd the necessary imports. The imports should look something like this:\nScala copysourceimport csw.database.scaladsl.JooqExtentions.{RichQuery, RichResultQuery}\nimport org.jooq.DSLContext\nimport org.tmt.sample.core.models.RaDecResponse\n\nimport java.util.UUID\nimport scala.concurrent.{ExecutionContext, Future}","title":"Create a Database access class"},{"location":"/flows/db-flow.html#update-backend-service-implementation","text":"Update RaDecImpl.scala to inject the repository dependency. We will also need an implicit execution context curried into this class since our RaDecRepository class requires one.\nScala copysourceclass RaDecImpl(raDecRepository: RaDecRepository)(implicit ec: ExecutionContext) extends RaDecService {\nUpdate the raDecToString implementation in RaDecImpl.scala to use the insert query method instead the locally stored list.\nScala copysourceoverride def raDecToString(raDecRequest: RaDecRequest): Future[RaDecResponse] = {\n  val formattedRa  = Angle.raToString(raDecRequest.raInDecimals)\n  val formattedDec = Angle.deToString(raDecRequest.decInDecimals)\n  raDecRepository.insertRaDec(formattedRa, formattedDec).map(id => RaDecResponse(id, formattedRa, formattedDec))\n}\nUpdate the getRaDecValues implementation in RaDecImpl.scala to use the get values query method.\nScala copysourceoverride def getRaDecValues: Future[scala.List[RaDecResponse]] =\n  raDecRepository.getRaDecValues\nReferences to the locally stored coordinate list can now be deleted since it is no longer needed.","title":"Update backend service implementation"},{"location":"/flows/db-flow.html#update-wiring","text":"Now we need to put everything together by updating the application wiring.\nFirst, create the DB setup in SampleWiring.scala\nScala copysourceprivate lazy val databaseServiceFactory = new DatabaseServiceFactory(actorRuntime.typedSystem)\nprivate val dbName                      = settings.config.getString(\"dbName\")\nprivate val dbUsernameHolder            = settings.config.getString(\"dbUsernameHolder\")\nprivate val dbPasswordHolder            = settings.config.getString(\"dbPasswordHolder\")\nprivate lazy val dslContext: DSLContext =\n  Await.result(\n    databaseServiceFactory.makeDsl(cswServices.locationService, dbName, dbUsernameHolder, dbPasswordHolder),\n    10.seconds\n  )\nHere you can see the database name, username, and password are obtained from the application configuration. These values are used to create the JOOQ DSLContext passed into our repository class. Let’s instantiate the repository, passing in our DSL context, and then update the implementation reference to receive the repository.\nScala copysourceimport actorRuntime.ec\nlazy val repository = new RaDecRepository(dslContext)\nlazy val raDecImpl  = new RaDecImpl(repository)\nNote It may not be a great security practice to keep database login info in a config file checked into GitHub, but we are not working on bank software here. Some applications may need a different approach but for most applications this is probably good enough. See also the CSW documentation.\nWe now need to update our application configuration file with the database configuration. Edit application.conf in the src/main/resources folder.\nScala copysourcehttp-server {\n  prefix: \"ESW.sample\"\n  dbName: postgres\n  dbUsernameHolder: DB_USERNAME\n  dbPasswordHolder: DB_PASSWORD\n}\nThe database username and password are obtained from the environment variables DB_USERNAME and DB_PASSWORD respectively. We will set these variables later before we run our backend.","title":"Update wiring"},{"location":"/flows/db-flow.html#run-the-new-application","text":"CSW Database Service uses the PostgreSQL database, which must be installed for the application to work properly. Once it is installed, the application database must be initially configured with to work with our application.","title":"Run the New Application"},{"location":"/flows/db-flow.html#database-setup","text":"Follow the installation guide to download and install PostgreSQL on your machine, if not already installed Link. See also the CSW documentation. For linux specific troubleshooting refer\nAt this point, we will re-run csw-services with the CSW Database Service enabled. This will run a PostgreSQL instance that we can then configure.\nThe following instructions show how to run the Database Service along with the Location Service and the Authentication and Authorization Service using csw-services:\nNote For running the Database Service using csw-services, the PGDATA environment variable must be set to the Postgres data directory where Postgres is installed e.g. for mac: “/usr/local/var/postgres”.\ncs install csw-services\ncsw-services start -k -d\nLogin to postgres with your default user and create a new user to be used with our application. The example code below sets up a user “postgres” with a password “postgres”, but you can use different credentials if you prefer.\npsql -d postgres\npostgres => CREATE USER postgres with password 'postgres';\npostgres => \\q\npsql -d postgres -U postgres\nNow for the application initialization. We will create an RADECVALUES table in the database that the application can use to perform fetch and insert queries. The following commands can be used to create a table:\npostgres =>\nCREATE TABLE RADECVALUES(\nid           TEXT             PRIMARY KEY,\nformattedRa  TEXT             NOT NULL,\nformattedDec TEXT             NOT NULL\n);\nAs mentioned above, we depend on environment variables to pick up your username and password for the database, thus DB_USERNAME and DB_PASSWORD need to be set to the credentials you provided above.\nTo set environment variables, use the command\nexport DB_USERNAME=<VALUE> DB_PASSWORD=<VALUE>\nNow, we are ready to run the backend application:\nsbt:sample-backend> run start\nTest your application either with the UI or by using apptest.http as described in previous tutorials, and verify the data is saved in your postgres table. This can be done in psql using the TABLE command:\npostgres => SELECT * FROM RADECVALUES;","title":"Database setup"},{"location":"/flows/docs-flow.html","text":"","title":"Adding Paradox Documentation"},{"location":"/flows/docs-flow.html#adding-paradox-documentation","text":"The section of the tutorial describes how to write documentation for your application using paradox. Documentation is written in GitHub-flavored markdown, which is documented here","title":"Adding Paradox Documentation"},{"location":"/flows/docs-flow.html#pre-requisite","text":"Your application code is checked in some repo in your organization GitHub account.","title":"Pre-requisite"},{"location":"/flows/docs-flow.html#documentation-development-flow","text":"The sample application generated from the template contains a docs folder. This is where you will write the documentation files for your project. The top-level build.sbt file contains the setup for this docs sbt project.\nLaunch sbt from your console and run command makeSite to construct the documentation pages. Then run the command openSite to open the generated docs in your default browser.\nsbt\nsbt:sample> makeSite\nsbt:sample> openSite\nYou can modify the various .md files present in docs folder and repeat above steps and verify your generated documentation. Refer to the Paradox documentation to learn more about the documentation system.","title":"Documentation Development Flow"},{"location":"/flows/docs-flow.html#documentation-publish-flow","text":"The template sets your project up to publish your documentation to GitHub using GitHub Pages. You need to specify the URL of your GitHub repo in the variable githubRepoUrl in your top-level build.sbt file. This allows Paradox to use a special branch, gh-pages, in your GitHub repository to keep track of your documentation.\nExecute reload in sbt so that updated URL is available in sbt.\nsbt:sample> reload\nCreate the gh_pages branch in your repo following these quick steps. Verify that you see a new branch gh_pages in your GitHub repository with an empty commit.\nThen, you can run the command ghpagesPushSite, to publish your documentation.\nsbt:sample> ghpagesPushSite\nVerify that you see a new commit in branch gh_pages, and branch should contain a folder with name 0.1.0-SNAPSHOT\nOpen your published site using URL, http://{your-username}.github.io/{your-project}/0.1.0-SNAPSHOT/","title":"Documentation Publish Flow"}]}