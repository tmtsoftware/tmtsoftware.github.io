{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Web Application Tutorial"},{"location":"/index.html#web-application-tutorial","text":"These are set of tutorials to create a Web Application using template\nCreating a Web Application Adding Authentication Adding Database Persistence Adding Paradox Documentation","title":"Web Application Tutorial"},{"location":"/flows/base-flow.html","text":"","title":"Creating a Web Application"},{"location":"/flows/base-flow.html#creating-a-web-application","text":"","title":"Creating a Web Application"},{"location":"/flows/base-flow.html#overview","text":"This template contains steps to create an example application using the template. It has below flows, Basic Flow is mandatory and others are extensions after doing basic flow.\nBasic flow - Creating a Web Application Adding Authentication Adding Persistence Adding Documentation\nBasic flow will show you how to add a routes to backend application and consume them in your frontend.\nAt any point in time if you want to see code with complete file, you can refer final example app and compare your changes.\nBasic flow starts here.","title":"Overview"},{"location":"/flows/base-flow.html#generate-application","text":"First we need to generate a scaffolding application using our gitter8 template\ng8 tmtsoftware/esw-web-app-template.g8 --name=sample\nIt will generate a sample folder with two sub-folders, frontend and backend","title":"Generate application"},{"location":"/flows/base-flow.html#compile-frontend","text":"This is where your frontend application is present, it uses Typescript, React and node. Make sure node is installed in your machine. Let’s compile our generated application.\ncd sample/frontend\nnpm install\nnpm run build","title":"Compile frontend"},{"location":"/flows/base-flow.html#compile-backend","text":"This is where your backend application is present, it uses Scala ecosystem. Make sure coursier, openjdk 11 and latest sbt version is installed in your machine. Let’s compile our generated application.\ncd sample/backend\nsbt\nsbt:backend> compile","title":"Compile backend"},{"location":"/flows/base-flow.html#add-routes-to-backend","text":"Open backend folder in you editor(e.g. Intellij) e.g.\ncd sample/backend\nidea .","title":"Add routes to backend"},{"location":"/flows/base-flow.html#cleanup-existing-sample","text":"Generated code contains a sample application, we will delete its code and add ours where appropriate.\nDelete folder src/main/java ,src/test Delete Existing files from core/models package in src Delete existing files from service package in src Delete file SampleImpl.scala from impl package in src Delete file JSampleImplWrapper.scala from http package in src","title":"Cleanup existing sample"},{"location":"/flows/base-flow.html#add-our-models-classes","text":"These model classes will be used to serialized and deserialized request and response.\nGo to core/models in src Add RaDecRequest.scala model class\nScala case class RaDecRequest(raInDecimals: Double, decInDecimals: Double)\nAdd RaDecResponse.scala model class\nScala case class RaDecResponse(id: String, formattedRa: String, formattedDec: String)","title":"Add our Models classes"},{"location":"/flows/base-flow.html#add-our-implementation","text":"Go to service in src Add a scala trait in RaDecService.scala file and add our raDecToString contract, using our request and response model\nScala trait RaDecService {\n  def raDecToString(raDecRequest: RaDecRequest): Future[RaDecResponse]\n}\nAdd getRaDecValues contract in service RaDecService.scala\nScala def getRaDecValues: Future[List[RaDecResponse]]\nGo to impl package in src Add RaDecImpl.scala Extend RaDecService.scala to implement raDecToString\nScala class RaDecImpl extends RaDecService {\n\n  private val raDecValues = mutable.ListBuffer[RaDecResponse]()\n\n  override def raDecToString(raDecRequest: RaDecRequest): Future[RaDecResponse] = {\n    val formattedRa   = Angle.raToString(raDecRequest.raInDecimals)\n    val formattedDec  = Angle.deToString(raDecRequest.decInDecimals)\n    val raDecResponse = RaDecResponse(UUID.randomUUID().toString, formattedRa, formattedDec)\n    raDecValues.append(raDecResponse)\n    Future.successful(raDecResponse)\n  }\n}\nImplement getRaDecValues contract in RaDecImpl.scala\nScala override def getRaDecValues: Future[List[RaDecResponse]] = Future.successful(raDecValues.toList)\nLets now try to compile our code\nsbt:backend> compile\nIt will give compilation errors hence, delete references to earlier deleted classes from SampleWiring.scala Add a placeholder for route\noverride lazy val routes: Route = ???\nGo to SampleRoute.scala Delete existing route Add a placeholder for route\nval route: Route = ???\nDelete references to earlier deleted classes from scala files SampleRoute, HttpCodecs\nTry compiling code again, this time it should compile\nsbt:backend> compile","title":"Add our implementation"},{"location":"/flows/base-flow.html#add-route-for-our-implementation","text":"Go to SampleWiring.scala Add raDecImpl reference\nScala lazy val raDecImpl = new RaDecImpl()\nAdd Route in placeholder\nScala import actorRuntime.ec\noverride lazy val routes: Route = new SampleRoute(raDecImpl, securityDirectives).route\nGo to SampleRoute.scala Add dependency of raDecService to SampleRoute\nScala class SampleRoute(raDecService: RaDecService, securityDirectives: SecurityDirectives)(implicit\n    ec: ExecutionContext\n) extends HttpCodecs {\nAdd route along with an implicit execution context which is provided by ServerWiring.\nWe are using akka routing dsl to compose our http routes. visit here to learn more about routing dsl.\nScala path(\"raDecValues\") {\n  post {\n    entity(as[RaDecRequest]) { raDecRequest =>\n      complete(raDecService.raDecToString(raDecRequest))\n    }\n  } ~\n  get {\n    complete(raDecService.getRaDecValues)\n  }\n} ~\nNote The tilda (~) at the end, is used as a path concatenator in akka dsl. You can safely remove it for now. However, in the following section of this tutorial we are going to add new routes to this file, at that point you would want to add it again to concat multiple routes.\nAfter we add the route, it will show some compilation errors, to fix that we need to add the codec to serialize/deserialize our request/response","title":"Add Route for our implementation"},{"location":"/flows/base-flow.html#add-codecs","text":"We are using borer to serialize/deserialize. It has support for two formats Json and Cbor(binary format)\nAdd codecs in HttpCodecs.scala\nScala implicit lazy val raDecResponseCodec: Codec[RaDecResponse] = MapBasedCodecs.deriveCodec\nimplicit lazy val raDecRequestCodec: Codec[RaDecRequest]   = MapBasedCodecs.deriveCodec\nSampleRoute should compile now successfully and ready to use.","title":"Add Codecs"},{"location":"/flows/base-flow.html#manually-test-our-application","text":"Start location service with authentication service (we will use auth in next section of tutorial)\ncs install csw-services:v4.0.0-M1\ncsw-services start -k\nTry running our backend application\nsbt:backend> run start\nIf application is successfully started it, will show log with server_ip and app_port registered to location service.\nUpdate apptest.http and test your raDecValues POST route\n#### Request to test raDecValues endpoint\nPOST http://<server_ip>:<app_port>/raDecValues\nContent-Type: application/json\n\n{\n  \"raInDecimals\": 2.13,\n  \"decInDecimals\": 2.18\n}\nSuccessful response contains the formattedRa and formattedDec value with a unique id.\n{\n  \"id\": \"80ab3f42-a4cf-4249-b9a0-2b209aab48e8\",\n  \"formattedRa\": \"8h 8m 9.602487087684134s\",\n  \"formattedDec\": \"124°54'17.277618670114634\\\"\"\n}\nAdd this to your apptest.http and test your raDecValues GET route\n####\nGET http://<server_ip>:<app_port>/raDecValues\nSuccessful response contains list of with formattedRa value.\n[\n  {\n    \"id\": \"d6a16719-72bf-4928-8bf3-abb125186f49\",\n    \"formattedRa\": \"8h 8m 9.602487087684134s\",\n    \"formattedDec\": \"124°54'17.277618670114634\\\"\"\n  }\n]","title":"Manually test our application"},{"location":"/flows/base-flow.html#consume-routes-in-frontend","text":"In this section, we will be consuming data with using our React components. We will show how to create a client side route to add/render custom components within the application.\nFirst lets cleanup unwanted code\nGo to components/pages folder in src, delete all component files under this directory Delete folder components/form Go to pages folder in test, delete all test files under this directory Remove the contents of api.ts file","title":"Consume routes in frontend"},{"location":"/flows/base-flow.html#add-models","text":"Go to Models.ts Delete existing model interfaces Add our request and response models\nTypescript export interface RaDecRequest {\n  raInDecimals: number\n  decInDecimals: number\n}\n\nexport interface RaDecResponse {\n  id: string\n  formattedRa: string\n  formattedDec: string\n}","title":"Add models"},{"location":"/flows/base-flow.html#add-fetch","text":"Implement the following methods to consume data from our POST and GET routes in api.ts file.\nFor POST Route\nTypescript export const postRaDecValues = async (\n  baseUrl: string,\n  raDecRequest: RaDecRequest\n): Promise<RaDecResponse | undefined> =>\n  (\n    await post<RaDecRequest, RaDecResponse>(\n      baseUrl + 'raDecValues',\n      raDecRequest\n    )\n  ).parsedBody\nFor GET Route\nTypescript export const getRaDecValues = async (\n  baseUrl: string\n): Promise<RaDecResponse[] | undefined> =>\n  (await get<RaDecResponse[]>(baseUrl + 'raDecValues')).parsedBody","title":"Add Fetch"},{"location":"/flows/base-flow.html#add-our-react-component","text":"In pages folder, create RaDecInput.tsx Add a simple input form to the RaDecInput react component\nTypescript export const RaDecInput = (): JSX.Element => {\n  return (\n    <Form\n      onFinish={onFinish}\n      style={{ padding: '1rem' }}\n      wrapperCol={{\n        span: 1\n      }}>\n      <Form.Item label='RaInDecimals' name='raInDecimals'>\n        <Input role='RaInDecimals' style={{ marginLeft: '0.5rem' }} />\n      </Form.Item>\n      <Form.Item label='DecInDecimals' name='decInDecimals'>\n        <Input role='DecInDecimals' />\n      </Form.Item>\n      <Form.Item>\n        <Button type='primary' htmlType='submit' role='Submit'>\n          Submit\n        </Button>\n      </Form.Item>\n    </Form>\n  )\n}\nYou would require locationService instance for getting backend url. This instance is available via context named LocationServiceProvider. Add the following as first line inside the RaDecInput component.\nTypescript export const RaDecInput = (): JSX.Element => {\n  const locationService = useLocationService()\nAdd onFinish handler and use postRaDecValues method in our component\nTypescript const onFinish = async (values: RaDecRequest) => {\n  const backendUrl = await getBackendUrl(locationService)\n  const valueInDecimal = {\n    raInDecimals: Number(values.raInDecimals),\n    decInDecimals: Number(values.decInDecimals)\n  }\n  if (backendUrl) {\n    const response = await postRaDecValues(backendUrl, valueInDecimal)\n    if (response?.formattedRa && response?.formattedDec) {\n      console.log(response.formattedRa)\n      console.log(response.formattedDec)\n    } else {\n      console.error(response)\n      throw new Error(\n        'Invalid response, formattedRa or formattedDec field is missing'\n      )\n    }\n  }\n}\nIn pages folder ,Add new component RaDecTable.tsx to display ra values table\nTypescript export const RaDecTable = (): JSX.Element => {\n  return (\n    <Table\n      rowKey={(record) => record.id}\n      pagination={false}\n      dataSource={raDecValues}\n      columns={columns}\n      bordered\n    />\n  )\n}\nAdd columns for the table in this component\nTypescript const HeaderTitle = ({ title }: { title: string }): JSX.Element => (\n  <Typography.Title level={5} style={{ marginBottom: 0 }}>\n    {title}\n  </Typography.Title>\n)\n\nconst columns: ColumnsType<RaDecResponse> = [\n  {\n    title: <HeaderTitle title={'Formatted Ra Value'} />,\n    dataIndex: 'formattedRa',\n    key: 'formattedRa'\n  },\n  {\n    title: <HeaderTitle title={'Formatted Dec Value'} />,\n    dataIndex: 'formattedDec',\n    key: 'formattedDec'\n  }\n]\nUse our getRaDecValues method in this component\nTypescript export const RaDecTable = (): JSX.Element => {\n  const locationService = useLocationService()\n  const [raDecValues, setRaValues] = useState<RaDecResponse[]>()\n\n  useEffect(() => {\n    async function fetchRaValues() {\n      const backendUrl = await getBackendUrl(locationService)\n      if (backendUrl) {\n        const raDecValues = await getRaDecValues(backendUrl)\n        console.error('raDecValues', raDecValues)\n        setRaValues(raDecValues)\n      } else {\n        errorMessage('Failed to fetch ra values')\n      }\n    }\n\n    fetchRaValues()\n  }, [])\n\n  return (\n    <Table\n      rowKey={(record) => record.id}\n      pagination={false}\n      dataSource={raDecValues}\n      columns={columns}\n      bordered\n    />\n  )\n}\nIn pages folder ,Add new component RaDec.tsx to compose above created components and display in a page\nTypescript export const RaDec = (): JSX.Element => {\n  return (\n    <>\n      <RaDecInput />\n      <RaDecTable />\n    </>\n  )\n}\nNext, we need to show our newly created RaDec component.\nUpdate Routes.tsx file and delete references to deleted files and their routes, map our new created RaDec component to / path.\nTypescript <Route exact path='/' component={RaDec} />\nNow, we need a link to let user navigate to Ra form from different parts of application.\nUpdate MenuBar.tsx and delete existing Menu and its Menu.Item. Add our menu item.\nTypescript <Menu mode='horizontal'>\n  <Menu.Item key='raDec'>\n    <Link to='/'>RaDec</Link>\n  </Menu.Item>\n</Menu>\nNow, we have linked all pieces of our frontend application.\n$:frontend> npm start\nIt will launch application in Browser with an input form.\nAdd a value like ‘2.13’ and ‘2.18’ and click submit. Refresh page You will see formatted ra and dec value in table below the input form.\nTo build the application for its production deployment\n$:frontend> npm run build","title":"Add our React component"},{"location":"/flows/auth-flow.html","text":"","title":"Adding Authentication"},{"location":"/flows/auth-flow.html#adding-authentication","text":"","title":"Adding Authentication"},{"location":"/flows/auth-flow.html#add-protected-route-in-backend","text":"","title":"Add protected route in backend"},{"location":"/flows/auth-flow.html#add-new-route-with-protection","text":"We will add a new route in SampleRoute.scala which is protected, to access this route, request should contain a token containing role esw-user. We have set up some sample users when we start csw-services with Authentication.\nScala path(\"securedRaDecValues\") {\n  post {\n    securityDirectives.sPost(RealmRolePolicy(\"Esw-user\")) { _ =>\n      entity(as[RaDecRequest]) { raDecRequest =>\n        complete(raDecService.raDecToString(raDecRequest))\n      }\n    }\n  }\n}","title":"Add new route with protection"},{"location":"/flows/auth-flow.html#consume-protected-route-in-frontend","text":"","title":"Consume protected route in frontend"},{"location":"/flows/auth-flow.html#add-secured-fetch","text":"Add the following method in api.ts which sends request to /securedRaValues backend route.\nTypescript export const securedPostRaDecValues = async (\n  baseUrl: string,\n  raDecRequest: RaDecRequest,\n  token: string\n): Promise<RaDecResponse | undefined> =>\n  (\n    await post<RaDecRequest, RaDecResponse>(\n      baseUrl + 'securedRaDecValues',\n      raDecRequest,\n      {\n        Authorization: `Bearer ${token}`\n      }\n    )\n  ).parsedBody","title":"Add secured Fetch"},{"location":"/flows/auth-flow.html#add-our-react-component-to-consume-secured-fetch","text":"In pages folder, create a file named SecuredRaDecInput.tsx Add the following form to the SecuredRaDecInput react component\nTypescript export const SecuredRaDecInput = (): JSX.Element => {\n  return (\n    <Form\n      onFinish={onFinish}\n      style={{ padding: '1rem' }}\n      wrapperCol={{\n        span: 1\n      }}>\n      <Form.Item label='RaInDecimals' name='raInDecimals'>\n        <Input role='RaInDecimals' style={{ marginLeft: '0.5rem' }} />\n      </Form.Item>\n      <Form.Item label='DecInDecimals' name='decInDecimals'>\n        <Input role='DecInDecimals' />\n      </Form.Item>\n      <Form.Item>\n        <Button type='primary' htmlType='submit' role='Submit'>\n          Submit\n        </Button>\n      </Form.Item>\n    </Form>\n  )\n}","title":"Add our React component to consume secured fetch"},{"location":"/flows/auth-flow.html#use-secured-fetch-in-our-component","text":"You would require locationService instance for getting backend url. This instance is available via context named LocationServiceProvider. Also, we need auth hook to get token. Add the following as first lines inside the SecuredRa component.\nTypescript export const SecuredRaDecInput = (): JSX.Element => {\n  const locationService = useLocationService()\n  const { auth } = useAuth()\nAdd onFinish handler\nTypescript const onFinish = async (values: RaDecRequest) => {\n  const backendUrl = await getBackendUrl(locationService)\n  const valueInDecimal = {\n    raInDecimals: Number(values.raInDecimals),\n    decInDecimals: Number(values.decInDecimals)\n  }\n\n  if (backendUrl) {\n    const token = auth?.token()\n    if (!token) {\n      errorMessage('Failed to greet user: Unauthenticated request')\n    } else {\n      const response = await securedPostRaDecValues(\n        backendUrl,\n        valueInDecimal,\n        token\n      )\n      if (response?.formattedRa && response?.formattedDec) {\n        console.log(response.formattedRa)\n        console.log(response.formattedDec)\n      } else {\n        console.error(response)\n        throw new Error(\n          'Invalid response, formattedRa or formattedDec field is missing'\n        )\n      }\n    }\n  }\n}\nAdd protected route in Routes.tsx\nTypescript <ProtectedRoute path='/securedRaDec' component={SecuredRaDecInput} />\nAdd action for our new route in MenuBar.tsx below previously added RaDec Menu.Item\nTypescript <Menu mode='horizontal'>\n  <Menu.Item key='raDec'>\n    <Link to='/'>RaDec</Link>\n  </Menu.Item>\n  <Menu.Item key='securedRaDec'>\n    <Link to='/securedRaDec'>SecuredRaDec</Link>\n  </Menu.Item>","title":"Use secured fetch in our component"},{"location":"/flows/auth-flow.html#add-login-logout-functionality","text":"Make use of generated Login and Logout components .\nAdd menu items actions for logging in and logging out in MenuBar.tsx below previously added SecuredRaDec Menu.Item\nTypescript <Menu.Item key='securedRaDec'>\n  <Link to='/securedRaDec'>SecuredRaDec</Link>\n</Menu.Item>\n{isAuthenticated ? <Logout logout={logout} /> : <Login login={login} />}\nUse Auth Hook to get handle on auth store.\nTypescript export const MenuBar = (): JSX.Element => {\n  const { auth, login, logout } = useAuth()\n  const isAuthenticated = auth?.isAuthenticated() ?? false","title":"Add Login & Logout functionality"},{"location":"/flows/db-flow.html","text":"","title":"Adding Database Persistence"},{"location":"/flows/db-flow.html#adding-database-persistence","text":"We will be using postgres to persist our data. We will be using Jooq dsl to write our queries, which is packaged inside CSW Database service.","title":"Adding Database Persistence"},{"location":"/flows/db-flow.html#database-setup","text":"Follow the installation guide to download & install postgres on your machine, if not already installed. Link\nThe CSW Database Service needs to be running before starting the App. Follow below instructions to run database service along with location service and authentication service:\ncs install csw-services:v4.0.0-M1\ncsw-services start -k -d\nLogin to your postgres with your default user and create a new user, this db user will be used to operate on our application.\npsql -d postgres\npostgres => CREATE USER postgres with password 'postgres';\npostgres => /q;\npsql -d postgres -U postgres\nThis application performs fetch and insert queries on the RAVALUES table in the database, thus it needs to be present. Following command can be used to create a table\npostgres = >\nCREATE TABLE RADECVALUES(\nid TEXT             PRIMARY KEY     NOT NULL,\nformattedRa TEXT                    NOT NULL,\nformattedDec TEXT                    NOT NULL\n);\nIn the application, we depend on environment variables to pick up your username and password for the database, thus DB_USERNAME and DB_PASSWORD need to be set. To set environment variables, use the command\nexport DB_USERNAME=<VALUE> DB_PASSWORD=<VALUE>\nIn the application, the database name, username, password is picked up from the application.conf Update application.conf , add these entries.\nScala http-server {\n  dbName: postgres\n  dbUsernameHolder: DB_USERNAME\n  dbPasswordHolder: DB_PASSWORD\n}","title":"Database setup"},{"location":"/flows/db-flow.html#update-backend-implementation","text":"Add csw-database dependency in Libs.scala\nScala val `csw-database` = \"com.github.tmtsoftware.csw\" %% \"csw-database\" % \"3.0.1\"\nUse csw-database dependency in build.sbt and reload project in your IDE.\nScala libraryDependencies ++= Seq(\n  Libs.`esw-http-template-wiring` % \"compile->compile;test->test\",\n  Libs.`csw-database`, // <---\n  Libs.`embedded-keycloak` % Test,\nGo to impl package, Add repository class RaDecRepository.scala using dsl context provided by CSW Database\nScala class RaDecRepository(dsl: DSLContext)(implicit ec: ExecutionContext) {\n}\nAdd method to insert data to db\nScala def insertRaDec(formattedRa: String, formattedDec: String): Future[String] = {\n  val id = UUID.randomUUID().toString\n  dsl\n    .query(s\"INSERT INTO RaDecValues (id,formattedRa,formattedDec) values (?,?,?)\", id, formattedRa, formattedDec)\n    .executeAsyncScala()\n    .map {\n      case x if x < 0 => throw new RuntimeException(s\"Failed to insert the (ra ,dec) value ($formattedRa, $formattedDec )\")\n      case _          => id\n    }\n}\nAdd method to get data from db\nScala def getRaDecValues: Future[scala.List[RaDecResponse]] =\n  dsl.resultQuery(\"SELECT * from RaDecValues\").fetchAsyncScala[RaDecResponse]\nAdd repository dependency and implicit execution context in RaDecImpl.scala\nScala class RaDecImpl(raDecRepository: RaDecRepository)(implicit ec: ExecutionContext) extends RaDecService {\nUpdate raDecToString implementation to use insert query method in RaDecImpl.scala\nScala override def raDecToString(raDecRequest: RaDecRequest): Future[RaDecResponse] = {\n  val formattedRa  = Angle.raToString(raDecRequest.raInDecimals)\n  val formattedDec = Angle.deToString(raDecRequest.decInDecimals)\n  raDecRepository.insertRaDec(formattedRa, formattedDec).map(id => RaDecResponse(id, formattedRa, formattedDec))\n}\nUpdate getRaDecValues implementation to use get values query method in RaDecImpl.scala\nScala override def getRaDecValues: Future[scala.List[RaDecResponse]] =\n  raDecRepository.getRaDecValues\nUpdate SampleWiring.scala\nAdd db setup in SampleWiring.scala\nScala private lazy val databaseServiceFactory = new DatabaseServiceFactory(actorRuntime.typedSystem)\nprivate val dbName                      = settings.config.getString(\"dbName\")\nprivate val dbUsernameHolder            = settings.config.getString(\"dbUsernameHolder\")\nprivate val dbPasswordHolder            = settings.config.getString(\"dbPasswordHolder\")\nprivate lazy val dslContext: DSLContext =\n  Await.result(\n    databaseServiceFactory.makeDsl(cswServices.locationService, dbName, dbUsernameHolder, dbPasswordHolder),\n    10.seconds\n  )\nAdd repository reference and Update implementation reference\nScala import actorRuntime.ec\nlazy val repository = new RaDecRepository(dslContext)\nlazy val raDecImpl  = new RaDecImpl(repository)\nRun backend application, test your application using apptest.http and verify data is saved in your postgres table.\nsbt:backend> run start","title":"Update backend Implementation"},{"location":"/flows/docs-flow.html","text":"","title":"Adding Paradox Documentation"},{"location":"/flows/docs-flow.html#adding-paradox-documentation","text":"If you want to write documentation for your application using paradox, you can follow below steps.","title":"Adding Paradox Documentation"},{"location":"/flows/docs-flow.html#pre-requisite","text":"Your application code is checked in some repo in your organization github account.","title":"Pre-requisite"},{"location":"/flows/docs-flow.html#documentation-development-flow","text":"Generated sample application contains a docs folder, which you can use to write documentation about your project. Top level build.sbt contains the setup for this docs sbt project.\nLaunch sbt from your console and run command makeSite. Then run command openSite\nsbt\nsbt:sample>makeSite\nsbt:sample>openSite\nIt will generate sample documentation and open it in your browser showing sample page. You can modify various .md files present in docs folder and repeat above steps and verify your generated documentation.","title":"Documentation development flow"},{"location":"/flows/docs-flow.html#documentation-publish-flow","text":"When your documentation is ready to be published, go to top level build.sbt, it contains a variable with name githubRepoUrl. Update this url with your github repo url. Paradox uses a special branch gh-pages, in your github repo itself to keep track of your documentation, Hence we need to set this github repo url.\nReload sbt so that updated url is available in sbt.\nsbt:sample>reload\nCreate gh_pages branch in your repo following these quick steps. Very that you see a new branch gh_pages in your github repo with an empty commit.\nRun command ghpagesPushSite, to publish your documentation.\nsbt:sample>ghpagesPushSite\nVery that you see a new commit in branch gh_pages, and branch should contain a folder with name 0.1.0-SNAPSHOT\nOpen your published site using URL, http://{your-username}.github.io/{your-project}/0.1.0-SNAPSHOT/","title":"Documentation publish flow"}]}