{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Web Application Tutorial"},{"location":"/index.html#web-application-tutorial","text":"This tutorial consists of a set of tutorials to create a Web Application using the ESW Web App template.\nThe application created in this tutorial is an coordinate formatter, and which will provide a form for inputting the right ascension and declination of a coordinate in decimal form, process it (in the backend HTTP service), and display the formatted sexagesimal result in the UI.\nThe tutorial has been divided into 4 main flows that incrementally demonstrated the constuction of a full web application, consisting of an HTTP service backend and a React-based user interface.\nThe basic flow in “Creating a Web Application” will show you how to add a routes to backend application and consume them in your frontend. The following flows are optional but demonstrate additional features to make your application more complete.\nAt any point in time if you want to see the completed code, you can refer final example app.\nCreating a Web Application Adding Authentication Adding Database Persistence Adding Paradox Documentation","title":"Web Application Tutorial"},{"location":"/flows/base-flow.html","text":"","title":"Creating a Web Application"},{"location":"/flows/base-flow.html#creating-a-web-application","text":"This flow demonstrates how to use the template to create our project, how to add simple routes, UI components, and how to build and test it.\nIn this tutorial, we will first generate the application from the template, and build it to ensure tools are in place. Then, we will delete the default implementation and replace it our own implementation of a coordinate formatter. To do this, we will delete much of the template code and rewrite our own classes custom to our implementation.","title":"Creating a Web Application"},{"location":"/flows/base-flow.html#generate-application","text":"First we need to generate a scaffolding application using our giter8 template:\ng8 tmtsoftware/esw-web-app-template.g8 --name=sample\nIt will generate a sample folder with two sub-folders, frontend and backend. For a sanity check, let’s go ahead and build the front and back ends created by the template. This will also help ensure you have the necessary tools installed.\nYou are welcome to try out the generated sample project, which is basically a “Hello World” application, by following the instructions in the READMEs in each sub-folder.","title":"Generate application"},{"location":"/flows/base-flow.html#compile-the-frontend","text":"The frontend sub-folder is where your frontend application is located. It uses Typescript, React and node. Make sure node is installed in your machine. Let’s compile our generated application.\ncd sample/frontend\nnpm install\nnpm run build","title":"Compile the frontend"},{"location":"/flows/base-flow.html#compile-the-backend","text":"The backend sub-folder is where your backend application is located. It uses the Scala ecosystem, which uses sbt as its build tool. Make sure coursier, OpenJDK 11 and the latest version of sbt version are installed in your machine. Let’s compile our generated application.\ncd sample/backend\nsbt\nsbt:backend> compile","title":"Compile the backend"},{"location":"/flows/base-flow.html#open-in-development-environment","text":"At this point, you may want to open the project in an Integrated Development Environment, such as Intellij, if you are using one.\nIn Intellij, you do this by clicking on File->New Project from Existing Sources… and then browsing to the root directory, sample. It should have a build.sbt file in it. Create an sbt project, and then accept the defaults, making sure the JDK is set to your installation of OpenJDK 11.","title":"Open in development environment"},{"location":"/flows/base-flow.html#develop-backend","text":"We will start with the backend HTTP service first. We will start by deleting the existing application and then creating our custom code. Our backend will be written in Scala, so all Java code will be removed.","title":"Develop Backend"},{"location":"/flows/base-flow.html#cleanup-existing-sample","text":"To remove the generated code from the sample application, go to the backend folder and:\nDelete the folders src/main/java ,src/test\nBrowse to src/main/scala/org/tmt/sample and\nDelete the existing files from core/models Delete the existing files from service Delete the file SampleImpl.scala from impl Delete the file JSampleImplWrapper.scala from http","title":"Cleanup existing sample"},{"location":"/flows/base-flow.html#add-our-models-classes","text":"We will now create the models used by our application. The first model is our request, in which we will take a RA/Dec pair as decimals. The other model is the response, which returns the pair as formatted Strings. It also includes a UUID String for the request. These model classes will be used to serialize and deserialize requests and responses.\nGo to core/models in src Add RaDecRequest.scala model class\nScala package org.tmt.sample.core.models\n\ncase class RaDecRequest(raInDecimals: Double, decInDecimals: Double)\nAdd the RaDecResponse.scala model class\nScala package org.tmt.sample.core.models\n\ncase class RaDecResponse(id: String, formattedRa: String, formattedDec: String)","title":"Add our Models classes"},{"location":"/flows/base-flow.html#add-our-implementation","text":"Now we will create our backend logic. First, we create the service API as a Scala trait. Our service will have two methods. The first method will take the RA/Dec request, format it, and then return the response. Our server will also maintain a list of all requests, so the method will also store this pair as formatted strings.\nThe second method returns this stored list of all processed RA/Dec pairs.\nGo to service in src Create a RaDecService.scala file and add our raDecToString contract to our API, RaDecService, using our request and response models Add the getRaDecValues contract in the service RaDecService.scala\nScala package org.tmt.sample.service\n\nimport org.tmt.sample.core.models.{RaDecRequest, RaDecResponse}\n\nimport scala.concurrent.Future\n\ntrait RaDecService {\n  def raDecToString(raDecRequest: RaDecRequest): Future[RaDecResponse]\n  def getRaDecValues: Future[List[RaDecResponse]]\n}\nNow we will create the implementation class of this service. We use the Angle class from CSW to create the sexagesimal strings.\nGo to the impl package in src Add RaDecImpl.scala Extend RaDecService.scala to implement raDecToString Implement getRaDecValues contract in RaDecImpl.scala\nScala package org.tmt.sample.impl\n\nimport csw.params.core.models.Angle\nimport org.tmt.sample.core.models.{RaDecRequest, RaDecResponse}\nimport org.tmt.sample.service.RaDecService\n\nimport java.util.UUID\nimport scala.collection.mutable\nimport scala.concurrent.Future\n\nclass RaDecImpl extends RaDecService {\n\n  private val raDecValues = mutable.ListBuffer[RaDecResponse]()\n\n  override def raDecToString(raDecRequest: RaDecRequest): Future[RaDecResponse] = {\n    val formattedRa   = Angle.raToString(Math.toRadians(raDecRequest.raInDecimals*15))\n    val formattedDec  = Angle.deToString(Math.toRadians(raDecRequest.decInDecimals))\n    val raDecResponse = RaDecResponse(UUID.randomUUID().toString, formattedRa, formattedDec)\n    raDecValues.append(raDecResponse)\n    Future.successful(raDecResponse)\n  }\n  override def getRaDecValues: Future[List[RaDecResponse]] = Future.successful(raDecValues.toList)\n}\nNow, lets try to compile our code\nsbt:backend> compile\nYou will notice it will give some compilation errors here. To fix these:\nDelete references to the classes we deleted earlier from src/main/org/tmt/sample/impl/SampleWiring.scala Add a placeholder for route\noverride lazy val routes: Route = ???\nGo to src/main/org/tmt/sample/http/SampleRoute.scala Delete references to the previously deleted classes from the Scala files Delete existing route Add a placeholder for route\nval route: Route = ???\nDelete references to the previously deleted classes from the Scala files in src/main/org/tmt/sample/http/HttpCodecs\nBe sure to delete references to deleted classes from import statements as well.\nTry compiling code again, this time it should compile successfully.\nsbt:backend> compile","title":"Add our implementation"},{"location":"/flows/base-flow.html#add-a-route-for-our-implementation","text":"Next, we will provide the routing that links our HTTP request methods on endpoints to backend server processing created in our implementation class RaDecImpl.\nFirst, we need to inject a reference to an implementation of our service API to the routes, so that the appropriate method will be called for the matching endpoint and request method. Change the constructor of the route to take such an instance, and add an import for RaDecService:\nScala class SampleRoute(raDecService: RaDecService, securityDirectives: SecurityDirectives)(implicit\n    ec: ExecutionContext\n) extends HttpCodecs {\nNext, we will add our routes. We will have a single endpoint raDecValues that supports two methods: POST and GET. The POST method will cause our backend service method raDecToString to be called, and GET will call getRaDecValues. We are using the Akka routing DSL to compose our HTTP routes. Visit here to learn more about the routing DSL.\nBe sure to add an import for our model RaDecRequest.\nScala val route: Route = {\n  path(\"raDecValues\") {\n    post {\n      entity(as[RaDecRequest]) { raDecRequest =>\n        complete(raDecService.raDecToString(raDecRequest))\n      }\n    } ~\n    get {\n      complete(raDecService.getRaDecValues)\n    }\n  } ~\n}\nNote The tilda (~) at the end, is used as a path concatenator in the Akka DSL. You can safely remove it for now. However, in the following section of this tutorial we are going to add new routes to this file. At that point, you would want to add it again to concatenate multiple routes.\nNext, let’s connect our routes to our service implementation in the wiring.\nGo to SampleWiring.scala Add a raDecImpl reference\nScala lazy val raDecImpl = new RaDecImpl()\nReplace the route placeholder with our route, injecting our service API implementation, and add an import for SampleRoute.\nScala import actorRuntime.ec\noverride lazy val routes: Route = new SampleRoute(raDecImpl, securityDirectives).route\nAfter we add the route, it will show some compilation errors, to fix that we need to add the codec to serialize/deserialize our request/response","title":"Add a Route for our implementation"},{"location":"/flows/base-flow.html#add-codecs","text":"We are using borer to serialize/deserialize. It has support for two formats: Json and Cbor(binary format)\nAdd the codecs in HttpCodecs.scala, along with imports for our models.\nScala implicit lazy val raDecResponseCodec: Codec[RaDecResponse] = deriveCodec\nimplicit lazy val raDecRequestCodec: Codec[RaDecRequest]   = deriveCodec\nSampleRoute should now compile successfully and is ready to use.","title":"Add Codecs"},{"location":"/flows/base-flow.html#manually-test-our-application","text":"Start the Location Service with the Authorization and Authentication Service (we will use auth in the next section of the tutorial)\ncs install csw-services:v4.0.0-M1\ncsw-services start -k\nSet INTERFACE_NAME and AAS_INTERFACE_NAME environment variables with Network interface of your machine, these are needed during startup of the application, so that it is able to connect to location service and register its ip address.\nDuring development in your local machine, these can point to same Network interface During production deployment, these should point to respective Network interface\nFor more details, refer CSW environment variables and network topology\nTry running our backend application\nsbt:backend> run start\nIf application is successfully started it, will show a log with the server_ip and app_port registered to the Location Service.\nUpdate apptest.http with the code below, replacing the <server_ip>:<app_port> with the ones for your server as displayed in the log messages. Then run the request to test your raDecValues POST route:\n#### Request to test raDecValues endpoint\nPOST http://<server_ip>:<app_port>/raDecValues\nContent-Type: application/json\n\n{\n  \"raInDecimals\": 2.13,\n  \"decInDecimals\": 2.18\n}\nSuccessful response contains the formattedRa and formattedDec values with a unique id.\n{\n  \"id\": \"80ab3f42-a4cf-4249-b9a0-2b209aab48e8\",\n  \"formattedRa\": \"8h 8m 9.602487087684134s\",\n  \"formattedDec\": \"124°54'17.277618670114634\\\"\"\n}\nAdd this to your apptest.http, again replacing the server IP and port number, and test your raDecValues GET route\n####\nGET http://<server_ip>:<app_port>/raDecValues\nA successful response contains a list with the previous formatted RA/DEC entry.\n[\n  {\n    \"id\": \"d6a16719-72bf-4928-8bf3-abb125186f49\",\n    \"formattedRa\": \"8h 8m 9.602487087684134s\",\n    \"formattedDec\": \"124°54'17.277618670114634\\\"\"\n  }\n]\nChange the numbers in the POST test and run it again. Then, run the GET test again, and you will see both entries displayed in the list.","title":"Manually test our application"},{"location":"/flows/base-flow.html#create-the-frontend","text":"In this section, we will be constructing a browser-based UI using React components in Typescript. We will create components that allow the user to specify an RA/Dec pair, and then a Submit button that will send the data to our backend. The response will then be rendered in UI components. We will also provide components to get and display the list of stored coordinates. This section of the tutorial will show how to add and render custom components within the application that act as clients to consume our backend routes.\nFirst, let’s cleanup unwanted code:\nGo to the components/pages folder in src and delete all component files under this directory Delete the folder components/form Go to the utils folder and remove the contents of the api.ts file Go to the pages folder in test and delete all test files under this directory","title":"Create the frontend"},{"location":"/flows/base-flow.html#add-models","text":"Now, we need to add Typescript models for the data we will send to and receive from our backend.\nGo to Models.ts in src/models Delete existing model interfaces Add our request and response models\nTypescript export interface RaDecRequest {\n  raInDecimals: number\n  decInDecimals: number\n}\n\nexport interface RaDecResponse {\n  id: string\n  formattedRa: string\n  formattedDec: string\n}","title":"Add models"},{"location":"/flows/base-flow.html#add-fetch","text":"Implement the the following methods to consume data from our POST and GET routes in the api.ts file. These methods will be called by our React components and perform HTTP requests to the backend. The post and get methods are defined in Http.ts and handle the formatting of the request method and arguments into a proper HTTP request, as well as formatting the response.\nFor POST Route\nTypescript export const postRaDecValues = async (\n  baseUrl: string,\n  raDecRequest: RaDecRequest\n): Promise<RaDecResponse | undefined> =>\n  (\n    await post<RaDecRequest, RaDecResponse>(\n      baseUrl + 'raDecValues',\n      raDecRequest\n    )\n  ).parsedBody\nFor GET Route\nTypescript export const getRaDecValues = async (\n  baseUrl: string\n): Promise<RaDecResponse[] | undefined> =>\n  (await get<RaDecResponse[]>(baseUrl + 'raDecValues')).parsedBody\nYou will need the following imports:\nTypscript import type { RaDecRequest, RaDecResponse } from '../models/Models'\nimport { get, post } from './Http'","title":"Add Fetch"},{"location":"/flows/base-flow.html#create-a-react-component","text":"The first component we will create is the form for entering a coordinate and submitting it to the backend server. We are using the Ant Design UI Component library for our components, so here we use an Ant.d Form.\nIn the pages folder, create RaDecInput.tsx Add a simple input form to the RaDecInput React component\nTypescript export const RaDecInput = ({\n  reload,\n  setReload\n}: {\n  reload: boolean\n  setReload: (s: boolean) => void\n}): JSX.Element => {\n  const locationService = useLocationService()\n  return (\n    <Form\n      onFinish={onFinish}\n      style={{ padding: '1rem' }}\n      wrapperCol={{\n        span: 1\n      }}>\n      <Form.Item label='RaInDecimals' name='raInDecimals'>\n        <Input role='RaInDecimals' style={{ marginLeft: '0.5rem' }} />\n      </Form.Item>\n      <Form.Item label='DecInDecimals' name='decInDecimals'>\n        <Input role='DecInDecimals' />\n      </Form.Item>\n      <Form.Item>\n        <Button type='primary' htmlType='submit' role='Submit'>\n          Submit\n        </Button>\n      </Form.Item>\n    </Form>\n  )\n}\nIt will be necessary to add the appropriate imports.\nNote the first line after the constructor stores a reference to the Location Service in the component.\nTypescript const locationService = useLocationService()\nThis instance is required to get the URL of the backend service. It is part of a React context named LocationServiceProvider, defined in the contexts folder. This is made available to our component when we put the components together in App.tsx.\nFinally, let’s add an onFinish handler to specify the behavior when the submit button is pressed. It will and use the postRaDecValues method in our component. Insert this code above the return statement defined above.\nTypescript const onFinish = async (values: RaDecRequest) => {\n  const backendUrl = await getBackendUrl(locationService)\n  const valueInDecimal = {\n    raInDecimals: Number(values.raInDecimals),\n    decInDecimals: Number(values.decInDecimals)\n  }\n  if (backendUrl) {\n    const response = await postRaDecValues(backendUrl, valueInDecimal)\n    setReload(!reload)\n    if (response?.formattedRa && response?.formattedDec) {\n      console.log(response.formattedRa)\n      console.log(response.formattedDec)\n    } else {\n      console.error(response)\n      throw new Error(\n        'Invalid response, formattedRa or formattedDec field is missing'\n      )\n    }\n  }\n}\nBe sure to add the necessary imports. It should look something like this:\nTypescript import { Button, Form, Input } from 'antd'\nimport React from 'react'\nimport { useLocationService } from '../../contexts/LocationServiceContext'\nimport type { RaDecRequest } from '../../models/Models'\nimport { postRaDecValues } from '../../utils/api'\nimport { getBackendUrl } from '../../utils/resolveBackend'","title":"Create a React component"},{"location":"/flows/base-flow.html#create-table-component","text":"In the pages folder, add a new component RaDecTable.tsx to display the RA/Dec values table. Again, we are using an Ant.d component, Table:\nTypescript export const RaDecTable = ({ reload }: { reload: boolean }): JSX.Element => {\n  return (\n    <Table\n      rowKey={(record) => record.id}\n      pagination={false}\n      dataSource={raDecValues}\n      columns={columns}\n      bordered\n    />\n  )\n}\nThe table will display a list of RaDecResponses obtained from the backend server, described below. In this table, the key for rows will come from the id field of the response model.\nThe columns will be defined in a constant outside of this class. Insert the following code above the RaDecTable declaration:\nTypescript const HeaderTitle = ({ title }: { title: string }): JSX.Element => (\n  <Typography.Title level={5} style={{ marginBottom: 0 }}>\n    {title}\n  </Typography.Title>\n)\n\nconst columns: ColumnsType<RaDecResponse> = [\n  {\n    title: <HeaderTitle title={'Formatted Ra Value'} />,\n    dataIndex: 'formattedRa',\n    key: 'formattedRa'\n  },\n  {\n    title: <HeaderTitle title={'Formatted Dec Value'} />,\n    dataIndex: 'formattedDec',\n    key: 'formattedDec'\n  }\n]\nThe data for the table will come from an raDecValues constant that gets populated using a React Hook. The useEffect hook is called whenever the component is rendered. In our hook, we call the method getRaDecValues which does the GET request to the backend, whose URL is obtained using the Location Service, obtained from the context.\nTypescript export const RaDecTable = ({ reload }: { reload: boolean }): JSX.Element => {\n  const locationService = useLocationService()\n  const [raDecValues, setRaValues] = useState<RaDecResponse[]>()\n\n  useEffect(() => {\n    async function fetchRaValues() {\n      const backendUrl = await getBackendUrl(locationService)\n      if (backendUrl) {\n        const raDecValues = await getRaDecValues(backendUrl)\n        console.log('raDecValues', raDecValues)\n        setRaValues(raDecValues)\n      } else {\n        errorMessage('Failed to fetch ra values')\n      }\n    }\n\n    fetchRaValues()\n  }, [reload, locationService])\n\n  return (\n    <Table\n      rowKey={(record) => record.id}\n      pagination={false}\n      dataSource={raDecValues}\n      columns={columns}\n      bordered\n    />\n  )\n}\nImports for this file will look something like this:\nTypescript import { Table, Typography } from 'antd'\nimport type { ColumnsType } from 'antd/lib/table'\nimport React, { useEffect, useState } from 'react'\nimport { useLocationService } from '../../contexts/LocationServiceContext'\nimport type { RaDecResponse } from '../../models/Models'\nimport { getRaDecValues } from '../../utils/api'\nimport { errorMessage } from '../../utils/message'\nimport { getBackendUrl } from '../../utils/resolveBackend'","title":"Create table component"},{"location":"/flows/base-flow.html#putting-out-components-together","text":"In the pages folder, add a new component RaDec.tsx to compose the components created above and display in a page\nTypescript export const RaDec = (): JSX.Element => {\n  const [reload, setReload] = useState<boolean>(false)\n  return (\n    <>\n      <RaDecInput reload={reload} setReload={setReload} />\n      <RaDecTable reload={reload} />\n    </>\n  )\n}\nNext, we need to show our newly created RaDec component.\nUpdate the Routes.tsx file and delete references to deleted files and their routes, and map our newly created RaDec component to the / path.\nTypescript <Route exact path='/' component={RaDec} />\nNow, we need a link to let the user navigate to the RA/Dec form from different parts of the application.\nUpdate MenuBar.tsx and delete the existing Menu and its Menu.Item. Add our menu item.\nTypescript <Menu mode='horizontal'>\n  <Menu.Item key='raDec'>\n    <Link to='/'>RaDec</Link>\n  </Menu.Item>\n</Menu>\nNow, we have linked all pieces of our frontend application.\n$:frontend> npm start\nIt will launch application in your default browser with an input form.\nAdd a value like ‘2.13’ and ‘2.18’ and click Submit. Refresh the page You will see the formatted RA and Dec values in the table below the input form.\nTo build the application for its production deployment\n$:frontend> npm run build","title":"Putting out components together"},{"location":"/flows/auth-flow.html","text":"","title":"Adding Authentication"},{"location":"/flows/auth-flow.html#adding-authentication","text":"","title":"Adding Authentication"},{"location":"/flows/auth-flow.html#add-protected-route-in-backend","text":"To demonstrate authorization, we will need to create a “protected” route, that is, an endpoint that requires a valid authorization token to access.","title":"Add protected route in backend"},{"location":"/flows/auth-flow.html#add-new-route-with-protection","text":"We will add a new route to our server which is protected. To access this route, the request should contain a token containing the role esw-user. We have set up some sample users when we start csw-services with the Authentication and Authorization Service enabled, and we will use one of these users for our tutorial.\nAdd the following route below to SampleRoute.scala. Note it requires the user to have the esw-user role to access the endpoint. If you deleted the tilde (~) at the end of your route in the last tutorial, be sure to put it back, and then append the following:\nScala path(\"securedRaDecValues\") {\n  post {\n    securityDirectives.sPost(RealmRolePolicy(\"Esw-user\")) { _ =>\n      entity(as[RaDecRequest]) { raDecRequest =>\n        complete(raDecService.raDecToString(raDecRequest))\n      }\n    }\n  }\n}","title":"Add new route with protection"},{"location":"/flows/auth-flow.html#consume-protected-route-in-frontend","text":"Now, we will create a component in our frontend UI that uses our protected route.","title":"Consume protected route in frontend"},{"location":"/flows/auth-flow.html#add-secured-fetch","text":"Add the following method in api.ts, which sends a request to our /securedRaValues backend route.\nTypescript export const securedPostRaDecValues = async (\n  baseUrl: string,\n  raDecRequest: RaDecRequest,\n  token: string\n): Promise<RaDecResponse | undefined> =>\n  (\n    await post<RaDecRequest, RaDecResponse>(\n      baseUrl + 'securedRaDecValues',\n      raDecRequest,\n      {\n        Authorization: `Bearer ${token}`\n      }\n    )\n  ).parsedBody\nNote that this method requires a token, which is then passed to the server with the request.","title":"Add secured Fetch"},{"location":"/flows/auth-flow.html#create-a-react-component-to-consume-our-secured-route","text":"In the pages folder, create a file named SecuredRaDecInput.tsx. Then create a SecuredRaDecInput React component with the following form.\nTypescript export const SecuredRaDecInput = (): JSX.Element => {\n  return (\n    <Form\n      onFinish={onFinish}\n      style={{ padding: '1rem' }}\n      wrapperCol={{\n        span: 1\n      }}>\n      <Form.Item label='RaInDecimals (secured)' name='raInDecimals'>\n        <Input role='RaInDecimals' style={{ marginLeft: '0.5rem' }} />\n      </Form.Item>\n      <Form.Item label='DecInDecimals (secured)' name='decInDecimals'>\n        <Input role='DecInDecimals' />\n      </Form.Item>\n      <Form.Item>\n        <Button type='primary' htmlType='submit' role='Submit'>\n          Submit\n        </Button>\n      </Form.Item>\n    </Form>\n  )\n}","title":"Create a React component to consume our secured route"},{"location":"/flows/auth-flow.html#use-secured-fetch-in-our-component","text":"Again, a reference to the Location Service is obtained via a context named LocationServiceProvider. Since this component requires authorization, we use another context to get a reference to the authorization system.\nAdd the following as first lines inside the SecuredRaDecInput component.\nTypescript export const SecuredRaDecInput = (): JSX.Element => {\n  const locationService = useLocationService()\n  const { auth } = useAuth()\nThe useAuth method is a hook provided in hooks/useAuth.tsx which accesses the context. Like LocationServiceProvider, this context, AuthContextProvider is made available to the component during construction in App.tsx.\nNow, add an onFinish handler above the return statement, similar to our non-secured component. Note this time we will obtain the token from the authorization context and pass that to our API method.\nTypescript const onFinish = async (values: RaDecRequest) => {\n  const backendUrl = await getBackendUrl(locationService)\n  const valueInDecimal = {\n    raInDecimals: Number(values.raInDecimals),\n    decInDecimals: Number(values.decInDecimals)\n  }\n\n  if (backendUrl) {\n    const token = auth?.token()\n    if (!token) {\n      errorMessage('Failed to greet user: Unauthenticated request')\n    } else {\n      const response = await securedPostRaDecValues(\n        backendUrl,\n        valueInDecimal,\n        token\n      )\n      if (response?.formattedRa && response?.formattedDec) {\n        console.log(response.formattedRa)\n        console.log(response.formattedDec)\n      } else {\n        console.error(response)\n        throw new Error(\n          'Invalid response, formattedRa or formattedDec field is missing'\n        )\n      }\n    }\n  }\n}\nAdd the necessary imports.","title":"Use secured fetch in our component"},{"location":"/flows/auth-flow.html#connect-our-new-component","text":"Next, we will add the protected route in Routes.tsx within the <Switch> block.\nTypescript <ProtectedRoute path='/securedRaDec' component={SecuredRaDecInput} />\nAdd an action for our new route in MenuBar.tsx below previously added RaDec Menu.Item\nTypescript <Menu mode='horizontal'>\n  <Menu.Item key='raDec'>\n    <Link to='/'>RaDec</Link>\n  </Menu.Item>\n  <Menu.Item key='securedRaDec'>\n    <Link to='/securedRaDec'>SecuredRaDec</Link>\n  </Menu.Item>\n</Menu>","title":"Connect our new component"},{"location":"/flows/auth-flow.html#add-login-logout-functionality","text":"To provide login and logout capabilities, we will make use of the generated Login and Logout components.\nAdd menu item actions for logging in and logging out in MenuBar.tsx below the previously added SecuredRaDec Menu.Item The menu item will change depending on whether the user is logged in or not.\nTypescript <Menu.Item key='securedRaDec'>\n  <Link to='/securedRaDec'>SecuredRaDec</Link>\n</Menu.Item>\n{isAuthenticated ? <Logout logout={logout} /> : <Login login={login} />}\nNote the authorization hook is used again here to get a handle to the authorization store.\nTypescript export const MenuBar = (): JSX.Element => {\n  const { auth, login, logout } = useAuth()\n  const isAuthenticated = auth?.isAuthenticated() ?? false","title":"Add Login & Logout functionality"},{"location":"/flows/auth-flow.html#try-it-out","text":"Compile the backend and restart it. Then run the UI as before and try it out. Clicking on the SecuredRaDec menu item will take you to the login page. Be sure to login with theesw-user1 user with the password esw-user1. Once logged in, you will be able to use this form. The behavior is the same as the non-secured version, but it gives you the idea of how pages and routes can be protected. You will have to switch to the RaDec tab to see your inputs.","title":"Try it out"},{"location":"/flows/db-flow.html","text":"","title":"Adding Database Persistence"},{"location":"/flows/db-flow.html#adding-database-persistence","text":"In this section of the tutorial, we will add a database to our application to store the RA/Dec coordinates entered in the UI instead of the local list variable in the backend. We will be using postgres to persist our data. We will be using the Jooq DSL to write our queries, which is packaged in the CSW Database Service.\nFirst, we will update our backend server to use the database, then we will set up the database itself, and then we will run the application.","title":"Adding Database Persistence"},{"location":"/flows/db-flow.html#update-backend-implementation","text":"First, we have to make the CSW Database Service accessible in our project. Add a csw-database dependency in project/Libs.scala\nScala val `csw-database` = \"com.github.tmtsoftware.csw\" %% \"csw-database\" % \"3.0.1\"\nUse the csw-database dependency in your build.sbt file and reload the project in your IDE (in IntelliJ, this can be done from the sbt tab, typically on the right side of the IDE).\nScala libraryDependencies ++= Seq(\n  Libs.`esw-http-template-wiring` % \"compile->compile;test->test\",\n  Libs.`csw-database`, // <---\n  Libs.`embedded-keycloak` % Test,","title":"Update backend Implementation"},{"location":"/flows/db-flow.html#create-a-database-access-class","text":"Now we can implement our database access code. Go to the impl package and add a repository class RaDecRepository.scala using the DSL context provided by JOOQ as part of the CSW Database Service. This will be constructed and injected later in our wiring.\nScala class RaDecRepository(dsl: DSLContext)(implicit ec: ExecutionContext) {\n}\nAdd a method to this class to insert data into the DB. The query method of the DSLContext is used to construct an SQL INSERT statement to insert our formatted RA/Dec strings along with a UUID. The CSW Database Service provides an asynchronous execute method, which returns a negative value on error. Since the insert is done asynchronously, this method returns a Future.\nScala def insertRaDec(formattedRa: String, formattedDec: String): Future[String] = {\n  val id = UUID.randomUUID().toString\n  dsl\n    .query(s\"INSERT INTO RaDecValues (id,formattedRa,formattedDec) values (?,?,?)\", id, formattedRa, formattedDec)\n    .executeAsyncScala()\n    .map {\n      case x if x < 0 => throw new RuntimeException(s\"Failed to insert the (ra ,dec) value ($formattedRa, $formattedDec )\")\n      case _          => id\n    }\n}\nWe will similarly add a method to get data from the DB:\nScala def getRaDecValues: Future[scala.List[RaDecResponse]] =\n  dsl.resultQuery(\"SELECT * from RaDecValues\").fetchAsyncScala[RaDecResponse]\nAdd the necessary imports. It should look something like this:\nScala import csw.database.scaladsl.JooqExtentions.{RichQuery, RichResultQuery}\nimport org.jooq.DSLContext\nimport org.tmt.sample.core.models.RaDecResponse\n\nimport java.util.UUID\nimport scala.concurrent.{ExecutionContext, Future}","title":"Create a Database access class"},{"location":"/flows/db-flow.html#update-backend-service-implementation","text":"Update RaDecImpl.scala to inject the repository dependency. We will also need an implicit execution context curried into this class since our RaDecRepository class requires one.\nScala class RaDecImpl(raDecRepository: RaDecRepository)(implicit ec: ExecutionContext) extends RaDecService {\nUpdate the raDecToString implementation in RaDecImpl.scala to use the insert query method instead the locally stored list.\nScala override def raDecToString(raDecRequest: RaDecRequest): Future[RaDecResponse] = {\n  val formattedRa  = Angle.raToString(raDecRequest.raInDecimals)\n  val formattedDec = Angle.deToString(raDecRequest.decInDecimals)\n  raDecRepository.insertRaDec(formattedRa, formattedDec).map(id => RaDecResponse(id, formattedRa, formattedDec))\n}\nUpdate the getRaDecValues implementation in RaDecImpl.scala to use the get values query method.\nScala override def getRaDecValues: Future[scala.List[RaDecResponse]] =\n  raDecRepository.getRaDecValues\nReferences to the locally stored list can now be deleted.","title":"Update backend service implementation"},{"location":"/flows/db-flow.html#update-wiring","text":"Now we need to put everything together by updating the wiring.\nFirst, create the DB setup in SampleWiring.scala\nScala private lazy val databaseServiceFactory = new DatabaseServiceFactory(actorRuntime.typedSystem)\nprivate val dbName                      = settings.config.getString(\"dbName\")\nprivate val dbUsernameHolder            = settings.config.getString(\"dbUsernameHolder\")\nprivate val dbPasswordHolder            = settings.config.getString(\"dbPasswordHolder\")\nprivate lazy val dslContext: DSLContext =\n  Await.result(\n    databaseServiceFactory.makeDsl(cswServices.locationService, dbName, dbUsernameHolder, dbPasswordHolder),\n    10.seconds\n  )\nHere you can see the database name, username, and password are obtained from the application configuration. These value are used to create the JOOQ DSLContext passed into our repository class. Let’s instantiate the repository, passing in our DSL context, and then update the implementation reference to receive the repository.\nScala import actorRuntime.ec\nlazy val repository = new RaDecRepository(dslContext)\nlazy val raDecImpl  = new RaDecImpl(repository)\nWe now need to update our application configuration file with the database configuration. Edit application.conf in the src/main/resources folder.\nScala http-server {\n  prefix: \"ESW.sample\"\n  dbName: postgres\n  dbUsernameHolder: DB_USERNAME\n  dbPasswordHolder: DB_PASSWORD\n}\nThe database username and password are obtained from the environment variables DB_USERNAME and DB_PASSWORD respectively. We will set these variables later before we run our backend.","title":"Update wiring"},{"location":"/flows/db-flow.html#run-the-new-application","text":"A PostgreSQL database is used in our application. It must first be installed and then initially configured to work with our application.","title":"Run the new application"},{"location":"/flows/db-flow.html#database-setup","text":"Follow the installation guide to download and install PostgreSQL on your machine, if not already installed. Link\nAt this point, we will re-run csw-services with the CSW Database Service enabled. This will run an PostgreSQL instance that we can then configure.\nThe following instructions show how to run the Database Service along with the Location Service and the Authentication and Authorization Service:\nNote For running the Database Service using csw-services, the PGDATA environment variable must be set to the Postgres data directory where Postgres is installed e.g. for mac: “/usr/local/var/postgres”.\ncs install csw-services:v4.0.0-M1\ncsw-services start -k -d\nLogin to postgres with your default user and create a new user to be used with our application. The example code below sets up a user “postgres” with a password “postgres”, but you can use different credentials if you prefer.\npsql -d postgres\npostgres => CREATE USER postgres with password 'postgres';\npostgres => \\q\npsql -d postgres -U postgres\nFor this application, we will create an RADECVALUES table in the database that the application can use to perform fetch and insert queries. The following commands can be used to create a table\npostgres =>\nCREATE TABLE RADECVALUES(\nid TEXT             PRIMARY KEY     NOT NULL,\nformattedRa TEXT                    NOT NULL,\nformattedDec TEXT                    NOT NULL\n);\nAs mentioned above, we depend on environment variables to pick up your username and password for the database, thus DB_USERNAME and DB_PASSWORD need to be set to the credentials you provided above.\nTo set environment variables, use the command\nexport DB_USERNAME=<VALUE> DB_PASSWORD=<VALUE>\nNow, we are ready to run the backend application:\nsbt:backend> run start\nTest your application either with the UI or by using apptest.http as described in previous tutorials, and verify the data is saved in your postgres table. This can be done in psql using the TABLE command:\npostgres => TABLE RADECVALUES","title":"Database setup"},{"location":"/flows/docs-flow.html","text":"","title":"Adding Paradox Documentation"},{"location":"/flows/docs-flow.html#adding-paradox-documentation","text":"The section of the tutorial describes how to write documentation for your application using paradox.","title":"Adding Paradox Documentation"},{"location":"/flows/docs-flow.html#pre-requisite","text":"Your application code is checked in some repo in your organization Github account.","title":"Pre-requisite"},{"location":"/flows/docs-flow.html#documentation-development-flow","text":"The sample application generated from the template contains a docs folder. This is where you will write the documentation files for your project. The top-level build.sbt file contains the setup for this docs sbt project.\nLaunch sbt from your console and run command makeSite to construct the documentation pages. Then run the command openSite to open the generated docs in your default browser.\nsbt\nsbt:sample> makeSite\nsbt:sample> openSite\nYou can modify the various .md files present in docs folder and repeat above steps and verify your generated documentation. Refer to the paradox documentation to learn more about the documentation system.","title":"Documentation development flow"},{"location":"/flows/docs-flow.html#documentation-publish-flow","text":"The template sets your project up to publish your documentation to Github using Github Pages. You need to specify the URL of your Github repo in the variable githubRepoUrl in your top-level build.sbt file. This allows paradox to use a special branch, gh-pages, in your Github repo to keep track of your documentation.\nReload sbt so that updated URL is available in sbt.\nsbt:sample> reload\nCreate the gh_pages branch in your repo following these quick steps. Verify that you see a new branch gh_pages in your github repo with an empty commit.\nThen, you can run the command ghpagesPushSite, to publish your documentation.\nsbt:sample> ghpagesPushSite\nVerify that you see a new commit in branch gh_pages, and branch should contain a folder with name 0.1.0-SNAPSHOT\nOpen your published site using URL, http://{your-username}.github.io/{your-project}/0.1.0-SNAPSHOT/","title":"Documentation publish flow"}]}