<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="docs">
<meta name="generator" content="Paradox, paradox-material-theme, mkdocs-material=1.11.0">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.languages" content="">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="docs">
<link rel="shortcut icon" href="assets/images/favicon.png">
<title>Communication using Commands · TMT Common Software (CSW)</title>
<script src="lib/modernizr/modernizr.min.js"></script>
<link rel="stylesheet" href="assets/stylesheets/application-0741cbeb94.css">
<link rel="stylesheet" href="lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="lib/prettify/prettify.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="assets/stylesheets/paradox-material-theme.css">
</head>
<body
data-md-color-primary="indigo"
data-md-color-accent="indigo">
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
<label class="md-overlay" data-md-component="overlay" for="drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="index.html" title="TMT Common Software (CSW)" class="md-header-nav__button md-logo">
<i class="md-icon md-icon--home"></i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<span class="md-flex__ellipsis md-header-nav__title">
Communication using Commands
</span>
</div>
<form name="search" style="display: none">
<input type="text" name="query">
</form>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<div class="md-nav__button md-logo">
<i class="md-icon md-icon--home"></i>
</div>
<a href="index.html" title="TMT Common Software (CSW)">
TMT Common Software (CSW)
</a>
</label>
<ul>
  <li><a href="manuals.html" class="page">Manuals</a></li>
  <li><a href="apps.html" class="page">Applications</a>
  <ul>
    <li><a href="apps/cswclusterseed.html" class="page">csw-cluster-seed</a></li>
    <li><a href="apps/cswlocationagent.html" class="page">csw-location-agent</a></li>
    <li><a href="apps/cswonfigserverapp.html" class="page">csw-config-server</a></li>
    <li><a href="apps/cswconfigclientcli.html" class="page">csw-config-client-cli</a></li>
    <li><a href="apps/hostconfig.html" class="page">csw-host-config</a></li>
  </ul></li>
  <li><a href="services.html" class="page">Services</a>
  <ul>
    <li><a href="services/location.html" class="page">Location service</a></li>
    <li><a href="services/config.html" class="page">Configuration service</a></li>
    <li><a href="services/logging.html" class="page">Logging service</a></li>
    <li><a href="services/messages.html" class="page">csw-messages</a></li>
  </ul></li>
  <li><a href="framework.html" class="page">Framework for creating components (HCD, Assembly, Container)</a>
  <ul>
    <li><a href="framework/describing-components.html" class="page">ComponentInfo</a></li>
    <li><a href="framework/creating-components.html" class="page">Creating an Assembly or Hcd Component</a></li>
    <li><a href="framework/handling-lifecycle.html" class="page">Lifecycle support</a></li>
    <li><a href="framework/managing-command-state.html" class="page">Managing Command State</a></li>
    <li><a href="framework/tracking-connections.html" class="page">Tracking Connections</a></li>
    <li><a href="framework/publishing-state.html" class="page">Publishing State</a></li>
    <li><a href="framework/handling-exceptions.html" class="page">Handling Exceptions</a></li>
    <li><a href="framework/deploying-components.html" class="page">Deploying Components</a></li>
  </ul></li>
  <li><a href="command.html" class="active page">Communication using Commands</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="toc">Table of contents</label>
<ul>
  <li><a href="command.html#communication-using-commands" class="header">Communication using Commands</a>
  <ul>
    <li><a href="command.html#artifacts" class="header">Artifacts</a></li>
    <li><a href="command.html#command-based-communication-between-components" class="header">Command based communication between components</a></li>
    <li><a href="command.html#commandservice" class="header">CommandService</a></li>
    <li><a href="command.html#matching-state-for-command-completion" class="header">Matching state for command completion</a></li>
    <li><a href="command.html#distributing-commands" class="header">Distributing commands</a></li>
  </ul></li>
</ul>
</nav>

<div class="md-nav__title--site md-version" title="Version">
<i class="md-icon">label_outline</i> 0.1*
</div>
</nav>

</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="toc">Table of contents</label>
<ul>
  <li><a href="command.html#communication-using-commands" class="header">Communication using Commands</a>
  <ul>
    <li><a href="command.html#artifacts" class="header">Artifacts</a></li>
    <li><a href="command.html#command-based-communication-between-components" class="header">Command based communication between components</a></li>
    <li><a href="command.html#commandservice" class="header">CommandService</a></li>
    <li><a href="command.html#matching-state-for-command-completion" class="header">Matching state for command completion</a></li>
    <li><a href="command.html#distributing-commands" class="header">Distributing commands</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#communication-using-commands" name="communication-using-commands" class="anchor"><span class="anchor-link"></span></a>Communication using Commands</h1>
<p><strong>csw-command</strong> library provides support for command based communication between components. </p>
<h2><a href="#artifacts" name="artifacts" class="anchor"><span class="anchor-link"></span></a>Artifacts</h2>
<dl>
  <dt>sbt</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;org.tmt&quot; %% &quot;csw-command&quot; % &quot;0.1-SNAPSHOT&quot;
</code></pre></dd>
  <dt>maven</dt>
  <dd>
  <pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
 &lt;groupId&gt;org.tmt&lt;/groupId&gt;
 &lt;artifactId&gt;csw-command_2.12&lt;/artifactId&gt;
 &lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;
 &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;
</code></pre></dd>
  <dt>gradle</dt>
  <dd>
  <pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: &quot;org.tmt&quot;, name: &quot;csw-command_2.12&quot;, version: &quot;0.1-SNAPSHOT&quot;
}
</code></pre></dd>
</dl>
<h2><a href="#command-based-communication-between-components" name="command-based-communication-between-components" class="anchor"><span class="anchor-link"></span></a>Command based communication between components</h2>
<p>A component can send <a href="services/messages/commands.html">Commands</a> to other components. The commands can be sent as following two types of messages: </p>
<ul>
  <li><strong>Submit</strong> - A command is sent as Submit when the result of completion is desired.</li>
  <li><strong>Oneway</strong> - A command is sent as Oneway when the result of completion is not desired.</li>
</ul>
<p>Following responses could be received as a <code>CommandResponse</code> after sending a command :</p>
<ul>
  <li><strong>Accepted</strong> : The command is validated and will be executed</li>
  <li><strong>Invalid</strong> : The command is not valid and will not be executed</li>
  <li><strong>CompletedWithResult</strong> : The command is executed successfully and generated some result</li>
  <li><strong>Completed</strong> : The command has been executed successfully</li>
  <li><strong>NoLongerValid</strong> : The command can no longer be executed</li>
  <li><strong>Error</strong> : The command has failed in execution</li>
  <li><strong>Cancelled</strong> : The command was cancelled</li>
  <li><strong>CommandNotAvailable</strong> : The queried command is not available</li>
  <li><strong>NotAllowed</strong> : The command cannot be executed currently because of the current state of the destination component. Eg another command is in execution in the presence of which it cannot accept any other command to execute.</li>
</ul>
<p>A command sent as <code>Submit</code> or <code>Oneway</code> is validated by the receiving component before actual execution. If the validation is successful, the actual execution can happen in two ways :</p>
<ul>
  <li><strong>Immediate</strong> - The component receiving the command can determine if the command can be executed immediately and thus provide the final execution response directly without sending a response for validation.</li>
</ul>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val eventualResponse: Future[CommandResponse] = async {
  await(assemblyComponent.submit(Setup(prefix, immediateCmd, obsId))) match {
    case response: Completed ⇒
      //do something with completed result
      response
    case otherResponse ⇒
      // do something with other response which is not expected
      otherResponse
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; eventualCommandResponse =
        hcdCmdService
                .submit(imdInvalidCommand, timeout)
                .thenApply(
                        response -&gt; {
                            if (response instanceof Completed) {
                                //do something with completed result
                            }
                            return response;
                        }
                );</code></pre></dd>
</dl>
<ul>
  <li><strong>Long running</strong> - The component receiving the command can determine if the command can not be executed immediately. In this case, the component provides a <code>Accepted</code> response as an acknowledgement and maintains the state of the command. The sender can query the state of a particular command or subscribe to get the final response when the execution is completed.</li>
</ul>
<p>The sender component can send following commands to the receiver component with the command id (RunId) of the command being sent originally to get the completion status and/or result of the command</p>
<ul>
  <li><strong>Query</strong> - Query the current state of the command</li>
</ul>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val setupForQuery = Setup(prefix, longRunning, Some(obsId))
assemblyCommandService.submit(setupForQuery)

//do some work before querying for the result of above command as needed

val eventualResponse: Future[CommandResponse] = assemblyCommandService.query(setupForQuery.runId)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">hcdCmdService.submit(controlCommand, timeout);

// do some work before querying for the result of above command as needed

CompletableFuture&lt;CommandResponse&gt; queryResponse = hcdCmdService.query(controlCommand.runId(), timeout);</code></pre></dd>
</dl>
<ul>
  <li><strong>Subscribe</strong> - Subscribe for getting the final state of the command asynchronously</li>
</ul>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val eventualCommandResponse = assemblyCommandService.submit(setup).flatMap {
  case _: Accepted ⇒ assemblyCommandService.subscribe(setup.runId)
  case _           ⇒ Future(CommandResponse.Error(setup.runId, &quot;&quot;))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; testCommandResponse =
        hcdCmdService
                .submit(controlCommand, timeout)
                .thenCompose(commandResponse -&gt; {
                    if (commandResponse instanceof CommandResponse.Accepted)
                        return hcdCmdService.subscribe(commandResponse.runId(), timeout);
                    else
                        return CompletableFuture.completedFuture(new CommandResponse.Error(commandResponse.runId(), &quot;test error&quot;));
                });</code></pre></dd>
</dl>
<h2><a href="#commandservice" name="commandservice" class="anchor"><span class="anchor-link"></span></a>CommandService</h2>
<p>The command service for a component can be obtained by creating an instance of <code>CommandService</code> using the <code>AkkaLocation</code> of the component discovered using location service. This command service instance will have methods for communicating with the component using commands. The API can be exercised as follows for different scenarios of command based communication:</p>
<h3><a href="#submit" name="submit" class="anchor"><span class="anchor-link"></span></a>submit</h3>
<p>Submit a command and get a <code>CommandResponse</code> as a Future. The CommandResponse can be a response of validation (Accepted, Invalid) or a final Response in case of immediate completion.</p>
<dl>
  <dt>Scala/immediate-response
  </dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val eventualResponse: Future[CommandResponse] = async {
  await(assemblyComponent.submit(Setup(prefix, immediateCmd, obsId))) match {
    case response: Completed ⇒
      //do something with completed result
      response
    case otherResponse ⇒
      // do something with other response which is not expected
      otherResponse
  }
}</code></pre></dd>
  <dt>Java/immediate-response
  </dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; eventualCommandResponse =
        hcdCmdService
                .submit(imdInvalidCommand, timeout)
                .thenApply(
                        response -&gt; {
                            if (response instanceof Completed) {
                                //do something with completed result
                            }
                            return response;
                        }
                );</code></pre></dd>
  <dt>Scala/validation-response
  </dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// `setupWithTimeoutMatcher` is a sample setup payload intended to be used when command response is not determined
// using matcher
val submitCommandResponseF: Future[Unit] = async {
  val initialResponse: CommandResponse = await(assemblyComponent.submit(setupWithTimeoutMatcher))
  initialResponse match {
    case accepted: Accepted ⇒
    // do Something
    case invalid: Invalid ⇒
    // do Something
    case x ⇒
    // do Something
  }
}</code></pre></dd>
  <dt>Java/validation-response
  </dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture submitCommandResponseF = hcdCmdService
        .oneway(setup, timeout)
        .thenAccept(initialCommandResponse -&gt; {
            if (initialCommandResponse instanceof CommandResponse.Accepted) {
                //do something
            } else if (initialCommandResponse instanceof CommandResponse.Invalid) {
                //do something
            } else {
                //do something
            }
        });
</code></pre></dd>
</dl>
<h3><a href="#oneway" name="oneway" class="anchor"><span class="anchor-link"></span></a>oneway</h3>
<p>Send a command as a Oneway and get a <code>CommandResponse</code> as a Future. The CommandResponse can be a response of validation (Accepted, Invalid) or a final Response.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// `setupWithTimeoutMatcher` is a sample setup payload intended to be used when command response is not determined
// using matcher
val onewayCommandResponseF: Future[Unit] = async {
  val initialResponse: CommandResponse = await(assemblyComponent.oneway(setupWithTimeoutMatcher))
  initialResponse match {
    case accepted: Accepted ⇒
    // do Something
    case invalid: Invalid ⇒
    // do Something
    case x ⇒
    // do Something
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture onewayCommandResponseF = hcdCmdService
        .oneway(setup, timeout)
        .thenAccept(initialCommandResponse -&gt; {
            if (initialCommandResponse instanceof CommandResponse.Accepted) {
                //do something
            } else if (initialCommandResponse instanceof CommandResponse.Invalid) {
                //do something
            } else {
                //do something
            }
        });
</code></pre></dd>
</dl>
<h3><a href="#subscribe" name="subscribe" class="anchor"><span class="anchor-link"></span></a>subscribe</h3>
<p>Subscribe for the result of a long running command which was sent as Submit to get a <code>CommandResponse</code> as a Future.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val eventualCommandResponse = assemblyCommandService.submit(setup).flatMap {
  case _: Accepted ⇒ assemblyCommandService.subscribe(setup.runId)
  case _           ⇒ Future(CommandResponse.Error(setup.runId, &quot;&quot;))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; testCommandResponse =
        hcdCmdService
                .submit(controlCommand, timeout)
                .thenCompose(commandResponse -&gt; {
                    if (commandResponse instanceof CommandResponse.Accepted)
                        return hcdCmdService.subscribe(commandResponse.runId(), timeout);
                    else
                        return CompletableFuture.completedFuture(new CommandResponse.Error(commandResponse.runId(), &quot;test error&quot;));
                });</code></pre></dd>
</dl>
<h3><a href="#query" name="query" class="anchor"><span class="anchor-link"></span></a>query</h3>
<p>Query for the result of a long running command which was sent as Submit to get a <code>CommandResponse</code> as a Future.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val setupForQuery = Setup(prefix, longRunning, Some(obsId))
assemblyCommandService.submit(setupForQuery)

//do some work before querying for the result of above command as needed

val eventualResponse: Future[CommandResponse] = assemblyCommandService.query(setupForQuery.runId)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">hcdCmdService.submit(controlCommand, timeout);

// do some work before querying for the result of above command as needed

CompletableFuture&lt;CommandResponse&gt; queryResponse = hcdCmdService.query(controlCommand.runId(), timeout);</code></pre></dd>
</dl>
<h3><a href="#submitandsubscribe" name="submitandsubscribe" class="anchor"><span class="anchor-link"></span></a>submitAndSubscribe</h3>
<p>Submit a command and Subscribe for the result if it was successfully validated as <code>Accepted</code> to get a final <code>CommandResponse</code> as a Future.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val setupForSubscribe = Setup(prefix, longRunning, Some(obsId))
val response          = assemblyCommandService.submitAndSubscribe(setupForSubscribe)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; finalResponseCompletableFuture = hcdCmdService.submitAndSubscribe(failureResCommand1, timeout);
CommandResponse actualValidationResponse = finalResponseCompletableFuture.get();</code></pre></dd>
</dl>
<h3><a href="#onewayandmatch" name="onewayandmatch" class="anchor"><span class="anchor-link"></span></a>onewayAndMatch</h3>
<p>Send a command and match the published state from the component using a <code>StateMatcher</code>. If the match is successful a <code>Completed</code> response is provided as a future. In case of a failure or unmatched state, <code>Error</code> CommandResponse is provided as a Future.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val eventualResponse1: Future[CommandResponse] = assemblyComponent.onewayAndMatch(setupWithMatcher, demandMatcher)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java"><br/>// create a DemandMatcher which specifies the desired state to be matched.
StateMatcher stateMatcher = new DemandMatcher(new DemandState(prefix().prefix()).add(param), false, timeout);

// create matcher instance
Matcher matcher1 = new Matcher(hcdLocation.componentRef().narrow(), demandMatcher, ec, mat);

// start the matcher so that it is ready to receive state published by the source
CompletableFuture&lt;MatcherResponse&gt; matcherResponse = matcher1.jStart();

CompletableFuture&lt;CommandResponse&gt; matchedCommandResponse =
        hcdCmdService.onewayAndMatch(setup, stateMatcher, timeout);
</code></pre></dd>
</dl>
<h3><a href="#submitallandgetresponse" name="submitallandgetresponse" class="anchor"><span class="anchor-link"></span></a>submitAllAndGetResponse</h3>
<p>Submit multiple commands and get one CommandResponse as a Future of <code>CommandResponse</code> for all commands. If all the commands were successful, a CommandResponse as <code>Completed</code> will be returned. If any one of the command fails, an <code>Error</code> will be returned.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala"><br/>val responseOfMultipleCommands = hcdComponent.submitAllAndGetResponse(Set(setupHcd1, setupHcd2))
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Setup setupHcd1 = new Setup(prefix(), shortRunning(), Optional.empty()).add(encoderParam);
Setup setupHcd2 = new Setup(prefix(), mediumRunning(), Optional.empty()).add(encoderParam);

HashMap&lt;JCommandService, Set&lt;ControlCommand&gt;&gt; componentsToCommands = new HashMap&lt;JCommandService, Set&lt;ControlCommand&gt;&gt;() {
    {
        put(hcdCmdService, new HashSet&lt;ControlCommand&gt;(Arrays.asList(setupHcd1, setupHcd2)));
    }
};

CompletableFuture&lt;CommandResponse&gt; commandResponse = hcdCmdService
        .submitAllAndGetResponse(
                new HashSet&lt;ControlCommand&gt;(Arrays.asList(setupHcd1, setupHcd2)),
                timeout
        );</code></pre></dd>
</dl>
<h3><a href="#submitallandgetfinalresponse" name="submitallandgetfinalresponse" class="anchor"><span class="anchor-link"></span></a>submitAllAndGetFinalResponse</h3>
<p>Submit multiple commands and get final CommandResponse for all as one CommandResponse. If all the commands were successful, a CommandResponse as <code>Completed</code> will be returned. If any one of the command fails, an <code>Error</code> will be returned. For long running commands, it will subscribe for the result of those which were successfully validated as <code>Accepted</code> and get the final CommandResponse.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala"><br/>val finalResponseOfMultipleCommands = hcdComponent.submitAllAndGetFinalResponse(Set(setupHcd1, setupHcd2))
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Setup setupHcd1 = new Setup(prefix(), shortRunning(), Optional.empty()).add(encoderParam);
Setup setupHcd2 = new Setup(prefix(), mediumRunning(), Optional.empty()).add(encoderParam);

HashMap&lt;JCommandService, Set&lt;ControlCommand&gt;&gt; componentsToCommands = new HashMap&lt;JCommandService, Set&lt;ControlCommand&gt;&gt;() {
    {
        put(hcdCmdService, new HashSet&lt;ControlCommand&gt;(Arrays.asList(setupHcd1, setupHcd2)));
    }
};

CompletableFuture&lt;CommandResponse&gt; finalCommandResponse = hcdCmdService
        .submitAllAndGetFinalResponse(
                new HashSet&lt;ControlCommand&gt;(Arrays.asList(setupHcd1, setupHcd2)),
                timeout
        );</code></pre></dd>
</dl>
<h3><a href="#subscribecurrentstate" name="subscribecurrentstate" class="anchor"><span class="anchor-link"></span></a>subscribeCurrentState</h3>
<p>This method can be used to subscribe to the <a href="services/messages/states.html">CurrentState</a> of the component by providing a callback. Subscribing results into a handle of <code>CurrentStateSubscription</code> which can be used to unsubscribe the subscription.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// subscribe to the current state of an assembly component and use a callback which forwards each received
// element to a test probe actor
assemblyCommandService.subscribeCurrentState(probe.ref ! _)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">// subscribe to the current state of an assembly component and use a callback which forwards each received
// element to a test probe actor
CurrentStateSubscription subscription = hcdCmdService.subscribeCurrentState(currentState -&gt; probe.ref().tell(currentState));</code></pre></dd>
</dl>
<h2><a href="#matching-state-for-command-completion" name="matching-state-for-command-completion" class="anchor"><span class="anchor-link"></span></a>Matching state for command completion</h2>
<p>A <code>Matcher</code> is provided for matching state against a desired state. The matcher is created with a source of state identified by its ActorRef and an instance of <code>StateMatcher</code> which defines the state and criteria for matching. Several instances of <code>StateMatcher</code> are available for common use. These are <code>DemandMatcherAll</code> for matching the entire <code>DemandState</code> against the current state, <code>DemandMatcher</code> for matching state with or without units against the current state and <code>PresenceMatcher</code> which checks if a matching state is found with a provided prefix. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala"><br/>// create a DemandMatcher which specifies the desired state to be matched.
val demandMatcher = DemandMatcher(DemandState(prefix, Set(param)), withUnits = false, timeout)

// create matcher instance
val matcher = new Matcher(assemblyLocation.componentRef, demandMatcher)

// start the matcher so that it is ready to receive state published by the source
val matcherResponseF: Future[MatcherResponse] = matcher.start

// submit command and if the command is successfully validated, check for matching of demand state against current state
val eventualCommandResponse: Future[CommandResponse] = async {
  val initialResponse = await(assemblyComponent.oneway(setupWithMatcher))
  initialResponse match {
    case _: Accepted ⇒
      val matcherResponse = await(matcherResponseF)
      // create appropriate response if demand state was matched from among the published state or otherwise
      matcherResponse match {
        case MatchCompleted  ⇒ Completed(setupWithMatcher.runId)
        case MatchFailed(ex) ⇒ Error(setupWithMatcher.runId, ex.getMessage)
      }
    case invalid: Invalid ⇒
      matcher.stop()
      invalid
    case x ⇒ x
  }
}

val commandResponse = Await.result(eventualCommandResponse, timeout.duration)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java"><br/>// create a DemandMatcher which specifies the desired state to be matched.
DemandMatcher demandMatcher = new DemandMatcher(new DemandState(prefix().prefix()).add(param), false, timeout);

// create matcher instance
Matcher matcher = new Matcher(hcdLocation.componentRef().narrow(), demandMatcher, ec, mat);

// start the matcher so that it is ready to receive state published by the source
CompletableFuture&lt;MatcherResponse&gt; matcherResponseFuture = matcher.jStart();

// submit command and if the command is successfully validated, check for matching of demand state against current state
CompletableFuture&lt;CommandResponse&gt; commandResponseToBeMatched = hcdCmdService
        .oneway(setup, timeout)
        .thenCompose(initialCommandResponse -&gt; {
            if (initialCommandResponse instanceof CommandResponse.Accepted) {
                return matcherResponseFuture.thenApply(matcherResponse -&gt; {
                    // create appropriate response if demand state was matched from among the published state or otherwise
                    if (matcherResponse.getClass().isAssignableFrom(MatcherResponses.jMatchCompleted().getClass()))
                        return new Completed(initialCommandResponse.runId());
                    else
                        return new CommandResponse.Error(initialCommandResponse.runId(), &quot;Match not completed&quot;);
                });
            } else {
                matcher.stop();
                return CompletableFuture.completedFuture(initialCommandResponse);
            }
        });

CommandResponse actualResponse = commandResponseToBeMatched.get();
</code></pre></dd>
</dl>
<h2><a href="#distributing-commands" name="distributing-commands" class="anchor"><span class="anchor-link"></span></a>Distributing commands</h2>
<p><code>CommandDistributor</code> is a utility for distributing commands to multiple components and get an aggregated response. </p>
<h3><a href="#aggregated-validation-response" name="aggregated-validation-response" class="anchor"><span class="anchor-link"></span></a>aggregated validation response</h3>
<p>A component can send one or more commands to one or more components using a <code>Map[ComponentRef, Set[ControlCommand]</code>, and get an aggregated response of validation as <code>Accepted</code> if all the commands were successfully validated. An <code>Error</code> response is returned otherwise</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val aggregatedValidationResponse = CommandDistributor(
  Map(assemblyCommandService → Set(setupAssembly1, setupAssembly2), hcdComponent → Set(setupHcd1, setupHcd2))
).aggregatedValidationResponse()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; cmdValidationResponseF =
        new JCommandDistributor(componentsToCommands).
                aggregatedValidationResponse(timeout, ec, mat);</code></pre></dd>
</dl>
<h3><a href="#aggregated-completion-response" name="aggregated-completion-response" class="anchor"><span class="anchor-link"></span></a>aggregated completion response</h3>
<p>A component can send one or more commands to one or more components using a <code>Map[ComponentRef, Set[ControlCommand]</code>. The utility handles subscribing for final completion result for all the commands post successful validation and get an aggregated response of completion as <code>Completed</code> if all the commands were successfully completed. An <code>Error</code> response is returned otherwise.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val aggregatedResponse = CommandDistributor(
  Map(assemblyCommandService → Set(setupAssembly1, setupAssembly2), hcdComponent → Set(setupHcd1, setupHcd2))
).aggregatedCompletionResponse()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; cmdCompletionResponseF =
        new JCommandDistributor(componentsToCommands).
                aggregatedCompletionResponse(timeout, ec, mat);</code></pre></dd>
</dl>
</div>
<div>
<a href="https://github.com/tmtsoftware/csw-prod/tree/master/docs/src/main/command.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.1*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="framework/deploying-components.html" title="Deploying Components" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Deploying Components
</span>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox" title="Paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/" title="Paradox Material Theme">Paradox Material Theme</a>

</div>
<div class="md-footer-social">
</div>

</div>
</div>
</footer>

</div>
<script src="assets/javascripts/application-268d62d82d.js"></script>
<script src="assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({url:{base:"./"}})</script>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
