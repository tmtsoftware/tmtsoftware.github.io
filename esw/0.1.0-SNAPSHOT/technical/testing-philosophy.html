<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="docs">
<meta name="generator" content="Paradox, paradox-material-theme=0.7.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="docs">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>OSW Testing Philosophy · TMT Executive Software Documentation</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="TMT Executive Software Documentation" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
TMT Executive Software Documentation
</span>
<span class="md-header-nav__topic">
OSW Testing Philosophy
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="TMT Executive Software Documentation" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="TMT Executive Software Documentation">
TMT Executive Software Documentation
</a>
</label>
<ul>
  <li><a href="../esw/eswOverview.html" class="page">Executive Software Overview</a></li>
  <li><a href="../sequencersandscripts/seq-index.html" class="page">Sequencers and Sequence Components</a>
  <ul>
    <li><a href="../sequencersandscripts/sequencer.html" class="page">Sequencers in the Executive Software</a></li>
    <li><a href="../sequencersandscripts/sequencer-app.html" class="page">Running a Sequencer Using esw-ocs-app</a></li>
  </ul></li>
  <li><a href="../scripts/scripts-index.html" class="page">Sequencer Scripts</a>
  <ul>
    <li><a href="../scripts/script-styles.html" class="page">Sequencer Script Styles</a></li>
    <li><a href="../scripts/dsl/script-constructs.html" class="page">Script DSL Constructs</a></li>
    <li><a href="../scripts/dsl/csw-services.html" class="page">CSW Services DSL</a></li>
  </ul></li>
  <li><a href="../eswshell/esw-shell.html" class="page">ESW Shell</a></li>
  <li><a href="../uisupport/uisupp-index.html" class="page">User Interface Support</a>
  <ul>
    <li><a href="../uisupport/UIOverview.html" class="page">User Interfaces in ESW and TMT</a></li>
    <li><a href="../uisupport/frontend-template.html" class="page">Creating and Using the Frontend UI Template</a></li>
    <li><a href="../uisupport/backend-template.html" class="page">Creating and Using the UI Backend Template</a></li>
    <li><a href="../uisupport/gateway.html" class="page">User Interface Gateway</a></li>
  </ul></li>
  <li><a href="../technical/tech-index.html" class="page">Technical Design Documents</a>
  <ul>
    <li><a href="../technical/sequence-manager-tech.html" class="page">Sequence Manager Technical Documentation</a></li>
    <li><a href="../technical/sequencer-tech.html" class="page">Sequencer Technical Documentation</a></li>
    <li><a href="../technical/sequence-component-tech.html" class="page">Sequence Component Technical Documentation</a></li>
    <li><a href="../technical/gateway-tech.html" class="page">Gateway Technical Documentation</a></li>
    <li><a href="../technical/agent-service-tech.html" class="page">Agent Service and Agent Technical Documentation</a></li>
    <li><a href="../technical/apps/apps-index.html" class="page">Technical Applications</a></li>
    <li><a href="../technical/esw-application-parts.html" class="page">ESW Application Architecture</a></li>
    <li><a href="../technical/contracts.html" class="page">Service Contracts</a></li>
    <li><a href="../technical/testing-philosophy.html" class="active page">OSW Testing Philosophy</a></li>
    <li><a href="../technical/esw-services.html" class="page">esw-services</a></li>
  </ul></li>
  <li><a href="../tutorials/web-app-tutorial.html" class="page">Web Application Tutorial</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../technical/testing-philosophy.html#osw-testing-philosophy" class="header">OSW Testing Philosophy</a>
  <ul>
    <li><a href="../technical/testing-philosophy.html#layered-software" class="header">Layered Software</a></li>
    <li><a href="../technical/testing-philosophy.html#layered-testing" class="header">Layered Testing</a></li>
    <li><a href="../technical/testing-philosophy.html#client-server-interfaces" class="header">Client-Server interfaces</a></li>
    <li><a href="../technical/testing-philosophy.html#integration-tests" class="header">Integration Tests</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.1.0*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../technical/testing-philosophy.html#osw-testing-philosophy" class="header">OSW Testing Philosophy</a>
  <ul>
    <li><a href="../technical/testing-philosophy.html#layered-software" class="header">Layered Software</a></li>
    <li><a href="../technical/testing-philosophy.html#layered-testing" class="header">Layered Testing</a></li>
    <li><a href="../technical/testing-philosophy.html#client-server-interfaces" class="header">Client-Server interfaces</a></li>
    <li><a href="../technical/testing-philosophy.html#integration-tests" class="header">Integration Tests</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#osw-testing-philosophy" name="osw-testing-philosophy" class="anchor"><span class="anchor-link"></span></a>OSW Testing Philosophy</h1>
<p>This document serves to describe the OSW Testing Philosophy, using the Sequence Manager code as an example. The philosophy can be summarized with the belief that unit tests should be favored over integration tests, in the sense that a comprehensive set of unit tests paired with a small set of integration tests can provide a complete test suite without the need for a large set of integration tests that pursue every possible code path. </p>
<p>Software today often follows the <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">Single Responsibility Principle</a>, in which code is often broken down into components and layers that cover one function of the program. This leads to more isolated “units” to test, but branching at each layer of code can lead to an exponential number of code paths to cover. Writing a complete set of integration tests that explore every branch of code can be extremely time consuming or even impossible.</p>
<p>Testing with a full set of integration tests can actually be entirely unnecessary. A comprehensive set of unit tests, when written properly, can demonstrate every code path sufficiently. Then, they can be combined with a few integration tests as both a sanity check and to ensure the connections are complete throughout the layers of code.</p>
<h2><a href="#layered-software" name="layered-software" class="anchor"><span class="anchor-link"></span></a>Layered Software</h2>
<p>As mentioned, it is common that software today is composed of layers, each with its own responsibility. This facilitates understanding of the software as well as making it easier to test. When we talk about the ordering of layers, we often start with the outward facing API layer as the top-most. This layer then will call methods of the layer below. That layer may call methods of the layer below it, an so on. It is important to note that typically a lower layer does not call methods of the layer above it. It simply returns responses back up the layers to the external user. A layer may have call methods from more than one class and therefore can have multiple layers directly beneath it. The layers directly beneath are called dependencies.</p>
<p>An important facet of our component construction is that, it follows the <a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> pattern. For each layer in our component, its dependencies are injected into the layer by passing them in the constructor of the layer. For OSW software, this is done by instantiating all layers in a wiring class. Lowest layer dependencies are instantiated first, and then layers are created going up the layers, each time passing in the dependencies for the layers below. The constructor of each layer should use the interface of the dependency, so that various implementations of the dependency can be passed in, such as a version for testing or simulation. This also allows mocks to be used for each dependency. This is essential for layered testing.</p>
<h2><a href="#layered-testing" name="layered-testing" class="anchor"><span class="anchor-link"></span></a>Layered Testing</h2>
<p>Layered testing forms the basis of our testing strategy. The fundamental idea is that if we can assume the dependency of a layer is tested and correct, we can then test the layer independent of the dependency by mocking it. In other words, if our software package is constructed using layers as described above, the entire package can be thoroughly tested by the implementing the layer class by using mocks or stubs for its dependencies.</p>
<p>In some cases, a layer is nothing more than translation or adapter layer which maps methods to some other protocol call to the layer below. An example of this is an Akka client layer that maps methods to Akka ask or tell calls to some Actor below it. In these case, all that is needed is to demonstrate is that each method maps to the appropriate request or method of the layer below. This is done by mocking the method call of the dependency and verifying the appropriate method is called when the client method is called.</p>
<h2><a href="#client-server-interfaces" name="client-server-interfaces" class="anchor"><span class="anchor-link"></span></a>Client-Server interfaces</h2>
<p>Any remoting or Client-Server type interface that requires serialization of messages or commands must demonstrate proper serialization and deserialization on both sides of the interface for all models that can sent and received over the wire. </p>
<h3><a href="#sequence-manager-as-an-example" name="sequence-manager-as-an-example" class="anchor"><span class="anchor-link"></span></a>Sequence Manager as an Example</h3>
<p>To start, we will go through the Sequence Manager code and tests to show the multiple layers involved and how testing is done at each one. </p>
<p>We’ll start with a look at the <a href="https://github.com/tmtsoftware/esw/blob/master/esw-sm/esw-sm-api/shared/src/main/scala/esw/sm/api/SequenceManagerApi.scala">SequenceManagerApi</a>:</p>
<pre class="prettyprint"><code class="language-scala">trait SequenceManagerApi {

  /**
   * Configures sequencers and resources needed for provided observing mode.
   */
  def configure(obsMode: ObsMode): Future[ConfigureResponse]

  /**
   * Shutdown running sequencer of provided Subsystem and Observing mode.
   */
  def shutdownSequencer(
    subsystem: Subsystem,
    obsMode: ObsMode
  ): Future[ShutdownSequencersResponse]

  // other APIs ...
}
</code></pre>
<p>The Sequence Manager provides both an HTTP and Akka interface to it, so it has two implementations of the API: a HTTP client and an Akka Client. The core functionality of the program is written as an Akka actor, and the HTTP service is merely an adaptive wrapper around the Akka interface, in that the HTTP service contains the Akka Client, and translates HTTP requests into Akka calls to the Sequence Manager Actor Behavior.</p>
<p>The HTTP server in the Sequence Manager is implemented using <a href="https://github.com/tmtsoftware/msocket">msocket</a> without any streams or callback methods (i.e. no websocket are needed), so only a “post-handler” class needs to be implemented. This class merely translates msocket requests, that is, POST requests to the “post-endpoint”, to SM API calls in the Akka implementation.</p>
<p>This program has many layers to it, summarized by the following list:</p>
<ul>
  <li>
  <p><strong>SequenceManagerClient</strong>: HTTP client, which provides a facade for post requests, which are  received by an msocket-based HTTP service. These requests are processed in the</p></li>
  <li>
  <p><strong>SequenceManagerRequestHandler</strong>: This takes the HTTP requests and, based on the request model,  translates them to commands in the</p></li>
  <li>
  <p><strong>SequenceManagerImpl</strong>: an Akka client to the SequenceManager actor, in which method calls are  translated to Akka messages, sent to the actor, and handled in the</p></li>
  <li>
  <p><strong>SequenceManagerBehavior</strong>: the actor behavior which receives the Akka messages and delegates to  utility classes, which sometimes is</p></li>
  <li>
  <p><strong>SequencerUtil</strong>: which performs operations on Sequencers. It uses the Location Service, and  sometimes needs to use</p></li>
  <li>
  <p><strong>SequenceComponentUtil</strong>: which performs operations on Sequence Components, such as killing them.  This requires interaction with the Location Service.</p></li>
</ul>
<p>Each layer must have a unit test that mocks the behavior of the layer below. Each test must verify every available method or interface of the layer below and all unique return types generated in the layer must be demonstrated.</p>
<p>Each of these classes are actually created in the <strong>SequenceManagerWiring</strong> class. This allows the class for the layer below to be passed in as an argument to the layer above. This is essential to dependency injection because it makes mocking that lower layer possible.</p>
<p>We will take a look at each layer, and examine the way it is defined and how to write the tests. We will focus on one particular method, <code>shutdownSequencer(subsystem: Subsystem, obsMode: ObsMode)</code>, because it is complete enough to demonstrate our testing philosophy, but simple enough to not over complicate this document. We will take a top-down look at the layers, so we will start with the HTTP Client. </p>
<h4><a href="#sequencemanagerclient" name="sequencemanagerclient" class="anchor"><span class="anchor-link"></span></a>SequenceManagerClient</h4>
<p>The <a href="https://github.com/tmtsoftware/esw/blob/master/esw-sm/esw-sm-api/shared/src/main/scala/esw/sm/api/client/SequenceManagerClient.scala">SequenceManagerClient</a> class has the msocket POST client passed in. The following snippet shows the implementation of <code>shutdownSequencer</code>:</p>
<pre class="prettyprint"><code class="language-scala">override def shutdownSequencer(
  subsystem: Subsystem,
  obsMode: ObsMode
): Future[ShutdownSequencersResponse] =
  postClient.requestResponse[ShutdownSequencersResponse](
    ShutdownSequencer(subsystem, obsMode)
  )
</code></pre>
<p>This method creates a <strong>ShutdownSequencer</strong> which is an ADT subtype of a <strong>SequenceManagerRequest</strong>, the type used by msocket to send over the wire via an HTTP POST. Then the model is sent to the post client to be transported via msocket.</p>
<p>So what does the testing fixture for this class (<a href="https://github.com/tmtsoftware/esw/blob/master/esw-sm/esw-sm-api/jvm/src/test/scala/esw/sm/api/client/SequenceManagerClientTest.scala">SequenceManagerClientTest</a>) look like? Well, if we follow our strategy, we will use a real implementation of SequenceManagerClient, and the post client will be mocked. </p>
<pre class="prettyprint"><code class="language-scala">class SequenceManagerClientTest
  extends BaseTestSuite
  with SequenceManagerServiceCodecs {
  
  val postClient: Transport[SequenceManagerRequest] = 
    mock[Transport[SequenceManagerRequest]]
  
  val client = new SequenceManagerClient(postClient)
}
</code></pre>
<p>To do this, we need to implement mocked behavior for <code>postClient.requestResponse</code>. For our method, this looks like this:</p>
<pre class="prettyprint"><code class="language-scala">&quot;SequenceManagerClient&quot; must {
  &quot;return ShutdownSequencersResponse for shutdownSequencer request&quot; in {
    val shutdownSequencersResponse = mock[ShutdownSequencersResponse]
    val shutdownSequencerMsg       = ShutdownSequencer(ESW, obsMode)
    when(
      postClient.requestResponse[ShutdownSequencersResponse](
        argsEq(shutdownSequencerMsg)
      )(
        any[Decoder[ShutdownSequencersResponse]](),
        any[Encoder[ShutdownSequencersResponse]]()
      )
    ).thenReturn(Future.successful(shutdownSequencersResponse))

    client.shutdownSequencer(
      ESW,
      obsMode
    ).futureValue shouldBe shutdownSequencersResponse
  }
}   
</code></pre>
<p>One thing to note is that we are also mocking the response. This insures that the response we get back from the call is coming from this mock, and not always returned by this method.</p>
<p>So what is the test verifying? In essence, it is simply showing the the client call is connected to the proper HTTP request. Since that is all this layer is doing, the test is complete (as long as all client calls are tested). We do not need to test the values of the <strong>ShutdownSequencer</strong> model because we are simply testing that the correct request is made.</p>
<h3><a href="#sequencemanagerrequesthandler" name="sequencemanagerrequesthandler" class="anchor"><span class="anchor-link"></span></a>SequenceManagerRequestHandler</h3>
<p>Now we will move on to the <a href="https://github.com/tmtsoftware/esw/blob/master/esw-sm/esw-sm-handler/src/main/scala/esw/sm/handler/SequenceManagerRequestHandler.scala">SequenceManagerRequestHandler</a> class, which is called in msocket to handle this request. The code for the handler looks like this:</p>
<pre class="prettyprint"><code class="language-scala">class SequenceManagerRequestHandler(
    sequenceManager: SequenceManagerApi,
    securityDirectives: SecurityDirectives
) extends HttpPostHandler[SequenceManagerRequest]
  with ServerHttpCodecs {

  import sequenceManager._
  override def handle(request: SequenceManagerRequest): Route =
    request match {
      case Configure(obsMode) =&gt; 
        sPost(complete(configure(obsMode)))
  
      case ShutdownSequencer(subsystem, obsMode) =&gt; 
        sPost(complete(shutdownSequencer(subsystem, obsMode)))

      // other ...
    }

  def sPost(route: =&gt; Route): Route = securityDirectives.sPost(EswUserRolePolicy())(_ =&gt; route)
}
</code></pre>
<p>Here, the lower layer is the <strong>SequenceManagerImpl</strong>, passed in as the sequenceManager. For our method, the handle method matches the request model as a <strong>ShutdownSequencer</strong> type, and then calls <code>shutdownSequencer(subsystem, obsMode)</code> which is an imported method of sequenceManager. This call is wrapped in an <code>sPost</code>, which provides AAS security, and complete, is an Akka-HTTP method to complete the HTTP request.</p>
<p>Again, this layer is just an adapter layer that changes HTTP requests into <strong>SequenceManagerImpl</strong> calls. All that is needed to test this class is to make sure each request calls the appropriate Akka client call. The real implementation of this class is used, and the layer below is mocked. <code>sPost</code> is mocked too, since this is already tested as part of AAS:</p>
<pre class="prettyprint"><code class="language-scala">class SequenceManagerRequestHandlerTest
  extends BaseTestSuite
  with ScalatestRouteTest
  with SequenceManagerServiceCodecs
  with ClientHttpCodecs {

  private val sequenceManagerApi = mock[SequenceManagerApi]
  private val securityDirectives = mock[SecurityDirectives]

  private val postHandler = 
    new SequenceManagerRequestHandler(sequenceManagerApi, securityDirectives)

  private val route =
    new PostRouteFactory[SequenceManagerRequest](&quot;post-endpoint&quot;, postHandler)
      .make()
}
</code></pre>
<p>The test creates a post-endpoint route via msocket, just like we using in our msocket-based HTTP server. Now, our test uses Akka-HTTP to POST a request to this route, using the Akka-HTTP testkit to “check” that what happens when the request with the proper model is sent to this endpoint is what expect. </p>
<pre class="prettyprint"><code class="language-scala">&quot;SequenceManagerRequestHandler&quot; must {
    &quot;return shutdown sequencer success for shutdownSequencer request&quot; in {
    
    when(securityDirectives.sPost(eswUserPolicy))
      .thenReturn(accessTokenDirective)
    when(sequenceManagerApi.shutdownSequencer(ESW, obsMode))
      .thenReturn(Future.successful(ShutdownSequencersResponse.Success))

    Post(&quot;/post-endpoint&quot;, ShutdownSequencer(ESW, obsMode).narrow) ~&gt; route ~&gt; check {
      verify(securityDirectives).sPost(eswUserPolicy)
      verify(sequenceManagerApi).shutdownSequencer(ESW, obsMode)

      responseAs[ShutdownSequencersResponse] should ===(
        ShutdownSequencersResponse.Success
      )
    }
  }
}
</code></pre>
<p>This test verifies when we send this model to this endpoint, <code>sPost</code> is called, and then the <code>shutdownSequencer</code> method of our Akka client is called, and the response matches the mocked response set up to return from that client method call. Note, in this case, the response here is a single real type of expected response, and not a mocked response. This is because the response requires serialization and we don’t have serialization set up for mocked typed. This is okay because we have tested serialization for all of our responses with round trip testing in <a href="https://github.com/tmtsoftware/esw/blob/master/esw-contract/src/test/scala/esw/contract/data/RoundTripTest.scala">RoundTripTest</a>.</p>
<h3><a href="#sequencemanagerimpl" name="sequencemanagerimpl" class="anchor"><span class="anchor-link"></span></a>SequenceManagerImpl</h3>
<p>The next layer down is the Akka Client, <a href="https://github.com/tmtsoftware/esw/blob/master/esw-sm/esw-sm-api/jvm/src/main/scala/esw/sm/api/actor/client/SequenceManagerImpl.scala">SequenceManagerImpl</a>. It takes API method calls and turns them into Akka ask calls to the Sequence Manager actor. The lower layer in this case is the Sequence Manager actor, implemented in <strong>SequenceManagerBehavior</strong>. </p>
<p>In this, however, the actor reference is not passed in. It is assumed to be created (by the wiring) and registered with the Location Service. Therefore, just the location is passed in and the actor reference is obtained from that:</p>
<pre class="prettyprint"><code class="language-scala">class SequenceManagerImpl(
    location: AkkaLocation
)(implicit actorSystem: ActorSystem[_]) extends SequenceManagerApi {

  private val smRef: ActorRef[SequenceManagerMsg] =
    location.uri.toActorRef.unsafeUpcast[SequenceManagerMsg]

}
</code></pre>
<p>The code for our method simply creates an Akka message the actor can handle (in this case, <strong>SequencerShutdown</strong>, which is a subtype of <strong>SequenceManagerMsg</strong>), and then performs an Akka ask by sending this message to the SM actor and transforming the reply into a Future.</p>
<pre class="prettyprint"><code class="language-scala">override def shutdownSequencer(
  subsystem: Subsystem,
  obsMode: ObsMode
): Future[ShutdownSequencersResponse] =
  (smRef ? (ShutdownSequencer(subsystem, obsMode, _)))(
    SequenceManagerTimeouts.ShutdownSequencer, actorSystem.scheduler
  )
</code></pre>
<p>For testing, instead of mocking the actor behavior directly, we use the <a href="https://github.com/tmtsoftware/esw/blob/master/esw-test-commons/src/main/scala/esw/testcommons/AskProxyTestKit.scala">AskProxyTestKit</a>. This piece of code can be used to create a custom behavior for an Akka ask with a particular message. In our case, we set up the <strong>AskProxyTestKit</strong> expect messages to be of type <strong>SequenceManagerMsg</strong> and come from a <strong>SequenceManagerImpl</strong>.</p>
<p>The test kit is set up by overriding the make method to return an instance of our Akka client to be used in the test kit features.</p>
<pre class="prettyprint"><code class="language-scala">private val askProxyTestKit =
  new AskProxyTestKit[SequenceManagerMsg, SequenceManagerImpl] {
    override def make(
      actorRef: ActorRef[SequenceManagerMsg]
    ): SequenceManagerImpl = {
      val location =
        AkkaLocation(
          AkkaConnection(
            ComponentId(Prefix(ESW, &quot;sequence_manager&quot;), Service)
          ), 
          actorRef.toURI, Metadata.empty
        )
    
      new SequenceManagerImpl(location)
    }
  }
</code></pre>
<p>The use of the test kit for our method is shown below, <strong>SequenceManagerImplTest</strong>:</p>
<pre class="prettyprint"><code class="language-scala">&quot;SequenceManagerImpl&quot; must {
  &quot;shutdownSequencer&quot; in {
    val shutdownSequencersResponse = mock[ShutdownSequencersResponse]
    withBehavior {
      case SequenceManagerMsg.ShutdownSequencer(`subsystem`, `obsMode`, replyTo) =&gt; 
        replyTo ! shutdownSequencersResponse
    } check { sm =&gt;
      sm.shutdownSequencer(subsystem, obsMode).futureValue should ===(
        shutdownSequencersResponse
      )
    }
  }
}
</code></pre>
<p>The <code>withBehavior</code> block is used to define whatever behavior is needed to handle the incoming message, which is a <strong>ShutdownSequencer</strong> message. For testing, we just want it to send a mocked response. The check block is used to execute the command we are testing. The sm object in this lambda is the <strong>SequenceManagerImpl</strong> we created when instantiating the test kit. Here, the check is making sure when we call the method on the client, our mocked response, which must come from our mocked behavior, is returned.</p>
<h3><a href="#sequencemanagerbehavior" name="sequencemanagerbehavior" class="anchor"><span class="anchor-link"></span></a>SequenceManagerBehavior</h3>
<p>Now we are down in our actor (<a href="https://github.com/tmtsoftware/esw/blob/master/esw-sm/esw-sm-impl/src/main/scala/esw/sm/impl/core/SequenceManagerBehavior.scala">SequenceManagerBehavior</a>), which uses utility classes to carry out operations. For this operation, it requires the <strong>SequencerUtil</strong> class, which is again created by the wiring and passed into the constructor of the behavior. Here is a snippet of handling our message:</p>
<pre class="prettyprint"><code class="language-scala">private def idle(self: SelfRef): SMBehavior =
  receive[SequenceManagerIdleMsg](Idle) {
    case Configure(obsMode, replyTo) =&gt; configure(obsMode, self, replyTo)
    case Provision(config, replyTo)  =&gt; provision(config, self, replyTo)

    // Shutdown sequencers
    case ShutdownSequencer(subsystem, obsMode, replyTo) =&gt;
      sequencerUtil.shutdownSequencer(
        subsystem, obsMode
      ).map(self ! ProcessingComplete(_))

      processing(self, replyTo)
  }
</code></pre>
<p>This takes the information in the message and calls the <code>shutdownSequencer</code> method in <strong>SequencerUtil</strong>, and then maps the response to be sent to itself, which now transitions to the processing state. When the actor receives the response in the processing state, it is then returned to the replyTo actor of the original message, and the SM actor returns to the idle state.</p>
<p>This means our test fixture needs to verify the following things:</p>
<p>When the actor receives the <strong>ShutdownSequencer</strong> message, it calls the <code>shutdownSequencer</code> method of sequencerUtil with the subsystem and obsMode from the message.</p>
<p>The actor then transitions to the processing state.</p>
<p>The response from our <code>sequenceUtil.shutdownSequencer</code> is returned to the replyTo actor in the <strong>ShutdownSequencer</strong> message.</p>
<p>The actor return to the idle state.</p>
<p>As seen below, this is what our test does. As we seen before the lower layer (or layers, in this case), are mocked.</p>
<pre class="prettyprint"><code class="language-scala">class SequenceManagerBehaviorTest
  extends BaseTestSuite
  with TableDrivenPropertyChecks {

  private val locationServiceUtil: LocationServiceUtil =
    mock[LocationServiceUtil]

  private val agentUtil: AgentUtil         = mock[AgentUtil]
  private val sequencerUtil: SequencerUtil = mock[SequencerUtil]

  private val sequenceComponentUtil: SequenceComponentUtil =
    mock[SequenceComponentUtil]

  private val sequenceManagerBehavior = new SequenceManagerBehavior(
    config,
    locationServiceUtil,
    agentUtil,
    sequencerUtil,
    sequenceComponentUtil
  )
  
  &quot;ShutdownSequencer&quot; must {
    val responseProbe = TestProbe[ShutdownSequencersResponse]()
    val shutdownMsg   = ShutdownSequencer(ESW, darkNight, responseProbe.ref)
    
    &quot;transition sm from Idle -&gt; Processing -&gt; Idle state and stop&quot; in {
      when(sequencerUtil.shutdownSequencer(ESW, darkNight))
        .thenReturn(future(1.seconds, ShutdownSequencersResponse.Success))

      // STATE TRANSITION: Idle -&gt; ShutdownSequencers -&gt; Processing -&gt; Idle
      assertState(Idle)
      smRef ! shutdownMsg
      assertState(Processing)
      assertState(Idle)

      responseProbe.expectMessage(ShutdownSequencersResponse.Success)
      verify(sequencerUtil).shutdownSequencer(ESW, darkNight)
    }
  }
}
</code></pre>
<h3><a href="#sequencerutil" name="sequencerutil" class="anchor"><span class="anchor-link"></span></a>SequencerUtil</h3>
<p>Now, we will move down to the next layer, <a href="https://github.com/tmtsoftware/esw/blob/master/esw-sm/esw-sm-impl/src/main/scala/esw/sm/impl/utils/SequencerUtil.scala">SequencerUtil</a>. This is where the Sequencer to shutdown is located and commanded to shutdown, which involves finding the Sequencer, getting the Sequence Component for that Sequencer, and then sending it an <code>unloadScript</code> command. This command is implemented in <strong>SequenceComponentUtil</strong>. The following shows bits of code from SequenceUtil pieced together to show the relevant logic:</p>
<pre class="prettyprint"><code class="language-scala">class SequencerUtil(
  locationServiceUtil: LocationServiceUtil,
  sequenceComponentUtil: SequenceComponentUtil
)(implicit actorSystem: ActorSystem[_]) {

  def shutdownSequencer(
    subsystem: Subsystem,
    obsMode: ObsMode
  ): Future[ShutdownSequencersResponse] =
    shutdownSequencersAndHandleErrors(getSequencer(subsystem, obsMode))

  private def getSequencer(subsystem: Subsystem, obsMode: ObsMode) =
    locationServiceUtil.findSequencer(subsystem, obsMode.name).mapRight(List(_))

  private def shutdownSequencersAndHandleErrors(
    sequencers: Future[Either[EswLocationError, List[AkkaLocation]]]
  ) =
    sequencers
    .flatMapRight(unloadScripts)
    .mapToAdt(identity, locationErrorToShutdownSequencersResponse)

  private def unloadScripts(sequencerLocations: List[AkkaLocation]) =
    Future
    .traverse(sequencerLocations)(unloadScript)
    .map(_ =&gt; ShutdownSequencersResponse.Success)

  // get sequence component from Sequencer and unload sequencer script
  private def unloadScript(sequencerLocation: AkkaLocation) =
    makeSequencerClient(sequencerLocation)
    .getSequenceComponent
    .flatMap(sequenceComponentUtil.unloadScript)
    .map(_ =&gt; ShutdownSequencersResponse.Success)

  // Created in order to mock the behavior of sequencer API availability for unit test
  private[sm] def makeSequencerClient(sequencerLocation: Location): SequencerApi =
    SequencerApiFactory.make(sequencerLocation)
}
</code></pre>
<p>Note that the Location Service is used to get a <strong>SequencerApi</strong> reference, which is used to the location of the Sequence Component. Then, <strong>SequenceComponentUtil</strong> is used to shutdown the Sequencer using the SequenceComponent location.</p>
<p>The Location Service and the SequenceComponentUtil classes are the lower layers in this class, so they are passed in, and mocked when testing. </p>
<h3><a href="#sequencecomponentutil" name="sequencecomponentutil" class="anchor"><span class="anchor-link"></span></a>SequenceComponentUtil</h3>
<p>The Location Service is a separate service, so it is tested separately. The <a href="https://github.com/tmtsoftware/esw/blob/master/esw-sm/esw-sm-impl/src/main/scala/esw/sm/impl/utils/SequenceComponentUtil.scala">SequenceComponentUtil</a> is the next layer of the Sequence Manager, and therefore requires tests. For our method, this class uses the Sequence Component location to unload the script, thus destroying the Sequencer:</p>
<pre class="prettyprint"><code class="language-scala">class SequenceComponentUtil(
  locationServiceUtil: LocationServiceUtil,
  sequenceComponentAllocator: SequenceComponentAllocator
)(implicit actorSystem: ActorSystem[_]) {

  def unloadScript(seqCompLocation: SeqCompLocation): Future[Ok.type] =
    sequenceComponentApi(seqCompLocation).unloadScript()

  private[sm] def sequenceComponentApi(
    seqCompLocation: SeqCompLocation
  ): SequenceComponentApi = new SequenceComponentImpl(seqCompLocation)
}
</code></pre>
<p>This is the bottom layer of our method. For our method here, a new Akka client to the Sequence Component is constructed from the location, and the <code>unloadScript</code> method is called on it. Thus, we have reached the bottom of our layers, and will not need to provide any test classes beyond this. The testing for this class must have tests for the methods we use, which in this case is just <code>unloadScript</code>.</p>
<pre class="prettyprint"><code class="language-scala">&quot;unloadScript&quot; must {
  val mockSeqCompApi = mock[SequenceComponentApi]

  val sequenceComponentUtil = 
    new SequenceComponentUtil(
      locationServiceUtil,
      sequenceComponentAllocator
    ) {
      override private[sm] def sequenceComponentApi(
        seqCompLocation: AkkaLocation
      ): SequenceComponentApi = mockSeqCompApi
    }

  &quot;return Ok if unload script is successful | ESW-166&quot; in {
    val seqCompLocation = sequenceComponentLocation(&quot;esw.primary&quot;)
    when(mockSeqCompApi.unloadScript()).thenReturn(Future.successful(Ok))

    sequenceComponentUtil.unloadScript(seqCompLocation).futureValue should ===(Ok)

    verify(mockSeqCompApi).unloadScript()
  }
}
</code></pre>
<p>Here, the Akka client for the Sequence Component is mocked, and it’s shown that when the <code>unloadScript</code> method in <strong>SequenceComponentUtil</strong> is called, it calls the unloadScript method in the Akka client. Note that this method always returns Ok. If it didn’t, the failure modes of this call would also need to be tested, using mocks, and it must be verified the proper error response is returned.</p>
<h3><a href="#additional-testing" name="additional-testing" class="anchor"><span class="anchor-link"></span></a>Additional Testing</h3>
<p>This leads us to discuss additional testing. It is important that all code paths are tested at at least one layer. The best place to test this is at the lowest level they occur. Let’s go back at take a look at SequenceUtil. </p>
<p>It uses the Location Service to find a reference to the Sequencer. There are two ways this operation can fail. If the Sequence is not registered, it can be assumed to not be running, and this is considered a success, since the goal of the method is to shutdown the Sequencer anyway. Another failure mode is if an error occurs when getting the location, such as the Location Service isn’t running or working properly. This would result in a <strong>RegistrationListingFailed</strong>. Since these two alternate scenarios represent cases in which the logic for the command come to an end, they are shown in the testing for this class:</p>
<pre class="prettyprint"><code class="language-scala">&quot;shutdownSequencer&quot; must {
  &quot;return Success even if sequencer is not running&quot; in {
    // mimic the exception thrown from LocationServiceUtil.findSequencer
    val findLocationFailed = futureLeft(LocationNotFound(&quot;location service error&quot;))
    
    when(locationServiceUtil.findSequencer(ESW, darkNightObsMode.name))
      .thenReturn(findLocationFailed)

    sequencerUtil.shutdownSequencer(ESW,darkNightObsMode).futureValue should ===(
      ShutdownSequencersResponse.Success
    )

    verify(locationServiceUtil).findSequencer(ESW, darkNightObsMode.name)
    verify(eswSequencerApi, never).getSequenceComponent
  }

  &quot;return Failure response when location service returns RegistrationListingFailed error&quot; in {
    when(locationServiceUtil.findSequencer(ESW, darkNightObsMode.name))
      .thenReturn(futureLeft(RegistrationListingFailed(&quot;Error&quot;)))

    sequencerUtil.shutdownSequencer(ESW, darkNightObsMode).futureValue should ===(
      LocationServiceError(&quot;Error&quot;)
    )

    verify(locationServiceUtil).findSequencer(ESW, darkNightObsMode.name)
  }
}
</code></pre>
<p>If we take another look at the <strong>SequencerUtil</strong> class, we can see that when this Location Service error occurs, it’s actually transformed to another type:</p>
<pre class="prettyprint"><code class="language-scala">private def shutdownSequencersAndHandleErrors(
  sequencers: Future[Either[EswLocationError, List[AkkaLocation]]]
) =
  sequencers.flatMapRight(unloadScripts).mapToAdt(
    identity, locationErrorToShutdownSequencersResponse
  )

private def locationErrorToShutdownSequencersResponse(err: EswLocationError) =
  err match {
    case _: EswLocationError.LocationNotFound =&gt; ShutdownSequencersResponse.Success
    case e: EswLocationError                  =&gt; LocationServiceError(e.msg)
  }
</code></pre>
<p>The <strong>LocationServiceError</strong> type is a <strong>ShutdownSequencersResponse.Failure</strong> message that can be returned to the Akka client. Therefore, this type needs to be tested in the <strong>SequenceManagerBehaviorTest</strong></p>
<pre class="prettyprint"><code class="language-scala">&quot;ShutdownSequencer&quot; must {
  val responseProbe = TestProbe[ShutdownSequencersResponse]()
  val shutdownMsg   = ShutdownSequencer(ESW, darkNight, responseProbe.ref)

  s&quot;return LocationServiceError if location service fails&quot; in {
    val err = LocationServiceError(&quot;error&quot;)
    when(sequencerUtil.shutdownSequencer(ESW, darkNight))
      .thenReturn(Future.successful(err))

    smRef ! shutdownMsg
    responseProbe.expectMessage(err)

    verify(sequencerUtil).shutdownSequencer(ESW, darkNight)
  }
}
</code></pre>
<p>The <code>sequencerUtil</code> method is mocked to return the error response, and it is verified that if the actor receives the shutdown message, this is returned to the replyTo.</p>
<h2><a href="#integration-tests" name="integration-tests" class="anchor"><span class="anchor-link"></span></a>Integration Tests</h2>
<p>For completeness, an integration test should be added. Integration tests should not use any mocks. This test should involve methods that go up and down the chain, but not all methods need to be included, nor all code paths for the methods used. That is what the units tests are for. However, for completeness, there should be an integration test for every public method in outward facing APIs showing at least one code path.</p>
<p>The integration test for the SM demonstrates performing a configure command. Sequencers are set up in real Sequence Components, and a sequence is submitted to the top-level sequencer. The test confirms the Sequence flows down the Sequencer hierarchy constructed by the command. After completion, the Sequencers are cleaned up using the <code>shutdownObsModeSequencers</code> command.</p>
</div>
<div>
<a href="https://github.com/tmtsoftware/esw/tree/master/docs/src/main/technical/testing-philosophy.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.1.0*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../technical/contracts.html" title="Service Contracts" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Service Contracts
</span>
</div>
</a>
<a href="../technical/esw-services.html" title="esw-services" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
esw-services
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
