{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"TMT Executive Software (ESW)"},{"location":"/index.html#tmt-executive-software-esw-","text":"","title":"TMT Executive Software (ESW)"},{"location":"/sequencer/state-transition.html","text":"","title":"Sequencer State Transition"},{"location":"/sequencer/state-transition.html#sequencer-state-transition","text":"Sequencer is implemented as a Finite State Machine. It has a set of states, and at any given time it could be in exactly one of those states. It supports a set of commands/messages, and on receiving those commands, it might choose to go in some other state.\nFollowing are the states supported by the Sequencer:\nIdle/Online: This is the default state of the Sequencer. A Sequencer is idle when it is up, but there’s no sequence under execution. A sequencer can come to idle state from the following situations: when the sequencer comes up for the first time when the sequencer has finished execution of a sequence when the sequencer was offline, and a goOnline command is sent Loaded: A sequencer is in loaded state when a sequence is loaded for execution, but execution of the sequence hasn’t started. A separate start command is expected to start execution of the sequence. All sequence editor actions (for e.g. add, remove, reset) are accepted in this state. From this state, the sequencer can go in InProgress state on receiving a start command, or it could go in offline state if goOffline command is sent. On receiving a reset command, which discards all the pending steps, the sequencer will go to idle state. InProgress/Running: The Sequencer is in running state, only when it is executing a sequence. All sequence editor actions (for e.g. add, remove, reset) are accepted in this state. From running state, the sequencer can go to idle state on completion of sequence, or it can be killed. In order to go offline from this state, the sequencer has to go to idle and then offline. Offline: The sequencer goes in offline state, only on receiving a goOffline command which can either come from an upstream sequencer, or from a user through the admin dashboard. In this state, only a few commands are excepted (for eg. goOnline, shutdown, status etc). Killed: This is the final state of the sequencer. The shutdown command can be sent in any state, hence a sequencer can transition to this state from any other state.","title":"Sequencer State Transition"},{"location":"/sequencer/scripts/scripts.html","text":"","title":"Sequencer Script"},{"location":"/sequencer/scripts/scripts.html#sequencer-script","text":"FSM High Level DSL","title":"Sequencer Script"},{"location":"/sequencer/scripts/fsm.html","text":"","title":"FSM"},{"location":"/sequencer/scripts/fsm.html#fsm","text":"Scripts have ability to define and run Finite State Machine(FSM). FSM can transition between defined states and can be made reactive to events and commands.","title":"FSM"},{"location":"/sequencer/scripts/fsm.html#define-fsm","text":"","title":"Define FSM"},{"location":"/sequencer/scripts/fsm.html#create-fsm","text":"To create an instance of FSM, a helper method Fsm is provided as shown in example. This method takes following parameters:\nname of FSM initial state of the FSM block having states of the FSM\nKotlin val irisFsm: Fsm = Fsm(name = \"iris-fsm\", initState = \"INIT\") {\n    // place to define all states of FSM\n}","title":"Create FSM"},{"location":"/sequencer/scripts/fsm.html#define-state","text":"As mentioned above, the third parameter of Fsm method is a block which is the place to define all the states of FSM. A method named state needs to be called with parameters name of the state and the block of actions to be performed in that state.\nNote State names are case-insensitive. In case of multiple states with same name, the last one will be considered.\nKotlin state(\"INIT\") {\n    // actions to be performed in this state\n}","title":"Define state"},{"location":"/sequencer/scripts/fsm.html#state-transition","text":"To transit between states, become method needs to be called with name of next state. This will change the state of the fsm to the given state and start executing next state. InvalidStateException will be thrown if provided state is not defined.\nKotlin become(state = \"IN-PROGRESS\")\nState transition should ideally be the last call in state or should be done with proper control flow so that become is not called multiple times.","title":"State transition"},{"location":"/sequencer/scripts/fsm.html#complete-fsm","text":"completeFsm marks the FSM complete. Calling it will immediately stop execution of the FSM and next steps will be ignored, so it should be called at the end of the state.\nKotlin completeFsm()   // will complete the Fsm\n// anything after this will not be executed","title":"Complete FSM"},{"location":"/sequencer/scripts/fsm.html#helper-constructs","text":"entry : executes the given block only when state transition happens from a different state Kotlin entry {\n    // do something\n} on : executes the given block if given condition is true Kotlin on(condition) {\n    // executes this when condition is true\n} after : executes the given block after the given duration Kotlin after(100.milliseconds) {\n    // do something\n}","title":"Helper constructs"},{"location":"/sequencer/scripts/fsm.html#start-fsm","text":"After creating instance of FSM, it needs to be explicitly started by calling start on it. This will start executing the initial state of fsm which is provided while creating instance of it.\nKotlin irisFsm.start()","title":"Start FSM"},{"location":"/sequencer/scripts/fsm.html#wait-for-completion","text":"As FSM has ability to be complete itself, await can be called to wait for its completion. Control flow will be blocked at the await statement till the FSM is marked complete.\nKotlin irisFsm.await()","title":"Wait for completion"},{"location":"/sequencer/scripts/fsm.html#reactive-fsm","text":"FSM can be made to react to changes in event and command parameters with help of Event variables and Command flags.\nbinding FSM to reactive variable is necessary to achieve the reactive behavior of FSM.","title":"Reactive FSM"},{"location":"/sequencer/scripts/fsm.html#event-variable","text":"Event variables are the way to make fsm react to events. Event variable can be tied to only one parameter key in an event. To make FSM react to event variable, we need to create a EventVariable for a specific parameter key of an event and bind the fsm to it.\nWhenever any event is published on the key of given event, all the FSMs bound to that variable will be re-evaluated. Event variables use EventService underneath, which makes it possible to share data between multiple sequencers.\nEvent variables are of 2 types:\nSystemVar - for System events ObserveVar - for Observe events\nFSM can be bind to multiple event vars and vise versa. Following examples shows how to create event variables, bind FSM to it and methods like get and set. set will publish the event with modified parameter.\nKotlin //**  System Var **//\nval tempKey: Key<Int> = intKey(\"temperature\")\nval systemVar: EventVariable<Int> = SystemVar(0, \"esw.temperature.temp\", tempKey)\n\nsystemVar.bind(irisFsm) // binds the FSM and event variable\n\n//**  Observe Var **//\nval coordKey: Key<Coord> = coordKey(\"co-ordinates\")\nval observeVar: EventVariable<Coord> = ObserveVar(JEqCoord.make(0, 0), \"iris.observe.coord\", coordKey)\nobserveVar.get() // returns the value of the parameter from the latest event\n\nobserveVar.bind(irisFsm) // binds the FSM and event variable\n\nobserveVar.set(JEqCoord.make(1, 1)) // publishes the given value on event key","title":"Event variable"},{"location":"/sequencer/scripts/fsm.html#commandflag","text":"Command flag acts as bridge which can used to pass Parameters to FSM from outside. Setting the params in command flag will re-evaluate the all the FSMs with provided params which are bound to that flag. It is possible to bind one FSM to multiple command flags and vise versa. Command flag is limited to scope of a single script. It does not have any remote impact.\nExample shows how to create CommandFlag, bind FSM to it and methods get and set which are provided to retrieve or set the value of params in command flag.\nKotlin val flag = CommandFlag()\nflag.value() // way to extract the current params value\n\nflag.bind(irisFsm) // bind the FSM and command flag\n\nflag.set(params) // refreshes the bound FSMs with the new params","title":"CommandFlag"},{"location":"/sequencer/scripts/fsm.html#example-fsm","text":"In the below example, temparatureFsm demonstrates how to define and use FSM in the scripts. The event variable is declared with event key esw.temperature.temp for param temperature and temperatureFsm is bind to it. The job of the temperatureFsm is to decide the state based on the temperature and publish it on event key esw.temperatureFsm with param key state.\nLogic of state change is:\ncondition state temp == 30 FINISH temp > 40 ERROR else OK\nKotlin val tempKey = longKey(\"temperature\")\nval stateKey = stringKey(\"state\")\n\nval tempFsmEvent = SystemEvent(\"esw.temperatureFsm\", \"state\")\nsuspend fun publishState(baseEvent: SystemEvent, state: String) = publishEvent(baseEvent.add(stateKey.set(state)))\n\n// temperature Fsm states\nval OK = \"OK\"\nval ERROR = \"ERROR\"\nval FINISHED = \"FINISHED\"\n\nval temperatureVar = SystemVar(0, \"esw.temperature.temp\", tempKey)\n\nval temperatureFsm = Fsm(\"TEMP\", OK) {\n    var fsmVariable = 10                    // [[ 1 ]]\n\n    state(OK) {\n        // [[ 2 ]]\n\n        entry {\n            publishState(tempFsmEvent, OK)\n        }\n        on(temperatureVar.get() == 30L) {\n            become(FINISHED)             // [[ 3 ]]\n        }\n        on(temperatureVar.get() > 40) {\n            become(ERROR)\n        }\n    }\n\n    state(ERROR) {\n        entry {\n            publishState(tempFsmEvent, ERROR)\n        }\n        on(temperatureVar.get() < 40) {\n            become(OK)\n        }\n    }\n\n    state(FINISHED) {\n        completeFsm()                   // [[ 4 ]]\n    }\n}\n\ntemperatureVar.bind(temperatureFsm)     // [[ 5 ]]\n\nonSetup(\"command-1\") {\n    temperatureFsm.start()              // [[ 6 ]]\n}\n\nonSetup(\"command-2\") {\n    temperatureFsm.await()              // [[ 7 ]]\n}\nKey things in above example code are :\n[[ 1 ]]: Shows top-level scope of the FSM which can used to declare variables in FSM’s scope and statements which should be executed while starting the FSM. Statements written here will be executed only once when the FSM starts. [[ 2 ]]: The scope of the state. Statements written here will be executed on every refresh of the state, which makes this a non-ideal place to declare variables. [[ 3 ]]: State transitions from OK state to ERROR. [[ 4 ]]: Marks the FSM complete. Re-evaluation or state transitions cannot happen after this is executed.\nTill point [[ 4 ]], it’s all about defining the blue-print and initialising state of FSM which includes executing statements at [[ 1 ]].\n[[ 5 ]]: Shows the binding of temperatureVar and temperatureFsm. After this point, FSM will re-evaluate whenever events are published on temperatureVar. [[ 6 ]]: Starts evaluating the initial state of the FSM. [[ 7 ]]: Waits for completion of the FSM. In example, the script execution will be blocked till line [[ 4 ]] is executed which will mark the FSM complete. The script will continue execution after FSM is marked complete.\nExample code also demos the use of the helper constructs like entry, on.","title":"Example FSM"},{"location":"/sequencer/scripts/dsl/dsl.html","text":"","title":"High Level DSL"},{"location":"/sequencer/scripts/dsl/dsl.html#high-level-dsl","text":"Command Service Config Service Event Service Logging Service Loop Misc Script Handlers Sequencer Command Service Time Service","title":"High Level DSL"},{"location":"/sequencer/scripts/dsl/services/command-service.html","text":"","title":"Command Service"},{"location":"/sequencer/scripts/dsl/services/command-service.html#command-service","text":"Command service dsl is kotlin wrapper over csw command service module provided for sending commands to assemblies or hcds via scripts. You can refer a detailed documentation of command Service provided by csw here. This dsl exposes following APIs:","title":"Command Service"},{"location":"/sequencer/scripts/dsl/services/command-service.html#assembly","text":"This dsl creates assembly instance with provided name and gives handle to command service dsl through which script can interact with assembly. For example send commands or lifecycle methods e.g. goOnline, goOffline, lock assembly etc. This api also takes default timeout which will be used in commands like submitAndWait, queryFinal etc.\nThis dsl takes following parameters: * prefix - Prefix of assembly * defaultTimeout - if dsl like submitAndWait, queryFinal etc does not explicitly provide timeout then this Default timeout is used.\nKotlin val galilAssembly = Assembly(\"tcs.galil\", defaultTimeout = 10.seconds)","title":"Assembly"},{"location":"/sequencer/scripts/dsl/services/command-service.html#hcd","text":"This dsl creates hcd instance with provided name and gives handle to command service dsl through which script can interact with hcd. For example send commands to assembly or lifecycle methods e.g. goOnline, goOffline, lock hcd etc. This api also takes default timeout which will be used in commands like submitAndWait, queryFinal etc.\nThis dsl takes following parameters: * prefix - Prefix of assembly * defaultTimeout - if dsl like submitAndWait, queryFinal etc does not explicitly provide timeout then this Default timeout is used.\nKotlin val filterWheelHcd = Hcd(\"tcs.filter.wheel.hcd\", defaultTimeout = 10.seconds)\nNote Since all the components in the TMT architecture are dynamic in nature, which implies they can be shutdown and spawned dynamically on some other location, the assembly/hdc is resolved each time on receiving a command with the provided prefix. Following dsl can be used to interact with both Assembly and HCD resolved using APIs explained above.","title":"Hcd"},{"location":"/sequencer/scripts/dsl/services/command-service.html#command-service-dsl","text":"","title":"Command Service Dsl"},{"location":"/sequencer/scripts/dsl/services/command-service.html#submit","text":"This dsl allows to submit a command to assembly/hcd and return after first phase. If it returns Started then final response can be obtained with query final api.\nKotlin val response = galilAssembly.submit(command, resumeOnError = true)\nval startedResponse = galilAssembly.submit(command)\ngalilAssembly.queryFinal(startedResponse.runId())","title":"Submit"},{"location":"/sequencer/scripts/dsl/services/command-service.html#error-handling","text":"submit always returns positive submit response. In case of negative submit response, onError handler (if written) is called and then onGlobalError handler is called. Script execution flow breaks in case of negative submit response and sequence is terminated with failure. Following example shows scenario where script execution flow breaks when submit return negative response, in this case onError handler will be executed followed by onGlobalError handler, and sequence is completed with failure.\nKotlin onSetup(\"submit-error-handling\") { command ->\n\n    /* =========== Scenario-1 (default) ============\n     * if submit returns negative response (which is considered as error by default)\n     * then current execution flow breaks and onError command handler gets invoked\n     * Hence, only Started (in case of long-running command) or Completed (in case of short running command) response is returned\n     */\n    val positiveSubmitResponse: CommandResponse.SubmitResponse = galilAssembly.submit(command)\n\n    //  First approach - using custom dsl (this is an alternative to kotlin pattern match using when)\n    positiveSubmitResponse\n            .onStarted { startedRes ->\n                val completedResponse = galilAssembly.queryFinal(startedRes.runId())\n                info(\"command completed with result: ${completedResponse.result}\")\n            }\n            .onCompleted { completed ->\n                info(\"command with ${completed.runId()} is completed with result: ${completed.result}\")\n            }\n\n    // Second approach - using kotlin pattern matching\n    when (positiveSubmitResponse) {\n        is CommandResponse.Started -> {\n            val completedResponse = galilAssembly.queryFinal(positiveSubmitResponse.runId())\n            info(\"command completed with response: $completedResponse\")\n        }\n        is CommandResponse.Completed -> info(\"command with ${positiveSubmitResponse.runId()} is completed\")\n        else -> finishWithError(\"Error starting WFS exposures: $positiveSubmitResponse\")\n    }\n\n}.onError { err ->\n    // onError is called when submit command to galil assembly fails\n    error(err.reason)\n}\nTo change this default behaviour, resumeOnError flag can be used. If this flag is set to true then script execution continues, and action is taken based on custom logic in script. Script writer can still choose to terminate sequence using failedOnTerminate utility.\nKotlin onSetup(\"submit-error-handling-resume\") { command ->\n    /* =========== Scenario-2 (resumeOnError = true) ============\n     * if submit returns negative response\n     * then current execution flow will continue because resumeOnError = true\n     * Here, all the possible SubmitResponses are expected to be returned\n     */\n    val submitResponse: CommandResponse.SubmitResponse = galilAssembly.submit(command, resumeOnError = true)\n\n    //  First approach - using custom dsl (this is an alternative to kotlin pattern match using when)\n    submitResponse\n            .onStarted { startedRes ->\n                val completedResponse = galilAssembly.queryFinal(startedRes.runId())\n                info(\"command completed with result: ${completedResponse.result}\")\n            }\n            .onCompleted { completed ->\n                info(\"command with ${completed.runId()} is completed with result: ${completed.result}\")\n            }\n            .onFailed { negativeResponse ->\n                error(\"command with ${negativeResponse.runId()} is failed with result: ${negativeResponse}\")\n\n            }\n\n    // Script writer can still choose to terminate sequence in case of negative response\n    submitResponse.onFailedTerminate()\n}","title":"Error handling"},{"location":"/sequencer/scripts/dsl/services/command-service.html#submitandwait","text":"This dsl allows submitting command to assembly/hcd to submit command to assembly/hcd and waits for positive final response. Script writer can provide a timeout for which it will wait for getting final submit response, otherwise command will timeout and script execution flow breaks and sequence is terminated with failure. If timeout is not provided explicitly, then timeout provided while creating instance of assembly/hcd is used as default timeout.\nKotlin galilAssembly.submitAndWait(command, timeout = 20.seconds)\nsubmitAndWait always return positive final response. In case of negative response it follows same error handling semantics as submit explained above.","title":"SubmitAndWait"},{"location":"/sequencer/scripts/dsl/services/command-service.html#query","text":"This dsl allows querying for response of submitted command. Started response returned by submit has runId which can be used to query for response. Query always returns positive submit response. In case of negative response it follows same error handling semantics as submit.\nKotlin val response = galilAssembly.submit(command, resumeOnError = true)\n\ngalilAssembly.query(response.runId())","title":"Query"},{"location":"/sequencer/scripts/dsl/services/command-service.html#queryfinal","text":"This dsl allows querying for final response of submitted command. Started response returned by submit has runId which can be used to query for final response. Script writer can provide a timeout for which it will wait for getting final submit response, otherwise command will timeout and script execution flow breaks and sequence is terminated with failure. If timeout is not provided explicitly, then timeout provided while creating instance of assembly/hcd is used as default timeout. QueryFinal always returns positive final response. In case of negative response it follows same error handling semantics as submit.\nKotlin val startedResponse = galilAssembly.submit(command)\ngalilAssembly.queryFinal(startedResponse.runId())\n\ngalilAssembly.query(response.runId())\nNote submit, submitAndWait, query and queryFinal always return positive response. In case of negative response (considered as error by default), script execution flow breaks, error handling mechanism kicks in and sequence is terminated with failure. resumeOnError allows to change this default behaviour and custom logic in script can decide flow. For details of error handling in script, please refer Error handling in script","title":"QueryFinal"},{"location":"/sequencer/scripts/dsl/services/command-service.html#subscribecurrentstate","text":"This dsl allows subscribing to current states of assembly/hcd. Script writer can provide state names to subscribe. If not provided all current states are subscribed. This dsl takes callback, callback provides handle to subscribed state and script writer can write logic in callback which will be executed for all subscribed states.\nKotlin galilAssembly.subscribeCurrentState(StateName(\"stateName1\")) { currentState ->\n    // do something with currentState matching provided state name\n    println(\"current state : $currentState\")\n}","title":"SubscribeCurrentState"},{"location":"/sequencer/scripts/dsl/services/command-service.html#going-online-offline-mode","text":"This is kotlin wrapper for sending assembly/hcd in online and offline mode. When assembly/hcd receives this command respective handlers are called. The detailed documentation of online/offline handlers for assembly/hcd can be found here","title":"Going online/offline mode"},{"location":"/sequencer/scripts/dsl/services/command-service.html#goonline","text":"This dsl allows sending assembly/hcd into online mode. goOnline can be called from anywhere in script. Following example shows sequencer sending goOnline command to downstream galil assembly when it receives goOnline command.\nKotlin onGoOnline {\n    // do some actions to go online\n    galilAssembly.goOnline()\n}","title":"goOnline"},{"location":"/sequencer/scripts/dsl/services/command-service.html#gooffline","text":"This dsl allows to send assembly/hcd into offline mode. goOffline can be called from anywhere in script. Following example shows sequencer sending goOffline command to downstream galil assembly when it receives goOffline command.\nKotlin onGoOffline {\n    // do some actions to go offline\n\n    galilAssembly.goOffline()\n\n}","title":"goOffline"},{"location":"/sequencer/scripts/dsl/services/command-service.html#operations-mode-and-diagnostic-mode","text":"","title":"Operations mode and Diagnostic mode"},{"location":"/sequencer/scripts/dsl/services/command-service.html#operationsmode","text":"This dsl allows to send assembly/hcd into operations mode. operationsMode can be called from anywhere in script. Following example shows sequencer sending operationsMode command to downstream galil assembly when it receives operationsMode command.\nKotlin onOperationsMode {\n    // do some actions to go to operations mode\n    galilAssembly.operationsMode()\n}","title":"operationsMode"},{"location":"/sequencer/scripts/dsl/services/command-service.html#diagnosticmode","text":"This dsl allows to send assembly/hcd into diagnostic data mode based on a hint at the specified startTime. diagnosticMode can be called from anywhere in script. Following example shows sequencer sending diagnosticMode command to downstream galil assembly when it receives diagnosticMode command.\nKotlin onDiagnosticMode { startTime, hint ->\n    // do some actions to go to diagnostic mode based on hint\n    galilAssembly.diagnosticMode(startTime, hint)\n}","title":"diagnosticMode"},{"location":"/sequencer/scripts/dsl/services/command-service.html#locking-and-unlocking","text":"","title":"Locking and unlocking"},{"location":"/sequencer/scripts/dsl/services/command-service.html#lock","text":"This dsl allows locking assembly/hcd from sequencer script for specified duration. When you lock assembly/hcd, sequencer sending lock command is treated as source. This dsl returns LockingResponse which can be LockAcquired in the successful scenario or AcquiringLockFailed in case of failure. This dsl also provides callbacks for onLockAboutToExpire and, onLockExpired where script writer can write custom logic. These callbacks are thread safe.\nKotlin galilAssembly.lock(\n        leaseDuration = 20.seconds,\n        onLockAboutToExpire = {\n            // do something when lock is about to expire\n            publishEvent(SystemEvent(\"esw.test\", \"tcs.lock.about.to.expire\"))\n        },\n        onLockExpired = {\n            // do something when lock expired\n            publishEvent(SystemEvent(\"esw.test\", \"tcs.lock.expired\"))\n        }\n)","title":"lock"},{"location":"/sequencer/scripts/dsl/services/command-service.html#unlock","text":"This dsl allows unlocking assembly/hcd from sequencer script for specified duration. When you unlock assembly/hcd, sequencer sending lock command is treated as source. This dsl returns LockingResponse which can be LockReleased or LockAlreadyReleased in the successful scenario or ReleasingLockFailed in case of failure.\nKotlin galilAssembly.unlock()","title":"unlock"},{"location":"/sequencer/scripts/dsl/services/command-service.html#source-code-for-examples","text":"Command Service Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/services/config-service.html","text":"","title":"Config Service"},{"location":"/sequencer/scripts/dsl/services/config-service.html#config-service","text":"Config Service Dsl is a wrapper over config service module provided by csw. You can refer a detailed documentation of Config Service provided by csw here.\nThis dsl provides APIs to check if file exists in configuration service and retrieve its contents.","title":"Config Service"},{"location":"/sequencer/scripts/dsl/services/config-service.html#existsconfig","text":"This DSL checks if provided file exists in configuration service with given revision id (if provided) and returns true or false based on that.\nKotlin val bootConfExist: Boolean = existsConfig(\"/wfos/boot.conf\")","title":"existsConfig"},{"location":"/sequencer/scripts/dsl/services/config-service.html#getconfig","text":"This DSL retrieves the content of the file present at the provided path in configuration service. It returns null if file is not available in configuration service.\nKotlin val bootConf: Config? = getConfig(\"/wfos/boot.conf\")","title":"getConfig"},{"location":"/sequencer/scripts/dsl/services/config-service.html#source-code-for-examples","text":"Config Service Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/services/event-service.html","text":"","title":"Event Service"},{"location":"/sequencer/scripts/dsl/services/event-service.html#event-service","text":"Event service dsl is kotlin wrapper over csw event service. This DSL have the ability of publishing, subscribing to events and holds some helper methods. You can refer a detailed documentation of Event Service provided by csw here.\nThis DSL exposes following APIs:","title":"Event Service"},{"location":"/sequencer/scripts/dsl/services/event-service.html#publishevent","text":"DSL to publish the given event.\nKotlin publishEvent(temperatureEvent)\nThis DSL can also publish events periodically when provided with duration and event generator function.\nKotlin publishEvent(10.seconds) {\n    // event generator which returns event to publish after the given interval\n    temperatureEvent\n}","title":"publishEvent"},{"location":"/sequencer/scripts/dsl/services/event-service.html#onevent","text":"DSL to subscribe to events getting published on the given event keys. Executes the given callback whenever any event is published on any of the provided keys.\nKotlin val tempEventKey = \"esw.temperature.temp\"\nval stateEventKey = \"esw.temperature.state\"\nonEvent(tempEventKey, stateEventKey) { event ->\n    // logic to execute on every event\n    println(event.eventKey())\n}\nThis DSL have the ability to limit the number of events by providing the duration (after which the latest event will be given).\nKotlin onEvent(tempEventKey, stateEventKey, duration = 2.seconds) { event ->\n    // logic to execute on every event\n    println(event.eventKey())\n}","title":"onEvent"},{"location":"/sequencer/scripts/dsl/services/event-service.html#getevent","text":"DSL to get the latest event published on each of the given event keys\nKotlin val tempEventKey = \"esw.temperature.temp\"\nval stateEventKey = \"esw.temperature.state\"\nval events: Set<Event> = getEvent(tempEventKey, stateEventKey)","title":"getEvent"},{"location":"/sequencer/scripts/dsl/services/event-service.html#helpermethods","text":"","title":"HelperMethods"},{"location":"/sequencer/scripts/dsl/services/event-service.html#eventkey","text":"Helper DSL to create EventKey model from a full event key string or using prefix and event name strings. Example demos both methods to create EventKey.\nKotlin // full event key string\nval tempKey: EventKey = EventKey(\"esw.temperature.temp\")\n\n// prefix and event name strings\nval tempKey1: EventKey = EventKey(\"esw.temperature\", \"temp\")","title":"EventKey"},{"location":"/sequencer/scripts/dsl/services/event-service.html#systemevent","text":"Helper DSL to create SystemEvent from the provided prefix, event name and parameters (optional).\nKotlin val temperatureEvent: SystemEvent = SystemEvent(\"esw.temperature\", \"temp\", parameters)","title":"SystemEvent"},{"location":"/sequencer/scripts/dsl/services/event-service.html#observeevent","text":"Helper DSL to create ObserveEvent from the provided prefix, event name and parameters (optional).\nKotlin val completionEvent: ObserveEvent = ObserveEvent(\"ocs.motor\", \"position\", parameters)","title":"ObserveEvent"},{"location":"/sequencer/scripts/dsl/services/event-service.html#systemvar","text":"Helper DSL to create EventVariable corresponding to SystemEvent. This DSL needs the initial value of the parameter, event key and parameter key. More details about SystemVar are provided in FSM documentation\nKotlin val locKey = intKey(\"current-location\")\nval systemVar: EventVariable<Int> = SystemVar(0, \"ocs.motor.position\", locKey)","title":"SystemVar"},{"location":"/sequencer/scripts/dsl/services/event-service.html#observevar","text":"Helper DSL to create EventVariable corresponding to ObserveEvent. This DSL needs the initial value of the parameter, event key and parameter key. More details about ObserveVar are provided in FSM documentation\nKotlin val angleKey = intKey(\"current-angle\")\nval observeVar: EventVariable<Int> = ObserveVar(0, \"tcs.filter.wheel\", angleKey)","title":"ObserveVar"},{"location":"/sequencer/scripts/dsl/services/event-service.html#source-code-for-examples","text":"Event Service Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/services/logging-service.html","text":"","title":"Logging Service"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#logging-service","text":"Logging Service DSL is a wrapper over logging service module provided by csw. You can refer a detailed documentation of Logging Service provided by csw here.\nThis dsl exposes following APIs to script writers for logging at different levels:","title":"Logging Service"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#trace","text":"Kotlin trace(message = \"logging at trace level\")\n\ntrace(message = \"logging at trace level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"trace"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#debug","text":"Kotlin debug(message = \"logging at debug level\")\n\ndebug(message = \"logging at debug level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"debug"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#info","text":"Kotlin info(message = \"logging at info level\")\n\ninfo(message = \"logging at info level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"info"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#warn","text":"Kotlin warn(message = \"logging at warn level\")\n\nwarn(message = \"logging at warn level\", cause = highTempRaisedEx)\n\nwarn(message = \"logging at warn level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))\n\nwarn(message = \"logging at warn level\", cause = highTempRaisedEx,\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"warn"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#error","text":"Kotlin error(message = \"logging at error level\")\n\nerror(message = \"logging at error level\", cause = highTempRaisedEx)\n\nerror(message = \"logging at error level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))\n\nerror(message = \"logging at error level\", cause = highTempRaisedEx,\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"error"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#fatal","text":"Kotlin fatal(message = \"logging at fatal level\")\n\nfatal(message = \"logging at fatal level\", cause = highTempRaisedEx)\n\nfatal(message = \"logging at fatal level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))\n\nfatal(message = \"logging at fatal level\", cause = highTempRaisedEx,\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"fatal"},{"location":"/sequencer/scripts/dsl/loop.html","text":"","title":"Loop"},{"location":"/sequencer/scripts/dsl/loop.html#loop","text":"Script supports following multiple variations of loop Dsl to satisfy different use cases:\nloop waitFor loopAsync","title":"Loop"},{"location":"/sequencer/scripts/dsl/loop.html#loop","text":"With default loop interval\nloop DSL allows you to start loop synchronously which means rest of the code written after loop will not be executed until stopWhen condition written inside loop becomes true. You can use this DSL when you want to iteratively perform some actions until certain condition becomes true. loop without providing any minimum interval uses default interval of 50 milliseconds. Default loopIntervalis used to reduce cpu contention.\nFollowing example demonstrate the usage of loop dsl without providing custom loop interval. In the loop body, motor is being moved by 10 degrees in every iteration of the loop. Loop will be terminated when motor’s current position reaches to expected position which is 100 degrees in this case.\nKotlin val expectedMotorPosition = 100\n\n// move motor by 10 degrees in each iteration, default loop interval is 50 millis\n// stop loop when current motor position matches expected motor position and continue with the execution of rest of the handler\nloop {\n    moveMotor(10)\n    stopWhen(motorPosition == expectedMotorPosition)\n}\nWith custom minimum loop interval\nloop DSL allows you to provide minimum loop interval and starts loop synchronously. Every iteration of loop will at least wait for minimum provided interval before executing next iteration.\nFollowing example demonstrate the usage of loop dsl by providing custom loop interval.\nKotlin // move motor by 20 degrees in every iteration after a loop interval of 100 millis (custom loop interval used here)\n// stop loop when current motor position matches expected motor position and continue with the execution of rest of the handler\nloop(minInterval = 100.milliseconds) {\n    moveMotor(20)\n    stopWhen(motorPosition == expectedMotorPosition)\n}\nNote minInterval needs to be greater than default interval of 50 milliseconds otherwise it will be ignored and default loop interval will be used.","title":"loop"},{"location":"/sequencer/scripts/dsl/loop.html#waitfor","text":"This is a specialized version of loop and satisfies simple use cases where you want to semantically block the execution until certain condition becomes true.\nIn the following example, initializeMotor method will start the initialization and eventually set motorUp flag to true indicating motor is successfully initialized. waitFor { motorUp } will check the value of motorUp flag every 50 milliseconds and if it is true then rest of the code execution will continue.\nKotlin // start initializing motor and this method will set motorUp flag to true once initialization is successful\ninitializeMotor()\n// pauses the init-motor command handlers execution until motor becomes up\nwaitFor { motorUp }","title":"waitFor"},{"location":"/sequencer/scripts/dsl/loop.html#loopasync","text":"With default loop interval\nloopAsync DSL allows you to start loop asynchronously in the background which means rest of the code written after loopAsync will be executed concurrently. loopAsync will be terminated when stopWhen condition written inside loop becomes true.\nYou can use this DSL when you want to iteratively perform some actions in the background. loopAsync without providing any minimum interval uses default interval of 50 milliseconds.\nFollowing example demonstrate the usage of loopAsync dsl without providing custom loop interval. In the loop body, current temperature is published every 50 milliseconds. LoopAsync will be terminated when stopPublishingTemperature flag becomes true and this is set to true in onStop handler.\nKotlin // start background loop which publishes current temperature of motor every 50 milliseconds (default loop interval)\nloopAsync {\n    val currentTemp = getCurrentTemp()\n    publishEvent(temperatureEvent.add(temperatureKey.set(currentTemp)))\n    stopWhen(stopPublishingTemperature)\n}\nWith custom loop interval\nloopAsync DSL allows you to provide minimum loop interval and start loop asynchronously. Every iteration of loopAsync will at least wait for minimum provided interval before executing next iteration.\nFollowing example demonstrate the usage of loopAsync dsl by providing custom loop interval.\nKotlin // start background loop which publishes current temperature of motor every 100 milliseconds\nloopAsync(minInterval = 100.milliseconds) {\n    val currentTemp = getCurrentTemp()\n    publishEvent(temperatureEvent.add(temperatureKey.set(currentTemp)))\n    stopWhen(stopPublishingTemperature)\n}","title":"loopAsync"},{"location":"/sequencer/scripts/dsl/loop.html#source-code-for-examples","text":"Loop Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/misc.html","text":"","title":"Misc"},{"location":"/sequencer/scripts/dsl/misc.html#misc","text":"","title":"Misc"},{"location":"/sequencer/scripts/dsl/misc.html#par","text":"This utility is provided to support running multiple tasks in parallel. Call to par returns when all the submitted task completes.\nFollowing example demonstrate a use case of sending commands in parallel to multiple HCD’s.\nKotlin val prefix = \"ocs.primary\"\nval hcd1 = Hcd(\"iris.filter.wheel1\", 10.minutes)\nval hcd2 = Hcd(\"iris.filter.wheel2\", 10.minutes)\nval hcd3 = Hcd(\"iris.filter.wheel3\", 10.minutes)\n\nonSetup(\"setup-iris-hcds\") {\n    // send 3 setup commands to 3 HCD's in parallel\n    val responses: List<SubmitResponse> =\n            par(\n                    { hcd1.submit(Setup(prefix, \"move-10\")) },\n                    { hcd2.submit(Setup(prefix, \"move-10\")) },\n                    { hcd3.submit(Setup(prefix, \"move-10\")) }\n            )\n}","title":"par"},{"location":"/sequencer/scripts/dsl/misc.html#source-code-for-examples","text":"Misc Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/handlers.html","text":"","title":"Script Handlers"},{"location":"/sequencer/scripts/dsl/handlers.html#script-handlers","text":"","title":"Script Handlers"},{"location":"/sequencer/scripts/dsl/handlers.html#command-handlers","text":"","title":"Command Handlers"},{"location":"/sequencer/scripts/dsl/handlers.html#onsetup","text":"This handler is used to handle a Setup command sent to this sequencer. The handler takes two parameters:\ncommand name which is matched against the sequence command sent, if the command name matches, corresponding block provided is executed block of code which contains logic to act on the sequence command.\nKotlin onSetup(\"command1\") {\n    // split command and send to downstream\n    val assembly1 = Assembly(\"filter.wheel\", 5.seconds)\n    val assembly2 = Assembly(\"wfos.red.detector\", 5.seconds)\n    par(\n            { assembly1.submit(Setup(\"tcs.darknight\", \"command-1\")) },\n            { assembly2.submit(Setup(\"tcs.darknight\", \"command-1\")) }\n    )\n}\nIn the block provided to this handler, all the csw services (event, alarm, time service, etc) and control dsl (loop, par etc) are accessible.","title":"onSetup"},{"location":"/sequencer/scripts/dsl/handlers.html#onobserve","text":"This handler is used to handle an Observe command sent to this sequencer. The handler takes two parameters:\ncommand name which is matched against the sequence command sent, if the command name matches, corresponding block provided is executed block of code which contains logic to act on the sequence command.\nKotlin onObserve(\"command2\") {\n    // do something\n}","title":"onObserve"},{"location":"/sequencer/scripts/dsl/handlers.html#online-and-offline-handlers","text":"","title":"Online and Offline Handlers"},{"location":"/sequencer/scripts/dsl/handlers.html#ongoonline","text":"On receiving the goOnline command, the onGoOnline handlers, if defined, will be called. Only if the handlers execute successfully, will the sequencer become online. Hence, error handling for the block passed to onGoOnline needs to be taken care of by the script writer.\nKotlin onGoOnline {\n    // send command to downstream components\n    val assembly = Assembly(\"filter.wheel\", 5.seconds)\n    assembly.goOnline()\n}","title":"onGoOnline"},{"location":"/sequencer/scripts/dsl/handlers.html#ongooffline","text":"On receiving the goOffline command, the onGoOffline handlers, if defined, will be called. Only if the handlers execute successfully, will the sequencer become offline. Hence, error handling for the block passed to onGoOffline needs to be taken care of by the script writer. Offline handlers could be written to clear the sequencer state before going offline.\nKotlin onGoOffline {\n    // send command to downstream components\n    val assembly = Assembly(\"filter.wheel\", 5.seconds)\n    assembly.goOffline()\n}","title":"onGoOffline"},{"location":"/sequencer/scripts/dsl/handlers.html#abort-sequence-handler","text":"","title":"Abort Sequence Handler"},{"location":"/sequencer/scripts/dsl/handlers.html#stop-handler","text":"","title":"Stop Handler"},{"location":"/sequencer/scripts/dsl/handlers.html#shutdown-handler","text":"","title":"Shutdown Handler"},{"location":"/sequencer/scripts/dsl/handlers.html#diagnostic-mode-handler","text":"","title":"Diagnostic Mode Handler"},{"location":"/sequencer/scripts/dsl/handlers.html#operations-mode-handler","text":"","title":"Operations Mode Handler"},{"location":"/sequencer/scripts/dsl/handlers.html#exceptionhandlers","text":"","title":"exceptionHandlers"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html","text":"","title":"Sequencer Command Service"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#sequencer-command-service","text":"In order to interact or send commands from one sequencer to the other, one needs to create a Sequencer instance first and then send commands to it.\nTo create a Sequencer instance, following parameters need to be passed:\nsubsystem: Subsystem of the Sequencer to be resolved and send commands to (for eg. TCS, IRIS) observingMode: observing mode of the Sequencer to be resolved and send commands to (for eg. darknight, clearsky) defaultTimeout: max timeout to wait for responses of commands like sumbitAndWait or queryFinal\nKotlin // create and resolve sequencer\nval tcsSequencer = Sequencer(\"TCS\", \"darknight\", 5.seconds)\nSince all the components in the TMT architecture are dynamic in nature, which implies they can be shutdown and spawned dynamically on some other location, the sequencer is resolved each time on receiving a command with the provided subsystem and observingMode.","title":"Sequencer Command Service"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#submitting-sequences-to-sequencer-querying-response","text":"","title":"Submitting Sequences to Sequencer & Querying response"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#creating-sequence","text":"A Sequence is a list of SequenceCommand which could be one of Setup, Observe or Wait. To create a Sequence, sequenceOf dsl could be used as shown below.\nKotlin val hcdCommand: SequenceCommand = Setup(\"tcs\", \"setup-tcs-hcd\")\nval assemblyCommand: SequenceCommand = Setup(\"tcs\", \"setup-tcs-assembly\")\nval sequence: Sequence = sequenceOf(hcdCommand, assemblyCommand)","title":"Creating Sequence"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#submitting-sequence-and-querying-response","text":"","title":"Submitting sequence and Querying response"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#submit-and-query","text":"In order to send Sequences to other Sequencers, you can use submit or submitAndWait dsl as shown in examples below. query and queryFinal dsl is provided to query response of the submitted sequence.\nKotlin val submitResponse: SubmitResponse = tcsSequencer.submit(sequence)\nval queryResponse: SubmitResponse = tcsSequencer.query(submitResponse.runId())\nquery returns the current response which could be either final response (eg. Completed) or intermediate response (eg. Started).","title":"Submit and Query"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#queryfinal","text":"Whereas queryFinal will wait for the final response of the sequence for the defaultTimeout specified at the time of creation of the Sequencer instance. This dsl will never return an intermediate response.\nKotlin val finalResponse: SubmitResponse = tcsSequencer.queryFinal(submitResponse.runId())\nIf you want to increase/decrease the defaultTimeout, you can use the other variation of the same dsl which takes a timeout.\nKotlin val finalRes: SubmitResponse = tcsSequencer.queryFinal(submitResponse.runId(), 5.seconds)","title":"QueryFinal"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#submit-and-wait","text":"The submitAndWait dsl is a combination of submit and queryFinal. If you are not interested in initial/intermediate response but only in final response of the Sequence, you can use this dsl. It submits the sequence and waits for the final response if the sequence was successfully Started. It will wait till the defaultTimeout specified at the time of creation of the Sequencer instance.\nKotlin val sequenceResponse: SubmitResponse = tcsSequencer.submitAndWait(sequence)\nIf you want to increase/decrease the default timeout, you can use the other variation of the same dsl which takes a timeout.\nKotlin val sequenceRes: SubmitResponse = tcsSequencer.submitAndWait(sequence, 5.seconds)","title":"Submit and Wait"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#going-online-offline","text":"","title":"Going online/offline"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#go-online","text":"This dsl is used to send online/offline commands to other sequencers. The Sequencer can go online only if it is currently in offline state. If this command is received in any other state apart from offline, an Unhandled response will be sent.\nIf the Sequencer is in Offline state, and it receives the goOnline command, the goOnline handlers of the receiving sequencer will be called. In case the handlers fail, a GoOnlineHookFailed response would be sent, resulting the sequencer remains in the previous state. Else an Ok message is sent, and the sequencer goes in online(idle) state.\nKotlin val response: GoOnlineResponse = tcsSequencer.goOnline()","title":"Go online"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#go-offline","text":"Go offline command is received in 2 states only.\nIf the sequencer is Idle, which means it is not processing any sequence currently If the sequencer is Loaded with a sequence\nIf this command is sent in any other state apart from these, an Unhandled response will be sent. If the Sequencer is in idle/loaded state, and it receives the goOffline command, the goOffline handlers of the receiving sequencer will be called. In case the handlers fail, a GoOfflineHookFailed response would be sent, resulting the sequencer remains in the previous state. Else an Ok message is sent, and the sequencer goes to offline state.\nKotlin val offlineResponse: GoOfflineResponse = tcsSequencer.goOffline()","title":"Go offline"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#diagnostic-and-operations-mode","text":"","title":"Diagnostic and operations mode"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#diagnostic-mode","text":"The diagnostic data mode command is accepted by Sequencers in all states and DiagnosticModeResponse is sent. If the sequencer has defined its diagnostic mode handlers, they will be called. If the handlers execute successfully, an Ok response is sent else DiagnosticHookFailed response is sent.\nKotlin val diagnosticModeResponse: DiagnosticModeResponse = tcsSequencer.diagnosticMode(utcTimeNow(), \"engineering\")","title":"Diagnostic mode"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#operations-mode","text":"Operations mode is accepted by Sequencers in all states and OperationsModeResponse is sent. If the sequencer has defined its operations mode handlers, they will be called. If the handlers execute successfully, an Ok response is sent else OperationsHookFailed response is sent.\nKotlin val operationsModeResponse: OperationsModeResponse = tcsSequencer.operationsMode()","title":"Operations mode"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#aborting-and-stopping-sequence","text":"","title":"Aborting and Stopping Sequence"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#aborting","text":"This command is accepted only if the Sequencer is in InProgress state, which means it is executing a sequence currently. If this command is sent in any other state, an Unhandled response is returned. In all other cases, an Ok response is sent.\nOn receiving this command in InProgress state, the Sequencer will execute the abort sequence handlers and on completion of execution of handlers (whether successful or failed), the Sequencer will discard all the pending steps and return an Ok response.\nNote that, abort sequence does not abruptly terminate the in-flight step(s) which are already under execution. It will discard only the pending steps, and the sequence is finished gracefully after the inflight step(s) are finished.\nKotlin val abortResponse: OkOrUnhandledResponse = tcsSequencer.abortSequence()","title":"Aborting"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#stopping","text":"Stopping sequence is very similar to aborting, only difference is that instead of abort handlers, the stop handlers are called. Script writers are expected to save state of sequencer-script in the Stop handlers.\nKotlin val stopResponse: OkOrUnhandledResponse = tcsSequencer.stop()","title":"Stopping"},{"location":"/sequencer/scripts/dsl/services/time-service.html","text":"","title":"Time Service"},{"location":"/sequencer/scripts/dsl/services/time-service.html#time-service","text":"Time Service Dsl is dsl wrapper over time service module provided by csw. This dsl exposes following APIs to script writers to schedule tasks at given time. It also exposes utility methods for getting specified utc time or tai time and calculate offset.","title":"Time Service"},{"location":"/sequencer/scripts/dsl/services/time-service.html#utctimenow","text":"This utility provides current utc time.\nKotlin val currentUtcTime = utcTimeNow()","title":"utcTimeNow"},{"location":"/sequencer/scripts/dsl/services/time-service.html#taitimenow","text":"This utility provides current utc time.\nKotlin val currentTaiTime = taiTimeNow()","title":"taiTimeNow"},{"location":"/sequencer/scripts/dsl/services/time-service.html#utctimeafter","text":"This utility provides utc time after provided duration. Following example shows how to get utc time after 1 hour\nKotlin val utcTime = utcTimeAfter(1.hours)","title":"utcTimeAfter"},{"location":"/sequencer/scripts/dsl/services/time-service.html#taitimeafter","text":"This utility provides tai time after provided duration. Following example shows how to get tai time after 1 hour\nKotlin val taiTime = taiTimeAfter(1.hours)","title":"taiTimeAfter"},{"location":"/sequencer/scripts/dsl/services/time-service.html#scheduleonce","text":"This API allows to schedule non periodic task in script at specified utc time or tai time. This a handle to cancel the execution of the task if it hasn’t been executed already\nKotlin scheduleOnce(taiTimeNow()) {\n    publishEvent(SystemEvent(\"lgsf\", \"publish.success\"))\n}","title":"scheduleOnce"},{"location":"/sequencer/scripts/dsl/services/time-service.html#scheduleoncefromnow","text":"This API allows to schedule non periodic task in script after specified duration. This API takes time duration after which task will be scheduled. scheduleOnceFromNow internally creates instance of utc time considering specified in duration. Following example shows scheduling task after 1 hour from current utc time. This a handle to cancel the execution of the task if it hasn’t been executed already.\nKotlin scheduleOnceFromNow(1.hours) {\n    publishEvent(SystemEvent(\"lgsf\", \"publish.success\"))\n}","title":"scheduleOnceFromNow"},{"location":"/sequencer/scripts/dsl/services/time-service.html#scheduleperiodically","text":"This API allows to schedules a task to execute periodically at the given interval. The task is executed once at the given start time followed by execution of task at each interval. This returns a handle to cancel the execution of further tasks.\nKotlin schedulePeriodically(utcTimeNow(), 5.seconds) {\n    publishEvent(SystemEvent(\"lgsf\", \"publish.success\"))\n}","title":"schedulePeriodically"},{"location":"/sequencer/scripts/dsl/services/time-service.html#scheduleperiodicallyfromnow","text":"This API allows to schedule a task to execute periodically at the given interval. This API takes time duration after which task will be scheduled once followed by execution of task at each interval. Following example shows scheduling task after 1 hour from current utc time and then executing it periodically at 10 seconds interval. This returns a handle to cancel the execution of further tasks.\nKotlin schedulePeriodicallyFromNow(1.hours, 10.seconds) {\n    publishEvent(SystemEvent(\"lgsf\", \"publish.success\"))\n}","title":"schedulePeriodicallyFromNow"},{"location":"/sequencer/scripts/dsl/services/time-service.html#source-code-for-above-examples","text":"Time Service Example Script","title":"Source code for above examples"},{"location":"/sequencer/scripts/dsl/error-handling.html","text":"","title":"Error handling in script"},{"location":"/sequencer/scripts/dsl/error-handling.html#error-handling-in-script","text":"","title":"Error handling in script"}]}