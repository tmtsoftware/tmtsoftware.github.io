{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"TMT Executive Software (ESW)"},{"location":"/index.html#tmt-executive-software-esw-","text":"Three main components are delivered as part of ESW Phase 1:\nSequencer: This allows users to create a Sequencer component. Both top-level Sequencer (OCS) and subsystem Sequencers can be created. Allows domain experts to write custom scripts for each sequencer in a Kotlin based domain specific language. All sequencer scripts will be written in the Sequencer Scripts Repo. Sequence Component: The Sequence Component is used to spawn and shutdown sequencers dynamically. ESW Gateway: This is provided to give access to all CSW and ESW services and components from the browser.\nNote Executive Software (ESW) is a reimplementation/refactoring of the prototype ESW code here developed during the ESW design phase with changes to make the code and public APIs more robust and resilient and to improve its usability and performance for use at the TMT Observatory.","title":"TMT Executive Software (ESW)"},{"location":"/sequencer/scripts/scripts.html","text":"","title":"Sequencer Scripts"},{"location":"/sequencer/scripts/scripts.html#sequencer-scripts","text":"All logic in Sequencer is implemented in Sequencer scripts. Scripts are written in in Kotlin using a TMT developed Domain Specific Language (DSL) to facilitate development. This section describes the DSL in detail.\nAs an alternate to procedural style scripting, some framework DSL has been provided to allow scripting using a Finite State Machine (FSM) (still in development).\nScript DSL Constructs Defining Script Script Handlers Looping Finite State Machines Other CSW Services DSL Location Service Config Service Assembly/HCD Command Service Sequencer Command Service Working with Params Submit Response Extensions Event Service Logging Service Alarm Service Time Service Database Service\nNote All the examples shown in each individual section assume that you have following import in place in script // import all the models, helpers, extensions\nimport esw.ocs.dsl.highlevel.models.*","title":"Sequencer Scripts"},{"location":"/sequencer/scripts/dsl/script-constructs.html","text":"","title":"Script DSL Constructs"},{"location":"/sequencer/scripts/dsl/script-constructs.html#script-dsl-constructs","text":"Defining Script Script Handlers Including Looping in Scripts Finite State Machines Other DSL","title":"Script DSL Constructs"},{"location":"/sequencer/scripts/dsl/constructs/define-script.html","text":"","title":"Defining Script"},{"location":"/sequencer/scripts/dsl/constructs/define-script.html#defining-script","text":"There are 3 variations of Sequencer Scripts. These variations are based the way the Script gets executed. The variations are:\nRegular Script Finite State Machine Script (FSM Script) Reusable Script","title":"Defining Script"},{"location":"/sequencer/scripts/dsl/constructs/define-script.html#regular-script","text":"Regular script is like a collection of script handlers which executes the handlers of requested action or command. To define a regular script, a function named script needs to be invoked with a block which contains the logic of the script. The below example shows way to declare the script.\nKotlin import esw.ocs.dsl.core.script\n\nscript {\n    // place to add Sequencer Script logic\n}\nThe logic can be divided into 2 parts:\nTop-level statements (initialisation logic) : Executed while loading (initialising) the script. Script Handlers: Executed when a command to execute a particular handler is received.\nScript handlers are defined to process Sequence of Commands or to perform actions like Going online or offline, starting Diagnostic mode etc. Documentation of handlers can be found here. Handlers will be executed whenever there is need to execute Sequence or to perform any action on Sequencer.\nEverything except Script Handlers are considered as Top-level statements and will be executed while loading the script. This is the place to declare the Script specific variables and tasks to be executed at initialisation of the Script.\nKotlin script {\n    info(\"Loading DarkNight script\")\n\n    val tromboneTemperatureAlarm =\n            Key.AlarmKey(Prefix(NFIRAOS, \"trombone\"), \"tromboneMotorTemperatureAlarm\")\n\n    loopAsync(1.seconds) {\n        setSeverity(tromboneTemperatureAlarm, getSeverity())\n    }\n\n    onSetup(\"basic-setup\") { command ->\n\n        val intKey = intKey(\"angle\")\n        val angle = command.parameter(intKey).head()!!\n\n        info(\"moving motor by : $angle\")\n        moveMotor(angle)\n        info(\"motor moved to required position\")\n    }\n\n    onObserve(\"start-observation\") {\n        info(\"opening the primary shutter to start observation\")\n\n        val openingStatusKey = stringKey(\"status\").set(\"open\")\n        publishEvent(ObserveEvent(\"IRIS.primary_shutter\", \"current-status\", openingStatusKey))\n\n        openPrimaryShutter()\n    }\n\n}\nThe example mainly demos:\nTop-level statements like declaring Script specific variable ( tromboneTemperatureAlarm ) , use of Script Constructs ( loopAsync ) and use of Csw Services ( info - Logging Service, setSeverity - Alarm Service) Defining Script Handlers like onSetup , onObserve using Csw Services.","title":"Regular Script"},{"location":"/sequencer/scripts/dsl/constructs/define-script.html#finite-state-machine-script-fsm-script-","text":"FSM script is a way of writing Sequencer Script as Finite State Machines (FSM), where execution of Script Handler is dependent on the Current State of the Sequencer Script.\nTo define FSM Script a function FSMScript needs to be called with the initial state to start script with, and the block containing Script logic. The block contains initialisation logic and different states.\nIn FSM Script, Script handlers can be defined in two scopes :\nDefault scope - top-level scope of the Script State scope - scope of a specific state.\nThe below code shows how to declare FSM Script and States. It also shows the scopes where handlers can be added.\nKotlin import esw.ocs.dsl.core.FsmScript\n\nFsmScript(\"INIT\") {\n\n    // Default scope\n    // place for Script variable declarations and initialisation statements\n\n    state(\"INIT\") { params ->\n        // Scope of INIT state\n        // handlers of INTI state\n    }\n\n    state(\"IN-PROGRESS\") {\n        // Scope of IN-PROGRESS state\n        // handlers of IN-PROGRESS state\n    }\n\n}\nInitialisation of the Script takes place by executing the top-level statements, and then executing the initial state. The top-level scope is the place to declare variables which can be used in Script.\nWhile defining handlers there is restriction about Command handlers that they can only be tied to State scope. Other Script handlers except the Command handlers can be tied both scopes of FSM script.\nTo execute any action, corresponding handlers in current State scope will be executed first and then handlers in Default scope will be executed. In case of a Command Sequence, if the current state does not handle Command which is being executed, the Sequence will be completed with Error with reason UnhandledCommandException.\nFor state transition, become needs to called from the current state with next state. It will start evaluating the next state, and will execute further actions on the next state. If the next state is not defined in Script, then an exception will be thrown saying No state declaration found for state.\nIt is also possible to pass Params from current state to the next state by passing them as last argument to the become function. The passed Params will be available as a function parameter while defining any State.\nIn below example, [[ 1 ]] shows use of become to change state. where [[ 2 ]] shows how to pass Params while changing state. The ON state shows how to consumes the Params.\nKotlin state(\"ON\") { params ->\n\n    onSetup(\"turn-off\") {\n        turnOffLight()\n        become(\"OFF\")                           // [[ 1 ]]\n    }\n}\n\nstate(\"OFF\") {\n\n    onSetup(\"turn-on\") { command ->\n        turnOnLight()\n        become(\"ON\", command.params)           // [[ 2 ]]\n    }\n}\nThe State scope can have top-level statements and Script handlers. The State’s top-level statements will be executed when state transition happens. So invoking become will initialise the next state which includes calling the top-level statements. The State top-level can be used to declare variables limited to State scope which will last till state transition. After that, state will be cleared and next time it will be initialised again to default values.\nKotlin state(\"SETTING-UP\") { params ->\n\n    val initialPos = params[intKey(\"current-position\")].get().head()\n    var moved = false\n\n    onSetup(\"move\") { command ->\n        val angle = command.params[intKey(\"angle\")].get().head()\n        moveBy(angle)\n        moved = true\n\n        info(\"moved from : $initialPos by angle : $angle\")\n\n        become(\"READY\")\n    }\n\n    onGoOffline {\n        stopSetup()\n        info(\"Going in offline mode\")\n    }\n\n}\nIn the example, initialPos and moved demos declaring State scoped variables. Whenever state transition happens to some other state and back to SETTING-UP state, these variables will be reinitialised to its default values as defined in code. Transition to self will not reinitialise variables.","title":"Finite State Machine Script (FSM Script)"},{"location":"/sequencer/scripts/dsl/constructs/define-script.html#reusable-script","text":"Reusable Scripts make it possible to write the common logic which needs to shared across multiple scripts. This can be used to create small building blocks for building Sequencer Scripts.\nThey are same as the Regular Script except they cannot be directly loaded into a Sequence Component, and can only be loaded into other Sequencer Scripts.\nThe common logic consists of Script handlers and the top-level statements(initialisation logic). The top-level statements will be executed while loading the script. Script handlers will be added to the corresponding handlers of the script loading it.\nFollowing code declares a Reusable Script with Observe Command Handler.\nKotlin import esw.ocs.dsl.core.reusableScript\n\nval startObservationScript = reusableScript {\n    onObserve(\"start-observation\") {\n        info(\"opening the primary shutter to start observation\")\n\n        val openingStatusKey = stringKey(\"status\").set(\"open\")\n        publishEvent(ObserveEvent(\"IRIS.primary_shutter\", \"current-status\", openingStatusKey))\n\n        openPrimaryShutter()\n    }\n\n}","title":"Reusable Script"},{"location":"/sequencer/scripts/dsl/constructs/define-script.html#loading-in-regular-script","text":"To use Reusable Scripts, the Regular script needs to call function called loadScript with the instance of Reusable Script. Calling loadScript will initialise the Reusable Script and then combine handlers of both scripts.\nKotlin script {\n\n    loadScripts(startObservationScript)\n\n}","title":"Loading in Regular Script"},{"location":"/sequencer/scripts/dsl/constructs/define-script.html#loading-in-fsm-script","text":"A Reusable Script cannot be directly imported at top-level of FSM script. It can only be imported in a particular State of the FSM script. Loaded script is limited to that particular State. Below example loading script into a State.\nKotlin state(\"INIT\") { params ->\n\n    loadScripts(startObservationScript)\n\n}","title":"Loading in FSM Script"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html","text":"","title":"Script Handlers"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#script-handlers","text":"A Sequencer script processes Sequences by defining “handlers” in the script. This is done by completing the special handler functions described below. There are handlers that can be created to process the Setup and Observe commands, which make up the Sequence, but there are also handlers for specific reasons including: aborting and stopping a sequence, putting the Sequencer in Online and Offline modes, and putting the Sequencer into a Diagnostic mode and back to Operations mode. There is also a global error handler to catch all uncaught exceptions, and a shutdown handler to perform cleanup befores the Sequencer shut down and exits. Each of these handlers are described below, with a section on how to handle exceptions after that.","title":"Script Handlers"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#command-handlers","text":"","title":"Command Handlers"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#onsetup","text":"This handler is used to handle a Setup command sent to this Sequencer. The handler takes two parameters:\ncommand name which is matched against the sequence command sent. If the command name matches, corresponding block provided is executed block of code which contains logic to act on the Setup command.\nIn this onSetup example, commands are sent in parallel to each of the WFOS filter wheels.\nKotlin onSetup(\"setupInstrument\") {command ->\n    // split command and send to downstream\n    val assembly1 = Assembly(WFOS, \"filter.blueWheel\", 5.seconds)\n    val assembly2 = Assembly(WFOS, \"filter.redWheel\", 5.seconds)\n    par(\n            { assembly1.submit(Setup(\"WFOS.wfos_darknight\", \"move\")) },\n            { assembly2.submit(Setup(\"WFOS.wfos_darknight\", \"move\")) }\n    )\n}\nIn the block provided to this handler, all the CSW services (Event, Alarm, Time Service, etc) and control DSL (loop, par etc) are accessible.","title":"onSetup"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#onobserve","text":"This handler is used to handle an Observe command sent to this Sequencer. The handler takes two parameters:\ncommand name which is matched against the sequence command sent, if the command name matches, corresponding block provided is executed block of code which contains logic to act on the Observe command.\nThe following example imagines a WFOS Sequencer receiving an Observe that contains an exposureTime parameter. The exposureTime is extracted into a Setup that is sent to the detector Assembly to start the exposure.\nKotlin // A detector assembly is defined with a long timeout of 60 minutes\nval detectorAssembly = Assembly(WFOS, \"detectorAssembly\", 60.minutes)\nval exposureKey = floatKey(\"exposureTime\")\n\nonObserve(\"startExposure\") { observe ->\n    // Extract the input exposure time and send a startObserve command to the detector Assembly\n    val expsosureTime = observe(exposureKey).head()\n    detectorAssembly.submitAndWait(Setup(\"WFOS.sequencer\", \"startObserve\", observe.obsId).add(observe(exposureKey)))\n}","title":"onObserve"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#online-and-offline-handlers","text":"","title":"Online and Offline Handlers"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#ongoonline","text":"On receiving the goOnline command, the onGoOnline handler, if defined, will be called. The Sequencer will become online only if the handler executes successfully.\nKotlin onGoOnline {\n    // send command to downstream components\n    assembly.goOnline()\n}","title":"onGoOnline"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#ongooffline","text":"On receiving the goOffline command, the onGoOffline handler, if defined, will be called. The Sequencer will become offline only if the handler executes successfully. Offline handlers could be written to clear the sequencer state before going offline.\nKotlin onGoOffline {\n    // send command to downstream components\n    assembly.goOffline()\n}","title":"onGoOffline"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#abort-sequence-handler","text":"The abort handler could be used to perform any cleanup tasks that need to be done before the current sequence is aborted (e.g. abort an exposure). Note that, even if the handlers fail, the sequence will be aborted.\nKotlin onAbortSequence {\n    // cleanup steps to be done before aborting will go here\n}","title":"Abort Sequence Handler"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#stop-handler","text":"This handler is provided to clear/save the Sequencer state or stop exposures before stopping. Note that, even if the handlers fail, the sequence will be aborted.\nKotlin onStop {\n    // steps for clearing sequencer-state before stopping will go here\n}","title":"Stop Handler"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#shutdown-handler","text":"This handler will be called just before the Sequencer is shutdown. Note that, even if the handlers fail, the Sequencer will be shutdown.\nKotlin onShutdown {\n    // cleanup steps to be done before shutdown will go here\n}","title":"Shutdown Handler"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#diagnostic-mode-handler","text":"This handler can be used to perform actions that need to be done when the Sequencer goes in the diagnostic mode. The handler gets access to two parameters:\nstartTime: UTC time at which the diagnostic mode actions should take effect hint: represents the diagnostic data mode supported by the Sequencer\nThe Sequencer can choose to publish any diagnostic data in this handler based on the hint received, and/or send a diagnostic command to downstream components.\nKotlin var diagnosticEventCancellable: Cancellable? = null\n\nonDiagnosticMode { startTime, hint ->\n    // start publishing diagnostic data on a supported hint (for e.g. engineering)\n    when (hint) {\n        \"engineering\" -> {\n            val diagnosticEvent = SystemEvent(\"ESW.ESW_darknight\", \"diagnostic\")\n            diagnosticEventCancellable = schedulePeriodically(startTime, 50.milliseconds) {\n                publishEvent(diagnosticEvent)\n            }\n        }\n    }\n}","title":"Diagnostic Mode Handler"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#operations-mode-handler","text":"This handler can be used to perform actions that need to be done when the Sequencer goes in the operations mode. Script writers can use this handler to stop all the publishing being done by the diagnostic mode handler, and/or send an operations mode command to downstream components.\nKotlin onOperationsMode {\n    // cancel all publishing events done from diagnostic mode\n    diagnosticEventCancellable?.cancel()\n    // send operations command to downstream\n    assembly.operationsMode()\n}","title":"Operations Mode Handler"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#error-handlers","text":"In many cases, any errors encountered in a script would likely cause the command (and therefore, sequence) to fail. Most of the time, not much can be done other than capture and report the error that occurred. It is possible to perform some remediation, but it is likely the sequence would need to run again.\nFor this reason, we have simplified the error handling of commands such that any DSL APIs that essentially return a negative (e.g. Error or Cancelled) SubmitResponse are recasted as exceptions, which can then be caught by error handlers that are global to the sequence command handler, or the entire script. In this way, such error handling does not need to be repeated throughout the script for each command sent.\nA script can error out in following scenarios:\nScript Initialization Error : When the construction of script throws exception then script initialization fails. In this scenario, the framework will log the error cause. The Sequencer will not start on this failure. One needs to fix the error and then load script again. Command Handlers Failure : While executing a sequence, Command Handlers e.g. onSetup , onObserve can fail because of two reasons: handler throws exception or The Command Service or Sequencer Command Service used to interact with downstream Assembly/HCD/Sequencer returns negative SubmitResponse. A negative SubmitResponse is by default considered as error. In this case of failure, sequence is terminated with failure. Handlers Failure : This failure occurs when any of handlers other than Command Handlers fail (e.g. OnGoOnline, onDiagnosticMode etc.). In this scenario, framework will log the error cause. Sequence execution will continue.\nThe Script DSL provides following constructs to handle failures while executing script:","title":"Error Handlers"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#global-error-handler","text":"onGlobalError : This construct is provided for the script writer. Logic in the onGlobalError will be executed for all Handler Failures including Command Handler Failures except the Shutdown Handler. If the onGlobalError handler is not provided by script, then only the logging of error cause is done by the framework.\nFollowing example shows usage of onGloablError\nKotlin // Scenario-1 onObserve handler fails\nonObserve(\"trigger-filter-wheel\") { command ->\n    val triggerStartEvent = ObserveEvent(\"esw.command\", \"trigger.start\", command(stringKey(name = \"triggerTime\")))\n    // publishEvent fails with EventServerNotAvailable which fails onObserve handler\n    // onGlobalError handler is called\n    // Sequence is terminated with failure.\n    publishEvent(triggerStartEvent)\n}\n\n// Scenario-2 onSetup handler fails - submit returns negative SubmitResponse\nonSetup(\"command-2\") { command ->\n    val assembly1 = Assembly(IRIS, \"filter.wheel\", 5.seconds)\n\n    // Submit command to assembly return negative response. (error by default) onGlobalError handler is called.\n    // Sequence is terminated with failure.\n    assembly1.submit(command)\n}\n\n// Scenario-3\nonDiagnosticMode { startTime, hint ->\n    // publishEvent fails with EventServerNotAvailable\n    // onDiagnosticMode handler fails\n    // onGlobalError is called. Sequence execution continues.\n    publishEvent(ObserveEvent(\"esw.diagnostic.mode\", hint))\n}\n\nonGlobalError { error ->\n    val errorReason = stringKey(\"reason\").set(error.reason)\n    val observationEndEvent = ObserveEvent(\"esw.observation.end\", \"error\", errorReason)\n    publishEvent(observationEndEvent)\n}\nNote Error in all handlers except the Shutdown Handler will execute the global error handler provided by script. If an error handler is not provided, the framework will log the error cause.","title":"Global Error Handler"},{"location":"/sequencer/scripts/dsl/constructs/handlers.html#error-handling-at-command-handler-level","text":"onError : This construct is specifically provided for Command Handler Failures. An onError block can be written specifically for each onSetup and onObserve handler. The SubmitResponse error is captured in a ScriptError type and passed to onError the block. This type contains a reason String explaining what went wrong. In case of failure, onError will be called first followed by onGlobalError and sequence will be terminated with failure. After the error handling blocks are called, the command and hence the sequence, terminate with an Error status.\nKotlin onSetup(\"submit-error-handling\") { command ->\n    // some logic that results into a Runtime exception\n    val result: Int = 1 / 0\n}.onError { err ->\n    error(err.reason)\n}\nBy default, a negative SubmitResponse is considered as error.\nKotlin onSetup(\"submit-error-handling\") { command ->\n    val positiveSubmitResponse: SubmitResponse = assembly.submit(command)\n\n}.onError { err ->\n    // onError is called when submit command to the assembly fails with a negative response (error, invalid etc)\n    error(err.reason)\n}\nretry: This construct is specifically provided for Command Handler Failures. A retry block can be written specifically for each onSetup and onObserve handler. A retry block expects a retryCount and optional parameter interval which specifies an interval after which onSetup or onObserve will be retried in case of failure. retry block can be used along with onError or it can be used independently. If retry is combined with onError then command handler failure will call onError before each retry attempt. If command handler still fails after all retry attempts then onError block is called followed by onGlobalError and sequence will be terminated with failure. After the error handling blocks are called, the command and hence the sequence, terminate with an Error status.\nFollowing example shows retry construct used along with onError.\nKotlin onSetup(\"submit-error-handling\") { command ->\n    val assembly1 = Assembly(IRIS, \"filter.wheel\", 5.seconds)\n\n    // Submit command to assembly return negative response. - error by default\n    assembly1.submit(command)\n}.onError { err ->\n    error(err.reason)\n}.retry(2)\nFollowing example shows retry with interval used independently (without having onError block).\nKotlin onSetup(\"submit-error-handling\") { command ->\n    val assembly1 = Assembly(IRIS, \"filter.wheel\", 5.seconds)\n\n    // Submit command to assembly return negative response. - error by default\n    assembly1.submit(command)\n}.retry(2, 10.seconds)","title":"Error handling at command handler level"},{"location":"/sequencer/scripts/dsl/constructs/loop.html","text":"","title":"Including Looping in Scripts"},{"location":"/sequencer/scripts/dsl/constructs/loop.html#including-looping-in-scripts","text":"The script DSL supports a variety of looping constructs to satisfy different use cases:\nloop waitFor loopAsync","title":"Including Looping in Scripts"},{"location":"/sequencer/scripts/dsl/constructs/loop.html#loop-with-default-loop-interval","text":"The loop DSL allows you to start a “blocking” loop so that the rest of the code after loop will not be executed until a stopWhen condition written inside loop becomes true. You can use this DSL when you want to iteratively perform some actions until a certain condition becomes true. An interval can be provided to set the minimum period of the loop, where every iteration of the loop wait at least for the minimum provided interval before executing the next iteration. If no period is provided, the default interval is 50 milliseconds.\nThe following example demonstrates the usage of the loop DSL with the default interval. In the loop body, a motor is being “moved” by 10 degrees in every iteration of the loop. The loop will be terminated when motor’s current position reaches the expected position of 100 degrees.\nKotlin var motorPosition = 0\nfun moveMotor(degrees: Int) {\n    // move motor logic\n    motorPosition += degrees\n}\nonSetup(\"move-motor\") {\n\n    val expectedMotorPosition = 100\n\n    // move motor by 10 degrees in each iteration, default loop interval is 50 millis\n    // stop loop when current motor position matches expected motor position and continue with the execution of rest of the handler\n    loop {\n        moveMotor(10)\n        stopWhen(motorPosition == expectedMotorPosition)\n    }\n}","title":"loop - With Default loop Interval"},{"location":"/sequencer/scripts/dsl/constructs/loop.html#loop-with-custom-minimum-loop-interval","text":"The following example demonstrates the usage of the loop DSL when providing a custom loop interval.\nKotlin onSetup(\"move-motor\") {\n\n    val expectedMotorPosition = 100\n    // move motor by 20 degrees in every iteration after a loop interval of 500 millis (custom loop interval used here)\n    // stop loop when current motor position matches expected motor position and continue with the execution of rest of the handler\n    loop(minInterval = 500.milliseconds) {\n        moveMotor(20)\n        stopWhen(motorPosition == expectedMotorPosition)\n    }\n}\nIs there a minimum loop interval? minInterval needs to be greater than default interval of 50 milliseconds otherwise it will be ignored and default loop interval will be used.","title":"loop - With Custom Minimum Loop Interval"},{"location":"/sequencer/scripts/dsl/constructs/loop.html#waitfor-loop-until-a-condition-is-true","text":"This is a specialized version of loop and satisfies simple use cases where you want to semantically block the execution until certain condition becomes true.\nIn the following example, initializeMotor method will start the initialization and eventually set motorUp flag to true indicating motor is successfully initialized. waitFor { motorUp } will check the value of motorUp flag every 50 milliseconds, and when it is true, the rest of the code execution will continue.\nKotlin var motorUp = false\n\nfun initializeMotor() {\n    // some motor initialization logic goes here\n    motorUp = true\n}\nonSetup(\"init-motor\") {\n    // start initializing motor and this method will set motorUp flag to true once initialization is successful\n    initializeMotor()\n    // pauses the init-motor command handlers execution until motor becomes up\n    waitFor { motorUp }\n\n    // rest of the handler implementation (here you can safely assume that motor is up)\n}","title":"waitFor - Loop Until a Condition is True"},{"location":"/sequencer/scripts/dsl/constructs/loop.html#loopasync-with-a-default-loop-interval","text":"The previous DSL loop constructs “block” until the loop completes. You can use this DSL when you want to iteratively perform some actions in the background. Since it is asynchronous, once the code in the background loop starts, the code written after loopAsync will be executed immediately and concurrently.\nLike loop, loopAsync will be terminated when a stopWhen condition written inside loop becomes true. loopAsync also has a default interval of 50 milliseconds.\nThe following example demonstrates the usage of loopAsync DSL with the default interval. In the loop body, a current temperature event is published every 50 milliseconds. The loopAsync will be terminated when stopPublishingTemperature flag becomes true, which is set to true in the onStop handler.\nKotlin var stopPublishingTemperature = false\nval temperatureEvent = ObserveEvent(\"IRIS.motor\", \"temperature\")\nval temperatureKey = longKey(\"temperature\")\n\nfun getCurrentTemp(): Long = TODO()\n\n// start background loop which publishes current temperature of motor every 50 milliseconds (default loop interval)\nloopAsync {\n    val currentTemp = getCurrentTemp()\n    publishEvent(temperatureEvent.add(temperatureKey.set(currentTemp)))\n    stopWhen(stopPublishingTemperature)\n}\n\nonStop {\n    stopPublishingTemperature = true\n}","title":"loopAsync - With a Default Loop Interval"},{"location":"/sequencer/scripts/dsl/constructs/loop.html#loopasync-with-a-custom-loop-interval","text":"The following example demonstrates the usage of loopAsync DSL with a custom loop interval specified.\nKotlin // start background loop which publishes current temperature of motor every 100 milliseconds\nloopAsync(minInterval = 100.milliseconds) {\n    val currentTemp = getCurrentTemp()\n    publishEvent(temperatureEvent.add(temperatureKey.set(currentTemp)))\n    stopWhen(stopPublishingTemperature)\n}","title":"loopAsync - With a Custom Loop Interval"},{"location":"/sequencer/scripts/dsl/constructs/loop.html#source-code-for-examples","text":"Loop Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html","text":"","title":"Finite State Machines"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#finite-state-machines","text":"Scripts have ability to define and run Finite State Machine (FSM). FSM can transition between defined states and can be made reactive to Event and Command.","title":"Finite State Machines"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#define-fsm","text":"","title":"Define FSM"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#create-fsm","text":"To create an instance of FSM, a helper method Fsm is provided as shown in example. This method takes following parameters:\nname of FSM initial state of the FSM block having states of the FSM\nKotlin val irisFsm: Fsm = Fsm(name = \"iris-fsm\", initState = \"INIT\") {\n    // place to define all states of FSM\n}","title":"Create FSM"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#define-state","text":"As mentioned above, the third parameter of Fsm method is a block which is the place to define all the states of FSM. A method named state needs to be called with parameters name of the state and the block of actions to be performed in that state.\nNote State names are case-insensitive. In case of multiple states with same name, the last one will be considered.\nKotlin state(\"INIT\") {\n    // actions to be performed in this state\n}","title":"Define state"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#state-transition","text":"To transit between states, become method needs to be called with name of next state. This will change the state of the fsm to next state and start executing it. InvalidStateException will be thrown if provided state is not defined.\nKotlin become(state = \"IN-PROGRESS\")\nCaution State transition should ideally be the last call in state or should be done with proper control flow so that become is not called multiple times.\nAlong with changing state, it is also possible to Params from current state to another. Params can be given to become as last argument, which will injected in the next state as a parameter.\nIn a case where state transition does not happen while executing a state, the FSM will stay in the same state and re-evaluating FSM after that will execute the same state until any state transition happens. The reactive variables plays an important role in this as they are the way to re-evaluate the FSM state.\nKotlin state(\"LOW\") {\n    on(temparature.get() < 20) {\n        // do something but state transition does not happen\n    }\n\n    on(temparature.get() >= 20) {\n        // do something and transit state\n        become(\"HIGH\")\n    }\n}\nIn the example above, the FSM is in LOW state. If the temperature is below 20, then there won’t be any state transition which will keep the FSM in same LOW state. Change in temperature after that will re-evaluate the “LOW” state again and if the temperature is greater than or equal to 20 then current state will change to HIGH. In the example temperature is a event variable which enables the re-evaluation of current state on changes in temperature value.","title":"State transition"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#complete-fsm","text":"completeFsm marks the FSM complete. Calling it will immediately stop execution of the FSM and next steps will be ignored, so it should be called at the end of the state.\nKotlin completeFsm()   // will complete the Fsm\n// anything after this will not be executed","title":"Complete FSM"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#helper-constructs","text":"entry : executes the given block only when state transition happens from a different state Kotlin entry {\n    // do something\n} on : executes the given block if given condition evaluates to true. This construct should be used for conditional execution of any task. Kotlin on(temparature.get() < 20) {\n    // do something but state transition does not happen\n}\n\non(temparature.get() >= 20) {\n    // do something and transit state\n    become(\"HIGH\")\n} after : executes the given block after the given duration Kotlin after(100.milliseconds) {\n    // do something\n}","title":"Helper constructs"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#start-fsm","text":"After creating instance of FSM, it needs to be explicitly started by calling start on it. This will start executing the initial state of fsm which is provided while creating instance of it.\nCaution Calling start more than once is not supported and will lead to unpredictable behaviour.\nKotlin irisFsm.start()","title":"Start FSM"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#wait-for-completion","text":"As FSM has ability to be complete itself, await can be called to wait for its completion. Execution will be paused at the await statement till the FSM is marked complete.\nKotlin irisFsm.await()\nCalling await before calling start will start the fsm internally and then wait for completion.","title":"Wait for completion"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#reactive-fsm","text":"FSM can be made to react to changes in Event and Command parameters with help of Event variables and Command flags.\nbinding FSM to reactive variable is necessary to achieve the reactive behavior of FSM.","title":"Reactive FSM"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#event-variable","text":"Event variables are the way to make fsm react to events. Event variable can be tied to only one Parameter Key in an event. To make FSM react to Event variable, we need to create a EventVariable for a specific Parameter Key of an Event and bind the FSM to it. FSM can be bind to multiple Event variables and vise versa.\nEvent variables use Event Service underneath, which makes it possible to share data between multiple sequencers. Whenever any event is published on the key of given event, all the FSMs bound to that variable will be re-evaluated.\nEvent variables are of 2 types:\nSystemVar - are based on SystemEvent ObserveVar - are based on ObserveEvent\nEvent variable takes 4 arguments: - the initial value to set in Event parameter against the given parameter Key - the event key to tie Event variable to - the param Key whose value to read from Event parameters - the duration (optional) of the polling (Significance of duration parameter is explained below.)\nEvent variable has capability to behave one of two ways\nSubscribe to the Events getting published Poll for a new event after every certain interval","title":"Event variable"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#subscribe","text":"Event variable subscribes to the given Event key and re-evaluates the FSMs current state as soon as an event is published.\nFollowing examples shows how to create Event variables with subscribing behavior, bind FSM to it and methods like get and set. set will publish the event with modified parameter.\nKotlin //**  System Var **//\nval tempKey: Key<Int> = intKey(\"temperature\")\nval systemVar: EventVariable<Int> = SystemVar(0, \"esw.temperature.temp\", tempKey)\n\nsystemVar.bind(irisFsm) // binds the FSM and event variable\n\n//**  Observe Var **//\nval coordKey: Key<Coord> = coordKey(\"co-ordinates\")\nval observeVar: EventVariable<Coord> = ObserveVar(JEqCoord.make(0, 0), \"IRIS.observe.coord\", coordKey)\nobserveVar.get() // returns the value of the parameter from the latest event\n\nobserveVar.bind(irisFsm) // binds the FSM and event variable\n\nobserveVar.set(JEqCoord.make(1, 1)) // publishes the given value on event key","title":"Subscribe"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#poll","text":"Polling behavior is for situations when it’s not necessary to re-evaluate FSM state on every Event and can be done periodically after a certain duration. Event variable polls to get the latest Event with given duration and if a new Event is published, it will re-evaluate the FSMs current state. Polling behavior can be used when the publisher is too fast and there is no need respond so quickly to it.\nFor creating Event variable with polling behavior, it needs an extra argument which is the duration to poll with, the example code demos it. Other methods like get, set and bind are same as shown Subscribe examples above.\nKotlin // SystemVar with polling duration of 2 seconds\nval pollingSysVar: EventVariable<Int> = SystemVar(0, \"esw.temperature.temp\", tempKey, 2.seconds)\n\n// ObserveVar with polling duration of 2 seconds\nval pollingObsVar: EventVariable<Coord> = ObserveVar(JEqCoord.make(0, 0), \"iris.observe.coord\", coordKey, 2.seconds)","title":"Poll"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#commandflag","text":"Command flag acts as bridge which can used to pass Parameters to FSM from outside. Setting the params in command flag will re-evaluate the all the FSMs with provided params which are bound to that flag. It is possible to bind one FSM to multiple command flags and vise versa. Command flag is limited to scope of a single script. It does not have any remote impact.\nExample shows how to create CommandFlag, bind FSM to it and methods get and set which are provided to retrieve or set the value of params in command flag.\nKotlin val flag = CommandFlag()\nflag.bind(irisFsm) // bind the FSM and command flag\n\nonSetup(\"setup-command\") { command ->\n    flag.set(command.params) // will set params and refreshes the bound FSMs with the new params\n}\n\nflag.value() // way to extract the current params value in FSM\nNote Binding FSM to reactive variables can be done anytime in the lifecycle of FSM not only before starting it. Doing it after completion of FSM does not do anything. Binding is must for achieving the reactive behavior.","title":"CommandFlag"},{"location":"/sequencer/scripts/dsl/constructs/fsm.html#example-fsm","text":"In the below example, temparatureFsm demonstrates how to define and use FSM in the scripts. The event variable is declared with event key esw.temperature.temp for param temperature and temperatureFsm is bind to it. The job of the temperatureFsm is to decide the state based on the temperature and publish it on event key esw.temperatureFsm with param key state.\nLogic of state change is:\ncondition state temp == 30 FINISH temp > 40 ERROR else OK\nKotlin val tempKey = longKey(\"temperature\")\nval stateKey = stringKey(\"state\")\n\nval tempFsmEvent = SystemEvent(\"esw.temperatureFsm\", \"state\")\nsuspend fun publishState(baseEvent: SystemEvent, state: String) =\n        publishEvent(baseEvent.add(stateKey.set(state)))\n\n// temperature Fsm states\nval OK = \"OK\"\nval ERROR = \"ERROR\"\nval FINISHED = \"FINISHED\"\n\nval temperatureVar = SystemVar(0, \"esw.temperature.temp\", tempKey)\nval commandFlag = CommandFlag()\n\nval temperatureFsm = Fsm(\"TEMP\", OK) {\n    var fsmVariable = 10                                     // [[ 1 ]]\n\n    state(OK) {\n        val currentTemp = temperatureVar.get()        // [[ 2 ]]\n        val expectedTemp = commandFlag.value().get(intKey(\"expected-temperature\")).get().first\n\n        entry {\n            publishState(tempFsmEvent, OK)\n        }\n        on(currentTemp == 30L) {\n            become(FINISHED)                                 // [[ 3 ]]\n        }\n        on(currentTemp > expectedTemp) {\n            become(ERROR, commandFlag().value())             // [[ 4 ]]\n        }\n        on(currentTemp <= expectedTemp) {\n            info(\"temperature is below expected threshold\",\n                    mapOf(\"exepected\" to expectedTemp, \"current\" to currentTemp)\n            )\n        }\n    }\n\n    state(ERROR) { params ->\n        val expectedTemp = params.get(intKey(\"expected-temperature\")).get().first\n\n        entry {\n            info(\"temperature is above expected threshold\",\n                    mapOf(\"exepected\" to expectedTemp)\n            )\n            publishState(tempFsmEvent, ERROR)\n        }\n        on(temperatureVar.get() < expectedTemp) {\n            become(OK)\n        }\n    }\n\n    state(FINISHED) {\n        completeFsm()                                        // [[ 5 ]]\n    }\n}\n\ntemperatureVar.bind(temperatureFsm)\ncommandFlag.bind(temperatureFsm)                             // [[ 6 ]]\n\nonSetup(\"command-1\") {\n    temperatureFsm.start()                                   // [[ 7 ]]\n}\n\nonSetup(\"command-2\") { command ->\n    commandFlag.set(command.params)                          // [[ 8 ]]\n}\n\nonSetup(\"command-3\") {\n    temperatureFsm.await()                                   // [[ 9 ]]\n}\nFull example code is available here.\nKey things in above example code are :\n[[ 1 ]]: Shows top-level scope of the FSM which can used to declare variables in FSM’s scope and statements which should be executed while starting the FSM. Statements written here will be executed only once when the FSM starts. [[ 2 ]]: The scope of the state. Statements written here will be executed on every evaluation of the state. So variables declared here will be reinitialized whenever state is re-evaluated. In the above case, the expectedTemp and currentTemp will be initialized every time the OK state is evaluated. [[ 3 ]]: State transitions from OK state to FINISHED. [[ 4 ]]: State transitions from OK state to ERROR with Params. ERROR state shows how to consume Params in a state. [[ 5 ]]: Marks the FSM complete. Re-evaluation or state transitions cannot happen after this is executed.\nTill point [[ 5 ]], it’s all about defining the blue-print and initialising state of FSM which includes executing statements at [[ 1 ]].\n[[ 6 ]]: Shows the binding temperatureFsm to temperatureVar and commandFlag. After this point, FSM will re-evaluate whenever events are published on temperatureVar. [[ 7 ]]: Starts evaluating the initial state of the FSM [[ 8 ]]: Sets the Params of the Command in the Command flag [[ 9 ]]: Waits for completion of the FSM. In example, the script execution will be blocked till line [[ 4 ]] is executed which will mark the FSM complete. The script will continue execution after FSM is marked complete.\nExample code also demos the use of the helper constructs like entry, on.","title":"Example FSM"},{"location":"/sequencer/scripts/dsl/constructs/misc.html","text":"","title":"Other DSL"},{"location":"/sequencer/scripts/dsl/constructs/misc.html#other-dsl","text":"","title":"Other DSL"},{"location":"/sequencer/scripts/dsl/constructs/misc.html#par","text":"This utility is provided to support running multiple tasks in parallel. A call to par returns when all the submitted tasks complete.\nThe following example demonstrates sending commands in parallel to multiple HCD’s.\nKotlin val prefix = \"OCS.IRIS_darkMode\"\nval hcd1 = Hcd(IRIS, \"filter.wheel1\", 10.minutes)\nval hcd2 = Hcd(IRIS, \"filter.wheel2\", 10.minutes)\nval hcd3 = Hcd(IRIS, \"filter.wheel3\", 10.minutes)\n\nonSetup(\"setup-iris-hcds\") {\n    // send 3 setup commands to 3 HCD's in parallel\n    val responses: List<SubmitResponse> =\n            par(\n                    { hcd1.submitAndWait(Setup(prefix, \"move-10\")) },\n                    { hcd2.submitAndWait(Setup(prefix, \"move-10\")) },\n                    { hcd3.submitAndWait(Setup(prefix, \"move-10\")) }\n            )\n}","title":"par"},{"location":"/sequencer/scripts/dsl/constructs/misc.html#source-code-for-examples","text":"Misc Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/csw-services.html","text":"","title":"CSW Services DSL"},{"location":"/sequencer/scripts/dsl/csw-services.html#csw-services-dsl","text":"Location Service Using the Configuration Service in Scripts Command Service for Assemblies and HCDs Sequencer Command Service Event Service Logging Service Alarm Service Time Service Access in Scripts Database Service Extension utilities on SubmitResponse Params","title":"CSW Services DSL"},{"location":"/sequencer/scripts/dsl/services/location-service.html","text":"","title":"Location Service"},{"location":"/sequencer/scripts/dsl/services/location-service.html#location-service","text":"Location Service DSL is a wrapper over Location Service module provided by CSW. You can refer a detailed documentation of Location Service provided by CSW here.\nThis DSL provides following APIs:","title":"Location Service"},{"location":"/sequencer/scripts/dsl/services/location-service.html#register","text":"This DSL registers provided Registration with Location Service and returns RegistrationResult which contains Location with which component is registered and handle for un-registration.\nRegistration can be one of:\nAkkaRegistration HttpRegistration TcpRegistration\nKotlin // register HTTP service running at port 8080 and routes are served from /routes endpoint\nval registrationResult: RegistrationResult =\n        register(HttpRegistration(httpConnection, port, \"/routes\"))\n\n// location which is registered with Location Service\nval location: Location = registrationResult.location\n\n// unregisters location from Location Service which triggers LocationRemoved event\nregistrationResult.unregister()","title":"register"},{"location":"/sequencer/scripts/dsl/services/location-service.html#unregister","text":"This DSL un-registers provided Connection from Location Service\nConnection can be one of:\nAkkaConnection HttpConnection TcpConnection\nKotlin val sourcePrefix: Prefix = cmd.source()\nval componentId = ComponentId(sourcePrefix, Service)\n\nunregister(HttpConnection(componentId))","title":"unregister"},{"location":"/sequencer/scripts/dsl/services/location-service.html#findlocation","text":"This DSL look up for provided Connection in Location Service and returns corresponding Location or null if not found.\nKotlin val prefix: Prefix = cmd.source()\nval assemblyConnection = AkkaConnection(ComponentId(prefix, Assembly))\n\nval location: AkkaLocation? = findLocation(assemblyConnection)\n\n// send a successful event to UI if assembly location is found\nlocation?.let { sendUIEvent(\"Resolved assembly location: $it\") }","title":"findLocation"},{"location":"/sequencer/scripts/dsl/services/location-service.html#resolvelocation","text":"This DSL keeps looking for provided Connection in Location Service for the provided/default duration and returns corresponding Location or null if not found after duration exhausts.\nKotlin val prefix: Prefix = cmd.source()\nval assemblyConnection = AkkaConnection(ComponentId(prefix, Assembly))\n\nval location: AkkaLocation? = resolveLocation(assemblyConnection)\n\n// send a successful event to UI if assembly location is found\nlocation?.let { sendUIEvent(\"Resolved assembly location: $it\") }","title":"resolveLocation"},{"location":"/sequencer/scripts/dsl/services/location-service.html#listlocations","text":"Lists all the locations currently registered with the Location Service.\nKotlin val allLocations: List<Location> = listLocations()\n\n// publish all locations to UI in the format of [location1, location2, ...]\nsendUIEvent(allLocations.joinToString(prefix = \"[\", postfix = \"]\"))","title":"listLocations"},{"location":"/sequencer/scripts/dsl/services/location-service.html#listlocationsby","text":"Following various APIs are provided for listing locations with filtering criteria:","title":"listLocationsBy"},{"location":"/sequencer/scripts/dsl/services/location-service.html#","text":"Filters locations based on provided ComponentType, for example, HCD, Assembly, Sequencer etc.\nFollowing example demonstrate a use case where script sends Offline command to all the Assemblies.\nKotlin onSetup(\"offline-assemblies\") {\n    // list all Assembly components\n    val assemblyLocations: List<Location> = listLocationsBy(Assembly)\n\n    // create Assemblies from locations and send offline command to each one of them\n    val assemblies = assemblyLocations.map { Assembly(it.prefix, 10.minutes) }\n    assemblies.forEach { it.goOffline() }\n}","title":"ComponentType"},{"location":"/sequencer/scripts/dsl/services/location-service.html#","text":"Filters locations based on provided ConnectionType, for example, AkkaType, HttpType, TcpType etc.\nFollowing example demonstrate a use case where script locks all the components i.e. Assemblies and HCD’s.\nKotlin onSetup(\"lock-all-components\") {\n    val timeout = 10.minutes\n    val leaseDuration = 20.minutes\n\n    // list all akka components\n    val akkaLocations: List<Location> = listLocationsBy(AkkaType)\n\n    // filter HCD's and Assemblies and send Lock command\n    akkaLocations.forEach { location ->\n        val compId: ComponentId = location.connection.componentId\n        val compType: ComponentType = compId.componentType\n        val prefix = location.prefix\n\n        // create Assembly or Hcd instance based on component type and send Lock command\n        when (compType) {\n            Assembly -> Assembly(prefix, timeout).lock(leaseDuration)\n\n            HCD -> Hcd(prefix, timeout).lock(leaseDuration)\n\n            else -> warn(\"Unable to lock component $compId, Invalid component type $compType\")\n        }\n    }\n}\nNote Following import is required for creating ConnectionType and ComponentType import esw.ocs.dsl.highlevel.models.*","title":"ConnectionType"},{"location":"/sequencer/scripts/dsl/services/location-service.html#hostname","text":"Filters locations based on provided hostname.\nIn the following example, we are listing all the components running on IRIS (hostname: 10.1.1.1) machine\nKotlin // list all the components running on IRIS machine\nval irisMachineHostname = \"10.1.1.1\"\nval irisMachineLocations: List<Location> = listLocationsBy(irisMachineHostname)\n\nsendUIEvent(\"IRIS machine running components: [$irisMachineLocations]\")","title":"Hostname"},{"location":"/sequencer/scripts/dsl/services/location-service.html#prefix","text":"Filters locations based on provided Prefix.\nIn the following example, we are listing all the componenst registered using Prefix: IRIS.filter.wheel where IRIS is a Subsystem and filter.wheel is a component name\nKotlin val irisPrefix = Prefix(\"IRIS.filter.wheel\")\nval irisComponents: List<Location> = listLocationsBy(irisPrefix)\n\n// log Assembly and HCD location\nirisComponents.forEach {\n    when (it.connection.componentId.componentType) {\n        Assembly -> info(\"$irisPrefix is registered as Assembly with location: $it\")\n\n        HCD -> info(\"$irisPrefix is registered as HCD with location: $it\")\n\n        else -> error(\"Invalid location: $it found for $irisPrefix\")\n    }\n}","title":"Prefix"},{"location":"/sequencer/scripts/dsl/services/location-service.html#onlocationtrackingevent","text":"This DSL allows you to add a callback on every location changed event which is represented by TrackingEvent.\nTrackingEvent has following two subclasses\nLocationUpdated: Published when location is registered with Location Service LocationRemoved: Published when location is removed from Location Service\nKotlin onObserve(\"monitor-iris-sequencer\") {\n    val irisPrefix = Prefix(\"IRIS.darknight\")\n    val irisComponent = ComponentId(irisPrefix, Sequencer)\n    val irisSequencerConnection = AkkaConnection(irisComponent)\n\n    // send UI events on iris sequencers location change\n    onLocationTrackingEvent(irisSequencerConnection) {\n        when (it) {\n            is LocationUpdated ->\n                sendUIEvent(\"[INFO] Location updated ${it.location()}\")\n\n            is LocationRemoved ->\n                sendUIEvent(\"[ERROR] Location removed for connection: ${it.connection()}\")\n        }\n    }\n}\nNote sendUIEvent used in above examples is just for demonstration purpose and is not part of DSL. sendUIEvent publish SystemEvent with provided message.","title":"onLocationTrackingEvent"},{"location":"/sequencer/scripts/dsl/services/location-service.html#source-code-for-examples","text":"Location Service Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/services/config-service.html","text":"","title":"Using the Configuration Service in Scripts"},{"location":"/sequencer/scripts/dsl/services/config-service.html#using-the-configuration-service-in-scripts","text":"The Configuration Service (CS) is available to script writers using the provided DSL. The Configuration Service DSL is a wrapper over the client Configuration Service module provided by CSW. The detailed documentation of Configuration Service provided by CSW here is useful to understand usage of CS and limits.\nThe CS DSL provides methods to check if a file exists in the Configuration Service and to retrieve a file’s contents.","title":"Using the Configuration Service in Scripts"},{"location":"/sequencer/scripts/dsl/services/config-service.html#existsconfig","text":"The existsConfig DSL method checks if provided file path exists in Configuration Service with a specific revision id (if provided) and returns true or false based on whether or not the file exists.\nKotlin val commandsFile = \"/wfos/commands.conf\"\nval commandsConfigExist: Boolean = existsConfig(commandsFile)\n\n// terminate script if required configuration file does not exist\nif (!commandsConfigExist) finishWithError(\"Configuration file [$commandsFile] not found in configuration service\")","title":"existsConfig"},{"location":"/sequencer/scripts/dsl/services/config-service.html#getconfig","text":"The getConfig DSL method retrieves the content of the file present at the provided path in Configuration Service. It returns null if file is not available in Configuration Service.\nIn the below example, we are performing following steps:\nRetrieve a configuration file from Configuration Service Fail/Terminate script if configuration file does not exist Parse retrieved configuration file and convert it to MotorCommands domain model When Sequencer receives set-motor-speed command, then submit set-speed command to downstream motor HCD When Sequencer receives rotate-motor command, then send set-resolution command to downstream motor HCD\nKotlin val wfosCommandsFile = \"/wfos/commands.conf\"\n\n// retrieve configuration file from config service, terminate script if configuration file does not exist\nval commandsConfig: Config = getConfig(wfosCommandsFile)\n        ?: finishWithError(\"Configuration file [$wfosCommandsFile] not found in configuration service\")\n\nval motorCommands = MotorCommands.from(commandsConfig)\n\n// on receiving `set-motor-speed` command, send `set-speed` command to downstream motor hcd\nonSetup(\"set-motor-speed\") {\n    val motorSpeedParam = motorSpeedKey.set(motorCommands.setMotorSpeed)\n    val setSpeedCommand = Setup(motorPrefixStr, \"set-speed\").add(motorSpeedParam)\n    motorHcd.submit(setSpeedCommand)\n}\n\n// on receiving `set-step-motor-resolution` command, send `set-resolution` command to downstream motor hcd\nonSetup(\"set-step-motor-resolution\") {\n    val setResolutionParam = motorResolutionKey.set(motorCommands.setStepMotorResolution)\n    val setResolutionCommand = Setup(motorPrefixStr, \"set-resolution\").add(setResolutionParam)\n    motorHcd.submit(setResolutionCommand)\n}\nThe following example shows sample code for converting a Config object retrieved from the Configuration Service to custom domain models. Note that TMT standard for configuration files is HOCON as supported by CSW.\nRefer to this guide for complete usage of Config.\nKotlin /**\n * ======== Sample commands.conf file ========\n * wfos.motor.commands {\n *      set-motor-speed = 50\n *      set-step-motor-resolution = \"1080p\"\n * }\n */\ndata class MotorCommands(val setMotorSpeed: Long, val setStepMotorResolution: String) {\n\n    // static factory to create `MotorCommands` from `Config` object\n    // Ex. MotorCommands.from(config)\n    companion object {\n        fun from(wfosCommandsConfig: Config): MotorCommands {\n            val motorCommandsConfig: Config = wfosCommandsConfig.getConfig(\"wfos.motor.commands\")\n            return MotorCommands(\n                    motorCommandsConfig.getLong(\"set-motor-speed\"),\n                    motorCommandsConfig.getString(\"set-step-motor-resolution\")\n            )\n        }\n    }\n}","title":"getConfig"},{"location":"/sequencer/scripts/dsl/services/config-service.html#source-code-for-examples","text":"Config Service Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/services/command-service.html","text":"","title":"Command Service for Assemblies and HCDs"},{"location":"/sequencer/scripts/dsl/services/command-service.html#command-service-for-assemblies-and-hcds","text":"A Sequencer script can send commands to Assemblies and HCDs. This section describes the Command Service DSL that is a wrapper for the CSW Command Service module for sending commands to Assemblies or HCDs within scripts. You can refer to detailed documentation of the Command Service provided by CSW here.\nThe DSL provides a way to define an Assembly or HCD as an object. This object encapsulates the Location Service and Command Service of CSW to provide a higher level DSL for script usage. This DSL exposes following APIs:\nA Sequencer can also send Sequences to other Sequencers. See here for more information on sending Sequences to Sequencers.","title":"Command Service for Assemblies and HCDs"},{"location":"/sequencer/scripts/dsl/services/command-service.html#assembly","text":"The Assembly DSL method creates a Command Service entity for an Assembly with the provided Prefix that can be used to send commands from a script, such as sending Setups or Observes or lifecycle methods e.g. goOnline, goOffline, lock Assembly etc. This DSL method provides a default timeout which will be used for commands like submitAndWait, queryFinal etc, but also allows adding an Assembly-specific default timeout. The built-in default timeout is 10 seconds. Commands requiring a timeout also allow command-specific timeouts.\nAssembly takes the following parameters:\nprefix: Prefix of the Assembly as defined in the Assembly’s model file defaultTimeout: optional command response timeout to be used when not explicitly provided for command\nKotlin val galilAssembly = Assembly(WFOS, \"FilterWheel\")\n\nval galilAssembly2 = Assembly(WFOS, \"FilterWheel\", defaultTimeout = 20.seconds)","title":"Assembly"},{"location":"/sequencer/scripts/dsl/services/command-service.html#hcd","text":"The HCD DSL method creates a Command Service DSL entity for an HCD with the provided Prefix that can be used to send commands from a script, such as sending Setups or Observes or lifecycle methods e.g. goOnline, goOffline, lock HCD etc. This DSL method provides a default timeout which will be used for commands like submitAndWait, queryFinal etc., but also allows adding an HCD-specific default timeout. The built-in timeout is 10.seconds. Commands requiring a timeout also allow command-specific timeouts.\nHCD takes the following parameters:\nprefix: - Prefix of HCD as defined in the HCD’s model file defaultTimeout: - optional command response timeout to be used when not explicitly provided for command\nKotlin val filterWheelHcd = Hcd(WFOS, \"GalilHcd1\")\n\nval filterWheelHcd2 = Hcd(WFOS, \"GalilHcd1\", defaultTimeout = 20.seconds)\nResolving a Component with Location Service Since all the components in the TMT architecture are dynamic in nature, which implies they can be shutdown and spawned dynamically on some other location, the Assembly/HCD is resolved each time the Command Service DSL is used. It is possible to create an Assembly or HCD entity for a non-existent component, but a command to the component will fail because the component is resolved when the command is sent.","title":"HCD"},{"location":"/sequencer/scripts/dsl/services/command-service.html#command-service-dsl","text":"The Command Service API provided by the DSL for use in scripts is similar to the CommandService API provided by Scala or Java. The big difference is that the DSL does not return a Future. In the scripting language, even though the commands are asynchronous, each completes and returns its value, such as a SubmitResponse, not a Future[SubmitResponse]. This section describes each of the available DSL methods.","title":"Command Service DSL"},{"location":"/sequencer/scripts/dsl/services/command-service.html#submit","text":"The submit method of the DSL allows sending a Setup or Observe command to an Assembly/HCD. submit returns a positive SubmitResponse which can be Completed or Started. A very short command may quickly return Completed. A command that starts actions that are long-running returns Started.\nsubmit or submitAndWait? submit is similar to submitAndWait in that both send a command to another component. submit is the right choice when the command starts long-running actions, and you need to take additional actions before the command completes. A successful long-running command returns a Started response that includes a runId, which can be used with query or queryFinal to wait for the commands final response at a later time. submitAndWait combines submit and queryFinal as a shortcut when you only need to wait for all started actions to complete before taking the next script step.\nThe following example shows a submit to the Galil Assembly that is going to take a long time.\nKotlin val parameters = intKey(\"target\").set(100)\nval galilCommand = Setup(\"ESW.IRIS_darkNight\", \"moveWheel\", command.obsId).add(parameters)\nval startedResponse = galilAssembly.submit(galilCommand)","title":"Submit"},{"location":"/sequencer/scripts/dsl/services/command-service.html#error-handling-in-scripts","text":"In most cases errors encountered in the execution of a script will likely cause the command (and therefore, Sequence) to fail. Most of the time, not much can be done when an error occurs other than to report the error that occurred. In some cases, it is possible some remediation can be performed, but it is likely the Sequence would need to run again. For this reason, the error handling of commands in a script has been simplified such that errors from the Command Service DSL calls are captured and delivered to error handlers specific to a single sequence command handler, or global to the entire script. In this way, such error handling does not need to be repeated throughout the script for each command sent.\nTo add an error handler to a command handler, extend the command handler block with a .onError block. The SubmitResponse error is captured in a ScriptError type and passed into the block. This type contains a reason String explaining what went wrong. If the command handler does not have an onError block, the global error handler will be called. See the page on Script Handlers for more information. After this block is called, the command sending the sequence terminates with an Error status.\nBecause of this mechanism, a submit (and other Command Service API calls) always returns a positive SubmitResponse. For submit, the two possible responses are Started and Completed. They can be handled using the .onStarted and .onCompleted methods, respectively. These methods allow you to specify a block of code to be called in each of those cases. Alternatively, a Kotlin when can be used to perform pattern matching on the result. An example of both are shown below, along with an example of an onError handler for the sequence command handler. Since there are only two positive options, forming an if statement using the isStarted call on the SubmitResponse is convenient in many cases.\nKotlin onSetup(\"submit-error-handling\") { command ->\n\n    /* =========== Scenario-1 (default) ============\n     * if submit returns negative response (which is considered as error by default)\n     * then current execution flow breaks and onError command handler gets invoked\n     * Hence, only Started (in case of long-running command) or Completed (in case of short running command) response is returned\n     */\n    val parameters = intKey(\"target\").set(100)\n    val galilCommand = Setup(\"ESW.IRIS_darkNight\", \"moveWheel\", command.obsId).add(parameters)\n    val positiveSubmitResponse: CommandResponse.SubmitResponse = galilAssembly.submit(galilCommand)\n\n    //  First approach - using custom dsl (this is an alternative to kotlin pattern match using when)\n    positiveSubmitResponse\n            .onStarted { startedRes ->\n                val completedResponse = galilAssembly.queryFinal(startedRes.runId())\n                info(\"command completed with result: ${completedResponse.result}\")\n            }\n            .onCompleted { completed ->\n                info(\"command with ${completed.runId()} is completed with result: ${completed.result}\")\n            }\n\n    // Second approach - using kotlin pattern matching\n    when (positiveSubmitResponse) {\n        is CommandResponse.Started -> {\n            val completedResponse = galilAssembly.queryFinal(positiveSubmitResponse.runId())\n            info(\"command completed with response: $completedResponse\")\n        }\n        is CommandResponse.Completed -> info(\"command with ${positiveSubmitResponse.runId()} is completed\")\n    }\n\n    // Third approach - use the isStarted value\n    if (positiveSubmitResponse.isStarted) {\n        val completedResponse = galilAssembly.queryFinal(positiveSubmitResponse.runId())\n        info(\"command completed with result: ${completedResponse.result}\")\n    } else {\n        info(\"command with ${positiveSubmitResponse.runId()} is completed with result: ${positiveSubmitResponse.result}\")\n    }\n\n}.onError { err ->\n    // onError is called when submit command to galil assembly fails\n    error(err.reason)\n}\nIf you desire to handle errors manually on a per-command basis, the resumeOnError flag can be used. If this flag is set to true, then script execution continues, and action is taken based on custom logic in the script using an .onFailed method. You can still choose to terminate the Sequence using the onFailedTerminate utility. This will cause similar behavior as when the flag is not set by calling the onError or onGlobalError blocks and terminating the sequence, if the SubmitResponse is some kind of error.\nKotlin onSetup(\"submit-error-handling-resume\") { command ->\n    /* =========== Scenario-2 (resumeOnError = true) ============\n     * if submit returns negative response\n     * then current execution flow will continue because resumeOnError = true\n     * Here, all the possible SubmitResponses are expected to be returned\n     */\n    val parameters = intKey(\"target\").set(100)\n    val galilCommand = Setup(\"ESW.iris_darkNight\", \"moveWheel\", command.obsId).add(parameters)\n    val submitResponse: CommandResponse.SubmitResponse = galilAssembly.submit(galilCommand, resumeOnError = true)\n\n    //  First approach - using custom dsl (this is an alternative to kotlin pattern match using when)\n    submitResponse\n            .onStarted { startedRes ->\n                val completedResponse = galilAssembly.queryFinal(startedRes.runId())\n                info(\"command completed with result: ${completedResponse.result}\")\n            }\n            .onCompleted { completed ->\n                info(\"command with ${completed.runId()} is completed with result: ${completed.result}\")\n            }\n            .onFailed { negativeResponse ->\n                error(\"command with ${negativeResponse.runId()} is failed with result: $negativeResponse\")\n\n            }\n\n    // Script writer can still choose to terminate sequence in case of negative response\n    submitResponse.onFailedTerminate()\n}","title":"Error Handling in Scripts"},{"location":"/sequencer/scripts/dsl/services/command-service.html#submitandwait","text":"The submitAndWait DSL method combines submit and queryFinal allowing you to submit a command to an Assembly/HCD and wait for the final response. A timeout can be specified if needed, indicating the time submitAndWait will wait to receive the final SubmitResponse. If this time expires, the command will timeout, breaking script execution flow, and the Sequence is terminated with failure. If timeout is not provided explicitly, then the timeout provided while creating the instance of Assembly or HCD is used as default timeout. This command follows the same error handling semantics as submit as described above.\nKotlin val parameters = intKey(\"target\").set(100)\nval galilCommand = Setup(\"ESW.IRIS_darkNight\", \"moveWheel\", command.obsId).add(parameters)\ngalilAssembly.submitAndWait(galilCommand, timeout = 20.seconds)\nDo I Need a Result Variable? Note that this example does not save the submitAndWait result. If a submitAndWait does not return a result, and since the submitAndWait returns only after the actions are completed, and errors are handled elsewhere, there is not much reason to bother with the result. If it is the case where the command returns a result in the Completed, save the returned Completed value and retrieve the result.","title":"SubmitAndWait"},{"location":"/sequencer/scripts/dsl/services/command-service.html#query","text":"The query DSL method allows you to check the status of a submit command that has returned a Started response . The Started response contains a runId that can be used to identify the command to query. The query command returns immediately while queryFinal waits for the final response. Therefore, query can be used to poll for the final response. Note that if the runId is not present or has been removed from the CRM, the response returned is an Invalid response with an IdNotAvailableIssue. This command follows the same error handling semantics as submit as described above.\nKotlin val response = galilAssembly.submit(command)\nval queryResponse = galilAssembly.query(response.runId())","title":"Query"},{"location":"/sequencer/scripts/dsl/services/command-service.html#queryfinal","text":"The queryFinal DSL method allows querying for the final response of a submit command that has returned a Started response . The Started response contains a runId that can be used to identify the command. A timeout can be specified, indicating how long queryFinal wait for getting the final SubmitResponse. If this time expires, the command will timeout, breaking script execution flow, and the sequence is terminated with failure. If timeout is not provided explicitly, then the timeout provided while creating instance of Assembly/HCD is used. Note that if the runId is not present or has been removed from the CRM, the response returned is an Invalid response with an IdNotAvailableIssue. This command follows the same error handling semantics as submit as described above.\nKotlin val startedResponse = galilAssembly.submit(galilCommand)\nval finalResponse = galilAssembly.queryFinal(startedResponse.runId())","title":"QueryFinal"},{"location":"/sequencer/scripts/dsl/services/command-service.html#subscribecurrentstate","text":"This DSL allows subscribing to the current state data of the Assembly/HCD. You can provide a list of state names to subscribe to. If not provided, all current state values are subscribed to. This DSL takes a callback (or lambda), which is called whenever the Assembly/HCD publishes an item in the list of subscribed values.\nKotlin galilAssembly.subscribeCurrentState(StateName(\"stateName1\")) { currentState ->\n    // do something with currentState matching provided state name\n    println(\"current state : $currentState\")\n}","title":"SubscribeCurrentState"},{"location":"/sequencer/scripts/dsl/services/command-service.html#going-to-online-offline-mode","text":"A Sequencer can command an Assembly or HCD to go to the online or offline state. This is a wrapper for putting another Assembly/HCD into Online or Offline mode. When an Assembly/HCD receives this command, its respective handlers are called. The detailed documentation of Online/Fffline handlers for Assembly/HCD can be found here","title":"Going To online/offline Mode"},{"location":"/sequencer/scripts/dsl/services/command-service.html#gooffline","text":"A declared Assembly/HCD includes a DSL command puts an Assembly/HCD into Offline mode. goOffline can be called from anywhere in script. This results in the triggering of the onGoOffline handler in the component. The following example shows a Sequencer sending the goOffline command to a downstream “Galil Assembly” when it receives a goOffline command.\nKotlin onGoOffline {\n    // do some actions to go offline\n\n    galilAssembly.goOffline()\n\n}","title":"goOffline"},{"location":"/sequencer/scripts/dsl/services/command-service.html#goonline","text":"A declared Assembly/HCD includes a DSL command to put an Assembly/HCD into Online mode. goOnline can be called from anywhere in the script. This results in the triggering of the onGoOnline handler in the component. The following example shows a Sequencer sending the goOnline command to a downstream “Galil Assembly” when it receives a goOnline command.\nKotlin onGoOnline {\n    // do some actions to go online\n    galilAssembly.goOnline()\n}","title":"goOnline"},{"location":"/sequencer/scripts/dsl/services/command-service.html#operations-mode-and-diagnostic-mode","text":"A Sequencer can place an Assembly or HCD in a diagnostic technical data mode. There are two methods in the Assembly/HCD Command Service DSL related to technical data collection.","title":"Operations Mode and Diagnostic Mode"},{"location":"/sequencer/scripts/dsl/services/command-service.html#diagnosticmode","text":"The diagnosticMode DSL method puts an Assembly/HCD into Diagnostic data mode based on a hint at the specified startTime. diagnosticMode can be called from anywhere in script. The hint is specifified by the component. Not all components have diagnostic modes for technical data. The following example shows a Sequencer sending the diagnosticMode command to a downstream “Galil Assembly” when it receives a diagnosticMode command.\nKotlin onDiagnosticMode { startTime, hint ->\n    // do some actions to go to diagnostic mode based on hint\n    galilAssembly.diagnosticMode(startTime, hint)\n}","title":"diagnosticMode"},{"location":"/sequencer/scripts/dsl/services/command-service.html#operationsmode","text":"This operationsMode DSL method returns an Assembly/HCD to Operations mode, the normal running mode. operationsMode can be called from anywhere in script. The following example shows a Sequencer sending the operationsMode command to a downstream “Galil Assembly” when it receives an operationsMode command.\nKotlin onOperationsMode {\n    // do some actions to go to operations mode\n    galilAssembly.operationsMode()\n}","title":"operationsMode"},{"location":"/sequencer/scripts/dsl/services/command-service.html#locking-and-unlocking-assemblies-and-hcds","text":"A Sequencer script can lock and unlock individual Assemblies and HCDs. When a Sequencer locks a component, it is the only component that can send commands to the component that will be accepted.","title":"Locking and Unlocking Assemblies and HCDs"},{"location":"/sequencer/scripts/dsl/services/command-service.html#lock","text":"This Command Service DSL method locks an Assembly/HCD from a Sequencer script for the specified duration. When you lock an Assembly/HCD, the Sequencer sending the lock command is designated as the source, which is the only component that can send commands to the locked component while locked. This DSL returns a LockingResponse which can be LockAcquired in the successful scenario or AcquiringLockFailed in case of failure. This DSL also provides callbacks for onLockAboutToExpire and, onLockExpired where script writer can write custom logic. These callbacks are thread safe.\nKotlin galilAssembly.lock(\n        leaseDuration = 20.seconds,\n        onLockAboutToExpire = {\n            // do something when lock is about to expire\n            publishEvent(SystemEvent(\"ESW.test\", \"TCS.lock.about.to.expire\"))\n        },\n        onLockExpired = {\n            // do something when lock expired\n            publishEvent(SystemEvent(\"ESW.test\", \"TCS.lock.expired\"))\n        }\n)","title":"lock"},{"location":"/sequencer/scripts/dsl/services/command-service.html#unlock","text":"This Command Service DSL method unlocks an Assembly/HCD from a Sequencer script. Only the Sequencer that locked the Assembly/HCD can unlock it. This DSL returns a LockingResponse which can be LockReleased or LockAlreadyReleased in the successful scenario or ReleasingLockFailed in case of failure.\nKotlin galilAssembly.unlock()","title":"unlock"},{"location":"/sequencer/scripts/dsl/services/command-service.html#source-code-for-examples","text":"Command Service Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html","text":"","title":"Sequencer Command Service"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#sequencer-command-service","text":"A Sequencer can send commands to Assemblies and HCDs and Sequences to other Sequencers. In order to interact or send commands from one Sequencer to the other, one needs to create a Sequencer instance first. The API provided by a Sequencer Command Service is tailored to Sequencer to Sequencer functionality.","title":"Sequencer Command Service"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#sequencer","text":"First a Sequencer instance is needed. To create a Sequencer instance, the following parameters need to be passed to the Sequencer method:\nsubsystem: Subsystem of the Sequencer to be resolved and sent commands (for eg. TCS, IRIS) observingMode: observing mode of the Sequencer to be resolved and send commands to (for eg. wfos_imaging, wfos_spec) defaultTimeout: optional max timeout to wait for completion of Sequences sent with sumbitAndWait or queryFinal. The default value for this option is set to 10 hours since it will be common that the handling of Sequences can take a long time, and we don’t want unexpected timeouts to occur in production. For development, it might make sense to set this to some smaller value. This can always be overridden in the specific submitAndWait and queryFinal calls, when appropriate (see below).\nHere is an example:\nKotlin // create a sequencer entity\nval wfos = Sequencer(WFOS, \"wfos_darknight\")\nand here is one showing the setting of the default timeout:\nKotlin // create a sequencer entity with a timeout\nval wfos2 = Sequencer(WFOS, \"wfos_darknight\", 5.minutes)\nResolving a Component with Location Service Since all the components in the TMT architecture are dynamic in nature, which implies they can be shutdown and spawned dynamically on some other location, the Sequencer is resolved each time the Command Service DSL is used. It is possible to create a Sequencer entity for a non-existent component, but a command to the component will fail because the component is resolved when the command is sent.","title":"Sequencer"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#submitting-sequences-to-a-sequencer-querying-the-response","text":"","title":"Submitting Sequences to a Sequencer & Querying the Response"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#creating-a-sequence","text":"Unlike Assemblies and HCDs, Sequencers send Sequences to other Sequencers. A Sequence is a list of SequenceCommand type instances, each of which can be one of the Setup, Observe or Wait types. To create a Sequence, create individual SequenceCommand objects and then create a Sequence with the sequenceOf DSL method as shown below.\nKotlin val wfosCommand1: SequenceCommand = Setup(\"ESW.wfos_darknight\", \"wfosCommand1\")\nval wfosCommand2: SequenceCommand = Setup(\"ESW.wfos_darknight\", \"wfosCommand2\")\nval sequence: Sequence = sequenceOf(wfosCommand1, wfosCommand2)\nThis example Sequence consists of two steps. The Sequencer sends the two step Sequence to the destination Sequencer and waits for it to complete, which means both of the two commands/steps are executed and completed. All Sequence steps must complete successfully for the Sequence to complete successfully.\nThe API for Sequence is here. The API for SequenceCommand is here","title":"Creating a Sequence"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#submit-a-sequence-to-a-sequencer","text":"In order to send a Sequence to another Sequencer, you can use the submit or submitAndWait DSL method as shown in examples below. The submit DSL method sends the Sequence and returns Started if the Sequence is started or Invalid if there is a reason it cannot be started. The query and queryFinal DSL is provided to check the response of a submitted sequence.\nKotlin val submitResponse: SubmitResponse = wfos.submit(sequence)\nval queryResponse: SubmitResponse = wfos.query(submitResponse.runId())\nThe query DSL method allows checking on the state of the Sequence. query returns the current response immediately, which could be either a final response (eg. Completed) or the Started response. The runId of the submitted Sequence can be obtained from the SubmitResponse returned by submit. query is useful in the case where polling of the command is needed or the script needs to take other actions and periodically check for the completion of the Sequence.\nNote that if the runId is not present in the Sequencer or has been removed from the CRM, the response returned is an Invalid response with an IdNotAvailableIssue.\nPlease refer to SubmitResponse extension utilities for using helper methods on SubmitResponse.\nBy default, any negative SubmitResponse (for e.g. Invalid or Error) is treated as a Script error. Refer to error handling section for more details. Alternatively, if you do not want to escalate a negative SubmitResponse, you can use submit Api with resumeOnError flag.\nKotlin val response: SubmitResponse = wfos.submit(sequence, resumeOnError = true)","title":"Submit a Sequence to a Sequencer"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#queryfinal","text":"While query returns immediately, queryFinal will wait for the final response of the Sequence for the defaultTimeout specified at the time of creation of the Sequencer instance.\nKotlin val finalResponse: SubmitResponse = wfos.queryFinal(submitResponse.runId())\nIf you want to increase/decrease the defaultTimeout, you can use the other variation of the same queryFinal DSL method which takes a timeout.\nKotlin val finalRes: SubmitResponse = wfos.queryFinal(submitResponse.runId(), 5.seconds)","title":"QueryFinal"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#sending-a-sequence-with-submitandwait","text":"The submitAndWait DSL method is a combination of submit followed with queryFinal. If you are not interested in the initial response but only in final response of the Sequence, the submitAndWait DSL method is more convenient. It submits the Sequence and waits for the final response. If the Sequence was successfully Started, it will wait until the defaultTimeout specified at the time of creation of the Sequencer instance.\nKotlin val sequenceResponse: SubmitResponse = wfos.submitAndWait(sequence)\nIf you want to increase/decrease the default timeout, you can use the other variation of the same DSL method which takes a timeout.\nKotlin val sequenceRes: SubmitResponse = wfos.submitAndWait(sequence, 5.seconds)","title":"Sending a Sequence with submitAndWait"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#handling-online-and-offline","text":"As with Assemblies and HCDs, a Sequencer can also indicate to another Sequencer to go offline or online using the Sequencer Command Service DSL.","title":"Handling Online and Offline"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#sequencer-sends-goonline","text":"This DSL method is used to send online/offline commands to other sequencers. The Sequencer can go online only if it is currently in the offline state. If this command is received in any other state apart from offline, an Unhandled response will be sent.\nIf the Sequencer is in the Offline state, and it receives the goOnline command, the goOnline handlers of the receiving Sequencer will be called. In case the handlers fail, a GoOnlineHookFailed response would be sent, and the Sequencer remains in the previous state. Otherwise, an Ok response is returned, and the Sequencer goes in online(idle) state.\nKotlin val onlineResponse: GoOnlineResponse = wfos.goOnline()","title":"Sequencer Sends goOnline"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#sequencer-sends-gooffline","text":"Go offline command is received in 2 states only.\nIf the Sequencer is Idle, which means it is not processing any sequence currently If the Sequencer is Loaded with a sequence\nIf this command is sent in any other state apart from these, an Unhandled response will be sent. If the Sequencer is in idle/loaded state, and it receives the goOffline command, the goOffline handlers of the receiving Sequencer will be called. In case the handlers fail, a GoOfflineHookFailed response would be sent, resulting the Sequencer remains in the previous state. Otherwise an Ok message is sent, and the Sequencer goes to offline state.\nKotlin val offlineResponse: GoOfflineResponse = wfos.goOffline()","title":"Sequencer Sends goOffline"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#handling-diagnostic-and-operations-mode","text":"","title":"Handling Diagnostic and Operations Mode"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#diagnostic-mode","text":"The diagnosticMode command can be sent to Sequencers in all states and a DiagnosticModeResponse is returned. If the Sequencer script has defined the diagnostic mode handlers, they will be called. If the handlers execute successfully, an Ok response is sent; otherwise, the DiagnosticHookFailed response is sent.\nKotlin val diagnosticModeResponse: DiagnosticModeResponse = wfos.diagnosticMode(utcTimeNow(), \"engineering\")","title":"Diagnostic Mode"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#operations-mode","text":"The operationsMode command returns a Sequencer in a diagnostic data mode to normal operation. operationsMode is accepted by Sequencers in all states and an OperationsModeResponse is returned to the sender. If the Sequencer has defined its operations mode handlers, they will be called. If the handlers execute successfully, an Ok response is sent; otherwise, the OperationsHookFailed response is sent.\nKotlin val operationsModeResponse: OperationsModeResponse = wfos.operationsMode()","title":"Operations Mode"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#aborting-and-stopping-a-sequence","text":"Stopping and aborting are meant to handle early termination of observing sequences in instruments. Aborting indicates that the current observe should stop as soon as possible and save the data if possible. Stop indicates that the current observe should stop at the end of the current step. In both cases, the observation is over and no subsequent steps can be executed.\nStop and abort commands are accepted only if the Sequencer is in InProgress state, which means it is executing a sequence. If this command is sent in any other state, an Unhandled response is returned. In all other cases, an Ok response is sent.","title":"Aborting and Stopping a Sequence"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#aborting-a-sequence","text":"On receiving the abort command in the InProgress state, the Sequencer will execute the abort sequence handlers and on completion of execution of handlers (whether successful or failed), the Sequencer will discard all the pending steps and return an Ok response.\nNote that, abort of a sequence does not abruptly terminate the in-flight step(s) which are already under execution. It will discard only the pending steps, and the sequence is finished gracefully after the inflight step(s) are finished although the script can take action to end the current step immediately.\nKotlin val abortResponse: OkOrUnhandledResponse = wfos.abortSequence()","title":"Aborting a Sequence"},{"location":"/sequencer/scripts/dsl/services/sequencer-command-service.html#stopping-a-sequence","text":"Stopping a Sequence is very similar to aborting. The only difference is that instead of abort handlers, the stop handlers are called.\nKotlin val stopResponse: OkOrUnhandledResponse = wfos.stop()","title":"Stopping a Sequence"},{"location":"/sequencer/scripts/dsl/services/event-service.html","text":"","title":"Event Service"},{"location":"/sequencer/scripts/dsl/services/event-service.html#event-service","text":"The Event Service DSL is a Kotlin wrapper for the CSW Event Service. This DSL has the ability of publishing, getting, and subscribing to events, and also contains some helper methods for model creation. You can refer to the detailed documentation of Event Service provided by CSW here.","title":"Event Service"},{"location":"/sequencer/scripts/dsl/services/event-service.html#helper-methods","text":"These methods can be used to create Systerm and Observe Events. Additionally, a System or Observe “Event Variable” can be created that can be tied to the first value of a parameter of an Event, similar to the way local variables are tied to “process variables” in the EPICS State Notation Language (see EPICS Sequencer Documentation for more information).","title":"Helper Methods"},{"location":"/sequencer/scripts/dsl/services/event-service.html#systemevent","text":"Helper DSL to create a SystemEvent from the provided prefix, event name and parameters (optional).\nKotlin val parameters = intKey(\"stepNumber\").set(1)\nval systemEvent: SystemEvent = SystemEvent(\"ESW.IRIS_darkNight\", \"stepInfo\", parameters)","title":"SystemEvent"},{"location":"/sequencer/scripts/dsl/services/event-service.html#observeevent","text":"Helper DSL to create an ObserveEvent from the provided prefix, event name and parameters (optional).\nKotlin val parameters = intKey(\"stepNumber\").set(1)\nval observeEvent: ObserveEvent = ObserveEvent(\"ESW.IRIS_darkNight\", \"observationStarted\")","title":"ObserveEvent"},{"location":"/sequencer/scripts/dsl/services/event-service.html#systemvar","text":"Helper DSL to create an EventVariable corresponding to a parameter of a SystemEvent. This DSL needs the initial value of the parameter, the name of the EventKey, and the ParameterKey of the connected parameter. More details about SystemVars are provided in the FSM documentation\nKotlin val locKey = intKey(\"current-location\")\nval systemVar: EventVariable<Int> = SystemVar(0, \"IRIS.ifs.motor.position\", locKey)","title":"SystemVar"},{"location":"/sequencer/scripts/dsl/services/event-service.html#observevar","text":"Helper DSL to create an EventVariable corresponding to a parameter of an ObserveEvent. This DSL needs the initial value of the parameter, the name of the EventKey and the ParameterKey of the connected parameter. More details about ObserveVars are provided in the FSM documentation\nKotlin val readNumberKey = intKey(\"readNumber\")\nval observeVar: EventVariable<Int> = ObserveVar(0, \"IRIS.ifs.detector.readCompleted\", readNumberKey)","title":"ObserveVar"},{"location":"/sequencer/scripts/dsl/services/event-service.html#publishevent","text":"DSL to publish the given Event.\nKotlin val systemEvent: SystemEvent = SystemEvent(\"ESW.IRIS_darkNight\", \"stepInfo\", parameters)\npublishEvent(systemEvent)\nThis DSL can also publish events periodically when provided with the optional duration and an event generator function. In the below example, an Event with temperature Key will get published every 10 seconds, with current temperature value given by getTemperature method.\nKotlin publishEvent(10.seconds) {\n    val temperatureKey = intKey(\"temperature\").set(getTemperature())\n    SystemEvent(\"ESW.IRIS_darkNight\", \"temperature\", temperatureKey)\n}","title":"publishEvent"},{"location":"/sequencer/scripts/dsl/services/event-service.html#onevent","text":"DSL to subscribe to events getting published on the given EventKey names. This DSL takes a callback as a lambda which operates on an event. The callback block will be invoked whenever an Event is published on any of the provided event keys.\nKotlin val tempEventKey = \"IRIS.env.temperature.temp\"\nval stateEventKey = \"IRIS.env.temperature.state\"\nonEvent(tempEventKey, stateEventKey) { event ->\n    // logic to execute on every event\n    println(event.eventKey())\n}\nThis DSL has the ability to control the subscription rate by providing a duration with the callback. This operates like the Rate Adapter Mode for regular Event Service subscriptions.\nKotlin onEvent(tempEventKey, stateEventKey, duration = 2.seconds) { event ->\n    // logic to execute on every event\n    println(event.eventKey())\n}","title":"onEvent"},{"location":"/sequencer/scripts/dsl/services/event-service.html#getevent","text":"DSL to get the latest Event published on each of the given EventKey names.\nKotlin val tempEventKey = \"IRIS.env.temperature.temp\"\nval stateEventKey = \"IRIS.env.temperature.state\"\nval events: Set<Event> = getEvent(tempEventKey, stateEventKey)","title":"getEvent"},{"location":"/sequencer/scripts/dsl/services/event-service.html#source-code-for-examples","text":"Event Service Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/services/logging-service.html","text":"","title":"Logging Service"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#logging-service","text":"The Logging Service DSL is a wrapper for the Logging Service module provided by CSW. You can refer to the detailed documentation of Logging Service provided by CSW here.\nThe CSW documentation explains all the supported logging related configurations for example, default log level, component specific log levels, log appender etc. It also explains how to override default values.\nAll Sequencer scripts are expected to be kept inside the sequencer-scripts repo under Subsystem specific directories. Read more about adding new scripts and script specific configuration files here.\nThe default log level for sequencers can be set using command line options. See the SequencerApp documentation for more information.\nThe Logging Service DSL exposes following APIs to script writers for logging at different levels:","title":"Logging Service"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#trace","text":"Kotlin trace(message = \"logging at trace level\")\n\ntrace(message = \"logging at trace level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"trace"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#debug","text":"Kotlin debug(message = \"logging at debug level\")\n\ndebug(message = \"logging at debug level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"debug"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#info","text":"Kotlin info(message = \"logging at info level\")\n\ninfo(message = \"logging at info level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"info"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#warn","text":"Kotlin warn(message = \"logging at warn level\")\n\nwarn(message = \"logging at warn level\", cause = highTempRaisedEx)\n\nwarn(message = \"logging at warn level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))\n\nwarn(message = \"logging at warn level\", cause = highTempRaisedEx,\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"warn"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#error","text":"Kotlin error(message = \"logging at error level\")\n\nerror(message = \"logging at error level\", cause = highTempRaisedEx)\n\nerror(message = \"logging at error level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))\n\nerror(message = \"logging at error level\", cause = highTempRaisedEx,\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"error"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#fatal","text":"Kotlin fatal(message = \"logging at fatal level\")\n\nfatal(message = \"logging at fatal level\", cause = highTempRaisedEx)\n\nfatal(message = \"logging at fatal level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))\n\nfatal(message = \"logging at fatal level\", cause = highTempRaisedEx,\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"fatal"},{"location":"/sequencer/scripts/dsl/services/logging-service.html#source-code-for-examples","text":"Logging Service Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/services/alarm-service.html","text":"","title":"Alarm Service"},{"location":"/sequencer/scripts/dsl/services/alarm-service.html#alarm-service","text":"The Alarm Service DSL is a wrapper for the Alarm Service module provided by CSW. You can refer to detailed documentation of the Alarm Service provided by CSW here.\nThis DSL provides an API to set the severity of alarm.","title":"Alarm Service"},{"location":"/sequencer/scripts/dsl/services/alarm-service.html#setseverity","text":"This API sets alarm severity for an AlarmKey to the provided level and keeps refreshing it in the background with the interval of config value csw-alarm.refresh-interval. Default value for csw-alarm.refresh-interval config is 3 seconds which is configured in downstream CSW alarm modules reference.conf file.\nThe setSeverity API requires user to provide AlarmKey and AlarmSeverity.","title":"setSeverity"},{"location":"/sequencer/scripts/dsl/services/alarm-service.html#alarmkey","text":"AlarmKey represents unique alarm in the given subsystem and component e.g. nfiraos.trombone.tromboneaxislowlimitalarm\nThe following example demonstrates the creation of an AlarmKey\nKotlin val tromboneTemperatureAlarm =\n        AlarmKey(Prefix(NFIRAOS, \"trombone\"), \"tromboneMotorTemperatureAlarm\")","title":"AlarmKey"},{"location":"/sequencer/scripts/dsl/services/alarm-service.html#alarmseverity","text":"The supported AlarmSeverity levels are:\nOkay Warning Major Indeterminate Disconnected Critical\nThe following example demonstrates the usage of the setSeverity API. In this example, a temperature FSM is created, and based on the state of the FSM, the severity is set accordingly.\nState Temperature Severity OK Temperature less than or equal to 40 Okay ERROR Temperature is greater than 40 Major\nKotlin /**\n * temp <= 40   => Severity.Okay\n * else        => Severity.Major\n */\nval temperatureFsm = Fsm(\"TEMP\", OK) {\n    state(OK) {\n        entry {\n            setSeverity(tromboneTemperatureAlarm, Okay)\n        }\n\n        on(temperatureVar.get() > 40) {\n            become(ERROR)\n        }\n    }\n\n    state(ERROR) {\n        entry {\n            setSeverity(tromboneTemperatureAlarm, Major)\n        }\n\n        on(temperatureVar.get() <= 40) {\n            become(OK)\n        }\n    }\n}","title":"AlarmSeverity"},{"location":"/sequencer/scripts/dsl/services/alarm-service.html#source-code-for-examples","text":"Alarm Service Examples","title":"Source code for examples"},{"location":"/sequencer/scripts/dsl/services/time-service.html","text":"","title":"Time Service Access in Scripts"},{"location":"/sequencer/scripts/dsl/services/time-service.html#time-service-access-in-scripts","text":"The time and scheduling functionality of the CSW Time Service are available to script writers. Time Service DSL provides access to the Time Service module provided by CSW. This DSL exposes the following API calls to script writers to access time and schedule tasks.","title":"Time Service Access in Scripts"},{"location":"/sequencer/scripts/dsl/services/time-service.html#time-access","text":"Time Service provides access to both TAI and UTC time that is synchronized at the telescope site with time on all the other computers and also with absolute time provided by a GPS system.\nTime access calls are made available to all scripts. Access to some time functionality requires the import of kotlin.time packages.","title":"Time Access"},{"location":"/sequencer/scripts/dsl/services/time-service.html#access-utc-time-with-utctimenow","text":"The utcTimeNow Time Service utility returns the current UTC time. The time value returned is a CSW UTCTime type, which is an absolute time value.\nKotlin val currentUtcTime = utcTimeNow()","title":"Access UTC Time with utcTimeNow"},{"location":"/sequencer/scripts/dsl/services/time-service.html#access-tai-time-with-taitimenow","text":"The taiTimeNow Time Service utility returns the current TAI time. The time value returned is a CSW TAITime type, which is an absolute time value.\nKotlin val currentTaiTime = taiTimeNow()","title":"Access TAI Time with taiTimeNow"},{"location":"/sequencer/scripts/dsl/services/time-service.html#access-utc-time-in-the-future-with-utctimeafter","text":"The utcTimeAfter Time Service utility provides an absolute UTC time some amount of time from now in the future. The value provided is a duration such as “1 hour”. The returned value is an absolute UTCTime type. The following example shows provides UTC time 1 hour from now.\nKotlin val utcTime = utcTimeAfter(1.hours)","title":"Access UTC time in the Future with utcTimeAfter"},{"location":"/sequencer/scripts/dsl/services/time-service.html#access-tai-time-in-the-future-with-taitimeafter","text":"The taiTimeAfter Time Service utility provides an absolute TAI time some amount of time from now in the future. The value provided is a duration. The returned value is an absolute TAITime type. The following example shows provides TAI time 1 hour from now.\nKotlin val taiTime = taiTimeAfter(1.hours)","title":"Access TAI Time in the Future with taiTimeAfter"},{"location":"/sequencer/scripts/dsl/services/time-service.html#scheduling-with-time-service","text":"The Time Service DSL provides script access to the CSW scheduling library allowing scripts to schedule one-off and periodic tasks. Access to the Time Service scheduling functionality is provided in the script writing environment with no extra imports.","title":"Scheduling with Time Service"},{"location":"/sequencer/scripts/dsl/services/time-service.html#using-scheduleonce","text":"The scheduleOnce Time Service DSL allows scheduling a task in a script once at the specified absolute UTC or TAI time. The function schedules the task and returns a handle that can be used to cancel the execution of the task if it has not yet executed. The task is a callback which will be executed in thread safe way.\nThe following example shows an onSetup handler of a script extracting a scheduled time from a Setup command and then uses the scheduleOnce to send a motion command to a Galil Assembly at the scheduled time.\nKotlin val scheduleTimeKey = utcTimeKey(\"scheduledTime\")\nval schedulePrefix = \"esw.test\"\nval galilAssembly = Assembly(TCS, \"galil\")\n\n//Usage inside handlers - schedule tasks while handling setup/observe commands\nonSetup(\"schedule-once\") { command ->\n    val scheduledTime = command(scheduleTimeKey)\n    val probeCommand = Setup(schedulePrefix, \"scheduledOffset\", command.obsId)\n\n    scheduleOnce(scheduledTime.head()) {\n        galilAssembly.submit(probeCommand)\n    }\n}","title":"Using scheduleOnce"},{"location":"/sequencer/scripts/dsl/services/time-service.html#using-scheduleoncefromnow","text":"Often, it is necessary to schedule a task in the future some amount of time from now. The scheduleOnceFromNow API allows scheduling non periodic task in script after a specified duration. The task is a callback which will be executed in thread-safe way. This API takes a time Duration type after which task will be scheduled.\nThe following example shows the scheduling of a task after 1 hour from now. The function takes a duration and returns a handle which can be used to cancel the execution of the task if it has not yet executed.\nKotlin scheduleOnceFromNow(1.hours) {\n    publishEvent(SystemEvent(\"LGSF\", \"publish.success\"))\n}","title":"Using scheduleOnceFromNow"},{"location":"/sequencer/scripts/dsl/services/time-service.html#using-scheduleperiodically","text":"The schedulePeriodically API allows scheduling a task to execute periodically at a given interval starting at a provided absolute start time. The provided task is a callback, which will be executed in thread-safe way.\nInitially, the task is executed once at the given start time followed by periodic execution of the task at the requested period. This function returns a handle that can be used to cancel the execution of further tasks.\nThe following example shows the scheduling of a task in an onSetup handler that starts running at the time provided in a parameter and then runs every 5 seconds until stopped.\nKotlin val offsetTimeKey = utcTimeKey(\"offsetTime\")\nval offsetPrefix = \"esw.offset\"\nval assemblyForOffset = Assembly(TCS, \"galil\")\n\nonSetup(\"schedule-periodically\") {command ->\n    val scheduledTime = command(offsetTimeKey)\n    val probeCommand = Setup(schedulePrefix, \"scheduledOffset\", command.obsId)\n\n    schedulePeriodically(scheduledTime.head(), interval = 5.seconds) {\n        assemblyForOffset.submit(probeCommand)\n    }\n}","title":"Using schedulePeriodically"},{"location":"/sequencer/scripts/dsl/services/time-service.html#using-scheduleperiodicallyfromnow","text":"The schedulePeriodicallyFromNow API is like schedulePeriodically but takes a duration as the start time rather than an absolute time. Initially, the task is executed once after a delay from the current time specified by the duration time. This execution is followed by periodic execution of the task at the requested period. The task is a callback which will be executed in thread-safe way. This function returns a handle that can be used to cancel the execution of further tasks.\nThe following example shows scheduling the publishing of an Event after 1 hour from now and then publishes an Event periodically with a 10 second period until cancelled.\nKotlin schedulePeriodicallyFromNow(1.hours, 10.seconds) {\n    publishEvent(SystemEvent(\"LGSF\", \"publish.success\"))\n}\nLimits of Scheduling The script environment for scheduling tasks should not be relied upon for very short periods or low jitter applications.","title":"Using schedulePeriodicallyFromNow"},{"location":"/sequencer/scripts/dsl/services/time-service.html#source-code-for-above-examples","text":"Time Service Example Script","title":"Source code for above examples"},{"location":"/sequencer/scripts/dsl/services/database-service.html","text":"","title":"Database Service"},{"location":"/sequencer/scripts/dsl/services/database-service.html#database-service","text":"The Database Service DSL is a wrapper for the Database Service module provided by CSW. You can refer to detailed documentation of the Database Service provided by CSW here.\nThis DSL provides APIs to create the connection to database.","title":"Database Service"},{"location":"/sequencer/scripts/dsl/services/database-service.html#create-database-connection-read-access-","text":"This API allows creating connection to database with default read access. The username and password for read access is picked from environment variables set on individual’s machine i.e. DB_READ_USERNAME and DB_READ_PASSWORD. It is expected that developers set these variables before calling this method. It returns Jooq’s DSLContext or fails with DatabaseException. DSLContext provide methods like fetchAsync, executeAsync, executeBatch, etc. Moreover, see JooqHelper in CSW which provides wrapper methods on Jooq’s DSLContext.","title":"Create Database Connection (Read Access)"},{"location":"/sequencer/scripts/dsl/services/submit-response-extensions.html","text":"","title":"Extension utilities on SubmitResponse"},{"location":"/sequencer/scripts/dsl/services/submit-response-extensions.html#extension-utilities-on-submitresponse","text":"A submit or query (and other Command Service or Sequencer Command Service API calls) always return a positive SubmitResponse unless called with resumeOnError flag as true. For submit, the two possible positive responses are Started and Completed. They can be handled using the .onStarted and .onCompleted methods, respectively. These methods allow you to specify a block of code to be called in each of those cases.\nKotlin val positiveSubmitResponse: SubmitResponse = assembly.submit(command)\n\npositiveSubmitResponse\n        .onStarted { startedResponse ->\n            val finalResponse: SubmitResponse = assembly.queryFinal(startedResponse.runId())\n            info(\"command completed with result: $finalResponse\")\n        }\n        .onCompleted { completedResponse ->\n            info(\"command with ${completedResponse.runId()} is completed with result: ${completedResponse.result}\")\n        }\nAlternatively, a Kotlin when can be used to perform pattern matching on the result. An example of that is shown below.\nKotlin when (positiveSubmitResponse) {\n    is Started -> {\n        val finalResponse: SubmitResponse = assembly.queryFinal(positiveSubmitResponse.runId())\n        info(\"command completed with response: $finalResponse\")\n    }\n    is Completed -> info(\"command with ${positiveSubmitResponse.runId()} is completed\")\n}\nIf you desire to handle errors manually on a per-command basis, the resumeOnError flag can be used. If this flag is set to true, then script execution continues, and action is taken based on custom logic in script by using an .onFailed method.\nKotlin val submitResponse: SubmitResponse = assembly.submit(command, resumeOnError = true)\npositiveSubmitResponse.onFailed { failedResponse ->\n    error(\"command completed with result: $failedResponse\")\n}\nYou can still choose to terminate sequence using the onFailedTerminate utility. This will cause similar behavior as when flag is not set by calling the onError or onGlobalError blocks and terminating the sequence, if the SubmitResponse is some kind of error.\nKotlin val submitRes: SubmitResponse = assembly.submit(command, resumeOnError = true)\npositiveSubmitResponse.onFailedTerminate()","title":"Extension utilities on SubmitResponse"},{"location":"/sequencer/scripts/dsl/services/params.html","text":"","title":"Params"},{"location":"/sequencer/scripts/dsl/services/params.html#params","text":"A Kotlin Dsl has been provided for creating Parameters to store values like primitive types, collection types or domain specific types. This Dsl is built over abstractions like Parameter, KeyType etc offered by CSW. Refer to the CSW doc for more information about this.","title":"Params"},{"location":"/sequencer/scripts/dsl/services/params.html#keys","text":"Following table lists all the key types, and their corresponding kotlin dsl provided.\nKeyType Kotlin Dsl Boolean booleanKey Character charKey Byte byteKey Short shortKey Long longKey Int intKey Float floatKey Double doubleKey String stringKey UtcTime utcTimeKey TaiTime taiTimeKey ByteArray byteArrayKey ShortArray shortArrayKey LongArray longArrayKey IntArray intArrayKey FloatArray floatArrayKey DoubleArray doubleArrayKey ByteMatrix byteMatrixKey ShortMatrix shortMatrixKey LongMatrix longMatrixKey IntMatrix intMatrixKey FloatMatrix floatMatrixKey DoubleMatrix doubleMatrixKey Choice choiceKey Struct structKey RaDec raDecKey EqCoord eqCoordKey SolarSystemCoord solarSystemCoordKey MinorPlanetCoord minorPlanetCoordKey CometCoord cometCoordKey AltAzCoord altAzCoordKey Coord (*) coordKey\nExample below shows usages of Dsl for different types of keys. Some other helper Dsl like struct, choicesOf, arrayData, matrixData etc have also been provided for ease of access. Usage of this helper Dsl is also shown in the below example.\nKotlin // Primitive keys\nval encoderKey: Key<Int> = intKey(\"encoder\")\nval flagKey: Key<Boolean> = booleanKey(\"flag\")\nval eventTimeKey: Key<UTCTime> = utcTimeKey(\"event-time\")\n\n// Arrays\nval arrayKey: Key<ArrayData<Int>> = intArrayKey(\"arrayKey\")\nval elms: Array<Int> = arrayOf(1, 2, 3, 4)\nval values1: ArrayData<Int> = arrayData(elms)\nval values2: ArrayData<Int> = arrayData(5, 6, 7, 8)\nval arrayParam: Parameter<ArrayData<Int>> = arrayKey.set(values1, values2)\n\n// Matrix\nval matrixKey: Key<MatrixData<Int>> = intMatrixKey(\"matrixKey\")\nval arr1: Array<Int> = arrayOf(1, 2, 3, 4)\nval arr2: Array<Int> = arrayOf(5, 6, 7, 8)\nval elms1: Array<Array<Int>> = arrayOf(arr1, arr2)\nval data1: MatrixData<Int> = matrixData(elms1)\nval data2: MatrixData<Int> = matrixData(arr1, arr2)\nval matrixParameter: Parameter<MatrixData<Int>> = matrixKey.set(data1, data2)\n\n// Domain specific types\nval choiceKey: Key<Choice> = choiceKey(\"choice\", choicesOf(\"A\", \"B\", \"C\"))\nval choiceParam: Parameter<Choice> = choiceKey.set(Choice(\"A\"), Choice(\"C\"))\n\n// Struct\nval intParam: Parameter<Int> = encoderKey.set(1, 2, 3)\nval paramSet: Set<Parameter<*>> = setOf(intParam, choiceParam)\nval complexKey: Key<Struct> = structKey(\"complexKey\")\nval struct1: Struct = struct(paramSet)\nval struct2: Struct = struct(command.params)\nval struct3: Struct = struct(intParam, arrayParam)\nval structParam: Parameter<Struct> = complexKey.set(struct1, struct2, struct3)","title":"Keys"},{"location":"/sequencer/scripts/dsl/services/params.html#creating-parameters","text":"Example below shows different ways of creating parameters and adding them to a command.\nKotlin val temperatureKey: Key<Int> = intKey(\"temperature\")\nval temperatureParam: Parameter<Int> = temperatureKey.set(1, 2, 3)\n\n// with values as Array\nval encoderKey: Key<Int> = intKey(\"encoder\")\nval encoderValues: Array<Int> = arrayOf(1, 2, 3)\nval encoderParam: Parameter<Int> = encoderKey.set(*encoderValues)\n\n// with units\nval powerKey: Key<Double> = doubleKey(\"power\")\nval values: Array<Double> = arrayOf(1.1, 2.2, 3.3)\nval powerParam: Parameter<Double> = powerKey.set(values, watt())\n\n// adding a param to command or event\nval setupCommand: Setup = Setup(\"ESW.iris_darkNight\", \"move\").add(temperatureParam)\nval systemEvent: SystemEvent = SystemEvent(\"ESW.iris_darkNight\", \"movement\").add(temperatureParam)\n\n// adding multiple params\nval setupCommand2: Setup = Setup(\"ESW.iris_darkNight\", \"move\").madd(temperatureParam, encoderParam)\n\n// adding params of one command to other\nval paramsFromIncomingCommand: Params = command.params\nval commandForDownstream: Setup = Setup(\"ESW.iris_darkNight\", \"move\").add(paramsFromIncomingCommand)","title":"Creating Parameters"},{"location":"/sequencer/scripts/dsl/services/params.html#extracting-a-parameter-from-params-command-event","text":"","title":"Extracting a parameter from Params/Command/Event"},{"location":"/sequencer/scripts/dsl/services/params.html#extracting-parameter","text":"Finding a parameter from Params/Command/Event.\nKotlin val params: Params = setupCommand.params\nval maybeParam: Parameter<Int>? = params.kFind(temperatureParam)\nval maybeParam2: Parameter<Int>? = setupCommand.kFind(temperatureParam)","title":"Extracting parameter"},{"location":"/sequencer/scripts/dsl/services/params.html#extracting-parameter-by-key","text":"Kotlin // extracting a param from Params instance\nval temperatureParameter: Parameter<Int>? = setupCommand.params.kGet(temperatureKey)\nval temperatureParameter2: Parameter<Int> = (setupCommand.params)(temperatureKey) // alternative\n\n// extracting a param directly from the command or event\nval temperatureParameter3: Parameter<Int>? = setupCommand.kGet(temperatureKey)\nval temperatureParameter4: Parameter<Int> = setupCommand(temperatureKey) // alternative","title":"Extracting parameter by key"},{"location":"/sequencer/scripts/dsl/services/params.html#extracting-parameter-by-keyname-and-keytype","text":"Kotlin val keyName = \"temperature\"\nval keyType: KeyType<Int> = JKeyType.IntKey()\nval param: Parameter<Int>? = setupCommand.params.kGet(keyName, keyType)","title":"Extracting parameter by keyName and KeyType"},{"location":"/sequencer/scripts/dsl/services/params.html#extracting-values-from-a-parameter","text":"Example below shows accessing values of a parameter, or accessing a specific value of a parameter.\nKotlin val temperatureKey: Key<Int> = intKey(\"temperature\")\nval temperatureParam: Parameter<Int> = temperatureKey.set(1, 2, 3)\n\n// extracting values from parameter\nval temperatureValues: List<Int> = temperatureParam.values\n\n// extracting first value from parameter\nval firstValue: Int = temperatureParam.first\n\n// extracting value of the parameter at a given index\nval temperatureValue: Int? = temperatureParam.kGet(1)\nval temperatureValue2: Int = temperatureParam(1) //alternative\nNote Note that the shorthand alternatives shown with // alternative comment in above examples, do not return optional values unlike their corresponding full version. Which means, with shorthand dsl, an error will occur in absence of the specified key/index.","title":"Extracting values from a parameter"},{"location":"/sequencer/scripts/dsl/services/params.html#removing-a-parameter","text":"A parameter could be removed from Params instance or from Command directly. Below example demonstrates both the dsl methods.\nKotlin // remove param from params by key\nval updatedParams: Params = setupCommand.params.remove(temperatureKey)\n\n// remove param from params\nval updatedParams2: Params = setupCommand.params.remove(temperatureParameter)\n\n// remove param from command by key\nval updatedCommand: Setup = setupCommand.remove(temperatureKey)\n\n// remove param from command\nval updatedCommand2: Setup = setupCommand.remove(temperatureParameter)","title":"Removing a parameter"},{"location":"/sequencer/scripts/dsl/services/params.html#checking-if-a-parameter-exists","text":"Kotlin // check if parameter with specified key exists in Params\nval temperatureKeyExists: Boolean = setupCommand.params.exists(temperatureKey)\n\n// check if parameter with specified key exists directly from command\nval temperatureKeyExists2: Boolean = setupCommand.exists(temperatureKey)","title":"Checking if a parameter exists"},{"location":"/sequencer/state-transition.html","text":"","title":"Sequencer State Transition"},{"location":"/sequencer/state-transition.html#sequencer-state-transition","text":"Sequencer is implemented as a Finite State Machine. It has a set of states, and at any given time it could be in exactly one of those states. It supports a set of commands/messages, and on receiving those commands, it might choose to go in some other state.\nFollowing are the states supported by the Sequencer:\nIdle/Online: This is the default state of the Sequencer. A Sequencer is idle when it is up, but there’s no sequence under execution. A Sequencer can come to idle state from the following situations: when the Sequencer comes up for the first time when the Sequencer has finished execution of a sequence when the Sequencer was offline, and a goOnline command is sent Loaded: A Sequencer is in loaded state when a sequence is loaded for execution, but execution of the sequence hasn’t started. A separate start command is expected to start execution of the sequence. All sequence editor actions (for e.g. add, remove, reset) are accepted in this state. From this state, the Sequencer can go in InProgress state on receiving a start command, or it could go in offline state if goOffline command is sent. On receiving a reset command, which discards all the pending steps, the Sequencer will go to idle state. InProgress/Running: The Sequencer is in running state, only when it is executing a sequence. All sequence editor actions (for e.g. add, remove, reset) are accepted in this state. From running state, the Sequencer can go to idle state on completion of sequence, or it can be killed. In order to go offline from this state, the Sequencer has to go to idle and then offline. Offline: The Sequencer goes in offline state, only on receiving a goOffline command which can either come from an upstream sequencer, or from a user through the admin dashboard. In this state, only a few commands are excepted (for eg. goOnline, shutdown, status etc). Killed: This is the final state of the sequencer. The shutdown command can be sent in any state, hence a Sequencer can transition to this state from any other state.","title":"Sequencer State Transition"},{"location":"/apps/apps.html","text":"","title":"Applications"},{"location":"/apps/apps.html#applications","text":"Prerequisites Getting ESW Apps sequencer-app","title":"Applications"},{"location":"/apps/apps.html#prerequisites","text":"For starting and running ESW apps for development, you need to run CSW services like location-server, event-service etc. Please refer to the doc here to run CSW services.","title":"Prerequisites"},{"location":"/apps/apps.html#getting-esw-apps","text":"Developer has to download esw-apps-<some-version>.zip from esw github releases and unzip it. There are two folders, as follows, in esw-apps-<some-version>\nbin lib\nAll the apps provided by ESW reside in bin folder.","title":"Getting ESW Apps"},{"location":"/apps/sequencerapp.html","text":"","title":"sequencer-app"},{"location":"/apps/sequencerapp.html#sequencer-app","text":"A command line application that facilitates starting Sequence Component and/or Sequencer.","title":"sequencer-app"},{"location":"/apps/sequencerapp.html#supported-commands","text":"seqcomp sequencer","title":"Supported Commands"},{"location":"/apps/sequencerapp.html#sequence-component-seqcomp-","text":"Spawns a new Sequence Component with provided subsytem and name. Note that with this command, only sequence component is spawned, not a sequencer. A separate loadScript command needs to be sent to the sequence component to spawn a sequencer inside it.\nSee sequencer command to spawn a sequence component and a sequencer in single command.\nOptions accepted by this command are described below:\n-s : subsystem of the sequence component, for e.g. tcs, iris etc -n, --name : optional name for sequence component, for e.g. primary, backup etc","title":"Sequence Component (seqcomp)"},{"location":"/apps/sequencerapp.html#examples-","text":"esw-ocs-app seqcomp -s tcs -n primary\nesw-ocs-app seqcomp -s tcs\nNote If sequence component name is not specified, a new name (prefixed with subsystem) will be generated for the sequence component. For e.g. TCS_123, IRIS_123","title":"Examples:"},{"location":"/apps/sequencerapp.html#sequencer-sequencer-","text":"Spawns two things:\nSequenceComponent: with provided subsystem, name Sequencer: with provided observing mode and subsytem of sequencer (-i option) if specified or else subsystem of sequence component (-s option)\nOptions accepted by this command are described below:\n-s : subsystem of the sequence component, for e.g. tcs, iris etc -n, --name : optional name for sequence component, for e.g. primary, backup etc -i : optional subsystem of sequencer script, for e.g. tcs, iris etc. Default value: subsystem provided by -s option -m, --mode : observing mode, for e.g. darknight","title":"Sequencer (sequencer)"},{"location":"/apps/sequencerapp.html#examples-","text":"Below example will spawn a sequence component OCS-primary and a sequencer TCS-darknight in it.\nesw-ocs-app sequencer -s ocs -n primary -i tcs -m darknight\nExample below will spawn a sequence component IRIS-primary and a sequencer IRIS-darknight in it.\nesw-ocs-app sequencer -s iris -n primary -m darknight","title":"Examples:"},{"location":"/apps/sequencerapp.html#setting-the-default-log-level","text":"The default log level for any component is specified in the application.conf file of the component. In this case, the Sequence Component is shared code among all Sequencers. Therefore, to specify a log level for your Sequencer, use the java -D option to override configuration values at runtime. For log level, the format is:\n-Dcsw-logging.component-log-levels.<Subsystem>.<observingMode>=<LEVEL>\nFor example, using the example above:\nesw-ocs-app sequencer -s iris -n primary -m darknight -Dcsw-logging.component-log-levels.IRIS.darknight=TRACE","title":"Setting the default log level"}]}