{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"TMT Executive Software Documentation"},{"location":"/index.html#tmt-executive-software-documentation","text":"Executive Software Overview Observatory Control System (OCS) ESW Phase 1 Development Sequencers and Sequence Components Sequencers in the Executive Software What is a Sequence Component, Sequencer, Script, and Sequence? Sequencer is an OMOA Component Defining Observing Modes Registering Sequencers in Location Service Sequencer Technical Design Running a Sequencer Using ocs-app Prerequisites for Running ocs-app 1. Install coursier and the TMT Apps Channel 2. Install ocs-app 3. Start Any Needed CSW Services 4. Run ocs-app Setting the Default Log Level Sequencer Scripts Sequencer Script Styles Handler-Oriented Scripts State Machine-Oriented Scripts Mixing the Two Styles Script DSL Constructs Defining A Script Script Handlers Including Looping in Scripts Finite State Machines Blocking Operations Within Script Other DSL CSW Services DSL Location Service Using the Configuration Service in Scripts Command Service for Assemblies and HCDs Sequencer Command Service Event Service Logging Service Alarm Service Time Service Access in Scripts Database Service Extension utilities on SubmitResponse Parameters User Interface Support User Interfaces in ESW and TMT ESW.UISTD and ESW.HCMS User Interface Support in ESW Phase 1 ESW Phase 1 Overview Front-end UI Applications Back-end UI Applications Creating and Using the Frontend UI Template Needs to be Written Creating and Using the UI Backend Template Installation Create Starter Project User Interface Gateway ESW Gateway with Authentication and Authorization Sample Requests Gateway Technical Design Running the UI Gateway App Prerequisites for Running gateway-server 1. Install coursier and the TMT Apps Channel 2. Start Any Needed CSW Services 3. Install gateway-server Setting the Default Log Level Technical Design Documents Sequence Manager Technical Documentation Introduction to Sequence Manager Modules Implementation Details Sequence Manager States Running Sequence Manager Sequence Manager simulation mode Sequencer Technical Documentation Modules Sequence execution process Implementation Details Sequencer Interfaces Interacting with Sequencer Running Sequencer Sequence Component Technical Documentation Introduction Modules Implementation Details Sequence Component Lifecycle Running Sequence Component Gateway Technical Documentation Implementation API call flow Modules Running Gateway Server Service Contracts Json Contract Agent Service and Agent Technical Documentation Agent Service Introduction Agent Service Implementation Details Agent Service Module (esw-agent-service) Agent Introduction Agent Implementation Agent Module (esw-agent-akka) Agent Client Running Agent and Agent Service Applications Getting and Running ESW Applications Starting Sequence Manager Using sequence-manager Agent Service App Agent App","title":"TMT Executive Software Documentation"},{"location":"/esw/eswOverview.html","text":"","title":"Executive Software Overview"},{"location":"/esw/eswOverview.html#executive-software-overview","text":"The functionality of TMT Observatory Software is provided by three Level 2 software subsystems in the Observatory Software Architecture of which ESW is one (the others are Data Management System, and Science Operations Support Software). ESW itself consists of five subsystems: ESW.OCS, Observatory Control System; ESW.UISTD, User Interface Standards, ESW.HCMS, High-level Control and Monitoring System; ESW.VIZ, Visualization System; ESW.ACQ, Acquisition and Observing Scripts. The ESW subsystems are largely independent, although ACQ does depend on OCS. However, the subsystems work together to provide the total functionality needed for OSW.\nThe OSW software architecture is split into the Technical Architecture and the Functional Architecture. ESW is part of the Functional Architecture that provides the software applications and components that implement the functionality of the observatory from the point of view of the users. It depends on and uses the Technical Architecture provided by the Common Software (CSW) subsystem. See CSW documentation here..\nThe ESW subsystems provide the core functionality needed to enable the TMT operations modes including: PI-Directed observing, Pre-planned Service Queue, and conditions-based queue scheduled observing. The ESW enables operation of all TMT subsystems from user interfaces or other programs. Sequencing is the term used to describe the operations the software system must do to coordinate control of the telescope subsystems and the instruments in the specific order needed to collect science data. The Observatory Control System (OCS) subsystem of ESW is the central engine that provides the sequencing functionality. The Sequencing System consists of one or more Sequence Components that are configured with Scripts to form Sequencers.\nIn this figure, a science-oriented description of an astronomical observation, as produced by a user interface program (such as an instrument acquisition user interface), planning tool, or database record is used as the input for sequencing. This input, as a Sequence, is passed to and accepted by the OCS, which creates and passes the observation description to the Sequence Components of the OCS. The Sequence Components and lower level control system software manipulate the hardware subsystems to generate science frames (made up of data frames and metadata). The science frames use the bulk data distribution functionality of the DMS and ESW.VIZ subsystem to distribute the science frames to dataset consumers (data processing or visualization, for instance).\nThe User Interface Standards subsystem (UISTD) of ESW includes user interface standards and reusable UI code solutions that enable local and remote use of user interfaces as well as common styles, conventions, and widgets that are shared across all user interfaces. The creation of specific observing user interfaces is the responsibility of the High level Control and Monitoring System (HCMS) subsystem. HCMS provides a consistent, unified experience across all tools and user interfaces built upon the standards and solutions of the UISTD package and the control and monitoring capabilities provided by OCS package and the technology choices of the CSW subsystem infrastructure.\nThe observer user interface for visualizing science frames during acquisition and observing (quick-look) is within the Visualization System (VIZ) package. VIZ also includes any infrastructure needed to support visualization of basic science images and wavefront sensor images as needed for acquisition such as image distribution and a platform for data processing.\nCompleting the observing workflow are support and scripts that implement observing and the acquisition process. Acquisition integrates almost every system of OSW, the telescope, and instrumentation. The Acquisition System (ACQ) package is a user focused package that implements the acquisition process for the observing sequences including known engineering observations. Acquisition-focused user interface tools will be included in ACQ as necessary based on how the observing workflows develop over the next few years.","title":"Executive Software Overview"},{"location":"/esw/eswOverview.html#observatory-control-system-ocs-","text":"In the TMT Software System, OCS provides the sequencing software to carry out the observations planned and scheduled via software implemented by the Science Operations Support Subsystem (SOSS). Planning information created during Phase 2 and contained in the Observing Database, a part of SOSS, is used to generate the Observing Block and the Sequence, which is passed to the ESW OCS for execution. All observation types: science, calibration, and engineering are executed through the ESW.OCS infrastructure. This is necessary to have a full understanding of how the telescope and instruments are used for time accounting purposes. It is also expected that most if not all observations, including calibration and engineering, will be described using the SOSS planning tools.\nESW.OCS provides the Sequence Component, which is one of the OMOA architecture components (along with HCD, Assembly, Container, and Application). The Sequence Component is programmable by running a “script” that can vary based on the observing mode in use. The generic Sequence Component when configured with a Script becomes a Sequencer. Scripts are stored in a dedicated change-controlled repository. The configured Sequencer executes the Sequence by examining and processing each step of the Sequence and taking any actions needed to match the step such as sending commands to other components.\nThe Sequencer Component contains the environment for executing scripts called the Engine. It provides the “service glue” that allows the script code to use the CSW Services to send commands and subscribe to and react to event data.\nFor most observations (i.e. science, calibration, engineering), a master OCS Sequencer is used to control other subsystem Sequencers (such as TCS and IRIS), which in turn control subsystem Assemblies and HCDS in the OMOA hierarchy, as shown in the following figure. The scripts for science, acquisition, and some engineering purposes used by the OCS master sequencer are a product of ESW.ACQ.\nOCS also includes a Sequence Manager application that acts as the front-end to the OCS sequencing system. The Sequence Manager receives Sequences from the SOSS or other tools, manages observatory resources, and starts, initializes, and stops Sequencers as needed for each received Sequence.\nThe following summarizes the responsibilities of OCS.\nAccept and execute Sequences submitted from SOSS in all operations modes. Manage the process of executing a single Sequence or multiple concurrent Sequences including starting any needed Sequencers. Ensure that the resources needed for a Sequence are available before allowing the Sequence to execute. Provide a reusable Sequence Component that executes Scripts and processes Sequences from SOSS. Provide a Script programming environment that provides access to appropriate CSW Services and has the level of control needed to execute acquisition, observing workflows, calibrations, and some engineering sequences. Allow an external user interface program to monitor and control the progress of an executing Sequence, and provide such tools. Define information needed for Observatory metrics (shared effort between OCS, ACQ, HCMS).","title":"Observatory Control System (OCS)"},{"location":"/esw/eswOverview.html#esw-phase-1-development","text":"Planning for ESW led to the conclusion that the best approach was to split the ESW work into two phases. Resource limitations were one factor, but it is also necessary to focus initially on providing the decisions and parts of ESW on which other TMT subsystems depend as soon as possible, so that those subsystems can continue with their design work. Once these features are available, OSW future development is largely decoupled from other subsystems, and the other subsystems have what they need to plan and develop independently of OSW. The plan is to have an ESW Phase 2 final design in the future.\nThe following are the Phase 1 priorities:\nSequencer/script design and integration with services Integration of the browser UI environment with CSW and early tool choices for UI development Define and implement Observe Events and the Observe command\nThree main components are delivered as part of ESW Phase 1:\nSequencer: This allows users to create a Sequencer component. Both top-level Sequencer (OCS) and subsystem Sequencers can be created using the same framework. This allows subsystem experts to write custom scripts for each sequencer in a Kotlin-based domain specific language (DSL). All sequencer scripts will be written in the Sequencer Scripts Repository. Sequence Component: The Sequence Component is used to spawn and shutdown sequencers dynamically. ESW Gateway: This is provided to give access to all CSW and ESW services and components from future browser-based user interfaces.\nWhat is in ESW Phase 1 Release 1? The first development phase of ESW Phase 1 has focused on the Sequence Component, Sequencer, and Scripts. The goal is to get feedback to guide further development in these areas. Additionally, the ESW Gateway is provided for testing. The Gateway provides CSW services focused on the needs of user interfaces. Future development phases will focus on Sequence Manager, Observing Events and user interface support.\nNote Executive Software (ESW) is a reimplementation/refactoring of the prototype ESW code here developed during the ESW design phase, with changes to make the code and public APIs more robust and resilient, and to improve its usability and performance for use at the TMT Observatory.","title":"ESW Phase 1 Development"},{"location":"/sequencersandscripts/seq-index.html","text":"","title":"Sequencers and Sequence Components"},{"location":"/sequencersandscripts/seq-index.html#sequencers-and-sequence-components","text":"Sequencers in the Executive Software What is a Sequence Component, Sequencer, Script, and Sequence? Sequencer is an OMOA Component Defining Observing Modes Registering Sequencers in Location Service Sequencer Technical Design Running a Sequencer Using ocs-app Prerequisites for Running ocs-app 1. Install coursier and the TMT Apps Channel 2. Install ocs-app 3. Start Any Needed CSW Services 4. Run ocs-app Starting a Sequence Component Starting a Sequencer Setting the Default Log Level","title":"Sequencers and Sequence Components"},{"location":"/sequencersandscripts/sequencer.html","text":"","title":"Sequencers in the Executive Software"},{"location":"/sequencersandscripts/sequencer.html#sequencers-in-the-executive-software","text":"Sequencers are part of the ESW Observatory Control System or OCS. The job of OCS is to receive the description of the science observation from the planning tools and execute the observation. It does this using Sequencers and a few other ideas defined here.\nThis first section provides an overview of the critical OCS architectural ideas. Subsequent sections go into more depth.","title":"Sequencers in the Executive Software"},{"location":"/sequencersandscripts/sequencer.html#what-is-a-sequence-component-sequencer-script-and-sequence-","text":"ESW.OCS provides the Sequence Component, which is one of the OMOA architecture components (along with HCD, Assembly, Container, and Application). The Sequence Component is configured by loading a “script” that is written in the “script language”. A different script can be written and loaded into a Sequence Component depending on the observing mode in use. When combined with a specific script, the Sequence Component becomes a Sequencer (i.e., Sequence Component + Script = Sequencer). The Sequence Component provides the framework and a consistent environment for a Sequencer. Scripts are stored in a dedicated script repository in the TMT Github called sequencer-scripts. All scripts for all subsystems reside in the script repository.\nA Sequence is defined in Common Software as a list of Sequence Commands: Setup, Observe, Wait. The only message type a Sequencer can receive and process is a Sequence, which can contain 1 or more Sequence Commands. Note that a Sequence with only 1 Sequence Command is still wrapped in a Sequence message.\nThere is one more term: Observing Block. The Observing Block is an SOSS type that is usually defined as the “smallest schedulable science entity”. The Observing Block describes the observation using high level terms, and may contain a sequence of exposures, such as dither patterns. A Sequence is created from the Observing Block, including acquisition and configuration steps, before it is sent to the OCS.\nIn the OMO architecture, the Sequencer does most of its work in a scripting environment. For OCS, “scripting” means that the code of the Script is easier to write and update without requiring installation of a new software version. This is unlike Assemblies, HCDs, and applications that are compiled programs. The reason for this is to support flexible Sequencer arrangements and Scripts that are minimal and can change based on the observing mode. Operations experience shows that the most frequent software changes will happen in the Sequencer level and changes to lower level devices (i.e., Assemblies and HCDs) are less frequent and more disruptive. It makes sense to make it easier to change the software that changes most frequently. The use of scripts also has the advantage of allowing for an interactive environment that can be used during engineering and acceptance testing.\nA Sequencer is created with a Script that may be specific to an observing or maintenance mode. Once the Sequencer is created with the specific Script it is able to execute Sequences for that mode. The specific Sequence Commands that may appear in a Sequence as input to a specific Sequencer/Script is the API for the Sequencer mode as defined in the ICD for the Sequencer/Script.\nEach Sequence Command in a Sequence is handled by the Script–usually one step at a time. The Script examines each input Sequence Command and takes whatever actions are needed to match the demands specified in the command. The Script actions taken may include involved activities that include sending commands to subsystem Assemblies and receiving events. The commands and events used by the executing Script are the commands defined by the Assemblies in their ICDs. The Sequence Command may trigger a mode or state machine that operates after the Sequence Command completes.\nThe Sequencers needed for an observing mode form a hierarchy. The OMOA allows any arrangement of Sequencers for an observing mode, but the construction agreement is that there will be one or more Sequencers for each of the major subsystems with Scripts written by each subsystem team. For a typical AO-dependent observation such as with IRIS and NFIRAOS the Sequencers would include: OCS (master sequencer), AOESW, TCS, and an instrument such as IRIS.\nThe following figure shows all of the key discussion points of the previous paragraphs. This figure shows a simplified construction Sequencer hierarchy with OCS Master Sequencer, TCS Sequencer, and an Instrument Sequencer arranged in a hierarchy. Each Sequencer has a loaded Script. The Master Sequencer has received a Sequence and in processing that Sequence. It has sent Sequences to the TCS and INS Sequencers.\nNote that in this hierarchical arrangement, a Sequencer can send commands to Assemblies using CSW Command Service or, as with the OCS Master Sequencer, it can construct and send a Sequence within the Script. The point of this figure is to show that the OCS Master Sequencer may receive a long Sequence that it will process and will typically submit smaller Sequences of one or two Sequence Commands to sub-Sequencers and wait for completion before processing additional steps.","title":"What is a Sequence Component, Sequencer, Script, and Sequence?"},{"location":"/sequencersandscripts/sequencer.html#sequencer-is-an-omoa-component","text":"Sequencers are OMOA components and must therefore contain the same basic functionality expected of all OMOA components. This includes:\nSupporting the component lifecycle. Registering itself in the Location Service. Using CSW to communicate with other components.\nThe core of each Sequencer is a Sequence Component, a reusable framework component which is used to construct a Sequencer as an OMOA component. Please refer Sequencer Component for details about Sequence Component.\nAll Sequencers use the same component framework. What makes a Sequencer unique is the Script with witch it was loaded. A Sequencer is a Sequence Component configured with a specific Script. The Script is written with a specific observing mode (or set of common observing modes) in mind. Behavior that is common to more than one observing mode can be defined in Scripts that can be shared and “imported” into other scripts (see ReusableScripts).\nWhich observing modes a Script can support is up to the developer, but the intention is that a Script can be developed independently of other Scripts to refine behavior specific to an observing mode, without affecting any other observing modes. In the future TMT operations phase, this will allow new observing modes to be added without necessarily impacting scripts that have been verified. It also makes maintenance easier because changes to verified scripts are easy to track and test.\nSince the Script defines the behavior of the Sequencer, one can be written to support a simulation mode or a standalone mode, such that development and testing can be performed with a Sequencer handling real Sequences, but only simulating its actions. Scripts can also be created for special purposes such as testing Assemblies or HCDs in the lab.","title":"Sequencer is an OMOA Component"},{"location":"/sequencersandscripts/sequencer.html#defining-observing-modes","text":"Observing modes are usually associated with instruments or engineering tasks. Observing modes must following the naming convention shown below:\n<system>_<modeName>\n\n                   IRIS_ifsonly\n                   WFOS_darknight\n                    ENG_pointingmap\nThe <system> indicates the system to which the observing mode applies to. This is typically the instrument subsystem used for the observations, but could be any subsystem or other tag (such as ENG) that identifies the observing mode. If a subsystem is used, it should be capitalized to conform with other subsystem uses. The <modeName> portion will generally also be part of the instrument configuration set in the observation planning tool. There are no restrictions on this name, but shorter is better. Any name can be used for testing.","title":"Defining Observing Modes"},{"location":"/sequencersandscripts/sequencer.html#registering-sequencers-in-location-service","text":"A Sequencer is a Sequence Component that has a script loaded. A Sequencer converts a Sequence Component, but the Sequence Component stays around. A Sequencer must be started specifying the subsystem for the Sequencer and the observing mode (as described above).\nLike Sequence Components, Sequencers register themselves in the Location Service based on arguments used when they are started. The following table shows scenarios that may happen when the Sequence Manager starts Sequencers for an observing mode.\nSequence Component Name Sequencer Subsystem Observing Mode Registered Location Description ESW.ESW_77 IRIS IRIS_ifsonly IRIS@IRIS_ifsonly An IRIS instrument Sequencer running the IRIS script for the IRIS_ifsonly observing mode using the ESW.ESW_77 Sequence Component. ESW.primary ESW IRIS_ifsonly ESW@IRIS_ifsonly An ESW Sequencer running the ESW script for the IRIS_ifsonly observing mode using the ESW.primary Sequence Component.\nAs shown above, the observing mode is the instrument name and an instrument-specific label related to observing mode features. Each instrument includes its scripts inside its specific package. The subsystem and observing mode are used to lookup the correct script in the script repository. Once the Sequencer script is loaded in a Sequence Component, the Sequencer API exposes a GetSequenceComponent command which returns the Location of the Sequence Component allowing the Sequence Manager or other client to determine which Sequence Component is executing the observing mode script for a specific packageId.\nThe figure below shows the Sequence Component ESW_77 loading the IRIS instrument script for the IRIS_ifsonly observing mode.\nOnce loaded, a client can ask the Sequence Component what Sequencer it is running using the GetStatus message. A client can ask what Sequence Component a Sequencer is running on using the GetSequenceComponent message. Both commands return a Location Service Location. The naming convention allows the following:\nThe Sequence Manager can search for all Sequencers related to an observing mode. The Sequence Manager can identify the Sequencer running a subsystem’s instrument observing mode script. The Sequence Manager can identify which Sequence Component is running a specific subsystem’s instrument observing mode.","title":"Registering Sequencers in Location Service"},{"location":"/sequencersandscripts/sequencer.html#sequencer-technical-design","text":"Details on the technical design of a Sequencer can be found here: Sequencer Technical Documentation.\nDetails on the technical design of the Sequence Component can be found here: Sequence Component Technical Documentation.","title":"Sequencer Technical Design"},{"location":"/sequencersandscripts/sequencer-app.html","text":"","title":"Running a Sequencer Using ocs-app"},{"location":"/sequencersandscripts/sequencer-app.html#running-a-sequencer-using-ocs-app","text":"The ocs-app is a command line application that facilitates starting a Sequence Component and/or Sequencer using the coursier dependency management application. The coursier tool is described with full documentation at the coursier site.","title":"Running a Sequencer Using ocs-app"},{"location":"/sequencersandscripts/sequencer-app.html#prerequisites-for-running-ocs-app","text":"The following steps should be followed to use ocs-app to start a Sequencer or Sequence Component.","title":"Prerequisites for Running ocs-app"},{"location":"/sequencersandscripts/sequencer-app.html#1-install-coursier-and-the-tmt-apps-channel","text":"The coursier application must be installed on your machine and the OCS Apps channel must be installed. The instructions for doing this is provided here.","title":"1. Install coursier and the TMT Apps Channel"},{"location":"/sequencersandscripts/sequencer-app.html#2-install-ocs-app","text":"The following command creates an executable file named ocs-app in the default installation directory.\ncs install ocs-app:<version | SHA>\nOne can specify an installation directory like the following:\ncs install \\\n    --install-dir /tmt/apps \\\n    ocs-app:<version | SHA>\nNote If you don’t provide the version or SHA in the above command, ocs-app will be installed with the latest tagged binary of esw-ocs-app","title":"2. Install ocs-app"},{"location":"/sequencersandscripts/sequencer-app.html#3-start-any-needed-csw-services","text":"To run Sequencers and Sequence Components, the CSW Location Service must be running. Any other CSW Services needed by scripts should also be running.\nInformation on starting CSW services is here","title":"3. Start Any Needed CSW Services"},{"location":"/sequencersandscripts/sequencer-app.html#4-run-ocs-app","text":"Supported Commands\nseqcomp - starts sequence component sequencer - starts sequence components and sequencer in single command","title":"4. Run ocs-app"},{"location":"/sequencersandscripts/sequencer-app.html#starting-a-sequence-component","text":"Ocs-app spawns a new Sequence Component with a provided subsytem and name. Note that with this command, only a sequence component is spawned, not a sequencer. A separate loadScript command needs to be sent to the sequence component to spawn a sequencer inside it.\nOptions accepted by this command are described below:\n-s : subsystem of the sequence component, for e.g. tcs, iris etc -n, --name : optional name for sequence component, for e.g. primary, backup etc\nOnce ocs-app is installed, one can simply run sequencer or sequence component by executing the start command.\nStart command supports following arguments:\n--port, -p : Optional argument: HTTP server will be bound to this port. If a value is not provided, port will be picked up from configuration. -l, --local : optional argument (true if config is to be read locally or false if from remote server) default value is false. -c, --commandRoleConfigPath : specifies command role mapping file path which gets fetched from config service or local file system based on –local option. -m, --metrics : optional argument: If true, enable gateway metrics. If not provided, default value is false and metrics will be disabled.\nHere are some examples.\nExample 1: Starts a Sequence Component with a name\n//cd to installation directory\ncd /tmt/apps\n\n//start sequence component with specified name\n./ocs-app seqcomp -s tcs -n primary\nExample 2: Starts a Sequence Component without a name\n//cd to installation directory\ncd /tmt/apps\n\n//start sequence component without name argument.\n./ocs-app seqcomp -s tcs\nNote If the Sequence Component name is not specified, a new name (prefixed with subsystem) will be generated for the Sequence Component. For e.g. TCS_123, IRIS_123 Refer to supported arguments section or ./ocs-app start --help for starting ocs-app with specific arguments","title":"Starting a Sequence Component"},{"location":"/sequencersandscripts/sequencer-app.html#starting-a-sequencer","text":"When starting a Sequencer, ocs-app spawns two things:\nSequence Component: with provided subsystem, name Sequencer: with provided observing mode and subsystem of sequencer (-i option) if specified or else subsystem of sequence component (-s option)\nOptions accepted by this command are described below:\n-s : subsystem of the sequence component, for e.g. tcs, iris etc. -n, --name : optional name for sequence component, for e.g. primary, backup etc. -i : optional subsystem of sequencer script, for e.g. tcs, iris etc. Default value: subsystem provided by -s option. -m, --mode : observing mode, for e.g. darknight.\nThe following command examples start both a Sequence Component and Sequencer:\nExample 1: Start a Sequencer with TCS darknight observing mode\n//cd to installation directory\ncd /tmt/apps\n\n//Below example will spawn a Sequence Component called `OCS.primary` and a Sequencer `TCS.darknight` in it.\n./ocs-app sequencer -s ocs -n primary -i tcs -m darknight\nExample 2: Start the IRIS-darknight Sequencer on an IRIS Sequence Component\n//cd to installation directory\ncd /tmt/apps\n\n//Example below will spawn a Sequence Component `IRIS-primary` and a Sequencer `IRIS-darknight` in it.\n./ocs-app sequencer -s iris -n primary -m darknight\nNote Refer supported arguments section or ./ocs-app start --help for starting ocs-app with specific arguments.","title":"Starting a Sequencer"},{"location":"/sequencersandscripts/sequencer-app.html#setting-the-default-log-level","text":"The default log level for any component is specified in the application.conf file of the component. In this case, the Sequence Component is shared code among all Sequencers. Therefore, to specify a log level for your Sequencer, use the java -J-D option to override configuration values at runtime. For log level, the format is:\n-J-Dcsw-logging.component-log-levels.<Subsystem>.<obsMode>=<LEVEL>\nFor example, using the example above:\n//cd to installation directory\ncd /tmt/apps\n\n// run sequencer iris.darknight on iris.primary sequence component\n./ocs-app -J-Dcsw-logging.component-log-levels.IRIS.darknight=TRACE sequencer -s iris -n primary -m darknight","title":"Setting the Default Log Level"},{"location":"/scripts/scripts-index.html","text":"","title":"Sequencer Scripts"},{"location":"/scripts/scripts-index.html#sequencer-scripts","text":"All logic in a Sequencer is implemented in Sequencer Scripts. Scripts are written in a TMT developed Domain Specific Language (DSL) to facilitate development based on the Kotlin programming language. This section describes the DSL in detail.\nIn order to provide thread-safe concurrency, the Active Object design pattern is used for Scripts. The Active Object design pattern features a single “Executor” thread, in which all requests are sent to, such that only one request is processed at a time. This allows the Script to maintain global state variables that can be accessed in a thread-safe way.\nDo not starve the execution thread! The Script DSL is written to execute with a single thread. Script processing steps should not stay busy for long periods. For instance, do not execute a CPU-bound routine on the single thread. In stead, follow patterns mentioned here.\nScripts can be written in two styles: handler-oriented and state machine-oriented. See the page on Scripting Styles for more information.\nSequencer Script Styles Handler-Oriented Scripts State Machine-Oriented Scripts Mixing the Two Styles Script DSL Constructs Defining A Script Script Handlers Including Looping in Scripts Finite State Machines Blocking Operations Within Script Other DSL CSW Services DSL Location Service Using the Configuration Service in Scripts Command Service for Assemblies and HCDs Sequencer Command Service Event Service Logging Service Alarm Service Time Service Access in Scripts Database Service Extension utilities on SubmitResponse Parameters\nNote All the examples shown in each individual section assume that you have following import in place in script // import all the models, helpers, extensions\nimport esw.ocs.dsl.highlevel.models.*\nA decision has been made to implement Scripts using a Domain Specific Language (DSL) written in Kotlin instead of true scripts in a more dynamic scripting language (however, we still refer to them as Scripts). This is for several reasons:\nScripts can be developed in an IDE, with full syntax checking and auto-completion support. Unit tests can easily be written using widely-used testing frameworks. Scripts can be compiled, with compile-time error checking. Build tools can be used to bundle scripts into Sequencer applications. Code from other Scripts can be accessed and used more easily. Seamless integration with Common Software and Sequencer Framework. Kotlin features type safety (enhancing compile time error checking) and functional programming (if desired). Kotlin’s use of coroutines allows for simpler procedural-style scripting without blocking. One less “glue” service layer implementation needed.\nThe most important feature of “scripting” languages that we wanted to retain is the ability to quickly modify and reload a script without recompiling and deploying software. Another important feature is interactivity. Scripting languages are usually based around a “shell” that allows interactive usage. This is provided with the esw-shell companion project here\nAt the ESW FDR, we planned using Scala for the scripting DSL. While this did work, the extra syntax of using Future’s was cumbersome for the scripting use case, and Kotlin provided the coroutine environment that provided the asynchronous feature of futures, but with a much clearer syntax.\nThe scripting capability has been updated from Release 1 based on comments, but it is still work in progress. We look forward to comments and suggestions from users of Release 2 that can be folded into Release 3.","title":"Sequencer Scripts"},{"location":"/scripts/script-styles.html","text":"","title":"Sequencer Script Styles"},{"location":"/scripts/script-styles.html#sequencer-script-styles","text":"Scripts can be written in two styles: handler-oriented or state machine-oriented. The choice is determined by how the developer wants their Sequencer to work.","title":"Sequencer Script Styles"},{"location":"/scripts/script-styles.html#handler-oriented-scripts","text":"A handler-oriented script is specified with command-handlers at the top-level scope of the script. There is a command-handler associated with every possible Setup or Observe that a received Sequence can contain. The developer can use mutable variables in the script to keep track of the state of the Sequencer script.\nA handler-oriented script must be started using the script keyword indicating a scope. The following brief example shows the structure of a handler-oriented script.\nscript {\n    val wfosSequencer = Sequencer(WFOS, \"wfos.bluearm\", 10.seconds)\n    val wfosBlueDetAssembly = Assembly(WFOS, \"blueDetectorAssembly\", 10.seconds)\n    var wfosState = IDLE\n\n    onSetup(\"wfos-command-1\") {\n      // Start actions for wfos-command-1\n      wfosState = BUSY \n    }\n\n    onSetup(\"wfos-command-2\") {\n      // Start actions for wfos-command-2\n      if (wfosState == BUSY) {\n        // Reject\n      } else {\n        // Do some IDLE action\n    }\n}\nThis example shows two Setup handlers. One for wfos-command-1 and one for wfos-command-2. These names are compared with the CommandName fields of incoming Setups in the Sequence. Note that the var represents internal state. The command-handlers must maintain their state and perform checks as needed to properly handle commands. Code can also be added outside of handlers. This code will be run when the script is loaded. This can be used to, for example, set up subscriptions to Events which can be manually associated with internal state variables or other actions.\nMore information on handlers is available here.","title":"Handler-Oriented Scripts"},{"location":"/scripts/script-styles.html#state-machine-oriented-scripts","text":"A State Machine-oriented Script models the entire script as a state machine. The script developer writes a number of state entries that make sense for the Sequencer. Logic can be tied to events or commands. Within a state one can define command handlers to process Sequence steps. The command handlers within a state only work when the state machine is in that state.\nA state machine-oriented script must start with the FsmScript keyword. The argument of FsmScript is the initial state machine state. Like handler-oriented scripts, state machine-oriented scripts can contain state that can be shared across states. The following example shows the most important features of an FsmScript.\nFsmScript(\"OFF\") {\n\n    state(\"ON\") { params ->\n\n        onSetup(\"turn-off\") {\n            turnOffLight()\n            become(\"OFF\") \n        }\n    }\n\n    state(\"OFF\") {\n\n        onSetup(\"turn-on\") { command ->\n            turnOnLight()\n            become(\"ON\", command.params)\n        }\n    }\n\n}\nIn this script, the states called ON and OFF are defined. The initial state is OFF. In the ON state, the script can process the turn-off command. It executes the turnOffLife function and switches to the ON state using the become keyword.\nMore information about state machine-oriented scripts is here.","title":"State Machine-Oriented Scripts"},{"location":"/scripts/script-styles.html#mixing-the-two-styles","text":"A handler-oriented script can include finite state machines. The top-level script is not modeled as a state machine, but the command handlers and script can include one or more state machines and can launch them when a command is received.\nA state machine-oriented script can receive commands with handlers as shown in the example above. A state machine-oriented script can start/stop/control other finite state machines as it processes the top-level state machine.","title":"Mixing the Two Styles"},{"location":"/scripts/dsl/script-constructs.html","text":"","title":"Script DSL Constructs"},{"location":"/scripts/dsl/script-constructs.html#script-dsl-constructs","text":"Defining A Script Script Handlers Including Looping in Scripts Finite State Machines Blocking Operations Within Script Other DSL","title":"Script DSL Constructs"},{"location":"/scripts/dsl/constructs/define-script.html","text":"","title":"Defining A Script"},{"location":"/scripts/dsl/constructs/define-script.html#defining-a-script","text":"There are 3 variations of Sequencer Scripts. These variations are based the way the Script gets executed. The variations are:\nHandler-Oriented Script State Machine-Oriented Script (FSM Script) Reusable Script","title":"Defining A Script"},{"location":"/scripts/dsl/constructs/define-script.html#handler-oriented-script","text":"A handler-oriented script is a collection of script handlers which execute the actions tied to a command. To define a handler-oriented script, a function named script needs to be invoked with a code block which contains the logic of the script. The example below shows the way to declare the script.\nKotlin import esw.ocs.dsl.core.script\nimport esw.ocs.dsl.highlevel.models.Major\n\nscript {\n    // place to add Sequencer Script logic\n}\nThe logic can be divided into 2 parts:\nTop-level statements (initialization logic): Executed while loading (initializing) the script. Script Handlers: Executed when a command to execute a particular handler is received.\nScript handlers are defined to process a Sequence of Commands or to perform actions like going online or offline, starting a diagnostic mode etc. Documentation of handlers can be found here. Handlers will be executed whenever the Sequence or outside client makes a request to perform an action on the Sequencer.\nEverything except Script Handlers are considered as top-level statements and will be executed while loading the script. This is the place to declare the Script specific variables and tasks to be executed at initialization of the Script.\nKotlin script {\n    info(\"Loading DarkNight script\")\n\n    var tromboneTemperature = 0.0\n    onEvent(\"nfiraos.tromboneAssembly.temperature\") { event ->\n        when (event) {\n            is SystemEvent -> {\n                tromboneTemperature = event(doubleKey(\"temperatureInCelsius\")).first\n            }\n        }\n    }\n\n    val tromboneTemperatureAlarm =\n            Key.AlarmKey(Prefix(NFIRAOS, \"trombone\"), \"tromboneMotorTemperatureAlarm\")\n\n    loopAsync(1.seconds) {\n        if (tromboneTemperature > 10.0) {\n            setSeverity(tromboneTemperatureAlarm, Major)\n        } else  {\n            setSeverity(tromboneTemperatureAlarm, Okay)\n        }\n    }\n\n    onSetup(\"basic-setup\") { command ->\n\n        val intKey = intKey(\"angle\")\n        val angle = command.parameter(intKey).head()!!\n\n        info(\"moving motor by : $angle\")\n        moveMotor(angle)\n        info(\"motor moved to required position\")\n    }\n\n    onObserve(\"start-observation\") {\n        info(\"opening the primary shutter to start observation\")\n\n        val openingStatusKey = stringKey(\"status\").set(\"open\")\n        publishEvent(SystemEvent(\"IRIS.primary_shutter\", \"current-status\", openingStatusKey))\n\n        openPrimaryShutter()\n    }\n\n}\nThe example mainly demos:\nTop-level statements like declaring Script specific variable (*tromboneTemperature*, tromboneTemperatureAlarm) , use of Script Constructs (*loopAsync*) and use of Csw Services (*info* - Logging Service, setSeverity - Alarm Service) Defining Script Handlers like onSetup and onObserve","title":"Handler-Oriented Script"},{"location":"/scripts/dsl/constructs/define-script.html#state-machine-oriented-script-fsm-script-","text":"FSM script is a way of writing a Sequencer Script as a Finite State Machine (FSM), where execution of Script Handler is dependent on the current state of the Sequencer Script.\nTo define FSM Script a function FSMScript needs to be called with the initial state of the script, and a block containing the Script logic. The block contains initialization logic for different states.\nIn an FSM Script, script handlers can be defined in two scopes :\nDefault scope - top-level scope of the Script State scope - scope of a specific state.\nThe below code shows how to declare FSM Script and States. It also shows the scopes where handlers can be added.\nKotlin import esw.ocs.dsl.core.FsmScript\n\nFsmScript(\"INIT\") {\n\n    // Default scope\n    // place for Script variable declarations and initialisation statements\n\n    state(\"INIT\") { params ->\n        // Scope of INIT state\n        // handlers of INTI state\n    }\n\n    state(\"IN-PROGRESS\") {\n        // Scope of IN-PROGRESS state\n        // handlers of IN-PROGRESS state\n    }\n\n}\nInitialization of the Script takes place by executing the top-level statements, and then executing the initial state. The top-level scope is the place to declare variables which can be used across all states in the Script.\nWhile defining handlers there are some restrictions about Command handlers and where they can be defined in the FSM script scope. Script handlers other than the Command handlers can be tied both scopes of FSM script.\nTo execute any action, the corresponding handlers in the current state scope will be executed first and then handlers in the Default scope, if any, will be executed. In case of a Command Sequence, if the current state does not handle the Command which is being executed, the Sequence will be completed with an Error with a UnhandledCommandException reason.\nFor state transitions, become needs to called from the current state with the next state as an argument. It will start evaluating and executing future actions in the next state. If the next state is not defined in the Script, then an exception will be thrown saying No state declaration found for state.\nIt is also possible to pass parameters from the current state to the next state by passing them as the last argument to the become function. The passed parameters will be available as a function parameter while defining any State. This can reduce the need for global variables.\nIn below example, [[ 1 ]] shows use of become to change state. where [[ 2 ]] shows how to pass Params while changing state. The ON state shows how to consume the Params.\nKotlin state(\"ON\") { params ->\n\n    onSetup(\"turn-off\") {\n        turnOffLight()\n        become(\"OFF\")                           // [[ 1 ]]\n    }\n}\n\nstate(\"OFF\") {\n\n    onSetup(\"turn-on\") { command ->\n        turnOnLight()\n        become(\"ON\", command.params)           // [[ 2 ]]\n    }\n}\nThe state scope can have top-level statements and Script handlers. The state’s top-level statements will be executed when state transition happens. So invoking become will initialize the next state which includes calling the top-level statements. The state top-level can be used to declare variables limited to the scope of the state which will last until state transition. After that, the state will be cleared, and the next time the FSM becomes that state, it will be initialized again to default values.\nKotlin state(\"SETTING-UP\") { params ->\n\n    val initialPos = params[intKey(\"current-position\")].get().head()\n    var moved = false\n\n    onSetup(\"move\") { command ->\n        val angle = command.params[intKey(\"angle\")].get().head()\n        moveBy(angle)\n        moved = true\n\n        info(\"moved from : $initialPos by angle : $angle\")\n\n        become(\"READY\")\n    }\n\n    onGoOffline {\n        stopSetup()\n        info(\"Going in offline mode\")\n    }\n\n}\nIn the example, initialPos and moved demonstrate declaring State scoped variables. Whenever state transition happens to some other state and the goes back to the SETTING-UP state, these variables will be reinitialized to their default values as defined in code. A transition to self will not reinitialize variables.","title":"State Machine-Oriented Script (FSM Script)"},{"location":"/scripts/dsl/constructs/define-script.html#reusable-scripts","text":"Reusable Scripts make it possible to write any common logic that can shared across multiple scripts. This can be used to create small building blocks for constructing Sequencer Scripts (although this does cause dependencies that reduce a script’s ability to stand alone). They cannot be directly loaded into a Sequence Component; they can only be loaded into other Sequencer Scripts.\nReusable Scripts may consist of Script handlers or the top-level statements (initialization logic). The top-level statements will be executed while loading the script. Script handlers will be added to the corresponding handlers of the script loading it.\nTHe following code declares a Reusable Script with an Observe Command Handler.\nKotlin import esw.ocs.dsl.core.reusableScript\n\nval startObservationScript = reusableScript {\n    onObserve(\"start-observation\") {\n        info(\"opening the primary shutter to start observation\")\n\n        val openingStatusKey = stringKey(\"status\").set(\"open\")\n        publishEvent(SystemEvent(\"IRIS.primary_shutter\", \"current-status\", openingStatusKey))\n\n        openPrimaryShutter()\n    }\n\n}","title":"Reusable Scripts"},{"location":"/scripts/dsl/constructs/define-script.html#loading-in-a-handler-oriented-script","text":"To use Reusable Scripts, a Handler-Oriented script needs to call the loadScripts function with the instance of Reusable Script. Calling loadScripts will initialize the Reusable Script and then combine handlers of both scripts.\nKotlin script {\n\n    loadScripts(startObservationScript)\n\n}","title":"Loading in a Handler-Oriented Script"},{"location":"/scripts/dsl/constructs/define-script.html#loading-in-fsm-script","text":"A Reusable Script cannot be directly imported at the top-level of an FSM script. It can only be imported in a particular State of the FSM script. THe loadScripts command and the logic from the loaded script is limited to that particular State. The example below shows loading a reusable script into a State.\nKotlin state(\"INIT\") { params ->\n\n    loadScripts(startObservationScript)\n\n}","title":"Loading in FSM Script"},{"location":"/scripts/dsl/constructs/handlers.html","text":"","title":"Script Handlers"},{"location":"/scripts/dsl/constructs/handlers.html#script-handlers","text":"A Sequencer script processes Sequences by defining “handlers” in the script. This is done by completing the special handler functions described below. There are handlers that can be created to process the Setup and Observe commands, which make up the Sequence, but there are also handlers for specific reasons including: aborting and stopping a sequence, putting the Sequencer in Online and Offline modes, and putting the Sequencer into a Diagnostic mode and back to Operations mode. There is also a global error handler to catch all uncaught exceptions, and a shutdown handler to perform cleanup before the Sequencer shut down and exits. Each of these handlers are described below, with a section on how to handle exceptions after that.","title":"Script Handlers"},{"location":"/scripts/dsl/constructs/handlers.html#command-handlers","text":"","title":"Command Handlers"},{"location":"/scripts/dsl/constructs/handlers.html#onsetup","text":"This handler is used to handle a Setup command sent to this Sequencer. The handler takes two parameters:\ncommand name which is matched against the sequence command sent. If the command name matches, corresponding block provided is executed. block of code which contains logic to act on the Setup command.\nIn this onSetup example, commands are sent in parallel to each of the WFOS filter wheels.\nKotlin onSetup(\"setupInstrument\") {command ->\n    // split command and send to downstream\n    val assembly1 = Assembly(WFOS, \"filter.blueWheel\", 5.seconds)\n    val assembly2 = Assembly(WFOS, \"filter.redWheel\", 5.seconds)\n    par(\n            { assembly1.submit(Setup(\"WFOS.wfos_darknight\", \"move\")) },\n            { assembly2.submit(Setup(\"WFOS.wfos_darknight\", \"move\")) }\n    )\n}\nIn the block provided to this handler, all the CSW services (Event, Alarm, Time Service, etc) and control DSL (loop, par etc) are accessible.","title":"onSetup"},{"location":"/scripts/dsl/constructs/handlers.html#onobserve","text":"This handler is used to handle an Observe command sent to this Sequencer. The handler takes two parameters:\ncommand name which is matched against the sequence command sent, if the command name matches, corresponding block provided is executed block of code which contains logic to act on the Observe command.\nThe following example imagines a WFOS Sequencer receiving an Observe that contains an exposureTime parameter. The exposureTime is extracted into a Setup that is sent to the detector Assembly to start the exposure.\nKotlin // A detector assembly is defined with a long timeout of 60 minutes\nval detectorAssembly = Assembly(WFOS, \"detectorAssembly\", 60.minutes)\nval exposureKey = floatKey(\"exposureTime\")\n\nonObserve(\"startExposure\") { observe ->\n    // Extract the input exposure time and send a startObserve command to the detector Assembly\n    val expsosureTime = observe(exposureKey).head()\n    detectorAssembly.submitAndWait(Setup(\"WFOS.sequencer\", \"startObserve\", observe.obsId).add(observe(exposureKey)))\n}","title":"onObserve"},{"location":"/scripts/dsl/constructs/handlers.html#online-and-offline-handlers","text":"","title":"Online and Offline Handlers"},{"location":"/scripts/dsl/constructs/handlers.html#ongoonline","text":"On receiving the goOnline command, the onGoOnline handler, if defined, will be called. The Sequencer will become online only if the handler executes successfully.\nKotlin onGoOnline {\n    // send command to downstream components\n    assembly.goOnline()\n}","title":"onGoOnline"},{"location":"/scripts/dsl/constructs/handlers.html#ongooffline","text":"On receiving the goOffline command, the onGoOffline handler, if defined, will be called. The Sequencer will become offline only if the handler executes successfully. Offline handlers could be written to clear the sequencer state before going offline.\nKotlin onGoOffline {\n    // send command to downstream components\n    assembly.goOffline()\n}","title":"onGoOffline"},{"location":"/scripts/dsl/constructs/handlers.html#abort-sequence-handler","text":"The abort handler could be used to perform any cleanup tasks that need to be done before the current sequence is aborted (e.g. abort an exposure). Note that, even if the handlers fail, the sequence will be aborted.\nKotlin onAbortSequence {\n    // cleanup steps to be done before aborting will go here\n}","title":"Abort Sequence Handler"},{"location":"/scripts/dsl/constructs/handlers.html#stop-handler","text":"This handler is provided to clear/save the Sequencer state or stop exposures before stopping. Note that, even if the handlers fail, the sequence will be aborted.\nKotlin onStop {\n    // steps for clearing sequencer-state before stopping will go here\n}","title":"Stop Handler"},{"location":"/scripts/dsl/constructs/handlers.html#shutdown-handler","text":"This handler will be called just before the Sequencer is shutdown. Note that, even if the handlers fail, the Sequencer will be shutdown.\nKotlin onShutdown {\n    // cleanup steps to be done before shutdown will go here\n}","title":"Shutdown Handler"},{"location":"/scripts/dsl/constructs/handlers.html#diagnostic-mode-handler","text":"This handler can be used to perform actions that need to be done when the Sequencer goes in the diagnostic mode. The handler gets access to two parameters:\nstartTime: UTC time at which the diagnostic mode actions should take effect hint: represents the diagnostic data mode supported by the Sequencer\nThe Sequencer can choose to publish any diagnostic data in this handler based on the hint received, and/or send a diagnostic command to downstream components.\nKotlin var diagnosticEventCancellable: Cancellable? = null\n\nonDiagnosticMode { startTime, hint ->\n    // start publishing diagnostic data on a supported hint (for e.g. engineering)\n    when (hint) {\n        \"engineering\" -> {\n            val diagnosticEvent = SystemEvent(\"ESW.ESW_darknight\", \"diagnostic\")\n            diagnosticEventCancellable = schedulePeriodically(startTime, 50.milliseconds) {\n                publishEvent(diagnosticEvent)\n            }\n        }\n    }\n}","title":"Diagnostic Mode Handler"},{"location":"/scripts/dsl/constructs/handlers.html#operations-mode-handler","text":"This handler can be used to perform actions that need to be done when the Sequencer goes in the operations mode. Script writers can use this handler to stop all the publishing being done by the diagnostic mode handler, and/or send an operations mode command to downstream components.\nKotlin onOperationsMode {\n    // cancel all publishing events done from diagnostic mode\n    diagnosticEventCancellable?.cancel()\n    // send operations command to downstream\n    assembly.operationsMode()\n}","title":"Operations Mode Handler"},{"location":"/scripts/dsl/constructs/handlers.html#error-handlers","text":"In many cases, any errors encountered in a script would likely cause the command (and therefore, sequence) to fail. Most of the time, not much can be done other than capture and report the error that occurred. It is possible to perform some remediation, but it is likely the sequence would need to run again.\nFor this reason, we have simplified the error handling of commands such that any DSL APIs that essentially return a negative (e.g. Error or Cancelled) SubmitResponse are recasted as exceptions, which can then be caught by error handlers that are global to the sequence command handler, or the entire script. In this way, such error handling does not need to be repeated throughout the script for each command sent.\nA script can error out in following scenarios:\nScript Initialization Error : When the construction of script throws exception then script initialization fails. In this scenario, the framework will log the error cause. The Sequencer will not start on this failure. One needs to fix the error and then load script again. Command Handlers Failure : While executing a sequence, Command Handlers e.g. onSetup , onObserve can fail because of two reasons: handler throws exception or The Command Service or Sequencer Command Service used to interact with downstream Assembly/HCD/Sequencer returns negative SubmitResponse. A negative SubmitResponse is by default considered as error. In this case of failure, sequence is terminated with failure. Handlers Failure : This failure occurs when any of handlers other than Command Handlers fail (e.g. OnGoOnline, onDiagnosticMode etc.). In this scenario, framework will log the error cause. Sequence execution will continue.\nThe Script DSL provides following constructs to handle failures while executing script:","title":"Error Handlers"},{"location":"/scripts/dsl/constructs/handlers.html#global-error-handler","text":"onGlobalError : This construct is provided for the script writer. Logic in the onGlobalError will be executed for all Handler Failures including Command Handler Failures except the Shutdown Handler. If the onGlobalError handler is not provided by script, then only the logging of error cause is done by the framework.\nFollowing example shows usage of onGlobalError\nKotlin // Scenario-1 onObserve handler fails\nonObserve(\"trigger-filter-wheel\") { command ->\n    val triggerStartEvent = SystemEvent(\"esw.command\", \"trigger.start\", command(stringKey(name = \"triggerTime\")))\n    // publishEvent fails with EventServerNotAvailable which fails onObserve handler\n    // onGlobalError handler is called\n    // Sequence is terminated with failure.\n    publishEvent(triggerStartEvent)\n}\n\n// Scenario-2 onSetup handler fails - submit returns negative SubmitResponse\nonSetup(\"command-2\") { command ->\n    val assembly1 = Assembly(IRIS, \"filter.wheel\", 5.seconds)\n\n    // Submit command to assembly return negative response. (error by default) onGlobalError handler is called.\n    // Sequence is terminated with failure.\n    assembly1.submit(command)\n}\n\n// Scenario-3\nonDiagnosticMode { startTime, hint ->\n    // publishEvent fails with EventServerNotAvailable\n    // onDiagnosticMode handler fails\n    // onGlobalError is called. Sequence execution continues.\n    publishEvent(SystemEvent(\"esw.diagnostic.mode\", hint))\n}\n\nonGlobalError { error ->\n    val errorReason = stringKey(\"reason\").set(error.reason)\n    val errorEvent = SystemEvent(\"esw.observation.end\", \"error\", errorReason)\n    publishEvent(errorEvent)\n}\nNote Error in all handlers except the Shutdown Handler will execute the global error handler provided by script. If an error handler is not provided, the framework will log the error cause.","title":"Global Error Handler"},{"location":"/scripts/dsl/constructs/handlers.html#error-handling-at-command-handler-level","text":"onError : This construct is specifically provided for Command Handler Failures. An onError block can be written specifically for each onSetup and onObserve handler. The SubmitResponse error is captured in a ScriptError type and passed to the onError block. This type contains a reason String explaining what went wrong. In case of failure, onError will be called first followed by onGlobalError and the sequence will be terminated with failure. After the error handling blocks are called, the command and sequence, terminate with an Error status.\nKotlin onSetup(\"submit-error-handling\") { command ->\n    // some logic that results into a Runtime exception\n    val result: Int = 1 / 0\n}.onError { err ->\n    error(err.reason)\n}\nBy default, a negative SubmitResponse is considered an error.\nKotlin onSetup(\"submit-error-handling\") { command ->\n    val positiveSubmitResponse: SubmitResponse = assembly.submit(command)\n\n}.onError { err ->\n    // onError is called when submit command to the assembly fails with a negative response (error, invalid etc)\n    error(err.reason)\n}\nretry: This construct can be attached to an onSetup or onObserve handler to automatically retry the handler code in the case of Command Handler Failures. A retry block expects a retryCount and optional parameter interval which specifies an interval after which onSetup or onObserve will be retried in case of failure. The retry block can be used along with onError or it can be used independently. If retry is combined with onError, the onError block will be called before each retry attempt. If the command handler still fails after all retry attempts, the command fails with an Error status. Then the onGlobalError block will be executed (if provided), and the sequence will be terminated with a failure as well (see Global Error Handler.\nThe following example shows the retry construct used along with onError.\nKotlin onSetup(\"submit-error-handling\") { command ->\n    val assembly1 = Assembly(IRIS, \"filter.wheel\", 5.seconds)\n\n    // Submit command to assembly return negative response. - error by default\n    assembly1.submit(command)\n}.onError { err ->\n    error(err.reason)\n}.retry(2)\nThe following example shows retry with an interval specified and used without an onError block.\nKotlin onSetup(\"submit-error-handling\") { command ->\n    val assembly1 = Assembly(IRIS, \"filter.wheel\", 5.seconds)\n\n    // Submit command to assembly return negative response. - error by default\n    assembly1.submit(command)\n}.retry(2, 10.seconds)","title":"Error handling at command handler level"},{"location":"/scripts/dsl/constructs/loop.html","text":"","title":"Including Looping in Scripts"},{"location":"/scripts/dsl/constructs/loop.html#including-looping-in-scripts","text":"The script DSL supports a variety of looping constructs to satisfy different use cases:\nloop waitFor loopAsync","title":"Including Looping in Scripts"},{"location":"/scripts/dsl/constructs/loop.html#loop-with-default-loop-interval","text":"The loop DSL allows you to start a “blocking” loop so that the rest of the code after loop will not be executed until a stopWhen condition written inside loop becomes true. You can use this DSL when you want to iteratively perform some actions until a certain condition becomes true. An interval can be provided to set the minimum period of the loop, where every iteration of the loop wait at least for the minimum provided interval before executing the next iteration. If no period is provided, the default interval is 50 milliseconds.\nThe following example demonstrates the usage of the loop DSL with the default interval. In the loop body, a motor is being “moved” by 10 degrees in every iteration of the loop. The loop will be terminated when motor’s current position reaches the expected position of 100 degrees.\nKotlin var motorPosition = 0\nfun moveMotor(degrees: Int) {\n    // move motor logic\n    motorPosition += degrees\n}\nonSetup(\"move-motor\") {\n\n    val expectedMotorPosition = 100\n\n    // move motor by 10 degrees in each iteration, default loop interval is 50 millis\n    // stop loop when current motor position matches expected motor position and continue with the execution of rest of the handler\n    loop {\n        moveMotor(10)\n        stopWhen(motorPosition == expectedMotorPosition)\n    }\n}","title":"loop - With Default loop Interval"},{"location":"/scripts/dsl/constructs/loop.html#loop-with-custom-minimum-loop-interval","text":"The following example demonstrates the usage of the loop DSL when providing a custom loop interval.\nKotlin onSetup(\"move-motor\") {\n\n    val expectedMotorPosition = 100\n    // move motor by 20 degrees in every iteration after a loop interval of 500 millis (custom loop interval used here)\n    // stop loop when current motor position matches expected motor position and continue with the execution of rest of the handler\n    loop(minInterval = 500.milliseconds) {\n        moveMotor(20)\n        stopWhen(motorPosition == expectedMotorPosition)\n    }\n}\nIs there a minimum loop interval? minInterval needs to be greater than default interval of 50 milliseconds otherwise it will be ignored and default loop interval will be used.","title":"loop - With Custom Minimum Loop Interval"},{"location":"/scripts/dsl/constructs/loop.html#waitfor-loop-until-a-condition-is-true","text":"This is a specialized version of loop and satisfies simple use cases where you want to semantically block the execution until certain condition becomes true.\nIn the following example, initializeMotor method will start the initialization and eventually set motorUp flag to true indicating motor is successfully initialized. waitFor { motorUp } will check the value of motorUp flag every 50 milliseconds, and when it is true, the rest of the code execution will continue.\nKotlin var motorUp = false\n\nfun initializeMotor() {\n    // some motor initialization logic goes here\n    motorUp = true\n}\nonSetup(\"init-motor\") {\n    // start initializing motor and this method will set motorUp flag to true once initialization is successful\n    initializeMotor()\n    // pauses the init-motor command handlers execution until motor becomes up\n    waitFor { motorUp }\n\n    // rest of the handler implementation (here you can safely assume that motor is up)\n}","title":"waitFor - Loop Until a Condition is True"},{"location":"/scripts/dsl/constructs/loop.html#loopasync-with-a-default-loop-interval","text":"The previous DSL loop constructs “block” until the loop completes. You can use this DSL when you want to iteratively perform some actions in the background. Since it is asynchronous, once the code in the background loop starts, the code written after loopAsync will be executed immediately and concurrently.\nLike loop, loopAsync will be terminated when a stopWhen condition written inside loop becomes true. loopAsync also has a default interval of 50 milliseconds.\nThe following example demonstrates the usage of loopAsync DSL with the default interval. In the loop body, a current temperature event is published every 50 milliseconds. The loopAsync will be terminated when stopPublishingTemperature flag becomes true, which is set to true in the onStop handler.\nKotlin var stopPublishingTemperature = false\nval temperatureEvent = SystemEvent(\"IRIS.motor\", \"temperature\")\nval temperatureKey = longKey(\"temperature\")\n\nfun getCurrentTemp(): Long = TODO()\n\n// start background loop which publishes current temperature of motor every 50 milliseconds (default loop interval)\nloopAsync {\n    val currentTemp = getCurrentTemp()\n    publishEvent(temperatureEvent.add(temperatureKey.set(currentTemp)))\n    stopWhen(stopPublishingTemperature)\n}\n\nonStop {\n    stopPublishingTemperature = true\n}","title":"loopAsync - With a Default Loop Interval"},{"location":"/scripts/dsl/constructs/loop.html#loopasync-with-a-custom-loop-interval","text":"The following example demonstrates the usage of loopAsync DSL with a custom loop interval specified.\nKotlin // start background loop which publishes current temperature of motor every 100 milliseconds\nloopAsync(minInterval = 100.milliseconds) {\n    val currentTemp = getCurrentTemp()\n    publishEvent(temperatureEvent.add(temperatureKey.set(currentTemp)))\n    stopWhen(stopPublishingTemperature)\n}","title":"loopAsync - With a Custom Loop Interval"},{"location":"/scripts/dsl/constructs/loop.html#source-code-for-examples","text":"Loop Examples","title":"Source code for examples"},{"location":"/scripts/dsl/constructs/fsm.html","text":"","title":"Finite State Machines"},{"location":"/scripts/dsl/constructs/fsm.html#finite-state-machines","text":"Scripts have ability to define, include, and run Finite State Machine (FSM). FSM can transition between defined states and can be made reactive to Events and Commands.","title":"Finite State Machines"},{"location":"/scripts/dsl/constructs/fsm.html#define-a-fsm","text":"","title":"Define a FSM"},{"location":"/scripts/dsl/constructs/fsm.html#create-the-fsm","text":"To create an instance of an FSM, a helper method Fsm is provided as shown in example. This method takes following parameters:\nname of FSM initial state of the FSM block having states of the FSM\nKotlin val irisFsm: Fsm = Fsm(name = \"iris-fsm\", initState = \"INIT\") {\n    // place to define all states of FSM\n}","title":"Create the FSM"},{"location":"/scripts/dsl/constructs/fsm.html#define-state","text":"As mentioned above, the third parameter of Fsm method is a block which is the place to define all the states of the FSM. A method named state needs to be called with parameters name of the state and the block of actions to be performed in that state.\nKotlin state(\"INIT\") {\n    // actions to be performed in this state\n}\nState names State names are case-insensitive. In case of multiple states with same name, the last one will be considered.","title":"Define State"},{"location":"/scripts/dsl/constructs/fsm.html#state-transition","text":"To transition between states, the become method needs to be called with name of next state. This will change the state of the FSM to the next state and start executing it. An InvalidStateException will be thrown if the provided next state is not defined.\nKotlin become(state = \"IN-PROGRESS\")\nCaution with Become State transition should ideally be the last call in state or should be done with proper control flow so that become is not called multiple times.\nAlong with changing state, it is also possible to pass Params from the current state to the next state. Params can be given to become as the last argument, which will then be injected in the next state as a parameter.\nIn the case where state transition does not happen while executing a state, the FSM will stay in the same state and any re-evaluation of the FSM after that will execute the same state until a state transition happens. The reactive variables plays an important role in this as they are the way to re-evaluate the FSM state.\nKotlin state(\"LOW\") {\n    on(temparature.first() < 20) {\n        // do something but state transition does not happen\n    }\n\n    on(temparature.first() >= 20) {\n        // do something and transit state\n        become(\"HIGH\")\n    }\n}\nIn the example above, the FSM is in LOW state. If the temperature is below 20, then there won’t be any state transition, and the FSM remain in the LOW state. A change in temperature after that will re-evaluate the “LOW” state again and if the temperature is greater than or equal to 20, then current state will change to HIGH. In the example temperature is an event based variable which enables re-evaluation of the current state on changes in temperature value.","title":"State Transition"},{"location":"/scripts/dsl/constructs/fsm.html#complete-fsm","text":"completeFsm marks the FSM as complete. Calling it will immediately stop execution of the FSM and next steps will be ignored. Therefore, it should be called at the end of a state.\nKotlin completeFsm()   // will complete the Fsm\n// anything after this will not be executed","title":"Complete FSM"},{"location":"/scripts/dsl/constructs/fsm.html#fsm-helper-constructs","text":"The following are some useful FSM constructs.\nentry : executes the given block only when state transition happens from a different state Kotlin entry {\n    // do something\n} on : executes the given block if the given condition evaluates to true. This construct should be used for conditional execution of a task. Kotlin on(temparature.first() < 20) {\n    // do something but state transition does not happen\n}\n\non(temparature.first() >= 20) {\n    // do something and transit state\n    become(\"HIGH\")\n} after : executes the given block after the given duration Kotlin after(100.milliseconds) {\n    // do something\n}","title":"FSM Helper Constructs"},{"location":"/scripts/dsl/constructs/fsm.html#start-fsm","text":"After creating instance of FSM, it needs to be explicitly started by calling start on it. This will start executing the initial state of the FSM, which is provided while defining the instance.\nCaution Calling start more than once is not supported and will lead to unpredictable behaviour.\nKotlin irisFsm.start()","title":"Start FSM"},{"location":"/scripts/dsl/constructs/fsm.html#wait-for-completion","text":"As an FSM has the ability to be complete itself, await can be called to wait for the FSM completion. Execution will be paused at the await statement until the FSM is marked complete.\nKotlin irisFsm.await()\nCalling await before calling start will start the FSM internally and then wait for completion.","title":"Wait for Completion"},{"location":"/scripts/dsl/constructs/fsm.html#reactive-fsm","text":"Reactive FSM means that changes of state can be tied to changes in Events as well as Commands. An FSM can be made to react to changes in Event and Command parameters with the help of Event based variables and Command flags. This reaction is called “re-evaluation”, which causes the code for the current state to be executed again. It is necessary to bind an FSM to reactive variables to achieve the reactive behavior.","title":"Reactive FSM"},{"location":"/scripts/dsl/constructs/fsm.html#event-based-variables","text":"Event-based variables are the way to make an FSM react to CSW Events. They are linked to Events (or Parameters of Events) and are then bound to an FSM such that when the value of the linked Event (or Parameter) changes, the FSM is re-evaluated. Event-based variables can be used to share data between multiple sequencers using Events.\nThere are two types of Event-based variables.","title":"Event-based variables"},{"location":"/scripts/dsl/constructs/fsm.html#eventvariable","text":"An EventVariable will be tied to an Event published on the given EventKey. The example below shows creating an instance of an EventVariable and the getEvent method which returns the latest event.\nAn EventVariable needs 2 parameters:\nevent key: specifies which Event to tie the variable to duration: (optional) polling period for updating the value of the Event (Significance of duration parameter is explained below.)\nKotlin val eventVariable: EventVariable = EventVariable(\"ESW.IRIS_darkNight.temperature\")\n\neventVariable.getEvent() // to get the latest Event","title":"EventVariable"},{"location":"/scripts/dsl/constructs/fsm.html#paramvariable","text":"A ParamVariable will be tied to a specific Parameter Key of an Event published on given EventKey The example below shows creating an instance of a ParamVariable and the usage of other helper methods.\nA ParamVariable takes 4 parameters:\ninitial: initial value for the Parameter. The value of the parameter in the Event is updated when the ParamVariable is created. event key: specifies the Event with the linked Parameter param Key: specifies which Parameter to tie the variable to duration: (optional) polling period for updating the value of the Parameter (Significance of duration parameter is explained below.)\nKotlin val paramVariable: ParamVariable<Int> = ParamVariable(0, \"ESW.temperature.temp\", tempKey)\n\nparamVariable.getParam() // to get the current values of the parameter\nparamVariable.first() // to get the first value from the values of the parameter\nparamVariable.setParam(10, 11) // publishes the given values on event key\n\nparamVariable.getEvent() // to get the latest Event\nTo make the FSM react to Event-based variables, we need to create an instance of the above event based variables and bind the FSM to it.\nAn FSM can be bound to multiple variables and vice versa.\nKotlin eventBasedVariable.bind(irisFsm)\nEvent-based variables have the ability to behave in one of two ways:\nSubscribe to the Events getting published Poll for a new event with a specified period","title":"ParamVariable"},{"location":"/scripts/dsl/constructs/fsm.html#subscribe-to-an-event","text":"If the duration parameter of an Event-based variable is not specified, a subscription is made to the Event and the value is updated (and the current state of the FSM is re-evaluated) whenever it is published.\nThe following example shows how to create Event Variables with the subscribing behavior and bind FSM to it.\nKotlin // ------------ EventVariable ---------------\nval eventVariable: EventVariable = EventVariable(\"ESW.IRIS_darkNight.temperature\")\neventVariable.bind(irisFsm)\n\n// ------------ ParamVariable ---------------\nval tempKey: Key<Int> = intKey(\"temperature\")\n\nval paramVariable: ParamVariable<Int> = ParamVariable(0, \"ESW.temperature.temp\", tempKey)\nparamVariable.bind(irisFsm) // binds the FSM and event variable","title":"Subscribe to an Event"},{"location":"/scripts/dsl/constructs/fsm.html#poll","text":"If it is preferable to have the FSM re-evaluated at a constant periodic rate regardless of when new Events are published, polling behavior can be used by specifying the duration parameter when creating the Event-based variable. This can be useful when the publisher is too fast and there is no need respond so quickly to it.\nThe example code demonstrates this feature. The binding part is same as in previous example.\nKotlin val tempKey: Key<Int> = intKey(\"temperature\")\n\n// ------------ ParamVariable ---------------\nval pollingParamVar: ParamVariable<Int> =\n        ParamVariable(0, \"ESW.temperature.temp\", tempKey, 2.seconds)\n\npollingParamVar.bind(irisFsm)\n\n// ------------ EventVariable ---------------\nval pollingEventVar = EventVariable(\"ESW.IRIS_darkNight.temperature\", 2.seconds)\npollingEventVar.bind(irisFsm)","title":"Poll"},{"location":"/scripts/dsl/constructs/fsm.html#commandflag","text":"Command Flag acts as bridge that can be used to pass Parameters to an FSM from outside (i.e via a Command Handler). A Command Flag can be defined in a scope accessible by a Command Handler and the FSM, and then be bound to the FSM. This causes the FSM to re-evaluate whenever the value of the Command Flag changes, which occurs when the set method is called in the Command Flag (which can be placed in a Command Handler, see example below).\nA Command Flag can be bound to multiple FSMs, and multiple Command Flags can be bound to a single FSM. A Command Flag is limited to the scope of a single script. It does not have any effect on external scripts.\nThe following example shows how to create a CommandFlag, bind an FSM to it, and use the methods get and set to retrieve and set the value of parameters in the Command Flag.\nKotlin val flag = CommandFlag()\nflag.bind(irisFsm) // bind the FSM and command flag\n\nonSetup(\"setup-command\") { command ->\n    flag.set(command.params) // will set params and refreshes the bound FSMs with the new params\n}\n\nval params = flag.value() // extract the current params value in FSM\nNote Binding FSM to reactive variables can be done anytime in the lifecycle of FSM not only before starting it. Doing it after completion of FSM does not do anything. Binding is necessary to achieve the reactive behavior.","title":"CommandFlag"},{"location":"/scripts/dsl/constructs/fsm.html#example-fsm","text":"In the below example, temparatureFsm demonstrates how to define and use FSM in the scripts. The Event-based variable is declared with the Event key esw.temperature.temp and parameter temperature, and the temperatureFsm is bound to it. The job of the temperatureFsm is to decide the state based on the temperature and publish it on the EventKey esw.temperatureFsm with the ParamKey state. The state is determined by comparing the “current temperature” (obtained from a ParamVariable) with the “temperatureLimit”, which defaults to 40, but can be updated using the Setup command “changeTemperatureLimit”.\nTHe logic of state change is:\ncondition state temp == 30 FINISH temp > tempLimit ERROR else OK\nKotlin // method to publish the state of the FSM\nval stateKey = stringKey(\"state\")\nval tempFsmEvent = SystemEvent(\"esw.temperatureFsm\", \"state\")\nsuspend fun publishState(baseEvent: SystemEvent, state: String) =\n        publishEvent(baseEvent.add(stateKey.set(state)))\n\n// temperature Fsm states\nval OK = \"OK\"\nval ERROR = \"ERROR\"\nval FINISHED = \"FINISHED\"\n\n// Event-based variable for current temperature\nval tempKey = longKey(\"temperature\")\nval temperatureVar = ParamVariable(0, \"esw.temperature.temp\", tempKey)\n\n// CommandFlag, and method to get expected temperature from it\nval commandFlag = CommandFlag()\nfun getTemperatureLimit(defaultTemperatureLimit: Int): Int {\n    val tempLimitParameter = commandFlag.value().get(intKey(\"temperatureLimit\"))\n    return if (tempLimitParameter.isDefined)\n        tempLimitParameter.get().first\n    else\n        defaultTemperatureLimit\n}\n\n// key for parameter passed to Error state from Ok state\nval deltaKey = longKey(\"delta\")\n\n// FSM definition\nval temperatureFsm = Fsm(\"TEMP\", OK) {\n    val initialTemperatureLimit = 40                         // [[ 1 ]]\n\n    state(OK) {\n        val currentTemp = temperatureVar.first()             // [[ 2 ]]\n        val tempLimit = getTemperatureLimit(initialTemperatureLimit)\n\n        entry {\n            publishState(tempFsmEvent, OK)                   // [[ 3 ]]\n        }\n        on(currentTemp == 30L) {\n            become(FINISHED)                                 // [[ 4 ]]\n        }\n        on(currentTemp > tempLimit) {\n            val deltaParam = deltaKey.set(currentTemp - tempLimit)\n            become(ERROR, Params(setOf(deltaParam)))         // [[ 5 ]]\n        }\n        on(currentTemp <= tempLimit) {\n            info(\"temperature is below expected threshold\",\n                    mapOf(\"limit\" to tempLimit, \"current\" to currentTemp)\n            )\n        }\n    }\n\n    state(ERROR) { params ->\n        val tempLimit = getTemperatureLimit(initialTemperatureLimit)\n\n        entry {\n            info(\"temperature is above expected threshold\",\n                    mapOf(\"limit\" to tempLimit, \"delta\" to params(deltaKey).first)\n            )\n            publishState(tempFsmEvent, ERROR)\n        }\n        on(temperatureVar.first() < tempLimit) {\n            become(OK)\n        }\n    }\n\n    state(FINISHED) {\n        completeFsm()                                        // [[ 6 ]]\n    }\n}\n\n// bind reactives to FSM\ntemperatureVar.bind(temperatureFsm)\ncommandFlag.bind(temperatureFsm)                             // [[ 7 ]]\n\n// Command handlers\nonSetup(\"startFSM\") {\n    temperatureFsm.start()                                   // [[ 8 ]]\n}\n\nonSetup(\"changeTemperatureLimit\") { command ->\n    commandFlag.set(command.params)                          // [[ 9 ]]\n}\n\nonSetup(\"waitForFSM\") {\n    temperatureFsm.await()                                   // [[ 10 ]]\n    info(\"FSM is no longer running.\")\n}\nFull example code is available here.\nKey things in above example code are :\n[[ 1 ]]: Shows top-level scope of the FSM which can used to declare variables in FSM’s scope and statements which should be executed while starting the FSM. Statements written here will be executed only once when the FSM starts. [[ 2 ]]: The scope of the state. Statements written here will be executed on every evaluation of the state. So variables declared here will be reinitialized whenever state is re-evaluated. In the above case, tempLimit and currentTemp will be initialized every time the OK state is evaluated. [[ 3 ]]: The code in the entry block is only executed when first transitioning to this state. Therefore, state will not be published repeatedly. [[ 4 ]]: State transitions from OK state to FINISHED. [[ 5 ]]: State transitions from OK state to ERROR with a Params set containing the delta temperature. The ERROR state shows how to consume Params in a state. [[ 6 ]]: Marks the FSM complete. Re-evaluation or state transitions cannot happen after this is executed. [[ 7 ]]: Shows the binding temperatureFsm to temperatureVar and commandFlag. After this point, a running FSM will re-evaluate whenever events are published on temperatureVar. [[ 8 ]]: Starts evaluating the initial state of the FSM. Until this is called the code in the Fsm block only specifies the FSM functionality. However, note that the initialization code in the top-level scope of the FSM is executed (item [[ 1 ]]) on construction. [[ 9 ]]: Updates the Params of the CommandFlag. In our example, we are using those params to specify the temperature limit. [[ 10 ]]: Waits for completion of the FSM. In our example, the script execution will be blocked until the completeFsm method is called in [[ 6 ]], which occurs when switching to the FINISHED state. Any code after the await call will execute after the FSM is completed.\nExample code also demos the use of the helper constructs like entry, on.","title":"Example FSM"},{"location":"/scripts/dsl/constructs/blocking.html","text":"","title":"Blocking Operations Within Script"},{"location":"/scripts/dsl/constructs/blocking.html#blocking-operations-within-script","text":"Script runs on a single thread, hence special care needs to be taken while performing blocking (CPU/IO) operations withing the script.\nNote All the CSW related DSL’s provided in the scripting environment does not block main script thread hence they can be used directly. Exception to this here is, callback based API’s for an ex. onEvent where you want to perform CPU/IO intensive tasks. In this case, you need to follow one of the pattern mentioned below.\nThis section explains following two types of blocking operations and patterns/recommendations to be followed while performing those.\nCPU Bound IO Bound\nDO NOT BLOCK Calling CPU intensive or IO operations from the main script is dangerous and should be avoided at all cost. Breaking this rule will cause all the background tasks started in script to halt and unexpected deadlocks.\nDO NOT ACCESS/UPDATE MUTABLE STATE Main sequencer script, and the techniques mentioned here for performing blocking tasks executes on different threads. Hence, accessing/updating mutable state defined in script from these blocking functions is not thread safe.","title":"Blocking Operations Within Script"},{"location":"/scripts/dsl/constructs/blocking.html#cpu-bound","text":"For any CPU bound operations follow these steps:\nCreate a new function and mark that with suspend keyword Wrap function body inside blockingCpu utility function\nFollowing example demonstrate writing CPU bound operation, In this example BigInteger.probablePrime(4096, Random()) is CPU bound and takes more than few seconds to finish.\nKotlin // Calculating probablePrime is cpu bound operation and should be wrapped inside blockingCpu utility function\n// Following function takes around 10 seconds to find a 4096 bit length prime number\nsuspend fun findBigPrime(): BigInteger =\n        blockingCpu {\n            BigInteger.probablePrime(4096, Random())\n        }\nFollowing shows, usage of the above compute heavy function in main sequencer script\nKotlin script {\n\n    loopAsync(100.milliseconds) {\n        // loop represents the computation running on the main script thread.\n    }\n\n    onSetup(\"prime number\") {\n        // by default calling findBigPrime cpu intensive task suspends and waits for result\n        // but this runs on different thread than the main script thread\n        // which allows other background tasks started previously to run concurrenlty\n        val bigPrime1: BigInteger = findBigPrime()\n\n        // if you want to run findBigPrime in the background, then wrap it within async\n        val bigPrimeDeferred: Deferred<BigInteger> = async { findBigPrime() }\n        // ...\n        // wait for compute intensive operation to finish which was previously started\n        val bigPrime2: BigInteger = bigPrimeDeferred.await()\n\n        // script continues...\n    }\n}","title":"CPU Bound"},{"location":"/scripts/dsl/constructs/blocking.html#io-bound","text":"For any IO bound operations follow these steps:\nCreate a new function and mark that with suspend keyword Wrap function body inside blockingIo utility function\nFollowing example demonstrate writing IO bound operation, In this example BufferredReader.readLine() is IO bound and takes more than few seconds to finish.\nKotlin // Reading a line from a file is blocking IO operation and should be wrapped inside blockingIo utility function\nsuspend fun readMessage(bufferedReader: BufferedReader): CharSequence? =\n        blockingIo {\n            bufferedReader.readLine()\n        }\nFollowing shows, usage of the above io heavy function in main sequencer script\nKotlin script {\n    loopAsync(100.milliseconds) {\n        // loop represents the computation running on the main script thread.\n    }\n\n    onSetup(\"read file\") {\n        val reader = File(\"someFile.txt\").bufferedReader()\n\n        // by default calling readMessage (blocking io) task suspends and waits for result\n        // but this runs on different thread than the main script thread\n        // which allows other background tasks started previously to run concurrenlty\n        val message1 = readMessage(reader)\n\n        // if you want to run readMessage in the background, then wrap it within async\n        val message2Deferred = async { readMessage(reader) }\n        // ...\n        // wait for blocking operation to finish which was previously started\n        val message2: CharSequence? = message2Deferred.await()\n\n        // script continues...\n    }\n}","title":"IO Bound"},{"location":"/scripts/dsl/constructs/blocking.html#recommendations-best-practices","text":"Create separate kotlin (.kt) file/files and maintain all the CPU/IO bound blocking tasks their Creating separate file/files makes sure you accidentally don’t access/modify mutable state present within the script Call these functions from script Wrap calling these function inside async block if you want to run them in parallel","title":"Recommendations/Best Practices"},{"location":"/scripts/dsl/constructs/blocking.html#how-does-it-work-behind-the-scenes-","text":"blockingCpu or blockingIo construct underneath uses different thread pools than the main script thread.\nThis means, accessing/updating mutable variables defined in sequencer script is not thread safe from these functions and should be avoided.\nYou can read more about these patterns of blocking here","title":"How does it work behind the scenes?"},{"location":"/scripts/dsl/constructs/other-dsl.html","text":"","title":"Other DSL"},{"location":"/scripts/dsl/constructs/other-dsl.html#other-dsl","text":"","title":"Other DSL"},{"location":"/scripts/dsl/constructs/other-dsl.html#par","text":"This utility is provided to support running multiple tasks in parallel. A call to par returns when all the submitted tasks complete.\nThe following example demonstrates sending commands in parallel to multiple HCD’s.\nKotlin val prefix = \"OCS.IRIS_darkMode\"\nval hcd1 = Hcd(IRIS, \"filter.wheel1\", 10.minutes)\nval hcd2 = Hcd(IRIS, \"filter.wheel2\", 10.minutes)\nval hcd3 = Hcd(IRIS, \"filter.wheel3\", 10.minutes)\n\nonSetup(\"setup-iris-hcds\") {\n    // send 3 setup commands to 3 HCD's in parallel\n    val responses: List<SubmitResponse> =\n            par(\n                    { hcd1.submitAndWait(Setup(prefix, \"move-10\")) },\n                    { hcd2.submitAndWait(Setup(prefix, \"move-10\")) },\n                    { hcd3.submitAndWait(Setup(prefix, \"move-10\")) }\n            )\n}","title":"par"},{"location":"/scripts/dsl/constructs/other-dsl.html#isonline","text":"A flag called isOnline is provided, which is true when sequencer is Online and false when sequencer is Offline. This dsl is accessible in all the scopes.\nKotlin onDiagnosticMode { _, _ ->\n    loopAsync(100.milliseconds) {\n        if (isOnline)\n            publishEvent(SystemEvent(\"TCS.filter.wheel\", \"online-diag-data\"))\n        else\n            publishEvent(SystemEvent(\"TCS.filter.wheel\", \"offline-diag-data\"))\n    }\n\n}","title":"isOnline"},{"location":"/scripts/dsl/constructs/other-dsl.html#prefix","text":"Prefix of the current sequencer is made available in all scopes by this dsl.\nKotlin val downstreamCommand: Setup = Setup(prefix, \"move\")","title":"prefix"},{"location":"/scripts/dsl/constructs/other-dsl.html#source-code-for-examples","text":"OtherDsl Examples","title":"Source code for examples"},{"location":"/scripts/dsl/csw-services.html","text":"","title":"CSW Services DSL"},{"location":"/scripts/dsl/csw-services.html#csw-services-dsl","text":"Location Service Using the Configuration Service in Scripts Command Service for Assemblies and HCDs Sequencer Command Service Event Service Logging Service Alarm Service Time Service Access in Scripts Database Service Extension utilities on SubmitResponse Parameters","title":"CSW Services DSL"},{"location":"/scripts/dsl/services/location-service.html","text":"","title":"Location Service"},{"location":"/scripts/dsl/services/location-service.html#location-service","text":"The Location Service DSL is a wrapper over the Location Service module provided by CSW. You can refer the detailed documentation of the Location Service provided by CSW here.\nThis DSL provides the following APIs:","title":"Location Service"},{"location":"/scripts/dsl/services/location-service.html#register","text":"This DSL registers a provided Registration with the Location Service and returns a RegistrationResult, which contains the Location with which a component is registered and a handle for un-registration.\nRegistration can be one of:\nAkkaRegistration HttpRegistration TcpRegistration\nKotlin // register HTTP service running at port 8080 and routes are served from /routes endpoint\nval registrationResult: RegistrationResult =\n        register(HttpRegistration(httpConnection, port, \"/routes\"))\n\n// location which is registered with Location Service\nval location: Location = registrationResult.location\n\n// unregisters location from Location Service which triggers LocationRemoved event\nregistrationResult.unregister()","title":"register"},{"location":"/scripts/dsl/services/location-service.html#unregister","text":"This DSL un-registers the provided Connection from Location Service\nConnection can be one of:\nAkkaConnection HttpConnection TcpConnection\nKotlin val sourcePrefix: Prefix = cmd.source()\nval componentId = ComponentId(sourcePrefix, Service)\n\nunregister(HttpConnection(componentId))","title":"unregister"},{"location":"/scripts/dsl/services/location-service.html#findlocation","text":"This DSL looks up the provided Connection in the Location Service and returns the corresponding Location, or null, if not found.\nKotlin val prefix: Prefix = cmd.source()\nval assemblyConnection = AkkaConnection(ComponentId(prefix, Assembly))\n\nval location: AkkaLocation? = findLocation(assemblyConnection)\n\n// send a successful event to UI if assembly location is found\nlocation?.let { sendUIEvent(\"Resolved assembly location: $it\") }","title":"findLocation"},{"location":"/scripts/dsl/services/location-service.html#resolvelocation","text":"This DSL looks for the specified Connection in the Location Service for the optionally specified duration (default is 5 seconds) and returns the corresponding Location. If the location is not resolved within the time limit, null is returned.\nKotlin val prefix: Prefix = cmd.source()\nval assemblyConnection = AkkaConnection(ComponentId(prefix, Assembly))\n\nval location: AkkaLocation? = resolveLocation(assemblyConnection, 10.seconds)\n\n// send a successful event to UI if assembly location is found\nlocation?.let { sendUIEvent(\"Resolved assembly location: $it\") }","title":"resolveLocation"},{"location":"/scripts/dsl/services/location-service.html#listlocations","text":"Lists all the locations currently registered with the Location Service.\nKotlin val allLocations: List<Location> = listLocations()\n\n// publish all locations to UI in the format of [location1, location2, ...]\nsendUIEvent(allLocations.joinToString(prefix = \"[\", postfix = \"]\"))","title":"listLocations"},{"location":"/scripts/dsl/services/location-service.html#listlocationsby","text":"The following various APIs are provided for listing locations with filtering criteria:","title":"listLocationsBy"},{"location":"/scripts/dsl/services/location-service.html#","text":"Filters locations based on provided ComponentType. A DSL is provided to specify the type, which can be one of: HCD, Assembly, Sequencer, SequenceComponent, Container, Service\nThe following example demonstrates a use case where the script sends an Offline command to all of the Assemblies currently registered.\nKotlin onSetup(\"offline-assemblies\") {\n    // list all Assembly components\n    val assemblyLocations: List<Location> = listLocationsBy(Assembly)\n\n    // create Assemblies from locations and send offline command to each one of them\n    val assemblies = assemblyLocations.map { Assembly(it.prefix, 10.minutes) }\n    assemblies.forEach { it.goOffline() }\n}","title":"ComponentType"},{"location":"/scripts/dsl/services/location-service.html#","text":"Filters locations based on provided ConnectionType. A DSL is provided to specify the type, which can be one of: AkkaType, HttpType, TcpType.\nThe following example demonstrates a use case where the script locks all of the Akka Type components i.e. Assemblies and HCD’s.\nKotlin onSetup(\"lock-all-components\") {\n    val timeout = 10.minutes\n    val leaseDuration = 20.minutes\n\n    // list all akka components\n    val akkaLocations: List<Location> = listLocationsBy(AkkaType)\n\n    // filter HCD's and Assemblies and send Lock command\n    akkaLocations.forEach { location ->\n        val compId: ComponentId = location.connection.componentId\n        val compType: ComponentType = compId.componentType\n        val prefix = location.prefix\n\n        // create Assembly or Hcd instance based on component type and send Lock command\n        when (compType) {\n            Assembly -> Assembly(prefix, timeout).lock(leaseDuration)\n\n            HCD -> Hcd(prefix, timeout).lock(leaseDuration)\n\n            else -> warn(\"Unable to lock component $compId, Invalid component type $compType\")\n        }\n    }\n}\nRequired import for Location Service APIs The following import is required for using ConnectionType and ComponentType: import esw.ocs.dsl.highlevel.models.*","title":"ConnectionType"},{"location":"/scripts/dsl/services/location-service.html#hostname","text":"Filters locations based on the provided hostname (or IP address).\nIn the following example, all of the components running on IRIS (hostname: 10.1.1.1) machine are listed.\nKotlin // list all the components running on IRIS machine\nval irisMachineHostname = \"10.1.1.1\"\nval irisMachineLocations: List<Location> = listLocationsByHostname(irisMachineHostname)\n\nsendUIEvent(\"IRIS machine running components: [$irisMachineLocations]\")","title":"Hostname"},{"location":"/scripts/dsl/services/location-service.html#prefix","text":"Filters locations based on the provided prefix string. As with the CSW Location Service, the method filters for all locations with prefixes that start with the provided string.\nIn the following example, it receives a list of all of the components registered with prefixes that start with: IRIS.filter.\nKotlin val irisPrefixString =\"IRIS.filter.\"\nval irisComponents: List<Location> = listLocationsBy(irisPrefixString)\n\n// log Assembly and HCD location\nirisComponents.forEach {\n    when (it.connection.componentId.componentType) {\n        Assembly -> info(\"Assembly starting with $irisPrefixString is registered with location: $it\")\n\n        HCD -> info(\"HCD starting with $irisPrefixString is registered with location: $it\")\n\n        else -> error(\"Invalid location: $it found for $irisPrefixString\")\n    }\n}","title":"Prefix"},{"location":"/scripts/dsl/services/location-service.html#onlocationtrackingevent","text":"This DSL allows you to add a callback that is called when the location of the specified connection changes, which is represented by a TrackingEvent.\nTrackingEvent has following two subclasses\nLocationUpdated: Published when the location is registered with the Location Service LocationRemoved: Published when the location is removed from the Location Service\nKotlin onObserve(\"monitor-iris-sequencer\") {\n    val irisPrefix = Prefix(\"IRIS.darknight\")\n    val irisComponent = ComponentId(irisPrefix, Sequencer)\n    val irisSequencerConnection = AkkaConnection(irisComponent)\n\n    // send UI events on iris sequencers location change\n    onLocationTrackingEvent(irisSequencerConnection) {\n        when (it) {\n            is LocationUpdated ->\n                sendUIEvent(\"[INFO] Location updated ${it.location()}\")\n\n            is LocationRemoved ->\n                sendUIEvent(\"[ERROR] Location removed for connection: ${it.connection()}\")\n        }\n    }\n}\nNote sendUIEvent used in above examples is just for demonstration purposes and is not part of DSL. The sendUIEvent method, defined elsewhere in the script, publishes a SystemEvent with the provided message.","title":"onLocationTrackingEvent"},{"location":"/scripts/dsl/services/location-service.html#source-code-for-examples","text":"Location Service Examples","title":"Source code for examples"},{"location":"/scripts/dsl/services/config-service.html","text":"","title":"Using the Configuration Service in Scripts"},{"location":"/scripts/dsl/services/config-service.html#using-the-configuration-service-in-scripts","text":"The Configuration Service (CS) is available to script writers using the provided DSL. The Configuration Service DSL is a wrapper over the client Configuration Service module provided by CSW. The detailed documentation of Configuration Service provided by CSW here is useful to understand usage of CS and limits.\nThe CS DSL provides methods to check if a file exists in the Configuration Service and to retrieve a file’s contents.","title":"Using the Configuration Service in Scripts"},{"location":"/scripts/dsl/services/config-service.html#existsconfig","text":"The existsConfig DSL method checks if provided file path exists in Configuration Service with a specific revision id (if provided) and returns true or false based on whether or not the file exists.\nKotlin val commandsFile = \"/wfos/commands.conf\"\nval commandsConfigExist: Boolean = existsConfig(commandsFile)\n\n// terminate script if required configuration file does not exist\nif (!commandsConfigExist) finishWithError(\"Configuration file [$commandsFile] not found in configuration service\")","title":"existsConfig"},{"location":"/scripts/dsl/services/config-service.html#getconfig","text":"The getConfig DSL method retrieves the content of the file present at the provided path in Configuration Service. It returns null if file is not available in Configuration Service.\nIn the below example, we are performing following steps:\nRetrieve a configuration file from Configuration Service Fail/Terminate script if configuration file does not exist Parse retrieved configuration file and convert it to MotorCommands domain model When Sequencer receives set-motor-speed command, then submit set-speed command to downstream motor HCD When Sequencer receives rotate-motor command, then send set-resolution command to downstream motor HCD\nKotlin val wfosCommandsFile = \"/wfos/commands.conf\"\n\n// retrieve configuration file from config service, terminate script if configuration file does not exist\nval commandsConfig: Config = getConfig(wfosCommandsFile)\n        ?: finishWithError(\"Configuration file [$wfosCommandsFile] not found in configuration service\")\n\nval motorCommands = MotorCommands.from(commandsConfig)\n\n// on receiving `set-motor-speed` command, send `set-speed` command to downstream motor hcd\nonSetup(\"set-motor-speed\") {\n    val motorSpeedParam = motorSpeedKey.set(motorCommands.setMotorSpeed)\n    val setSpeedCommand = Setup(motorPrefixStr, \"set-speed\").add(motorSpeedParam)\n    motorHcd.submit(setSpeedCommand)\n}\n\n// on receiving `set-step-motor-resolution` command, send `set-resolution` command to downstream motor hcd\nonSetup(\"set-step-motor-resolution\") {\n    val setResolutionParam = motorResolutionKey.set(motorCommands.setStepMotorResolution)\n    val setResolutionCommand = Setup(motorPrefixStr, \"set-resolution\").add(setResolutionParam)\n    motorHcd.submit(setResolutionCommand)\n}\nThe following example shows sample code for converting a Config object retrieved from the Configuration Service to custom domain models. Note that TMT standard for configuration files is HOCON as supported by CSW.\nRefer to this guide for complete usage of Config.\nKotlin /**\n * ======== Sample commands.conf file ========\n * wfos.motor.commands {\n *      set-motor-speed = 50\n *      set-step-motor-resolution = \"1080p\"\n * }\n */\ndata class MotorCommands(val setMotorSpeed: Long, val setStepMotorResolution: String) {\n\n    // static factory to create `MotorCommands` from `Config` object\n    // Ex. MotorCommands.from(config)\n    companion object {\n        fun from(wfosCommandsConfig: Config): MotorCommands {\n            val motorCommandsConfig: Config = wfosCommandsConfig.getConfig(\"wfos.motor.commands\")\n            return MotorCommands(\n                    motorCommandsConfig.getLong(\"set-motor-speed\"),\n                    motorCommandsConfig.getString(\"set-step-motor-resolution\")\n            )\n        }\n    }\n}","title":"getConfig"},{"location":"/scripts/dsl/services/config-service.html#source-code-for-examples","text":"Config Service Examples","title":"Source code for examples"},{"location":"/scripts/dsl/services/command-service.html","text":"","title":"Command Service for Assemblies and HCDs"},{"location":"/scripts/dsl/services/command-service.html#command-service-for-assemblies-and-hcds","text":"A Sequencer script can send commands to Assemblies and HCDs. This section describes the Command Service DSL that is a wrapper for the CSW Command Service module for sending commands to Assemblies or HCDs within scripts. You can refer to detailed documentation of the Command Service provided by CSW here.\nThe DSL provides a way to define an Assembly or HCD as an object. This object encapsulates the Location Service and Command Service of CSW to provide a higher level DSL for script usage. This DSL exposes following APIs:\nA Sequencer can also send Sequences to other Sequencers. See here for more information on sending Sequences to Sequencers.","title":"Command Service for Assemblies and HCDs"},{"location":"/scripts/dsl/services/command-service.html#assembly","text":"The Assembly DSL method creates a Command Service entity for an Assembly with the provided Prefix that can be used to send commands from a script, such as sending Setups or Observes or lifecycle methods e.g. goOnline, goOffline, lock Assembly etc. This DSL method provides a default timeout which will be used for commands like submitAndWait, queryFinal etc, but also allows adding an Assembly-specific default timeout. The built-in default timeout is 10 seconds. Commands requiring a timeout also allow command-specific timeouts.\nAssembly takes the following parameters:\nprefix: Prefix of the Assembly as defined in the Assembly’s model file defaultTimeout: optional command response timeout to be used when not explicitly provided for command\nKotlin val galilAssembly = Assembly(WFOS, \"FilterWheel\")\n\nval galilAssembly2 = Assembly(WFOS, \"FilterWheel\", defaultTimeout = 20.seconds)","title":"Assembly"},{"location":"/scripts/dsl/services/command-service.html#hcd","text":"The HCD DSL method creates a Command Service DSL entity for an HCD with the provided Prefix that can be used to send commands from a script, such as sending Setups or Observes or lifecycle methods e.g. goOnline, goOffline, lock HCD etc. This DSL method provides a default timeout which will be used for commands like submitAndWait, queryFinal etc., but also allows adding an HCD-specific default timeout. The built-in timeout is 10.seconds. Commands requiring a timeout also allow command-specific timeouts.\nHCD takes the following parameters:\nprefix: - Prefix of HCD as defined in the HCD’s model file defaultTimeout: - optional command response timeout to be used when not explicitly provided for command\nKotlin val filterWheelHcd = Hcd(WFOS, \"GalilHcd1\")\n\nval filterWheelHcd2 = Hcd(WFOS, \"GalilHcd1\", defaultTimeout = 20.seconds)\nResolving a Component with Location Service Since all the components in the TMT architecture are dynamic in nature, which implies they can be shutdown and spawned dynamically on some other location, the Assembly/HCD is resolved each time the Command Service DSL is used. It is possible to create an Assembly or HCD entity for a non-existent component, but a command to the component will fail because the component is resolved when the command is sent.","title":"HCD"},{"location":"/scripts/dsl/services/command-service.html#command-service-dsl","text":"The Command Service API provided by the DSL for use in scripts is similar to the CommandService API provided by Scala or Java. The big difference is that the DSL does not return a Future. In the scripting language, even though the commands are asynchronous, each completes and returns its value, such as a SubmitResponse, not a Future[SubmitResponse]. This section describes each of the available DSL methods.","title":"Command Service DSL"},{"location":"/scripts/dsl/services/command-service.html#submit","text":"The submit method of the DSL allows sending a Setup or Observe command to an Assembly/HCD. submit returns a positive SubmitResponse which can be Completed or Started. A very short command may quickly return Completed. A command that starts actions that are long-running returns Started.\nsubmit or submitAndWait? submit is similar to submitAndWait in that both send a command to another component. submit is the right choice when the command starts long-running actions, and you need to take additional actions before the command completes. A successful long-running command returns a Started response that includes a runId, which can be used with query or queryFinal to wait for the commands final response at a later time. submitAndWait combines submit and queryFinal as a shortcut when you only need to wait for all started actions to complete before taking the next script step.\nThe following example shows a submit to the Galil Assembly that is going to take a long time.\nKotlin val parameters = intKey(\"target\").set(100)\nval galilCommand = Setup(\"ESW.IRIS_darkNight\", \"moveWheel\", command.obsId).add(parameters)\nval startedResponse = galilAssembly.submit(galilCommand)","title":"Submit"},{"location":"/scripts/dsl/services/command-service.html#error-handling-in-scripts","text":"In most cases errors encountered in the execution of a script will likely cause the command (and therefore, Sequence) to fail. Most of the time, not much can be done when an error occurs other than to report the error that occurred. In some cases, it is possible some remediation can be performed, but it is likely the Sequence would need to run again. For this reason, the error handling of commands in a script has been simplified such that errors from the Command Service DSL calls are captured and delivered to error handlers specific to a single sequence command handler, or global to the entire script. In this way, such error handling does not need to be repeated throughout the script for each command sent.\nTo add an error handler to a command handler, extend the command handler block with a .onError block. The SubmitResponse error is captured in a ScriptError type and passed into the block. This type contains a reason String explaining what went wrong. If the command handler does not have an onError block, the global error handler will be called. See the page on Script Handlers for more information. After this block is called, the command sending the sequence terminates with an Error status.\nBecause of this mechanism, a submit (and other Command Service API calls) always returns a positive SubmitResponse. For submit, the two possible responses are Started and Completed. They can be handled using the .onStarted and .onCompleted methods, respectively. These methods allow you to specify a block of code to be called in each of those cases. Alternatively, a Kotlin when can be used to perform pattern matching on the result. An example of both are shown below, along with an example of an onError handler for the sequence command handler. Since there are only two positive options, forming an if statement using the isStarted call on the SubmitResponse is convenient in many cases.\nKotlin onSetup(\"submit-error-handling\") { command ->\n\n    /* =========== Scenario-1 (default) ============\n     * if submit returns negative response (which is considered as error by default)\n     * then current execution flow breaks and onError command handler gets invoked\n     * Hence, only Started (in case of long-running command) or Completed (in case of short running command) response is returned\n     */\n    val parameters = intKey(\"target\").set(100)\n    val galilCommand = Setup(\"ESW.IRIS_darkNight\", \"moveWheel\", command.obsId).add(parameters)\n    val positiveSubmitResponse: CommandResponse.SubmitResponse = galilAssembly.submit(galilCommand)\n\n    //  First approach - using custom dsl (this is an alternative to kotlin pattern match using when)\n    positiveSubmitResponse\n            .onStarted { startedRes ->\n                val completedResponse = galilAssembly.queryFinal(startedRes.runId())\n                info(\"command completed with result: ${completedResponse.result}\")\n            }\n            .onCompleted { completed ->\n                info(\"command with ${completed.runId()} is completed with result: ${completed.result}\")\n            }\n\n    // Second approach - using kotlin pattern matching\n    when (positiveSubmitResponse) {\n        is CommandResponse.Started -> {\n            val completedResponse = galilAssembly.queryFinal(positiveSubmitResponse.runId())\n            info(\"command completed with response: $completedResponse\")\n        }\n        is CommandResponse.Completed -> info(\"command with ${positiveSubmitResponse.runId()} is completed\")\n    }\n\n    // Third approach - use the isStarted value\n    if (positiveSubmitResponse.isStarted) {\n        val completedResponse = galilAssembly.queryFinal(positiveSubmitResponse.runId())\n        info(\"command completed with result: ${completedResponse.result}\")\n    } else {\n        info(\"command with ${positiveSubmitResponse.runId()} is completed with result: ${positiveSubmitResponse.result}\")\n    }\n\n}.onError { err ->\n    // onError is called when submit command to galil assembly fails\n    error(err.reason)\n}\nIf you desire to handle errors manually on a per-command basis, the resumeOnError flag can be used. If this flag is set to true, then script execution continues, and action is taken based on custom logic in the script using an .onFailed method. You can still choose to terminate the Sequence using the onFailedTerminate utility. This will cause similar behavior as when the flag is not set by calling the onError or onGlobalError blocks and terminating the sequence, if the SubmitResponse is some kind of error.\nKotlin onSetup(\"submit-error-handling-resume\") { command ->\n    /* =========== Scenario-2 (resumeOnError = true) ============\n     * if submit returns negative response\n     * then current execution flow will continue because resumeOnError = true\n     * Here, all the possible SubmitResponses are expected to be returned\n     */\n    val parameters = intKey(\"target\").set(100)\n    val galilCommand = Setup(\"ESW.iris_darkNight\", \"moveWheel\", command.obsId).add(parameters)\n    val submitResponse: CommandResponse.SubmitResponse = galilAssembly.submit(galilCommand, resumeOnError = true)\n\n    //  First approach - using custom dsl (this is an alternative to kotlin pattern match using when)\n    submitResponse\n            .onStarted { startedRes ->\n                val completedResponse = galilAssembly.queryFinal(startedRes.runId())\n                info(\"command completed with result: ${completedResponse.result}\")\n            }\n            .onCompleted { completed ->\n                info(\"command with ${completed.runId()} is completed with result: ${completed.result}\")\n            }\n            .onFailed { negativeResponse ->\n                error(\"command with ${negativeResponse.runId()} is failed with result: $negativeResponse\")\n\n            }\n\n    // Script writer can still choose to terminate sequence in case of negative response\n    submitResponse.onFailedTerminate()\n}","title":"Error Handling in Scripts"},{"location":"/scripts/dsl/services/command-service.html#submitandwait","text":"The submitAndWait DSL method combines submit and queryFinal allowing you to submit a command to an Assembly/HCD and wait for the final response. A timeout can be specified if needed, indicating the time submitAndWait will wait to receive the final SubmitResponse. If this time expires, the command will timeout, breaking script execution flow, and the Sequence is terminated with failure. If timeout is not provided explicitly, then the timeout provided while creating the instance of Assembly or HCD is used as default timeout. This command follows the same error handling semantics as submit as described above.\nKotlin val parameters = intKey(\"target\").set(100)\nval galilCommand = Setup(\"ESW.IRIS_darkNight\", \"moveWheel\", command.obsId).add(parameters)\ngalilAssembly.submitAndWait(galilCommand, timeout = 20.seconds)\nDo I Need a Result Variable? Note that this example does not save the submitAndWait result. If a submitAndWait does not return a result, and since the submitAndWait returns only after the actions are completed, and errors are handled elsewhere, there is not much reason to bother with the result. If it is the case where the command returns a result in the Completed, save the returned Completed value and retrieve the result.","title":"SubmitAndWait"},{"location":"/scripts/dsl/services/command-service.html#query","text":"The query DSL method allows you to check the status of a submit command that has returned a Started response . The Started response contains a runId that can be used to identify the command to query. The query command returns immediately while queryFinal waits for the final response. Therefore, query can be used to poll for the final response. Note that if the runId is not present or has been removed from the CRM, the response returned is an Invalid response with an IdNotAvailableIssue. This command follows the same error handling semantics as submit as described above.\nKotlin val response = galilAssembly.submit(command)\nval queryResponse = galilAssembly.query(response.runId())","title":"Query"},{"location":"/scripts/dsl/services/command-service.html#queryfinal","text":"The queryFinal DSL method allows querying for the final response of a submit command that has returned a Started response . The Started response contains a runId that can be used to identify the command. A timeout can be specified, indicating how long queryFinal wait for getting the final SubmitResponse. If this time expires, the command will timeout, breaking script execution flow, and the sequence is terminated with failure. If timeout is not provided explicitly, then the timeout provided while creating instance of Assembly/HCD is used. Note that if the runId is not present or has been removed from the CRM, the response returned is an Invalid response with an IdNotAvailableIssue. This command follows the same error handling semantics as submit as described above.\nKotlin val startedResponse = galilAssembly.submit(galilCommand)\nval finalResponse = galilAssembly.queryFinal(startedResponse.runId())","title":"QueryFinal"},{"location":"/scripts/dsl/services/command-service.html#subscribecurrentstate","text":"This DSL allows subscribing to the current state data of the Assembly/HCD. You can provide a list of state names to subscribe to. If not provided, all current state values are subscribed to. This DSL takes a callback (or lambda), which is called whenever the Assembly/HCD publishes an item in the list of subscribed values.\nKotlin galilAssembly.subscribeCurrentState(StateName(\"stateName1\")) { currentState ->\n    // do something with currentState matching provided state name\n    println(\"current state : $currentState\")\n}","title":"SubscribeCurrentState"},{"location":"/scripts/dsl/services/command-service.html#going-to-online-offline-mode","text":"A Sequencer can command an Assembly or HCD to go to the online or offline state. This is a wrapper for putting another Assembly/HCD into Online or Offline mode. When an Assembly/HCD receives this command, its respective handlers are called. The detailed documentation of Online/Offline handlers for Assembly/HCD can be found here","title":"Going To online/offline Mode"},{"location":"/scripts/dsl/services/command-service.html#gooffline","text":"A declared Assembly/HCD includes a DSL command puts an Assembly/HCD into Offline mode. goOffline can be called from anywhere in script. This results in the triggering of the onGoOffline handler in the component. The following example shows a Sequencer sending the goOffline command to a downstream “Galil Assembly” when it receives a goOffline command.\nKotlin onGoOffline {\n    // do some actions to go offline\n\n    galilAssembly.goOffline()\n\n}","title":"goOffline"},{"location":"/scripts/dsl/services/command-service.html#goonline","text":"A declared Assembly/HCD includes a DSL command to put an Assembly/HCD into Online mode. goOnline can be called from anywhere in the script. This results in the triggering of the onGoOnline handler in the component. The following example shows a Sequencer sending the goOnline command to a downstream “Galil Assembly” when it receives a goOnline command.\nKotlin onGoOnline {\n    // do some actions to go online\n    galilAssembly.goOnline()\n}","title":"goOnline"},{"location":"/scripts/dsl/services/command-service.html#operations-mode-and-diagnostic-mode","text":"A Sequencer can place an Assembly or HCD in a diagnostic technical data mode. There are two methods in the Assembly/HCD Command Service DSL related to technical data collection.","title":"Operations Mode and Diagnostic Mode"},{"location":"/scripts/dsl/services/command-service.html#diagnosticmode","text":"The diagnosticMode DSL method puts an Assembly/HCD into Diagnostic data mode based on a hint at the specified startTime. diagnosticMode can be called from anywhere in script. The hint is specified by the component. Not all components have diagnostic modes for technical data. The following example shows a Sequencer sending the diagnosticMode command to a downstream “Galil Assembly” when it receives a diagnosticMode command.\nKotlin onDiagnosticMode { startTime, hint ->\n    // do some actions to go to diagnostic mode based on hint\n    galilAssembly.diagnosticMode(startTime, hint)\n}","title":"diagnosticMode"},{"location":"/scripts/dsl/services/command-service.html#operationsmode","text":"This operationsMode DSL method returns an Assembly/HCD to Operations mode, the normal running mode. operationsMode can be called from anywhere in script. The following example shows a Sequencer sending the operationsMode command to a downstream “Galil Assembly” when it receives an operationsMode command.\nKotlin onOperationsMode {\n    // do some actions to go to operations mode\n    galilAssembly.operationsMode()\n}","title":"operationsMode"},{"location":"/scripts/dsl/services/command-service.html#locking-and-unlocking-assemblies-and-hcds","text":"A Sequencer script can lock and unlock individual Assemblies and HCDs. When a Sequencer locks a component, it is the only component that can send commands to the component that will be accepted.","title":"Locking and Unlocking Assemblies and HCDs"},{"location":"/scripts/dsl/services/command-service.html#lock","text":"This Command Service DSL method locks an Assembly/HCD from a Sequencer script for the specified duration. When you lock an Assembly/HCD, the Sequencer sending the lock command is designated as the source, which is the only component that can send commands to the locked component while locked. This DSL returns a LockingResponse which can be LockAcquired in the successful scenario or AcquiringLockFailed in case of failure. This DSL also provides callbacks for onLockAboutToExpire and, onLockExpired where script writer can write custom logic. These callbacks are thread safe.\nKotlin galilAssembly.lock(\n        leaseDuration = 20.seconds,\n        onLockAboutToExpire = {\n            // do something when lock is about to expire\n            publishEvent(SystemEvent(\"ESW.test\", \"TCS.lock.about.to.expire\"))\n        },\n        onLockExpired = {\n            // do something when lock expired\n            publishEvent(SystemEvent(\"ESW.test\", \"TCS.lock.expired\"))\n        }\n)","title":"lock"},{"location":"/scripts/dsl/services/command-service.html#unlock","text":"This Command Service DSL method unlocks an Assembly/HCD from a Sequencer script. Only the Sequencer that locked the Assembly/HCD can unlock it. This DSL returns a LockingResponse which can be LockReleased or LockAlreadyReleased in the successful scenario or ReleasingLockFailed in case of failure.\nKotlin galilAssembly.unlock()","title":"unlock"},{"location":"/scripts/dsl/services/command-service.html#source-code-for-examples","text":"Command Service Examples","title":"Source code for examples"},{"location":"/scripts/dsl/services/sequencer-command-service.html","text":"","title":"Sequencer Command Service"},{"location":"/scripts/dsl/services/sequencer-command-service.html#sequencer-command-service","text":"A Sequencer can send commands to Assemblies and HCDs and Sequences to other Sequencers. In order to interact or send commands from one Sequencer to the other, one needs to create a Sequencer instance first. The API provided by a Sequencer Command Service is tailored to Sequencer to Sequencer functionality.","title":"Sequencer Command Service"},{"location":"/scripts/dsl/services/sequencer-command-service.html#sequencer","text":"First a Sequencer instance is needed. To create a Sequencer instance, the following parameters need to be passed to the Sequencer method:\nsubsystem: Subsystem of the Sequencer to be resolved and sent commands (for eg. TCS, IRIS) obsMode: observing mode of the Sequencer to be resolved and send commands to (for eg. wfos_imaging, wfos_spec) defaultTimeout: optional max timeout to wait for completion of Sequences sent with sumbitAndWait or queryFinal. The default value for this option is set to 10 hours since it will be common that the handling of Sequences can take a long time, and we don’t want unexpected timeouts to occur in production. For development, it might make sense to set this to some smaller value. This can always be overridden in the specific submitAndWait and queryFinal calls, when appropriate (see below).\nHere is an example:\nKotlin // create a sequencer entity\nval wfos = Sequencer(WFOS, ObsMode(\"wfos_darknight\"))\nHere is one showing the setting of the default timeout:\nKotlin // create a sequencer entity with a timeout\nval wfos2 = Sequencer(WFOS, ObsMode(\"wfos_darknight\"), 5.minutes)\nResolving a Component with Location Service Since all the components in the TMT architecture are dynamic in nature, which implies they can be shutdown and spawned dynamically on some other location, the Sequencer is resolved each time the Command Service DSL is used. It is possible to create a Sequencer entity for a non-existent component, but a command to the component will fail because the component is resolved when the command is sent.","title":"Sequencer"},{"location":"/scripts/dsl/services/sequencer-command-service.html#submitting-sequences-to-a-sequencer-querying-the-response","text":"","title":"Submitting Sequences to a Sequencer & Querying the Response"},{"location":"/scripts/dsl/services/sequencer-command-service.html#creating-a-sequence","text":"Unlike Assemblies and HCDs, Sequencers send Sequences to other Sequencers. A Sequence is a list of SequenceCommand type instances, each of which can be one of the Setup, Observe or Wait types. To create a Sequence, create individual SequenceCommand objects and then create a Sequence with the sequenceOf DSL method as shown below.\nKotlin val wfosCommand1: SequenceCommand = Setup(\"ESW.wfos_darknight\", \"wfosCommand1\")\nval wfosCommand2: SequenceCommand = Setup(\"ESW.wfos_darknight\", \"wfosCommand2\")\nval sequence: Sequence = sequenceOf(wfosCommand1, wfosCommand2)\nThis example Sequence consists of two steps. The Sequencer sends the two step Sequence to the destination Sequencer and waits for it to complete, which means both of the two commands/steps are executed and completed. All Sequence steps must complete successfully for the Sequence to complete successfully.\nThe API for Sequence is here. The API for SequenceCommand is here","title":"Creating a Sequence"},{"location":"/scripts/dsl/services/sequencer-command-service.html#submit-a-sequence-to-a-sequencer","text":"In order to send a Sequence to another Sequencer, you can use the submit or submitAndWait DSL method as shown in examples below. The submit DSL method sends the Sequence and returns Started if the Sequence is started or Invalid if there is a reason it cannot be started. The query and queryFinal DSL is provided to check the response of a submitted sequence.\nKotlin val submitResponse: SubmitResponse = wfos.submit(sequence)\nval queryResponse: SubmitResponse = wfos.query(submitResponse.runId())\nThe query DSL method allows checking on the state of the Sequence. query returns the current response immediately, which could be either a final response (eg. Completed) or the Started response. The runId of the submitted Sequence can be obtained from the SubmitResponse returned by submit. query is useful in the case where polling of the command is needed or the script needs to take other actions and periodically check for the completion of the Sequence.\nNote that if the runId is not present in the Sequencer or has been removed from the CRM, the response returned is an Invalid response with an IdNotAvailableIssue.\nPlease refer to SubmitResponse extension utilities for using helper methods on SubmitResponse.\nBy default, any negative SubmitResponse (for e.g. Invalid or Error) is treated as a Script error. Refer to error handling section for more details. Alternatively, if you do not want to escalate a negative SubmitResponse, you can use submit Api with resumeOnError flag.\nKotlin val response: SubmitResponse = wfos.submit(sequence, resumeOnError = true)","title":"Submit a Sequence to a Sequencer"},{"location":"/scripts/dsl/services/sequencer-command-service.html#queryfinal","text":"While query returns immediately, queryFinal will wait for the final response of the Sequence for the defaultTimeout specified at the time of creation of the Sequencer instance.\nKotlin val finalResponse: SubmitResponse = wfos.queryFinal(submitResponse.runId())\nIf you want to increase/decrease the defaultTimeout, you can use the other variation of the same queryFinal DSL method which takes a timeout.\nKotlin val finalRes: SubmitResponse = wfos.queryFinal(submitResponse.runId(), 5.seconds)","title":"QueryFinal"},{"location":"/scripts/dsl/services/sequencer-command-service.html#sending-a-sequence-with-submitandwait","text":"The submitAndWait DSL method is a combination of submit followed with queryFinal. If you are not interested in the initial response but only in final response of the Sequence, the submitAndWait DSL method is more convenient. It submits the Sequence and waits for the final response. If the Sequence was successfully Started, it will wait until the defaultTimeout specified at the time of creation of the Sequencer instance.\nKotlin val sequenceResponse: SubmitResponse = wfos.submitAndWait(sequence)\nIf you want to increase/decrease the default timeout, you can use the other variation of the same DSL method which takes a timeout.\nKotlin val sequenceRes: SubmitResponse = wfos.submitAndWait(sequence, 5.seconds)","title":"Sending a Sequence with submitAndWait"},{"location":"/scripts/dsl/services/sequencer-command-service.html#handling-online-and-offline","text":"As with Assemblies and HCDs, a Sequencer can also indicate to another Sequencer to go offline or online using the Sequencer Command Service DSL.","title":"Handling Online and Offline"},{"location":"/scripts/dsl/services/sequencer-command-service.html#sequencer-sends-goonline","text":"This DSL method is used to send online/offline commands to other sequencers. The Sequencer can go online only if it is currently in the offline state. If this command is received in any other state apart from offline, an Unhandled response will be sent.\nIf the Sequencer is in the Offline state, and it receives the goOnline command, the goOnline handlers of the receiving Sequencer will be called. In case the handlers fail, a GoOnlineHookFailed response would be sent, and the Sequencer remains in the previous state. Otherwise, an Ok response is returned, and the Sequencer goes in online(idle) state.\nKotlin val onlineResponse: GoOnlineResponse = wfos.goOnline()","title":"Sequencer Sends goOnline"},{"location":"/scripts/dsl/services/sequencer-command-service.html#sequencer-sends-gooffline","text":"Go offline command is received in 2 states only.\nIf the Sequencer is Idle, which means it is not processing any sequence currently If the Sequencer is Loaded with a sequence\nIf this command is sent in any other state apart from these, an Unhandled response will be sent. If the Sequencer is in idle/loaded state, and it receives the goOffline command, the goOffline handlers of the receiving Sequencer will be called. In case the handlers fail, a GoOfflineHookFailed response would be sent, resulting the Sequencer remains in the previous state. Otherwise, an Ok message is sent, and the Sequencer goes to offline state.\nKotlin val offlineResponse: GoOfflineResponse = wfos.goOffline()","title":"Sequencer Sends goOffline"},{"location":"/scripts/dsl/services/sequencer-command-service.html#handling-diagnostic-and-operations-mode","text":"","title":"Handling Diagnostic and Operations Mode"},{"location":"/scripts/dsl/services/sequencer-command-service.html#diagnostic-mode","text":"The diagnosticMode command can be sent to Sequencers in all states and a DiagnosticModeResponse is returned. If the Sequencer script has defined the diagnostic mode handlers, they will be called. If the handlers execute successfully, an Ok response is sent; otherwise, the DiagnosticHookFailed response is sent.\nKotlin val diagnosticModeResponse: DiagnosticModeResponse = wfos.diagnosticMode(utcTimeNow(), \"engineering\")","title":"Diagnostic Mode"},{"location":"/scripts/dsl/services/sequencer-command-service.html#operations-mode","text":"The operationsMode command returns a Sequencer in a diagnostic data mode to normal operation. operationsMode is accepted by Sequencers in all states and an OperationsModeResponse is returned to the sender. If the Sequencer has defined its operations mode handlers, they will be called. If the handlers execute successfully, an Ok response is sent; otherwise, the OperationsHookFailed response is sent.\nKotlin val operationsModeResponse: OperationsModeResponse = wfos.operationsMode()","title":"Operations Mode"},{"location":"/scripts/dsl/services/sequencer-command-service.html#aborting-and-stopping-a-sequence","text":"Stopping and aborting are meant to handle early termination of observing sequences in instruments. Aborting indicates that the current observe should stop as soon as possible and save the data if possible. Stop indicates that the current observe should stop at the end of the current step. In both cases, the observation is over and no subsequent steps can be executed.\nStop and abort commands are accepted only if the Sequencer is in Running state, which means it is executing a sequence. If this command is sent in any other state, an Unhandled response is returned. In all other cases, an Ok response is sent.","title":"Aborting and Stopping a Sequence"},{"location":"/scripts/dsl/services/sequencer-command-service.html#aborting-a-sequence","text":"On receiving the abort command in the Running state, the Sequencer will execute the abort sequence handlers and on completion of execution of handlers (whether successful or failed), the Sequencer will discard all the pending steps and return an Ok response.\nNote that, abort of a sequence does not abruptly terminate the in-flight step(s) which are already under execution. It will discard only the pending steps, and the sequence is finished gracefully after the inflight step(s) are finished although the script can take action to end the current step immediately.\nKotlin val abortResponse: OkOrUnhandledResponse = wfos.abortSequence()","title":"Aborting a Sequence"},{"location":"/scripts/dsl/services/sequencer-command-service.html#stopping-a-sequence","text":"Stopping a Sequence is very similar to aborting. The only difference is that instead of abort handlers, the stop handlers are called.\nKotlin val stopResponse: OkOrUnhandledResponse = wfos.stop()","title":"Stopping a Sequence"},{"location":"/scripts/dsl/services/event-service.html","text":"","title":"Event Service"},{"location":"/scripts/dsl/services/event-service.html#event-service","text":"The Event Service DSL is a Kotlin wrapper for the CSW Event Service. This DSL has the ability of publishing, getting, and subscribing to events, and also contains some helper methods for model creation. You can refer to the detailed documentation of Event Service provided by CSW here.","title":"Event Service"},{"location":"/scripts/dsl/services/event-service.html#helper-methods","text":"These methods can be used to create System and Observe Events. Additionally, a System or Observe “Event Variable” can be created that can be tied to the first value of a parameter of an Event, similar to the way local variables are tied to “process variables” in the EPICS State Notation Language.","title":"Helper Methods"},{"location":"/scripts/dsl/services/event-service.html#systemevent","text":"Helper DSL to create a SystemEvent from the provided prefix, event name and parameters (optional).\nKotlin val parameters = intKey(\"stepNumber\").set(1)\nval systemEvent: SystemEvent = SystemEvent(\"ESW.IRIS_darkNight\", \"stepInfo\", parameters)","title":"SystemEvent"},{"location":"/scripts/dsl/services/event-service.html#observeevent","text":"Helper DSL to create an ObserveEvent using factory provided to create various sequencer observe events.\nKotlin val parameters = intKey(\"stepNumber\").set(1)\nval observeEvent: ObserveEvent = sequencerObserveEvent.observationStart(ObsId(\"2020A-001-123\"))","title":"ObserveEvent"},{"location":"/scripts/dsl/services/event-service.html#publishevent","text":"DSL to publish the given Event.\nKotlin val systemEvent: SystemEvent = SystemEvent(\"ESW.IRIS_darkNight\", \"stepInfo\", parameters)\npublishEvent(systemEvent)\nThis DSL can also publish events periodically when provided with the optional duration and an event generator function. In the below example, an Event with temperature Key will get published every 10 seconds, with current temperature value given by getTemperature method.\nKotlin publishEvent(10.seconds) {\n    val temperatureKey = intKey(\"temperature\").set(getTemperature())\n    SystemEvent(\"ESW.IRIS_darkNight\", \"temperature\", temperatureKey)\n}","title":"publishEvent"},{"location":"/scripts/dsl/services/event-service.html#onevent","text":"DSL to subscribe to events getting published on the given EventKey names. This DSL takes a callback as a lambda which operates on an event. The callback block will be invoked whenever an Event is published on any of the provided event keys.\nKotlin val tempEventKey = \"IRIS.env.temperature.temp\"\nval stateEventKey = \"IRIS.env.temperature.state\"\nonEvent(tempEventKey, stateEventKey) { event ->\n    // logic to execute on every event\n    println(event.eventKey())\n}\nThis DSL has the ability to control the subscription rate by providing a duration with the callback. This operates like the Rate Adapter Mode for regular Event Service subscriptions.\nKotlin onEvent(tempEventKey, stateEventKey, duration = 2.seconds) { event ->\n    // logic to execute on every event\n    println(event.eventKey())\n}","title":"onEvent"},{"location":"/scripts/dsl/services/event-service.html#getevent","text":"DSL to get the latest Event published on each of the given EventKey names. There are two variations. One is for getting the latest event for single key, the other variation is to get the latest events against multiple keys.\nKotlin val tempEventKey = \"IRIS.env.temperature.temp\"\nval stateEventKey = \"IRIS.env.temperature.state\"\nval event = getEvent(tempEventKey) // for single event key\n\nval events: Set<Event> = getEvent(tempEventKey, stateEventKey) // for single event key","title":"getEvent"},{"location":"/scripts/dsl/services/event-service.html#source-code-for-examples","text":"Event Service Examples","title":"Source code for examples"},{"location":"/scripts/dsl/services/logging-service.html","text":"","title":"Logging Service"},{"location":"/scripts/dsl/services/logging-service.html#logging-service","text":"The Logging Service DSL is a wrapper for the Logging Service module provided by CSW. You can refer to the detailed documentation of Logging Service provided by CSW here.\nThe CSW documentation explains all the supported logging related configurations for example, default log level, component specific log levels, log appender etc. It also explains how to override default values.\nAll Sequencer scripts are expected to be kept inside the sequencer-scripts repo under Subsystem specific directories. Read more about adding new scripts and script specific configuration files here.\nThe default log level for sequencers can be set using command line options. See the SequencerApp documentation for more information.\nThe Logging Service DSL exposes following APIs to script writers for logging at different levels:","title":"Logging Service"},{"location":"/scripts/dsl/services/logging-service.html#trace","text":"Kotlin trace(message = \"logging at trace level\")\n\ntrace(message = \"logging at trace level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"trace"},{"location":"/scripts/dsl/services/logging-service.html#debug","text":"Kotlin debug(message = \"logging at debug level\")\n\ndebug(message = \"logging at debug level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"debug"},{"location":"/scripts/dsl/services/logging-service.html#info","text":"Kotlin info(message = \"logging at info level\")\n\ninfo(message = \"logging at info level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"info"},{"location":"/scripts/dsl/services/logging-service.html#warn","text":"Kotlin warn(message = \"logging at warn level\")\n\nwarn(message = \"logging at warn level\", cause = highTempRaisedEx)\n\nwarn(message = \"logging at warn level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))\n\nwarn(message = \"logging at warn level\", cause = highTempRaisedEx,\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"warn"},{"location":"/scripts/dsl/services/logging-service.html#error","text":"Kotlin error(message = \"logging at error level\")\n\nerror(message = \"logging at error level\", cause = highTempRaisedEx)\n\nerror(message = \"logging at error level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))\n\nerror(message = \"logging at error level\", cause = highTempRaisedEx,\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"error"},{"location":"/scripts/dsl/services/logging-service.html#fatal","text":"Kotlin fatal(message = \"logging at fatal level\")\n\nfatal(message = \"logging at fatal level\", cause = highTempRaisedEx)\n\nfatal(message = \"logging at fatal level\",\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))\n\nfatal(message = \"logging at fatal level\", cause = highTempRaisedEx,\n        extraInfo = mapOf(\"key1\" to \"value1\", \"key2\" to \"value2\"))","title":"fatal"},{"location":"/scripts/dsl/services/logging-service.html#source-code-for-examples","text":"Logging Service Examples","title":"Source code for examples"},{"location":"/scripts/dsl/services/alarm-service.html","text":"","title":"Alarm Service"},{"location":"/scripts/dsl/services/alarm-service.html#alarm-service","text":"The Alarm Service DSL is a wrapper for the Alarm Service module provided by CSW. You can refer to detailed documentation of the Alarm Service provided by CSW here.\nThis DSL provides an API to set the severity of an alarm. This is the component API for CSW Alarm Service. While this API is available for special purposes, alarms should be maintained by lower-level Assemblies and HCDs, and not in the Sequencers. This is also a problem because Sequencers do not always execute.","title":"Alarm Service"},{"location":"/scripts/dsl/services/alarm-service.html#setseverity","text":"This API sets alarm severity for an AlarmKey to the provided level and keeps refreshing it in the background with the interval of config value csw-alarm.refresh-interval. Default value for csw-alarm.refresh-interval config is 3 seconds which is configured in downstream CSW alarm modules reference.conf file.\nThe setSeverity API requires user to provide AlarmKey and AlarmSeverity.","title":"setSeverity"},{"location":"/scripts/dsl/services/alarm-service.html#alarmkey","text":"AlarmKey represents unique alarm in the given subsystem and component e.g. nfiraos.trombone.tromboneaxislowlimitalarm\nThe following example demonstrates the creation of an AlarmKey\nKotlin val tromboneTemperatureAlarm =\n        AlarmKey(Prefix(NFIRAOS, \"trombone\"), \"tromboneMotorTemperatureAlarm\")","title":"AlarmKey"},{"location":"/scripts/dsl/services/alarm-service.html#alarmseverity","text":"The supported AlarmSeverity levels are:\nOkay Warning Major Critical Indeterminate\nThe following example demonstrates the usage of the setSeverity API. In this example, a temperature FSM is created, and based on the state of the FSM, the severity is set accordingly.\nState Temperature Severity OK Temperature less than or equal to 40 Okay ERROR Temperature is greater than 40 Major\nKotlin /**\n * temp <= 40   => Severity.Okay\n * else        => Severity.Major\n */\nval temperatureFsm = Fsm(\"TEMP\", OK) {\n    state(OK) {\n        entry {\n            setSeverity(tromboneTemperatureAlarm, Okay)\n        }\n\n        on(temperatureVar.first() > 40) {\n            become(ERROR)\n        }\n    }\n\n    state(ERROR) {\n        entry {\n            setSeverity(tromboneTemperatureAlarm, Major)\n        }\n\n        on(temperatureVar.first() <= 40) {\n            become(OK)\n        }\n    }\n}","title":"AlarmSeverity"},{"location":"/scripts/dsl/services/alarm-service.html#source-code-for-examples","text":"Alarm Service Examples","title":"Source code for examples"},{"location":"/scripts/dsl/services/time-service.html","text":"","title":"Time Service Access in Scripts"},{"location":"/scripts/dsl/services/time-service.html#time-service-access-in-scripts","text":"The time and scheduling functionality of the CSW Time Service are available to script writers. Time Service DSL provides access to the Time Service module provided by CSW. This DSL exposes the following API calls to script writers to access time and schedule tasks.","title":"Time Service Access in Scripts"},{"location":"/scripts/dsl/services/time-service.html#time-access","text":"Time Service provides access to both TAI and UTC time that is synchronized at the telescope site with time on all the other computers and also with absolute time provided by a GPS system.\nTime access calls are made available to all scripts. Access to some time functionality requires the import of kotlin.time packages.","title":"Time Access"},{"location":"/scripts/dsl/services/time-service.html#access-utc-time-with-utctimenow","text":"The utcTimeNow Time Service utility returns the current UTC time. The time value returned is a CSW UTCTime type, which is an absolute time value.\nKotlin val currentUtcTime = utcTimeNow()","title":"Access UTC Time with utcTimeNow"},{"location":"/scripts/dsl/services/time-service.html#access-tai-time-with-taitimenow","text":"The taiTimeNow Time Service utility returns the current TAI time. The time value returned is a CSW TAITime type, which is an absolute time value.\nKotlin val currentTaiTime = taiTimeNow()","title":"Access TAI Time with taiTimeNow"},{"location":"/scripts/dsl/services/time-service.html#access-utc-time-in-the-future-with-utctimeafter","text":"The utcTimeAfter Time Service utility provides an absolute UTC time some amount of time from now in the future. The value provided is a duration such as “1 hour”. The returned value is an absolute UTCTime type. The following example shows provides UTC time 1 hour from now.\nKotlin val utcTime = utcTimeAfter(1.hours)","title":"Access UTC time in the Future with utcTimeAfter"},{"location":"/scripts/dsl/services/time-service.html#access-tai-time-in-the-future-with-taitimeafter","text":"The taiTimeAfter Time Service utility provides an absolute TAI time some amount of time from now in the future. The value provided is a duration. The returned value is an absolute TAITime type. The following example shows provides TAI time 1 hour from now.\nKotlin val taiTime = taiTimeAfter(1.hours)","title":"Access TAI Time in the Future with taiTimeAfter"},{"location":"/scripts/dsl/services/time-service.html#scheduling-with-time-service","text":"The Time Service DSL provides script access to the CSW scheduling library allowing scripts to schedule one-off and periodic tasks. Access to the Time Service scheduling functionality is provided in the script writing environment with no extra imports.","title":"Scheduling with Time Service"},{"location":"/scripts/dsl/services/time-service.html#using-scheduleonce","text":"The scheduleOnce Time Service DSL allows scheduling a task in a script once at the specified absolute UTC or TAI time. The function schedules the task and returns a handle that can be used to cancel the execution of the task if it has not yet executed. The task is a callback which will be executed in thread safe way.\nThe following example shows an onSetup handler of a script extracting a scheduled time from a Setup command and then uses the scheduleOnce to send a motion command to a Galil Assembly at the scheduled time.\nKotlin val scheduleTimeKey = utcTimeKey(\"scheduledTime\")\nval schedulePrefix = \"esw.test\"\nval galilAssembly = Assembly(TCS, \"galil\")\n\n//Usage inside handlers - schedule tasks while handling setup/observe commands\nonSetup(\"schedule-once\") { command ->\n    val scheduledTime = command(scheduleTimeKey)\n    val probeCommand = Setup(schedulePrefix, \"scheduledOffset\", command.obsId)\n\n    scheduleOnce(scheduledTime.head()) {\n        galilAssembly.submit(probeCommand)\n    }\n}","title":"Using scheduleOnce"},{"location":"/scripts/dsl/services/time-service.html#using-scheduleoncefromnow","text":"Often, it is necessary to schedule a task in the future some amount of time from now. The scheduleOnceFromNow API allows scheduling non periodic task in script after a specified duration. The task is a callback which will be executed in thread-safe way. This API takes a time Duration type after which task will be scheduled.\nThe following example shows the scheduling of a task after 1 hour from now. The function takes a duration and returns a handle which can be used to cancel the execution of the task if it has not yet executed.\nKotlin scheduleOnceFromNow(1.hours) {\n    publishEvent(SystemEvent(\"LGSF\", \"publish.success\"))\n}","title":"Using scheduleOnceFromNow"},{"location":"/scripts/dsl/services/time-service.html#using-scheduleperiodically","text":"The schedulePeriodically API allows scheduling a task to execute periodically at a given interval. It is also possible to provide the start time otherwise the task will be executed immediately. The provided task is a callback, which will be executed in thread-safe way.\nInitially, the task is executed once immediately / on start time and then followed by periodic execution of the task at the requested period. This function returns a handle that can be used to cancel the execution of further tasks.\nThe following examples show the scheduling of a task in onSetup handlers. The second usage demos using time provided in a parameter as start time. Tasks run every 5 seconds after start time until stopped.\nKotlin val offsetTimeKey = utcTimeKey(\"offsetTime\")\nval offsetPrefix = \"esw.offset\"\nval assemblyForOffset = Assembly(TCS, \"galil\")\n\nonSetup(\"schedule-periodically\") { command ->\n    val probeCommand = Setup(schedulePrefix, \"scheduledOffset\", command.obsId)\n\n    schedulePeriodically(interval = 5.seconds) {\n        assemblyForOffset.submit(probeCommand)\n    }\n}\n\nonSetup(\"schedule-periodically-with-start-time\") { command ->\n    val scheduledTime = command(offsetTimeKey)\n    val probeCommand = Setup(schedulePrefix, \"scheduledOffset\", command.obsId)\n\n    // *** schedule with start time ***\n    schedulePeriodically(scheduledTime.head(), interval = 5.seconds) {\n        assemblyForOffset.submit(probeCommand)\n    }\n}","title":"Using schedulePeriodically"},{"location":"/scripts/dsl/services/time-service.html#using-scheduleperiodicallyfromnow","text":"The schedulePeriodicallyFromNow API is like schedulePeriodically but takes a duration as the start time rather than an absolute time. Initially, the task is executed once after a delay from the current time specified by the duration time. This execution is followed by periodic execution of the task at the requested period. The task is a callback which will be executed in thread-safe way. This function returns a handle that can be used to cancel the execution of further tasks.\nThe following example shows scheduling the publishing of an Event after 1 hour from now and then publishes an Event periodically with a 10 second period until cancelled.\nKotlin schedulePeriodicallyFromNow(1.hours, 10.seconds) {\n    publishEvent(SystemEvent(\"LGSF\", \"publish.success\"))\n}\nLimits of Scheduling The script environment for scheduling tasks should not be relied upon for very short periods or low jitter applications.","title":"Using schedulePeriodicallyFromNow"},{"location":"/scripts/dsl/services/time-service.html#source-code-for-above-examples","text":"Time Service Example Script","title":"Source code for above examples"},{"location":"/scripts/dsl/services/database-service.html","text":"","title":"Database Service"},{"location":"/scripts/dsl/services/database-service.html#database-service","text":"The Database Service DSL is a wrapper for the Database Service module provided by CSW. You can refer to detailed documentation of the Database Service provided by CSW here.\nThis DSL provides APIs to create the connection to a database. It uses a Jooq library underneath for creating database connections and queries. APIs for creating the database connection expose a DSLContext object. All database-related functionality from the Database Service is available using the Java APIs exposed by DSLContext.\nNote Jooq is a Java library that provides a higher level API for accessing data i.e. DDL support, DML support, fetch, batch execution, prepared statements, safety against SQL injection, connection pooling, etc. To know more about Jooq and its features, please refer to this link.","title":"Database Service"},{"location":"/scripts/dsl/services/database-service.html#create-a-database-connection-read-access-","text":"This API allows creating a connection to a database with default read access. The username and password for read access is picked from environment variables set on individual’s machine i.e. DB_READ_USERNAME and DB_READ_PASSWORD. It is expected that developers set these variables before calling this method. It returns a Jooq DSLContext or fails with a DatabaseException. The DSLContext provides methods like fetchAsync, executeAsync, executeBatch, etc. Additionally, the CSW JooqHelper and its wrapper methods can be used. For methods returning a Future, script will need to explicitly await for the future to complete to achieve sequential flow.\nTHe following example shows the creation of a database connection and a query to the database.\nKotlin val readDslContext = makeDatabaseService(dbName = \"IRIS_db\")\n\nonSetup(\"setup-iris\") {\n    val query = readDslContext\n            .resultQuery(\"SELECT filter_key FROM filter_table\")\n\n    //await to get result of query to achieve sequential flow of execution\n    val filterKeys = JooqHelper.fetchAsync(query, String::class.java).await()\n\n    // do something with filter keys\n}","title":"Create a Database Connection (Read Access)"},{"location":"/scripts/dsl/services/database-service.html#create-a-database-connection-read-write-access-","text":"This API allows creating a connection to a database with read/write access. User name and password credentials should be stored in environment variables, and the names of these environment variables are passed as method parameters. If the correct write access credentials can be obtained from these environment variables, then a database connection will be created with write access. It returns a Jooq DSLContext or fails with a DatabaseException.\nThe following example shows the creation of a database connection with write access and alternative way of using the DSLContext to do queries.\nKotlin val context = makeDatabaseService(\"IRIS_db\", \"db_write_username\", \"db_write_password\")\n\nonObserve(\"command-1\") {\n    val result = context\n            .select(field(\"event_name\"))\n            .from(name(\"table_1\")).fetch()\n\n    // do something with result\n}","title":"Create a Database Connection (Read/Write Access)"},{"location":"/scripts/dsl/services/database-service.html#source-code-for-examples","text":"Database Service Examples","title":"Source code for examples"},{"location":"/scripts/dsl/services/submit-response-extensions.html","text":"","title":"Extension utilities on SubmitResponse"},{"location":"/scripts/dsl/services/submit-response-extensions.html#extension-utilities-on-submitresponse","text":"A submit or query (and other Command Service or Sequencer Command Service API calls) always return a positive SubmitResponse unless called with resumeOnError flag as true. For submit, the two possible positive responses are Started and Completed. They can be handled using the .onStarted and .onCompleted methods, respectively. These methods allow you to specify a block of code to be called in each of those cases.\nKotlin val positiveSubmitResponse: SubmitResponse = assembly.submit(command)\n\npositiveSubmitResponse\n        .onStarted { startedResponse ->\n            val finalResponse: SubmitResponse = assembly.queryFinal(startedResponse.runId())\n            info(\"command completed with result: $finalResponse\")\n        }\n        .onCompleted { completedResponse ->\n            info(\"command with ${completedResponse.runId()} is completed with result: ${completedResponse.result}\")\n        }\nAlternatively, a Kotlin when can be used to perform pattern matching on the result. An example of that is shown below.\nKotlin when (positiveSubmitResponse) {\n    is Started -> {\n        val finalResponse: SubmitResponse = assembly.queryFinal(positiveSubmitResponse.runId())\n        info(\"command completed with response: $finalResponse\")\n    }\n    is Completed -> info(\"command with ${positiveSubmitResponse.runId()} is completed\")\n}\nIf you desire to handle errors manually on a per-command basis, the resumeOnError flag can be used. If this flag is set to true, then script execution continues, and action is taken based on custom logic in script by using an .onFailed method.\nKotlin val submitResponse: SubmitResponse = assembly.submit(command, resumeOnError = true)\npositiveSubmitResponse.onFailed { failedResponse ->\n    error(\"command completed with result: $failedResponse\")\n}\nYou can still choose to terminate sequence using the onFailedTerminate utility. This will cause similar behavior as when flag is not set by calling the onError or onGlobalError blocks and terminating the sequence, if the SubmitResponse is some kind of error.\nKotlin val submitRes: SubmitResponse = assembly.submit(command, resumeOnError = true)\npositiveSubmitResponse.onFailedTerminate()","title":"Extension utilities on SubmitResponse"},{"location":"/scripts/dsl/services/params.html","text":"","title":"Parameters"},{"location":"/scripts/dsl/services/params.html#parameters","text":"A DSL has been provided for creating Parameters to store values like primitive types, collection types or domain specific types, to be used for ParameterSets in Events and Commands. This DSL is built over abstractions like Parameter, KeyType, etc. offered by CSW. Refer to the CSW docs for more information about this.","title":"Parameters"},{"location":"/scripts/dsl/services/params.html#keys","text":"Following table lists all the key types, and their corresponding DSL.\nKeyType DSL Boolean booleanKey Character charKey Byte byteKey Short shortKey Long longKey Int intKey Float floatKey Double doubleKey String stringKey UtcTime utcTimeKey TaiTime taiTimeKey ByteArray byteArrayKey ShortArray shortArrayKey LongArray longArrayKey IntArray intArrayKey FloatArray floatArrayKey DoubleArray doubleArrayKey ByteMatrix byteMatrixKey ShortMatrix shortMatrixKey LongMatrix longMatrixKey IntMatrix intMatrixKey FloatMatrix floatMatrixKey DoubleMatrix doubleMatrixKey Choice choiceKey Struct structKey RaDec raDecKey EqCoord eqCoordKey SolarSystemCoord solarSystemCoordKey MinorPlanetCoord minorPlanetCoordKey CometCoord cometCoordKey AltAzCoord altAzCoordKey Coord (*) coordKey\nThe example below shows usages of the DSL for different types of keys. Some other DSL helpers like struct, choicesOf, arrayData, matrixData, etc. have also been provided for ease of access. Usage of this helper DSLs is also shown in the example below.\nKotlin // Primitive keys\nval encoderKey: Key<Int> = intKey(\"encoder\")\nval flagKey: Key<Boolean> = booleanKey(\"flag\")\nval eventTimeKey: Key<UTCTime> = utcTimeKey(\"event-time\")\n\n// Arrays\nval arrayKey: Key<ArrayData<Int>> = intArrayKey(\"arrayKey\")\nval elms: Array<Int> = arrayOf(1, 2, 3, 4)\nval values1: ArrayData<Int> = arrayData(elms)\nval values2: ArrayData<Int> = arrayData(5, 6, 7, 8)\nval arrayParam: Parameter<ArrayData<Int>> = arrayKey.set(values1, values2)\n\n// Matrix\nval matrixKey: Key<MatrixData<Int>> = intMatrixKey(\"matrixKey\")\nval arr1: Array<Int> = arrayOf(1, 2, 3, 4)\nval arr2: Array<Int> = arrayOf(5, 6, 7, 8)\nval elms1: Array<Array<Int>> = arrayOf(arr1, arr2)\nval data1: MatrixData<Int> = matrixData(elms1)\nval data2: MatrixData<Int> = matrixData(arr1, arr2)\nval matrixParameter: Parameter<MatrixData<Int>> = matrixKey.set(data1, data2)\n\n// Domain specific types\nval choiceKey: Key<Choice> = choiceKey(\"choice\", choicesOf(\"A\", \"B\", \"C\"))\nval choiceParam: Parameter<Choice> = choiceKey.set(Choice(\"A\"), Choice(\"C\"))\n\n// Struct\nval intParam: Parameter<Int> = encoderKey.set(1, 2, 3)\nval paramSet: Set<Parameter<*>> = setOf(intParam, choiceParam)\nval complexKey: Key<Struct> = structKey(\"complexKey\")\nval struct1: Struct = struct(paramSet)\nval struct2: Struct = struct(command.params)\nval struct3: Struct = struct(intParam, arrayParam)\nval structParam: Parameter<Struct> = complexKey.set(struct1, struct2, struct3)\n\n// with units\nval temperatureInKelvinKey: Key<Int> = intKey(\"encoder\", JUnits.kelvin)","title":"Keys"},{"location":"/scripts/dsl/services/params.html#creating-parameters","text":"The example below shows different ways of creating parameters and adding them to a command.\nKotlin val temperatureKey: Key<Int> = intKey(\"temperature\")\nval temperatureParam: Parameter<Int> = temperatureKey.set(1, 2, 3)\n\n// with values as Array\nval encoderKey: Key<Int> = intKey(\"encoder\")\nval encoderValues: Array<Int> = arrayOf(1, 2, 3)\nval encoderParam: Parameter<Int> = encoderKey.setAll(encoderValues)\n\n// with units\nval powerKey: Key<Double> = doubleKey(\"power\")\nval values: Array<Double> = arrayOf(1.1, 2.2, 3.3)\nval powerParam: Parameter<Double> = powerKey.setAll(values).withUnits(JUnits.watt)\n\n// adding a param to command or event\nval setupCommand: Setup = Setup(\"ESW.IRIS_darkNight\", \"move\").add(temperatureParam)\nval systemEvent: SystemEvent = SystemEvent(\"ESW.IRIS_darkNight\", \"movement\").add(temperatureParam)\n\n// adding multiple params\nval setupCommand2: Setup = Setup(\"ESW.IRIS_darkNight\", \"move\").madd(temperatureParam, encoderParam)\n\n// adding params of one command to other\nval paramsFromIncomingCommand: Params = command.params\nval commandForDownstream: Setup = Setup(\"ESW.IRIS_darkNight\", \"move\").add(paramsFromIncomingCommand)","title":"Creating Parameters"},{"location":"/scripts/dsl/services/params.html#extracting-a-parameter-from-params-command-event","text":"","title":"Extracting a parameter from Params/Command/Event"},{"location":"/scripts/dsl/services/params.html#extracting-parameter","text":"You can extract a parameter from Params/Command/Event using another parameter with the same key name and key type (values of the parameter passed in are ignored).\nKotlin val params: Params = setupCommand.params\nval maybeParam: Parameter<Int>? = params.kFind(temperatureParam)\nval maybeParam2: Parameter<Int>? = setupCommand.kFind(temperatureParam)","title":"Extracting parameter"},{"location":"/scripts/dsl/services/params.html#extracting-parameter-by-key","text":"Yuo can also use a Key:\nKotlin // extracting a param from Params instance\nval temperatureParameter: Parameter<Int>? = setupCommand.params.kGet(temperatureKey)\nval temperatureParameter2: Parameter<Int> = (setupCommand.params)(temperatureKey) // alternative\n\n// extracting a param directly from the command or event\nval temperatureParameter3: Parameter<Int>? = setupCommand.kGet(temperatureKey)\nval temperatureParameter4: Parameter<Int> = setupCommand(temperatureKey) // alternative","title":"Extracting parameter by key"},{"location":"/scripts/dsl/services/params.html#extracting-parameter-by-keyname-and-keytype","text":"Or, you can use the key name and type:\nKotlin val keyName = \"temperature\"\nval keyType: KeyType<Int> = JKeyType.IntKey()\nval param: Parameter<Int>? = setupCommand.params.kGet(keyName, keyType)","title":"Extracting parameter by keyName and KeyType"},{"location":"/scripts/dsl/services/params.html#extracting-values-from-a-parameter","text":"The example below shows the accessing a List of values or a specific value of a parameter.\nKotlin val temperatureKey: Key<Int> = intKey(\"temperature\")\nval temperatureParam: Parameter<Int> = temperatureKey.set(1, 2, 3)\n\n// extracting values from parameter\nval temperatureValues: List<Int> = temperatureParam.values\n\n// extracting first value from parameter\nval firstValue: Int = temperatureParam.first\n\n// extracting value of the parameter at a given index\nval temperatureValue: Int? = temperatureParam.kGet(1)\nval temperatureValue2: Int = temperatureParam(1) //alternative\nNote Note that the shorthand alternatives shown with // alternative comment in above examples, do not return optional values unlike their corresponding full version. This means, with shorthand DSL, an error will occur in the absence of the specified key/index.","title":"Extracting values from a parameter"},{"location":"/scripts/dsl/services/params.html#removing-a-parameter","text":"A parameter could be removed from a Params instance or from a Command directly. The example below demonstrates both of these DSL methods.\nKotlin // remove param from params by key\nval updatedParams: Params = setupCommand.params.remove(temperatureKey)\n\n// remove param from params\nval updatedParams2: Params = setupCommand.params.remove(temperatureParameter)\n\n// remove param from command by key\nval updatedCommand: Setup = setupCommand.remove(temperatureKey)\n\n// remove param from command\nval updatedCommand2: Setup = setupCommand.remove(temperatureParameter)","title":"Removing a parameter"},{"location":"/scripts/dsl/services/params.html#checking-if-a-parameter-exists","text":"Kotlin // check if parameter with specified key exists in Params\nval temperatureKeyExists: Boolean = setupCommand.params.exists(temperatureKey)\n\n// check if parameter with specified key exists directly from command\nval temperatureKeyExists2: Boolean = setupCommand.exists(temperatureKey)","title":"Checking if a parameter exists"},{"location":"/uisupport/uisupp-index.html","text":"","title":"User Interface Support"},{"location":"/uisupport/uisupp-index.html#user-interface-support","text":"User Interfaces in ESW and TMT ESW.UISTD and ESW.HCMS User Interface Support in ESW Phase 1 ESW Phase 1 Overview Front-end UI Applications Back-end UI Applications Creating and Using the Frontend UI Template Needs to be Written Creating and Using the UI Backend Template Installation Create Starter Project User Interface Gateway ESW Gateway with Authentication and Authorization Sample Requests Gateway Technical Design Running the UI Gateway App Prerequisites for Running gateway-server 1. Install coursier and the TMT Apps Channel 2. Start Any Needed CSW Services 3. Install gateway-server Setting the Default Log Level","title":"User Interface Support"},{"location":"/uisupport/UIOverview.html","text":"","title":"User Interfaces in ESW and TMT"},{"location":"/uisupport/UIOverview.html#user-interfaces-in-esw-and-tmt","text":"This section is an overview of the user interface approach for TMT. TMT has an OAD requirement for graphical user interfaces as the standard style for user interfaces. The CSW technical choice for graphical user interfaces is the web platform consisting of the web browser as the host for the user interface and web technologies based on JavaScript along with HTTP, and CSS, etc. Most UI innovation and development at this time is based on these technologies and there is no apparent change in sight, so this decision continues to makes sense. One other big advantage of the browser-based UI is that it can provide an easy solution for remote access in many situations. The entire reason for web technologies is to provide remote access to systems and services.","title":"User Interfaces in ESW and TMT"},{"location":"/uisupport/UIOverview.html#esw-uistd-and-esw-hcms","text":"TMT user interfaces can be grouped into two categories: observing user interfaces and engineering user interfaces. High-level Control and Monitoring (HCMS) is the ESW subsystem that provides the observing user interfaces to be used by staff and visitors to control the telescope and other systems, monitor their status and behavior, and to perform observations that generate science data. Engineering user interfaces are the responsibility of the subsystem teams, but these user interfaces also use the technology choices and support provided by ESW.\nESW’s User Interface Standards (UISTD) subsystem provides the architectural solution for this technical problem. UISTD also provides glue code for the JavaScript-based environment that is used by UI builders to access CSW services along with examples. UISTD provides style and layout guidelines and standards (look-and-feel) with examples that demonstrate the guidelines. UISTD also provides UI components that demonstrate common usage of CSW glue code (TBD as needed). This document describes the UI architecture.","title":"ESW.UISTD and ESW.HCMS"},{"location":"/uisupport/UIOverview.html#user-interface-support-in-esw-phase-1","text":"The development of ESW was split into two phases called Phase 1 and Phase 2. Phase 1, which is currently in development, delivers products and features that other subsystems need from ESW. ESW Phase 2 will execute in the future covering the rest of ESW at a more leisurely pace.","title":"User Interface Support in ESW Phase 1"},{"location":"/uisupport/UIOverview.html#user-interface-responsibilities-of-esw","text":"The following bullet items summarize the responsibilities of UISTD and HCMS and whether they are part of Phase 1 or Phase 2.\nProvide JavaScript-based glue code running in the browser providing access to CSW services needed by user interfaces (UISTD) (Phase 1). Provide a gateway/bridge infrastructure that connects the browser-based user interfaces to the JVM-based services and components (UISTD) (Phase 1). Provide examples of glue code and user interface standards (UISTD) (Phase 2). Provide style and layout guidelines for standardized user interface look and feel (UISTD) (Phase 2) Provide browser-based user interfaces required by support staff for control and monitoring of the telescope and instrument systems (HCMS) (Phase 2).","title":"User Interface Responsibilities of ESW"},{"location":"/uisupport/UIOverview.html#esw-phase-1-overview","text":"The primary technical problem the UI architecture must solve is that a browser-based user interface executes in a different software environment from JVM-based CSW/ESW using a different language and technology; therefore, it is necessary to bridge the two environments. This is true of any control system technology that isn’t written in JavaScript and is not unique to the CSW JVM choice.\nThe ESW design for user interfaces identifies two approaches for user interfaces that we have named: Front-end UI and Back-end UI. The difference between the two is based on the sophistication and requirements of the user interface.","title":"ESW Phase 1 Overview"},{"location":"/uisupport/UIOverview.html#front-end-ui-applications","text":"A Front-end UI is a UI that only needs CSW service access. The following figure shows an example instance of the ESW architecture for a simplified instrument and its user interface (or Engineering UI) that are Front-end UI applications. The figure shows an example user interface executing in the browser called “Focused Instrument User Interface” that must send commands to and receive events from individual Assemblies in the CSW-based instrument control system in the lower part of the figure represented by a Sequencer and two Assemblies/HCDs.\nCommands are issued when the user pushes a button on the UI to move the filter wheel (or other device). Events are subscribed to and received by the UI that contain the current positions of the filter wheel and grating. The event contents are used to update information on the UI to keep the user up to date on the state of the instrument. The UI Application Gateway is JVM-based server that provides an HTTP-based interface with routes for sending commands and subscribing to events. Command completion information and events are returned to the UI through Websockets. Commands, responses, and events are serialized as JSON, which is already supported in CSW.\nThe key is the UI Application Gateway (UIAG) provided as part of UISTD/ESW Phase 1 shown in green in the figure. The UIAG is a JVM-based application that acts as an HTTP server. The UIAG has several functions:\nIt registers itself with the Location Service so the UI can also use the Location Service to find the UIAG’s connection information using the Location Service HTTP API. It may serve web pages if needed for the presentation of the UI, although splitting presentation pages to another web server is also an option. (This feature is not currently implemented). It provides site security by requiring credentials from all users and authentication with the CSW Authentication and Authorization Service. It supports the OSW AAS authentication approach (see here) It contains TMT-standardized API endpoints that allow interactions with CSW Services needed for user interfaces including Command Service and Event Service.\nThe UIAG is available in the release of ESW. There is a template project that can be used to create a Front-end UI application. See the dedicated documentation section here and the esw-ui-template repo for more information.","title":"Front-end UI Applications"},{"location":"/uisupport/UIOverview.html#back-end-ui-applications","text":"The Back-end UI is an application that may need to do more than use CSW services. It may have specialized backend commands that are better-suited to the server-side than the browser-based UI. This may be computationally intensive functions or the use of CSW Database Service with specialized queries as examples.\nThe Back-end UI uses it’s own back-end HTTP-based service to implement application-specific routes. The sophisticated UI that needs a back-end server may only use its back-end server, but more likely it will be a hybrid and also use the UI Application Gateway for access to CSW commands and events since duplicating this support is costly and error-prone. The following figure shows the components of a hybrid Back-end UI application.\nThere are challenges to creating a back-end server. The server must be secure and implement the same AAS model as the gateway. The back-end service must register itself with Location Service. To make this easier, there is also a back-end service template. See the dedicated documentation section here and the esw-backend-template repo for more information.","title":"Back-end UI Applications"},{"location":"/uisupport/frontend-template.html","text":"","title":"Creating and Using the Frontend UI Template"},{"location":"/uisupport/frontend-template.html#creating-and-using-the-frontend-ui-template","text":"","title":"Creating and Using the Frontend UI Template"},{"location":"/uisupport/frontend-template.html#","text":"","title":"Needs to be Written"},{"location":"/uisupport/backend-template.html","text":"","title":"Creating and Using the UI Backend Template"},{"location":"/uisupport/backend-template.html#creating-and-using-the-ui-backend-template","text":"In this tutorial, you’ll see how to create a Scala/Java project using a giter8 template for ESW ( esw-backend-template.g8) which contains sample application make using ESW library. You can use this as a starting point for your own projects.","title":"Creating and Using the UI Backend Template"},{"location":"/uisupport/backend-template.html#installation","text":"Supported Operating Systems are: CentOS and MacOS\nMake sure you have the Java AdoptOpenJDK 11. Run javac -version in the command line and make sure you see javac 11._._ If you don’t have version 11 or higher, links given below will help you to reach there. Mac Linux Install sbt Mac Linux Install IntelliJ MAC Linux Install following IntelliJ Plugins Scala Scalafmt Recommended testing frameworks/tools: ScalaTest JUnit, JUnit Interface Note: these dependencies are specified by default in esw-backend-template.g8, and the sbt will resolve them when it runs.","title":"Installation"},{"location":"/uisupport/backend-template.html#create-starter-project","text":"Follow the template readme.md for detailed information about project creation.","title":"Create Starter Project"},{"location":"/uisupport/gateway.html","text":"","title":"User Interface Gateway"},{"location":"/uisupport/gateway.html#user-interface-gateway","text":"This is provided to give access to all CSW and ESW services and components from browser-based user interfaces.","title":"User Interface Gateway"},{"location":"/uisupport/gateway.html#esw-gateway-with-authentication-and-authorization","text":"All TMT users use browser-based user interfaces to interact with the control system, and all TMT users must be authenticated. Once authenticated, they are authorized to use certain commands based on their roles. All UI programs must use the UI Gateway to reach the control system. The UI Gateway provides authorization and authentication in the ESW/CSW system.\nESW UI Gateway is accessible to the outside network and exposes API endpoints through an HTTP interface, hence we need to protect its endpoints from unauthorized access. To better understand the inside and outside network terminology, refer network-topology.","title":"ESW Gateway with Authentication and Authorization"},{"location":"/uisupport/gateway.html#protection-on-command-service-endpoints-on-gateway","text":"Each subsystem can control command access using three roles: user, eng, and admin. For example: APS-user, APS-eng, and APS-admin. The user role is the least restrictive, eng role more restrictive, and admin the most restrictive. The eng role is meant for commands that should only be executed by qualified subsystem engineers. The admin command role should be reserved for commands that may damage or otherwise risk equipment. A subsystem is not required to have eng or admin role commands. It’s okay to have only commands that are accessible to all subsystem users.\nA TMT user must at least have a subsystem’s user role to be allowed to access commands in a subsystem. By default, all commands are available to a user with the user role unless they are listed in the command map as requiring a more restrictive role. The hierarchy of roles is shown in the following figure:\nThere are often commands which are more restrictive and should not be accessible to every user. These commands need eng or admin role for the most restricted or dangerous commands. Also, these more restrictive eng commands need a fine-grained control mechanism so that they can be safely executed by authorized person having specific role at subsystem level. To achieve this we have the role hierarchy at subsystem level along with a config table containing the mapping between more restrictive commands and these roles.\nThis type of role hierarchy is created in Keycloak as one time setup. As per this hierarchy there should be three roles present for each subsystem which are composed in specific order.\nE.g. TCS-admin -> TCS-eng -> TCS-user. When you assign a user TCS-eng role, keycloak will automatically add TCS-user role to that user When you assign a user TCS-admin role, keycloak will automatically add TCS-eng and TCS-user role to that user\nAlso, there are three special roles. OSW-admin, OSW-eng and OSW-user which are composed of all respective subsystem level roles.\nE.g. When you assign a user OSW-eng role, keycloak will automatically add roles TCS-eng, APS-eng and so on to that user and these roles will automatically add their respective lower level roles TCS-user, APS-user and so on.","title":"Protection on Command Service Endpoints on Gateway"},{"location":"/uisupport/gateway.html#examples-","text":"","title":"Examples:"},{"location":"/uisupport/gateway.html#command-role-mapping","text":"Below shown are example entries in config table with commands and roles who can execute those commands.\nIRIS.filter.wheel.startExposure: [IRIS-user, APS-eng]\nIRIS.filter.wheel.stopExposure: [IRIS-user, APS-eng]\nWe need to create a config containing role mapping entries like shown above and use it when starting esw-gateway server.","title":"Command Role Mapping"},{"location":"/uisupport/gateway.html#protection-on-sequencer-endpoints-on-gateway","text":"On protected endpoints of sequencer commands in esw-gateway, {subsystem}-user role check is performed.\nSubsystem is obtained from componentId E.g. If current sequence to be executed is for esw.primary then user should have minimum ESW-user role.","title":"Protection on Sequencer endpoints on Gateway"},{"location":"/uisupport/gateway.html#sample-requests","text":"","title":"Sample Requests"},{"location":"/uisupport/gateway.html#request-without-auth-token","text":"curl --location --request POST 'http://<host>:<port>/post-endpoint' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"_type\": \"ComponentCommand\",\n    \"componentId\": {\n        \"prefix\": \"IRIS.filter.wheel\",\n        \"componentType\": \"hcd\"\n    },\n    \"command\": {\n        \"_type\": \"Submit\",\n        \"controlCommand\": {\n            \"_type\": \"Setup\",\n            \"source\": \"CSW.ncc.trombone\",\n            \"commandName\": \"startExposure\",\n            \"maybeObsId\": [\n                \"2020A-001-123\"\n            ],\n            \"paramSet\": []\n        }\n    }'","title":"Request without auth token"},{"location":"/uisupport/gateway.html#request-with-auth-token","text":"curl --location --request POST 'http://<host>:<port>/post-endpoint' \\\n--header 'Content-Type: application/json' \\\n--header 'Authorization: <bearer token> \\\n--data-raw '{\n    \"_type\": \"SetLogLevel\",\n    \"componentId\": {\n        \"prefix\": \"CSW.ncc.trombone\",\n        \"componentType\": \"HCD\"\n    },\n    \"level\": \"ERROR\"\n}'","title":"Request with auth token"},{"location":"/uisupport/gateway.html#gateway-technical-design","text":"See ESW Gateway Technical Documentation.","title":"Gateway Technical Design"},{"location":"/uisupport/gateway-app.html","text":"","title":"Running the UI Gateway App"},{"location":"/uisupport/gateway-app.html#running-the-ui-gateway-app","text":"gateway-server is a command line application that starts the ESW UI Gateway Server. The UI Gateway Server allows browser-based user interface programs using to interact securely with the CSW-based components.","title":"Running the UI Gateway App"},{"location":"/uisupport/gateway-app.html#prerequisites-for-running-gateway-server","text":"The following steps should be followed to use gateway-server to start the UI Gateway Server.","title":"Prerequisites for Running gateway-server"},{"location":"/uisupport/gateway-app.html#1-install-coursier-and-the-tmt-apps-channel","text":"The coursier application must be installed on your machine and the OCS Apps channel must also be installed. The instructions for doing this are provided here.","title":"1. Install coursier and the TMT Apps Channel"},{"location":"/uisupport/gateway-app.html#2-start-any-needed-csw-services","text":"To run gateway-server, the CSW Location Service must be running. Gateway-server requires CSW AAS to be running. Any other CSW Services needed by scripts or browser UIs should also be running.\nInformation on starting CSW services is here","title":"2. Start Any Needed CSW Services"},{"location":"/uisupport/gateway-app.html#3-install-gateway-server","text":"The following command creates an executable file named gateway-server in the default installation directory.\ncs install gateway-server:<version | SHA>\nOne can specify installation directory like following:\ncs install \\\n    --install-dir /tmt/apps \\\n    gateway-server:<version | SHA>\nNote If you don’t provide the version or SHA in the above command, gateway-server will be installed with the latest tagged binary of esw-gateway-server.","title":"3. Install gateway-server"},{"location":"/uisupport/gateway-app.html#4-run-gateway-server","text":"Once gateway-server is installed, one can simply run gateway-server by executing the start command.\nStart command supports following arguments:\n--port , -p : Optional argument: HTTP server will be bound to this port. If a value is not provided, port will be picked up from a default configuration. -l, --local : optional argument (true if config is to be read locally or false if from CSW Configuration Service) default value is false. -c, --commandRoleConfigPath : specifies command role mapping file path which gets fetched from CSW Configuration Service or local file system based on –local option. -m, --metrics : optional argument: If true, enable gateway metrics. If not provided, default value is false and metrics will be disabled.\nNote On starting gateway server app, it will be registered in location service as ESW.EswGateway as HttpRegistration. This prefix is picked up from application.conf file.\nThe following example commands start the Gateway Server.\nExample 1: Local command map with metrics enabled\n//cd to installation directory\ncd /tmt/apps\n\n// run gateway server with provided port, local command role config file and with metrics enabled\n./gateway-server start -p 8090 -l -c command-role-mapping.conf -m\nExample 2: Use the Configuration Service to provide the command role mapping\n//cd to installation directory\ncd /tmt/apps\n\n// run gateway server with remote command role config file\n./gateway-server start -c command-role-mapping.conf\nNote Refer supported arguments section or ./gateway-server start --help for starting gateway server with specific arguments.","title":"4. Run gateway-server"},{"location":"/uisupport/gateway-app.html#setting-the-default-log-level","text":"The default log level for any component is specified in the application.conf file of the component. Use the java -J-D option to override configuration values at runtime. For log level, the format is:\n-J-Dcsw-logging.component-log-levels.<Subsystem>.<ComponentName>=<LEVEL>\nFor example, using the example above:\n//cd to installation directory\ncd /tmt/apps\n\n// run Sequence Manager\n./gateway-server -J-Dcsw-logging.component-log-levels.ESW.EswGateway=TRACE start -p 8090 -l -c command-role-mapping.conf","title":"Setting the Default Log Level"},{"location":"/technical/tech-index.html","text":"","title":"Technical Design Documents"},{"location":"/technical/tech-index.html#technical-design-documents","text":"Sequence Manager Technical Documentation Introduction to Sequence Manager Modules Implementation Details Sequence Manager States Running Sequence Manager Sequence Manager simulation mode Sequencer Technical Documentation Modules Sequence execution process Implementation Details Sequencer Interfaces Interacting with Sequencer Running Sequencer Sequence Component Technical Documentation Introduction Modules Implementation Details Sequence Component Lifecycle Running Sequence Component Gateway Technical Documentation Implementation API call flow Modules Running Gateway Server Service Contracts Json Contract Agent Service and Agent Technical Documentation Agent Service Introduction Agent Service Implementation Details Agent Service Module (esw-agent-service) Agent Introduction Agent Implementation Agent Module (esw-agent-akka) Agent Client Running Agent and Agent Service Applications Getting and Running ESW Applications Starting Sequence Manager Using sequence-manager Agent Service App Agent App","title":"Technical Design Documents"},{"location":"/technical/sequence-manager-tech.html","text":"","title":"Sequence Manager Technical Documentation"},{"location":"/technical/sequence-manager-tech.html#sequence-manager-technical-documentation","text":"Sequence Manager is a service that is part of the Observatory Control System (OCS) subsystem of ESW. Sequence Manager provides functionality that will be used by the operators and users of the future telescope through user interfaces that will be developed as part of ESW HCMS. Sequence Manager provides functionality needed by user interfaces, but does not take actions by itself unless called by the future operator.\nSequence Manager has the following high-level responsibilities in the ESW.OCS design:\nStart Sequence Components on different machines setup to host Sequence Components and Sequencers. This is called provisioning. Start Sequencers as required by a specific Observing Mode/Sequence and initialize each with the correct Script. Manage and track Observatory resources. Ensure that the resources needed for a Sequence are available allowing parallel Sequences to execute when possible. Monitor overall Sequence execution and perform cleanup at the conclusion of a Sequence.\nThe following sections provide details on the Sequence Manager.","title":"Sequence Manager Technical Documentation"},{"location":"/technical/sequence-manager-tech.html#introduction-to-sequence-manager","text":"Sequence Manager is an ESW component that takes care of provisioning Sequence Components needed for an observation and the configuration of Sequencer scripts as per observing mode. It has capabilities to start, re-start, shutdown Sequencer/s, shutdown Sequence Components as well as to know status of TMT components such as which script is loaded on which Sequence Component or which Sequence Component/s are running on which agent/host. Sequence Manager is implemented using Akka actors. Sequence Manager provides two communication interfaces that are registered with Location Service.\nAkka-based interface HTTP interface\nThe Akka interface will be used by JVM-based applications to interact with Sequence Manager. The HTTP interface is provided so UI applications can be built which will interact directly with the Sequence Manager (as opposed to using the User Interface Application Gateway).\nThe Sequence Manager uses the Agent Service and Agents to provision Sequence Components. See: Agent Service for more information.","title":"Introduction to Sequence Manager"},{"location":"/technical/sequence-manager-tech.html#modules","text":"Sequence Manager implementation is distributed into the following modules:","title":"Modules"},{"location":"/technical/sequence-manager-tech.html#esw-sm-api","text":"This Sequence Manager API module code supports the following responsibilities:\nDirectory Responsibility shared API which is cross compiled to JVM as well JavaScript shared HTTP client which can be used by JVM as well as scala-js applications jvm Akka client for JVM applications, Akka actor messages, Akka message serializer","title":"esw-sm-api"},{"location":"/technical/sequence-manager-tech.html#esw-sm-handler","text":"This Sequence Manager handler module is responsible for providing HTTP routes for the Sequence Manager HTTP server.","title":"esw-sm-handler"},{"location":"/technical/sequence-manager-tech.html#esw-sm-impl","text":"This module contains core logic for the Sequence Manager Akka Actor.","title":"esw-sm-impl"},{"location":"/technical/sequence-manager-tech.html#esw-sm-app","text":"This module contains a CLI which starts Sequence Manager component as well as the HTTP server of Sequence Manager.","title":"esw-sm-app"},{"location":"/technical/sequence-manager-tech.html#implementation-details","text":"Boot-up time for TMT ecosystem is expected to start an Agent on every machine that will host Sequence Components and Sequencers, Sequence Manager on an ESW machine, and HCD/Assembly components on respective subsystem machines.\nSequence Manager supports multiple APIs that allow it to configure a set of Sequencers based on an observing mode and cleanup/shutdown Sequencers after an observation is completed.\nAn extended use case is used here to explain the use of the Sequence Manager API as it is intended to be used during observing. The use case leads to the configuration for an observing mode.\nNote The use case starts with no Sequence Components or Sequencers running in the system as provisioning is not yet done. But an Agent Service is started at boot-time on each machine that will host Sequence Components.","title":"Implementation Details"},{"location":"/technical/sequence-manager-tech.html#getagentstatus","text":"This API allows a future UI to show the status of TMT ecosystem components (Agents, Sequence Components and Sequencers). It allows showing which Agents are up and running, which Sequence Components are running on those Agents, and which Sequencer and/or script is loaded on each Sequence Component.\nThe figure below shows a simple UI mockup that shows 4 machines are configured with Agents but there is nothing running on the machines.","title":"GetAgentStatus"},{"location":"/technical/sequence-manager-tech.html#provision-sequence-components","text":"This API allows a future UI to provision Sequence Components per Agent. The provision API call requires a simple configuration which specifies the number of Sequence Components needed to be spawned on each particular Agent.\nThe following diagram depicts status of TMT ecosystem after provisioning as per the configuration argument shown on the right side of the figure.\nNote Provision API will first shutdown all running Sequence Components if any. After shutting down already running Sequence Components, it spawns new Sequence Components on Agents as per a configuration provided with the provision call.\nThe following flow chart shows the algorithm for provision flow.\nNote Normally, the system is provisioned once at the beginning of observing, and the Sequence Components are then used for all Sequencers needed in the course of a night. The system can be easily re-provisioned if there is a failure or other issue to minimize downtime.","title":"Provision Sequence Components"},{"location":"/technical/sequence-manager-tech.html#configuring-sequencers-for-an-observing-mode","text":"Once the system is provisioned, Sequence Manager can take the configure step. Configure is used for starting Sequencers needed for an observing mode. It also checks for any resource conflicts with ongoing observations. It is allowed that TMT run more than one concurrent observation as long as they do not conflict. The configure API ensures this is the case. If there is a conflict, the configure call will fail.\nA configuration file mapping observing mode to required Sequencers (called obsModeConfig) is provided to Sequence Manager when it starts. Configure API, checks for required Sequencers and resources in the obsModeConfig file. This config file contains mapping of observing mode to required Sequencers and resources. When configure for a particular observing mode command is received by Sequence Manager, it checks the following:\nExistence of a mapping for required observing mode exists in configuration file Availability of adequate Sequence Components for starting Sequencers No resource conflict should occur with ongoing observations\nIf these checks succeed, the Sequencers are configured, the location of the top-level ESW Sequencer is returned to the caller.\nNote Once Sequence Manager configures for an observing mode, a Sequence can be sent to the Top Level Sequencer (ESW sequencer for that observing mode) by SOSS.\nThe following flow chart shows the algorithm for configure flow.","title":"Configuring Sequencers for an Observing Mode"},{"location":"/technical/sequence-manager-tech.html#shutdown-of-sequencers","text":"Once an observation is complete, and the operator determines that it is necessary to configure for a new observing mode, cleanup for the current observation may involve shutting down all Sequencers of that observing mode. Sequence Manager provides shutdown sequencers API variations which allow:\nshutdown of all Sequencers of an observing mode, shutdown of all Sequencers belonging to specific subsystem, shutdown of a particular Sequencer, shutdown of all running Sequencers.\nNote The various shutdown options are also available to handle possible issues during observation execution.\nThis use case explains the most important way Sequence Manager is used.","title":"Shutdown of Sequencers"},{"location":"/technical/sequence-manager-tech.html#other-apis","text":"Apart from APIs explained above, Sequence Manager also provides following useful APIs:\nstartSequencer - start a Sequencer for the provided subsystem and observing mode restartSequencer - re-start a Sequencer for provided subsystem and observing mode shutdownSequenceComponent - shutdown a Sequence Component with provided prefix shutdownAllSequenceComponents - shutdown all running Sequence Components\nWe anticipate these capabilities will be useful for future user interfaces and dealing with possible issues during observing.","title":"Other APIs"},{"location":"/technical/sequence-manager-tech.html#sequence-manager-states","text":"Sequence Manager Actor is implemented as a state machine with two states: Idle and Processing. At any point of time, Sequence Manager must be in exactly one of these states.\nThe following diagram depicts the state transitions of Sequence Manager:\nImplementation of these msgs is asynchronous in nature. So handling any other msgs while previous msg processing is incomplete can result in an inconsistent system. For example, configure Observing_Mode_1 msg is received by Sequence Manager Actor. Let’s assume that this requires starting ESW, IRIS and TCS sequencers. Configure flow has checked for resource conflict. No conflict is there so configure goes ahead with processing. During this processing, if any other msg like startSequencer for IRIS subsystem and Observing_Mode_2 is received then this will result in inconsistent behaviour. To avoid these cases, certain msgs are accepted only when Sequence Manager is idle. When any one of idle state msg is received, Sequence Manager goes into processing state where it accepts only common msgs (read state msgs which will not cause any inconsistency). In processing state, actor waits for processing complete msg. Once processing complete msg is received, actor goes back to idle state and ready to process any of idle state msg. Both idle and processing state can handle common msgs without any state change.","title":"Sequence Manager States"},{"location":"/technical/sequence-manager-tech.html#running-sequence-manager","text":"For running Sequence Manager, please refer this.","title":"Running Sequence Manager"},{"location":"/technical/sequence-manager-tech.html#sequence-manager-simulation-mode","text":"Simulation mode for SM is mainly for testing the functionality/scenarios of apps interacting with SM.","title":"Sequence Manager simulation mode"},{"location":"/technical/sequence-manager-tech.html#approach-followed-","text":"In this approach we will be spawning actual Sequence Manager, agents, sequence-components and sequencers(simulation mode). When the Sequence Manager is started using the esw-services with the simulation flag, the following things are done. If a obs-mode config is provided using -o flag, it is used and if not then a default config is used. Three agents are spawned automatically(ESW, TCS, IRIS) When the sequence-manager is up and running(–simulation): suppose Provision command is sent to SM. Now as we are using actual agents, seq-components our production level logic eg: shutting-down previous seq-comps, agent-allocation for seq-comps, etc. can be tested suppose Configure command is sent to SM. Now as we are using sequencers in simulated mode any obs-mode can be configured(as long as there is an entry for it in the provided obs-mode conf or the default). Also the success as well as all the failure scenarios (resource conflict, configuration missing, etc) can be tested. all the other apis like startSequencer, shutdownAllSeqComps etc will work properly with correct entries made in location service. Only agents will be started in the same jvm process.Since sequence components are started by agents using cs launch ..., command they will not be in the same process.","title":"Approach followed:"},{"location":"/technical/sequence-manager-tech.html#running-sequence-manager-in-simulation-mode","text":"For running Sequence Manager, please refer this.","title":"Running Sequence Manager in simulation mode"},{"location":"/technical/sequencer-tech.html","text":"","title":"Sequencer Technical Documentation"},{"location":"/technical/sequencer-tech.html#sequencer-technical-documentation","text":"Sequencer is OMOA component which has responsibility of executing Sequence of Steps. In an observation, Sequencers will form a hierarchy where with a top-level ESW Sequencer sending Sequences to downstream Sequencers and downstream Sequencers sending commands to Assemblies/HCDs.\nThe Sequencer implementation has two main parts:\nSequencer Framework Scripting Support\nSequencer Framework uses an Akka Actor at a core and is responsible for executing the received Sequence and calling handlers in the Script. Sequencer Scripting Support defines behaviour of Sequencer while executing Sequence. Scripts are written using Domain Specific Language provided as a part of Framework.","title":"Sequencer Technical Documentation"},{"location":"/technical/sequencer-tech.html#modules","text":"esw-ocs-api - This is cross-compiled module, which is compiled into JVM as well as JavaScript code. This module includes SequencerApi which defines an interface for Sequencer. This module also consists of core models, actor client, JVM and JavaScript client for Sequencer. esw-ocs-impl - This module consists of the core implementation of Sequencer the actor which is SequencerBehaviour (Sequencer Actor), Engine and SequencerData. esw-ocs-app - This module consists of wiring as well as cli application to start Sequencer. The wiring integrates Sequencer into the rest of the ESW/CSW environment. esw-ocs-dsl - This module consists of Scala implementation supporting the Script DSL. esw-ocs-dsl-kt - This module consists of Kotlin counterpart of the Script DSL. esw-ocs-handler - This handler module is responsible for providing HTTP routes for Sequencer HTTP server. Sequencer provides an HTTP and Akka interface. The HTTP routes are defined and implemented here.","title":"Modules"},{"location":"/technical/sequencer-tech.html#sequence-execution-process","text":"","title":"Sequence execution process"},{"location":"/technical/sequencer-tech.html#starting-a-sequencer","text":"Sequencer wiring creates an execution Engine which is responsible for processing each step. When Engine is initialized, Kotlin Script is loaded into it via reflection. After initialization, Sequencer’s Akka and HTTP connection is registered to Location Service.\nNote Engine is a continuous running loop, it pulls next step once current step is finished.","title":"Starting a Sequencer"},{"location":"/technical/sequencer-tech.html#loading-and-running-a-sequence-in-sequencer","text":"During initialization of Sequencer, it is set to IDLE state and initialized with empty data in Sequence Data like empty Step List,etc. Once initialized, user can either Load a sequence or Submit a sequence, in both cases list of commands will be converted to richer model of list of Steps. Load a Sequence: Here, Sequence Data(described below) will be initialized with Sequence Steps. Once initialized, user can give startSequence command to start the execution of steps. Submit a Sequence: Sequence Data will be initialized with Sequence Steps, and it will also start the sequence execution. After any of above flow, Sequencer will go into RUNNING state.\nSequence Data has different fields as follows:\nstepList - This will store steps of the Sequence runId - This is runId of Sequence sequenceResponseSubscribers - This is a list of Subscribers who is interested in response either via submitting a sequence or querying response. When subscriber has submitted the sequence, we can use submitAndWait API and get response once Sequence is completed with Success/Failure For other Subscribers(who has not submitted the sequence), they can also get response using queryFinal API, for this they need to provide runId of Sequence\nExecution of a single Step\nEngine pulls one step at a time, and it is executed using command handler in the script. Command handler is selected based upon type and name of command present in Step.","title":"Loading and Running a sequence in Sequencer"},{"location":"/technical/sequencer-tech.html#completion-of-a-sequence","text":"Once every step is executed, it is marked as Finished with Success or Failure. If any of step is Failed, Sequence is terminated and Error response is sent to all Subscribers. If all steps are completed with Success, then Success response is sent to all Subscribers.","title":"Completion of a Sequence"},{"location":"/technical/sequencer-tech.html#implementation-details","text":"Sequencer framework uses Akka Actor as core implementation (Sequencer Actor). The following figure explains the architecture of the Sequencer framework. Sequencer is registered with Location Service. The future SOSS Planning Tool or ESW.HCMS Script Monitoring Tool will use the Location of the top-level Sequencer returned by Sequence Manager to resolve the top-level Sequencer, and will send the Observation’s Sequence to top-level Sequencer.\nEngine and Sequencer Actor are core parts of Framework. The framework part is the same for every Sequencer, but the Script can vary. The Script defines the behaviour of the Sequencer for each step within a Sequence.\nThe following sections explain the core components of Sequencer:\nSequencer Lifecycle Scripting Support","title":"Implementation Details"},{"location":"/technical/sequencer-tech.html#sequencer-lifecycle","text":"The Sequencer lifecycle is implemented as a fairly complicated finite state machine as shown in the figure below. This Section explains the different states and messages accepted in each respective state of Sequencer. At any given time a Sequencer is in exactly one of these states. The state of the Sequencer is tied to whether or not it has received a Sequence and whether or not the Sequence has started executing. Sequencer supports a set of commands/messages, and on receiving those commands, it takes an action and transitions to other states.\nFollowing are the states supported by the Sequencer:\nIdle/Online: This is the default state of the Sequencer. A Sequencer is idle when it is starts up. It has a Script since it has been loaded/created by the Sequence Component, but there is no Sequence under execution. A Sequencer can come to the idle state from the following situations: when the Sequencer starts up for the first time with a Script loaded when the Sequencer has finished execution of a Sequence when the Sequencer was offline, and a goOnline command is received\nIn this state, the Sequencer can only receive a Sequence, goOffline, or shutdown, in which the Sequencer transitions to the Loaded, Offline, and Killed states, respectively.\nLoaded: A Sequencer is in loaded state when a Sequence is received and ready for execution, but execution of the Sequence hasn’t started. A separate start command is expected to start execution of the Sequence. All sequence editor actions (for e.g. add, remove, reset) are accepted in this state. From this state, the Sequencer can go to the Running state on receiving a start command, or it could go to the Offline state if goOffline command is sent. On receiving a reset command, which discards all the pending steps, the Sequencer will go to Idle state. InProgress/Running: The Sequencer is in the Running state only when it is executing a Sequence. All sequence editor actions (for e.g. add, remove, reset) are accepted in this state. From the Running state, the Sequencer can go to Idle state on completion of a Sequence, or it can be shutdown. A Sequencer cannot go Offline from this state; the Sequencer must first to go to the Idle state and then Offline. Offline: The Sequencer goes to the Offline state only on receiving a goOffline command, which can either come from an upstream Sequencer, or from a user through the admin dashboard. In this state, only a few commands are excepted (for eg. goOnline, shutdown, status etc). Killed: This is the final state of the Sequencer, achieved when receiving a shutdown command. The shutdown command can be sent in any state, hence a Sequencer can transition to this state from any other state. However, a Sequencer doesn’t stay in this state long; when a Sequencer is killed, it is removed from the Location Service, and ActorSystem is shutdown, effectively destroying the Sequencer.","title":"Sequencer Lifecycle"},{"location":"/technical/sequencer-tech.html#scripting-support","text":"Sequencer Scripts are the most important part of the Sequencer architecture. The scripting environment has following core requirements:\nDomain Specific Language (DSL) constructs for writing Scripts. For example, par to execute commands in parallel, onSetup like constructs where the script writer will define logic to be executed when Setup steps are processed. Kotlin has been used to create the DSL for writing a Script. Kotlin has excellent language support for writing an embedded DSL. Kotlin also has excellent support for asynchronous processing/tasks that allows a more script-like syntax for the kinds of things ESW Scripts need to do.\nMutable State within the script To handle mutable state in thread safe manner, Script is implemented using the Active Object Pattern. Every operation in a Script needs to be asynchronous and non-blocking in nature, and each operation will be scheduled on Single Threaded Execution Context (StrandEC). This ensures that state inside the Script can be accessed/modified at any place inside with the guarantee of thread safety. If there is need to have CPU intensive or blocking operations in Script, patterns supporting these needs to be followed which uses another Execution Context so that Script StrandEC is not blocked. The scripting DSL provides special constructs for background processing.\nScripting Support is implemented using Kotlin. onSetup and onObserve handlers are provided which will be used by script writers to write behaviour when Setup and Observe commands are received. Specific onSetup handler will be picked based on command name specified in handler. For more details about scripting please refer here","title":"Scripting Support"},{"location":"/technical/sequencer-tech.html#sequencer-interfaces","text":"Sequencer exposes its interface in three ways:\nAkka interface - Sequencer is registered as an Akka-based component. One can resolve Sequencer and use the Akka client to interact with Sequencer. HTTP direct interface - Each Sequencer also exposes an HTTP-based interface as an embedded Sequencer Server (direct and unprotected usage). This access provides routes that allow user to directly control the Sequencer without any auth protection. UI applications are supposed to use Gateway interface described below to interact with Sequencer as Gateway provided auth protection layer. HTTP Gateway interface - It is also possible to interact with Sequencer using the UI Application Gateway (as outside network interface). Being outside network interface, this access requires user to be authenticated and authorized. The Gateway hosts the Sequencer API, which communicates with the Sequencer via the Akka interface. Please refer to the Gateway documentation for more information.\nFollowing snippet shows instantiating Akka Interface to interact with Sequencer:\nScala private implicit val actorSystem: ActorSystem[SpawnProtocol.Command] = ActorSystemFactory.remote(SpawnProtocol(), \"example\")\nprivate val sequencerAkkaConnection: AkkaConnection                  = AkkaConnection(ComponentId(Prefix(ESW, \"IRIS_DARKNIGHT\"), Sequencer))\nprivate val locationService: LocationService                         = HttpLocationServiceFactory.makeLocalClient(actorSystem)\n\nprivate val sequencerAkkaLocation: AkkaLocation =\n  Await.result(locationService.resolve(sequencerAkkaConnection, 10.seconds), 10.seconds).get\n\nprivate val sequencer: SequencerApi = SequencerApiFactory.make(sequencerAkkaLocation)\nFollowing snippet shows instantiating HTTP direct Interface to interact with Sequencer:\nScala private val sequencerHttpConnection: HttpConnection = HttpConnection(ComponentId(Prefix(ESW, \"IRIS_DARKNIGHT\"), Sequencer))\nprivate val sequencerHttpLocation: HttpLocation =\n  Await.result(locationService.resolve(sequencerHttpConnection, 10.seconds), 10.seconds).get\nprivate val sequencerHttpClient: SequencerApi = SequencerApiFactory.make(sequencerHttpLocation)\n\nsequencerHttpClient.getSequence\nFor interacting using HTTP Gateway interface, please refer here\nNote Sequencer Http direct interface is not supposed to be used from anywhere as it is unprotected and also bind to inside network ip.","title":"Sequencer Interfaces"},{"location":"/technical/sequencer-tech.html#interacting-with-sequencer","text":"One can use Akka Interface or HTTP Gateway interface to interact with Sequencer. APIs to interact with Sequencer are broadly categorised as following.\nSequencer Command Service - Provided as a part of CSW. Provides way to submit sequence and receive response. Sequence Editor APIs - Provided as a part of ESW. Provided way to edit sequence submitted to Sequencer. Sequencer Lifecycle APIs - Provided as a part of ESW. Provided way to send lifecycle commands to Sequencer. Other APIs - Provided as a part of ESW.","title":"Interacting with Sequencer"},{"location":"/technical/sequencer-tech.html#sequencer-command-service","text":"Commands can be sent to Sequencer to submit sequence and response is received in return.\nSequencer Interface exposes APIs on top of Sequencer Command Service. Sequencer Command Service provides way to submit sequence to Sequencer and receive started or final response. Sequencer Command Service is provided as a part of CSW and details about using Sequencer Command Service can be found here.","title":"Sequencer Command Service"},{"location":"/technical/sequencer-tech.html#sequence-editor-apis","text":"Sequence Editor APIs allow actions to edit sequence such as add more steps, delete/replace existing steps, Add/remove breakpoint in sequence. For using Sequence Editor actions, sequencer must be running a sequence. If Sequencer is not running any sequence then, Sequencer will return Unhandled response.\nadd This API allows to add more steps to sequence. Steps will be added in the end of sequence.\nScala val stepsToAdd: List[SequenceCommand] = List(\n  Setup(Prefix(ESW, \"filter.wheel\"), CommandName(\"setup-iris\")),\n  Setup(Prefix(ESW, \"filter.wheel\"), CommandName(\"setup-tcs\"))\n)\nsequencer.add(stepsToAdd)\nprepend This API allows to add more steps to sequence. Steps will be added after currently running step of sequence.\nScala val stepsToPrepend: List[SequenceCommand] = List(\n  Setup(Prefix(ESW, \"filter.wheel\"), CommandName(\"setup-iris\")),\n  Setup(Prefix(ESW, \"filter.wheel\"), CommandName(\"setup-tcs\"))\n)\nsequencer.prepend(stepsToPrepend)\ngetSequence This API allows returns Sequence running in Sequencer if any.\nScala private val stepList: StepList = Await.result(sequencer.getSequence, 1.seconds).get\nreplace This API allows to replace particular step in the sequence with more steps.\nScala val stepsToReplace: List[SequenceCommand] = List(\n  Setup(Prefix(ESW, \"filter.wheel\"), CommandName(\"setup-iris\")),\n  Setup(Prefix(ESW, \"filter.wheel\"), CommandName(\"setup-tcs\"))\n)\nsequencer.replace(stepList.steps(4).id, stepsToReplace)\ninsertAfter This API allows to insert more steps after particular step in the sequence.\nScala val stepsToInsertAfter: List[SequenceCommand] = List(\n  Setup(Prefix(ESW, \"filter.wheel\"), CommandName(\"setup-iris\")),\n  Setup(Prefix(ESW, \"filter.wheel\"), CommandName(\"setup-tcs\"))\n)\nsequencer.insertAfter(stepList.steps(4).id, stepsToInsertAfter)\ndelete This API allows to delete particular step in the sequence.\nScala private val stepToDelete: Id = stepList.steps(4).id\nsequencer.delete(stepToDelete)\nadd and remove breakpoint These APIs allows to add and remove breakpoint for particular step in the sequence.\nScala private val breakpointStep: Id = stepList.steps(4).id\nsequencer.addBreakpoint(breakpointStep)\nsequencer.removeBreakpoint(breakpointStep)\nreset These APIs allows to discard all pending steps in the sequence.\nScala sequencer.reset()\npause and resume sequence These APIs allows to pause and resume sequence. This essentially adds/removes breakpoint at first pending step in sequence\nScala sequencer.pause\nsequencer.resume","title":"Sequence Editor APIs"},{"location":"/technical/sequencer-tech.html#sequencer-lifecycle-apis","text":"Sequencer Lifecycle APIs allow to send lifecycle commands to Sequencer such as goOnline, abortSequence etc.\nCertain commands are restricted depending on state of Sequencer. For example, goOnline command is handled only when Sequencer is in Offline state. If goOnline is sent otherwise it will return Unhandled response with error msg. For details refer Sequencer Lifecycle Section\nisAvailable\nThis API allows to check if Sequencer is in Idle state or not. It returns true if Sequencer is in Idle state.\nScala sequencer.isAvailable\nonline/offline\nThese APIs allow to send goOnline/goOffline mode commands to Sequencer. isOnline command returns true if Sequencer is online.\nScala sequencer.isOnline\nsequencer.goOnline()\nsequencer.goOffline()\nabortSequence\nThis API allow to abort running sequence. This essentially discards pending steps from sequence and also call onAbortSequence handler written in script.\nScala sequencer.abortSequence()\nStop\nThis API allow to stop sequence. This essentially discards pending steps from sequence and also call onStop handler written in script.\nScala sequencer.stop()\ngetSequencerState\nSequencer is implememted as state machine. It accepts/discards msgs based on Sequencer State. This API allow returns current sequencer state.\nScala sequencer.getSequencerState\ndiagnosticMode\nThis API allow to send diagnosticMode command to Sequencer. This calls onDiagnosticMode handler written in script\nScala sequencer.diagnosticMode(UTCTime.now(), \"diagnostic-mode\")\noperationsMode\nThis API allow to send operationsMode command to Sequencer. This calls onOperationsMode handler written in script\nScala sequencer.operationsMode()","title":"Sequencer Lifecycle APIs"},{"location":"/technical/sequencer-tech.html#other-apis","text":"loadSequence\nThis API allows to load sequence in Sequencer. Loaded Sequence does not start execution unless StartSequence Command is received. One can replace already loaded sequence by firing another loadSequence command.\nScala val sequence: Sequence = Sequence(\n  Setup(Prefix(ESW, \"filter.wheel\"), CommandName(\"setup-iris\")),\n  Setup(Prefix(ESW, \"filter.wheel\"), CommandName(\"setup-tcs\"))\n)\nsequencer.loadSequence(sequence)\nstartSequence\nThis API allows to start execution of previously loaded sequence in Sequencer. This return SubmitResponse which is Started in case of success.\nScala sequencer.startSequence()\ngetSequenceComponent\nThis API allows to get location of Sequence Component running the Sequencer.\nScala sequencer.getSequenceComponent\nsequencer.getSequenceComponent","title":"Other APIs"},{"location":"/technical/sequencer-tech.html#running-sequencer","text":"For running Sequencer Script, please refer this.","title":"Running Sequencer"},{"location":"/technical/sequence-component-tech.html","text":"","title":"Sequence Component Technical Documentation"},{"location":"/technical/sequence-component-tech.html#sequence-component-technical-documentation","text":"","title":"Sequence Component Technical Documentation"},{"location":"/technical/sequence-component-tech.html#introduction","text":"The Sequence Component is a standalone application that can load scripts and in doing so, become a Sequencer. In the OCS scripting approach, the Sequence Component is the reusable environment that supports the execution of different scripts. Use of the Sequence Component also reduces the time to load a Sequencer Script–similar to a scripting language shell.\nSequence Component will be a continuously running JVM process which will load and unload different script. When loading a script, the Sequencer will be started as a part of existing Sequence Component process. This step minimizes the start-up time for Sequencer to a fraction of a second.\nThe Sequence Component application and its arguments are described here.","title":"Introduction"},{"location":"/technical/sequence-component-tech.html#modules","text":"esw-ocs-api - This module contains the API for Sequence Component. This is cross-compiled module, which is compiled into JVM as well as JS code. This module includes SequenceComponentApi, which defines the interface for Sequence Component. This module also consists of core models, actor client, JVM and JS client for Sequence Component. esw-ocs-impl - This module consists of core implementation of Sequence Component which is SequenceComponentActor. esw-ocs-app - This module consists of wiring as well as cli application to start Sequence Component. The wiring is the code that integrates Sequence Component to the ESW/CSW environment.","title":"Modules"},{"location":"/technical/sequence-component-tech.html#implementation-details","text":"The Sequence Component is written in Scala to provide integration with the CSW Component Framework and Services. Since component developers do not need to modify Sequence Component code, there is no Java version.\nThe Sequence Component registers itself with the Location Service when started. This allows the Sequence Manager to find the Sequence Component and send it commands. Sequence Component is started with a Subsystem and an optional name. While the Subsystem for a Sequence Component identifies to which subsystem the Sequence Component belongs, a Sequence Component can load Scripts for any subsystem, and therefore become a Sequencer for any subsystem. For example, if for some reason the IRIS Sequence Component is not reachable, an IRIS Script can be loaded into an ESW Sequence Component and it can then be used as the IRIS Instrument Sequencer.\nSequence Component will be registered as Akka Connection in Location Service. The following table describes the registration of a Sequence Component in the Location Service:\nSubsystem Name Registered Location ESW (none) ESW.ESW_77 ESW primary ESW.primary\nNote that CSW always capitalizes a subsystem when it is displayed. Arguments can be entered as lowercase.\nWarning In all cases, the subsystem must be the acronyms defined by Systems Engineering and as defined in CSW. If the subsystem is not a valid TMT subsystem, an error will occur.\nNote If Name is not provided while starting Sequence Component, it will be uniquely generated using pattern -Subsystem.Subsystem_<Random number 1 to 100>. There exists possibility that, this generated name is already taken by another Sequence Component. To solve this scenario, Sequence Component registration involves retry mechanism which then generates another name and starts Sequence Component.\nThe Sequence Component provides framework code to support the loading and unloading of Scripts and a few other useful capabilities.\nMessage Description LoadScript Load a script in the Sequence Component to create a Sequencer. Takes a subsystem and observing mode as arguments. UnloadScript Unloads a loaded script returning a Sequence Component. RestartScript Unloads and reloads a script causing initialization of state. GetStatus Returns the Location of the Sequence Component’s loaded Sequencer Shutdown Shutdown sequence component and sequencer loaded(if any)\nFor more details on the messages handled by the Sequence Component see here","title":"Implementation Details"},{"location":"/technical/sequence-component-tech.html#sequence-component-lifecycle","text":"Sequence Component is implemented as Finite State Machine using Akka Actor as core. The Sequence Component also has a lifecycle, but it is simpler than the Sequencer lifecycle. The following figure shows the Sequence Component has two states: Idle and Running.\nIdle: This is the default state of a Sequence Component when it is started. It is ready for the loading of a Script that will create a Sequencer, which occurs on a LoadScript command. If successful, the Sequence Component transitions to the Running state. While in the Idle state, the Sequence Component responds to the GetStatus message and ignores the UnloadScript message without error. For RestartScript message, sequence component responds with error saying RestartScript in unhandled in idle state. Running: Once a Sequence Component has successfully loaded a Script, it is in the Running state. The new Sequencer will be available to process Sequences until it receives an UnloadScript message and transitions back to the Idle state. While in the Running state, the Sequence Component can also receive a RestartScript message, which restarts a Sequencer by unloading the Script and shutting down the Sequencer, immediately followed by the loading of the Script again. This has the effect of initializing the script. For LoadScript message, sequence component responds with error saying that LoadScript is unhandled in Running state. The Sequence Component responds successfully to the GetStatus message.\nNote Shutdown sequence component message is handled in both Idle and Running state. In Idle state, it un-registers sequence component in location service, terminates actor system and gracefully shutdown sequence component. In Running state, shutdown consist of additional step apart from Idle state shutdown, which is shutting down sequencer loaded on the sequence component.","title":"Sequence Component Lifecycle"},{"location":"/technical/sequence-component-tech.html#running-sequence-component","text":"For running Sequence Component Stand-alone or with Sequencer Script, please refer this.","title":"Running Sequence Component"},{"location":"/technical/gateway-tech.html","text":"","title":"Gateway Technical Documentation"},{"location":"/technical/gateway-tech.html#gateway-technical-documentation","text":"Gateway gives access to all CSW and ESW services (available to user) and components from browser-based user interfaces. Gateway also enforces auth on command and sequencer APIs to protect from unauthorised access.","title":"Gateway Technical Documentation"},{"location":"/technical/gateway-tech.html#implementation","text":"Gateway service is an HTTP service which relies on msocket framework. Internally it delegates to the various services(of both ESW or CSW) needed as per the request.\nIt provides access to following:\nCommand Service APIs (CSW) Alarm APIs (CSW) Event APIs (CSW) Sequencer Service APIs (ESW) Admin APIs (ESW) Logging APIS (ESW)\nSome services are not part of the gateway. This is mainly because of 2 reasons: 1. The services can be accessed via its own HTTP interface. Example, Config Service. 2. The services are not user facing. Example, Sequence Manager Service.\nThe security directives created in the app for command and sequencer services are passed on to the routes in order to enable auth for command and sequencer services.","title":"Implementation"},{"location":"/technical/gateway-tech.html#api-call-flow","text":"Let’s take example of GetSequence command coming from browser to sequencer service via a gateway:\nSince sequencer APIs are protected using auth, the UI app gets a valid token from AAS that will enable access to sequencer API in gateway. The UI app will create a getSequence request using the auth token and send it to gateway. Gateway validates the request auth token and the role of UI app against the command role config. If the validation is successful, gateway delegates the request to sequencer service. Sequencer service executes the request and return the stepList as response. This response is given back to the UI app that made the request.\nBelow diagram depicts the flow mapped by above points:","title":"API call flow"},{"location":"/technical/gateway-tech.html#modules","text":"","title":"Modules"},{"location":"/technical/gateway-tech.html#esw-gateway-api","text":"All the request models, clients, and APIs exposed in gateway service resides within this module. This also contains the codecs for the models.\nIt is a cross-compiled project which has following parts:\njs - code used by scala-js. jvm - code used by jvm shared - code which can be used by both scala-js and jvm","title":"esw-gateway-api"},{"location":"/technical/gateway-tech.html#esw-gateway-impl","text":"This module depends on esw-gateway-api and contains implementation for all the apis declared in esw-gateway-api. In case of CSW services(ex, Event Service, Alarm Service), the implementation delegates the call to respective CSW service.","title":"esw-gateway-impl"},{"location":"/technical/gateway-tech.html#esw-gateway-server","text":"This module contains the main application which when run starts the gateway server. This includes server wiring, post and websocket handlers and cli app.\nThis module depends on esw-http-core for starting up an HTTP service.","title":"esw-gateway-server"},{"location":"/technical/gateway-tech.html#running-gateway-server","text":"For running Gateway server, please refer this.","title":"Running Gateway Server"},{"location":"/technical/contracts.html","text":"","title":"Service Contracts"},{"location":"/technical/contracts.html#service-contracts","text":"Most ESW Services support both Akka-based communication and HTTP-based communication. The HTTP-based interfaces are documented according to a contract specified by CSW and ESW in terms of JSON model files. A client following these contracts is able to communicate with the services using HTTP. The contracts are generated by the source and are always correct, but may change between major versions.\nThe Complete ESW service contracts to access Http/Websocket endpoints can be found below:","title":"Service Contracts"},{"location":"/technical/contracts.html#","text":"","title":"Json Contract"},{"location":"/technical/agent-service-tech.html","text":"","title":"Agent Service and Agent Technical Documentation"},{"location":"/technical/agent-service-tech.html#agent-service-and-agent-technical-documentation","text":"","title":"Agent Service and Agent Technical Documentation"},{"location":"/technical/agent-service-tech.html#agent-service-introduction","text":"The Agent Service was created to support the creation and configuration Sequence Components (and Sequencers) at run-time, a key feature of the OSW Observing Mode Oriented Architecture. Agent Service was created primarily for use by the Sequence Manager, but it provides a general service that may become more heavily used in the future.\nFor instance, Sequence Manager provides a provision function that takes a configuration and starts one or more Sequence Components on a set of machines. These Sequence Components can be used to run Sequencers.\nThe functionality of Agent Service is flexible and can be used to provide a more resilient OSW by allowing the operator of the telescope to easily respond to unexpected failures. For instance, the Sequence Manager itself can be created using the Agent Service. In this use case, a future operations user interface will allow the operator to start a new Sequence Manager on a backup machine in the case where the machine running the Sequence Manager has failed. This kind of scenario can in many cases reduce or eliminate OSW down-time due to machine failures.","title":"Agent Service Introduction"},{"location":"/technical/agent-service-tech.html#agent-service-implementation-details","text":"The figure below shows the key parts of the Agent Service. Agent Service consists of a few different, collaborating parts deployed on different machines. Agent Service depends on and uses CSW Location Service. The Agent Service is a protected service using CSW Authorization and Authentication Service. Only users with an appropriate role are able to use the Agent Service functionality.\nThe Agent Service has the following layers and modules:\nServer: which provides the protected HTTP-based interface. Service implementation layer: implementation logic that includes creating the AgentClient for an Agent. Agent: a second program executing on hosts, which spawns or kills a given component.\nThe figure shows a browser contacting the Agent Service executing on an ESW machine. It is registered in the Location Service. The browser makes an authorized HTTP call to the Agent Server. The server locates an Agent on the desired host using the CSW Location Service. It then uses the Agent’s Akka-based API to execute the request on the remote host. The Agent returns a response that is serialized by the Agent Server and returned as an AgentServiceResponse.\nThe following sections describe the major modules of the Agent Service. The Agent itself is described below.","title":"Agent Service Implementation Details"},{"location":"/technical/agent-service-tech.html#agent-service-module-esw-agent-service-","text":"Agent Service starts with an HTTP service built using the msocket framework that is common to all ESW HTTP-based services. See msocket for more information.\nImplementation of Agent Service is distributed within the following submodules:","title":"Agent Service Module (esw-agent-service)"},{"location":"/technical/agent-service-tech.html#esw-agent-service-api","text":"All the request models and APIs related to AgentService reside within this module. This module also contains the codecs for the models. This module depends on esw-agent-akka-api module which provides all the response models.\nThis module is a cross-compiled project which has following parts:\njs - code which is related to scala-js (for possible future UI usage) jvm - code which is related only to JVM shared - code which can be used by both scala-js and JVM","title":"esw-agent-service-api"},{"location":"/technical/agent-service-tech.html#esw-agent-service-impl","text":"This module depends on the esw-agent-service-api module. It contains the AgentService API’s implementation which has the logic of creation of the AgentClient for a given specific Agent and calling the specific APIs of the AgentClient.","title":"esw-agent-service-impl"},{"location":"/technical/agent-service-tech.html#esw-agent-service-app","text":"A command-line application exists to start the Agent Service. It is implemented in this module.\nThis module contains all the HTTP handlers, server wiring, and the CLI app to start the agent server.","title":"esw-agent-service-app"},{"location":"/technical/agent-service-tech.html#agent-introduction","text":"Agent is an Akka-based actor which is used to spawn or kill a component on the machine where the Agent is running. The Agent must be started on each machine that is available to spawn components. At this time, we anticipate this will be primarily ESW machines, but any subsystem that needs to run a Sequencer on their machine (rather than on ESW machines) will also start an Agent.\nCurrently, Agent is able to spawn or kill the following components:\nSequence Manager Sequence Component","title":"Agent Introduction"},{"location":"/technical/agent-service-tech.html#agent-implementation","text":"Agent is an Akka actor which can spawn or kill a JVM process (at this time) depending on the received message. If actor receives a spawn message(e.g., SpawnSequenceManager etc), it will first check if the given component is already registered in the Location Service. If yes, it replies with a failure response indicating the component already exists; otherwise, it tries to spawn the component.\nOn any spawn message Agent follows following steps:\nChecks if the component is already registered. If yes it returns the Failure response If not then it goes to the next step It spawns the component by starting a JVM-based process. If the process is spawned successfully, it returns the Spawned response If the process fails to spawn, it returns the Failure response\nThe following modules are part of the Agent implementation.","title":"Agent Implementation"},{"location":"/technical/agent-service-tech.html#agent-module-esw-agent-akka-","text":"The Agent is not a relatively simple module with only a few modules. Implementation of Agent is distributed within the following submodules:","title":"Agent Module (esw-agent-akka)"},{"location":"/technical/agent-service-tech.html#esw-agent-akka-app","text":"This module contains Agent actor’s implementation. The Akka-based API is implemented here. This module depends on Agent Client for the Agent actor’s messages and codecs.\nThere is also a CLI-based application for starting an Agent, and it is also implemented in this module.","title":"esw-agent-akka-app"},{"location":"/technical/agent-service-tech.html#agent-client","text":"A formal Akka-based client is provided for applications that need to send and receive messages to/from the Agent. This module defines the Agent actor messages and codecs.\nAgent Client is an actor proxy to the Agent actor. It provides the API which is used internally to send messages to the Agent actor and return responses of the Agent actor to the caller.","title":"Agent Client"},{"location":"/technical/agent-service-tech.html#running-agent-and-agent-service","text":"For running Agent, please refer this. For running Agent Service, please refer this.","title":"Running Agent and Agent Service"},{"location":"/technical/apps/apps-index.html","text":"","title":"Applications"},{"location":"/technical/apps/apps-index.html#applications","text":"Getting and Running ESW Applications 1. Install coursier 2. Add TMT Apps channel to coursier 3. Starting CSW Services 4. Install and Run ESW Apps Starting Sequence Manager Using sequence-manager Prerequisites for Running sequence-manager App 1. Install coursier and the TMT Apps Channel 2. Start Any Needed CSW Services 3. Install sequence-manager 4. Run sequence-manager Setting the Log Level Starting Sequence Manager in simulation mode Agent Service App Running Agent Service App using Coursier Setting the default log level Agent App Running Agent App using Coursier Setting the default log level","title":"Applications"},{"location":"/technical/apps/getting-apps.html","text":"","title":"Getting and Running ESW Applications"},{"location":"/technical/apps/getting-apps.html#getting-and-running-esw-applications","text":"ESW applications are installed locally using the coursier application, a standalone program that makes using the JVM and Scala/Java applications easier to use and maintain.\nTo use any ESW application, coursier must be installed on your machine.","title":"Getting and Running ESW Applications"},{"location":"/technical/apps/getting-apps.html#1-install-coursier","text":"The installation process is documented in the coursier installation document.\nThis blog post: Single Command Scala Setup by Alex Archambault, is a more friendly introduction to coursier.","title":"1. Install coursier"},{"location":"/technical/apps/getting-apps.html#2-add-tmt-apps-channel-to-coursier","text":"TMT apps are installed using a coursier channel. The channel must be added to the local installation of coursier using the cs install option. The apps channel is maintained on the TMT GitHub site. To install the TMT Apps channel use one of the following commands.\nFor developer machine setup, type:\ncs channel --add https://raw.githubusercontent.com/tmtsoftware/osw-apps/master/apps.json\nFor a production machine setup, type:\ncs channel --add https://raw.githubusercontent.com/tmtsoftware/osw-apps/master/apps.prod.json","title":"2. Add TMT Apps channel to coursier"},{"location":"/technical/apps/getting-apps.html#3-starting-csw-services","text":"Often when using an ESW application for development, it is necessary to also run one or more CSW services such as Location Service, Event Service, etc. The CSW documentation provides the information needed to start CSW services here.","title":"3. Starting CSW Services"},{"location":"/technical/apps/getting-apps.html#4-install-and-run-esw-apps","text":"cs install command will be used to install executables/launchers of each of ESW apps. This Step varies for each application. Each app section explains installation and running procedure in detail.\nFor example following command shows installation for agent app,\ncs install agent-app:<version | SHA>","title":"4. Install and Run ESW Apps"},{"location":"/technical/apps/sequence-manager-app.html","text":"","title":"Starting Sequence Manager Using sequence-manager"},{"location":"/technical/apps/sequence-manager-app.html#starting-sequence-manager-using-sequence-manager","text":"sequence-manager is a command line application that facilitates starting Sequence Manager and the HTTP server that is part of Sequence Manager using the coursier dependency management application. The coursier tool is described with full documentation at the coursier site.","title":"Starting Sequence Manager Using sequence-manager"},{"location":"/technical/apps/sequence-manager-app.html#prerequisites-for-running-sequence-manager-app","text":"The following steps should be followed to use sequence-manager to start a Sequencer Manager.","title":"Prerequisites for Running sequence-manager App"},{"location":"/technical/apps/sequence-manager-app.html#1-install-coursier-and-the-tmt-apps-channel","text":"The coursier application must be installed on your machine and the OCS Apps channel must be installed. The instructions for doing this are provided here.","title":"1. Install coursier and the TMT Apps Channel"},{"location":"/technical/apps/sequence-manager-app.html#2-start-any-needed-csw-services","text":"To run sequence-manager, the CSW Location Service must be running. CSW AAS should be running.\nInformation on starting CSW services is here","title":"2. Start Any Needed CSW Services"},{"location":"/technical/apps/sequence-manager-app.html#3-install-sequence-manager","text":"The following command creates an executable file named sequence-manager in the default installation directory.\ncs install sequence-manager:<version | SHA>\nOne can specify installation directory like the following:\ncs install \\\n    --install-dir /tmt/apps \\\n    sequence-manager:<version | SHA>\nNote If you don’t provide the version or SHA in above command, sequence-manager will be installed with the latest tagged binary of esw-sm-app","title":"3. Install sequence-manager"},{"location":"/technical/apps/sequence-manager-app.html#4-run-sequence-manager","text":"Once sequence-manager is installed, one can simply run sequence-manager by executing start command\nStart command supports following arguments:\n-o : Config file path which has mapping of sequencers and resources needed for different observing modes -l : optional argument (true if config is to be read locally or false if from remote server) default value is false -a : optional argument: agentPrefix on which Sequence Manager will be spawned, ex: ESW.agent1, IRIS.agent2 etc. This argument is used when Sequence Manager is spawned using Agent. For starting standalone Sequence Manager for testing or on local this argument is not needed.\nThis command starts Sequence Manager as well as its HTTP server.\n//cd to installation directory\ncd /tmt/apps\n\n// run Sequence Manager\n./sequence-manager start -o obsmode.conf\nNote Refer to supported arguments section or ./sequence-manager start --help for starting Sequence Manager with specific arguments","title":"4. Run sequence-manager"},{"location":"/technical/apps/sequence-manager-app.html#setting-the-log-level","text":"The default log level for any component is specified in the application.conf file of the component. Use the java -J-D option to override configuration values at runtime. For log level, the format is:\n-J-Dcsw-logging.component-log-levels.<Subsystem>.<ComponentName>=<LEVEL>\nFor example, using the example above:\n//cd to installation directory\ncd /tmt/apps\n\n// run Sequence Manager\n./sequence-manager -J-Dcsw-logging.component-log-levels.ESW.sequence_manager=TRACE start -o obsmode.conf","title":"Setting the Log Level"},{"location":"/technical/apps/sequence-manager-app.html#starting-sequence-manager-in-simulation-mode","text":"","title":"Starting Sequence Manager in simulation mode"},{"location":"/technical/apps/sequence-manager-app.html#prerequisites-for-running-sequence-manager-app-in-simulation-mode","text":"","title":"Prerequisites for Running sequence-manager App in simulation mode"},{"location":"/technical/apps/sequence-manager-app.html#1-install-coursier-and-the-tmt-apps-channel","text":"The coursier application must be installed on your machine and the OCS Apps channel must be installed. The instructions for doing this are provided here.","title":"1. Install coursier and the TMT Apps channel"},{"location":"/technical/apps/sequence-manager-app.html#2-start-any-needed-csw-services","text":"To run sequence-manager in simulation mode, the CSW Location Service must be running.","title":"2. Start any Needed CSW services"},{"location":"/technical/apps/sequence-manager-app.html#3-install-esw-services","text":"The following command creates an executable file named esw-services in the default installation directory.\ncs install esw-services:<version | SHA>","title":"3. Install esw-services"},{"location":"/technical/apps/sequence-manager-app.html#4-run-sequence-manager-in-simulation-mode","text":"cs launch esw-services – start -s --simulation\n//  where:\n//    -s : to start SequenceManager\n//    --simulation : in simulation mode","title":"4. Run sequence-manager in simulation mode"},{"location":"/technical/apps/sequence-manager-app.html#5-running-sequence-manager-in-simulation-mode-independent-of-esw-services","text":"cs launch sequence-manager:<version | SHA> -- start --simulation\nWarning If sequence-manager is started independent of esw-services in the simulation mode then following things are needed to be taken care of: * Agents won’t be spawned automatically, they have to be started manually. * A version.conf needs to be created in config-service for the Provision api to work.","title":"5. Running sequence-manager in simulation mode independent of esw-services"},{"location":"/technical/apps/agent-service-app.html","text":"","title":"Agent Service App"},{"location":"/technical/apps/agent-service-app.html#agent-service-app","text":"This application will start the AgentService’s server.\nWarning To access any protected AgentService endpoints, ESW-user role is required.","title":"Agent Service App"},{"location":"/technical/apps/agent-service-app.html#running-agent-service-app-using-coursier","text":"The following steps should be followed to start Agent Service Application","title":"Running Agent Service App using Coursier"},{"location":"/technical/apps/agent-service-app.html#1-install-coursier-and-the-tmt-apps-channel","text":"The coursier application must be installed on your machine and the OCS Apps channel must be installed. The instructions for doing this are provided here.","title":"1. Install coursier and the TMT Apps Channel"},{"location":"/technical/apps/agent-service-app.html#2-start-any-needed-csw-services","text":"To run agent service app, the CSW Location Service must be running. CSW AAS should be running.\nInformation on starting CSW services is here","title":"2. Start Any Needed CSW Services"},{"location":"/technical/apps/agent-service-app.html#3-install-agent-service-app","text":"Following command creates an executable file named agent-service-app in the default installation directory.\ncs install agent-service-app:<version | SHA>\nOne can specify installation directory like following:\ncs install \\\n    --install-dir /tmt/apps \\\n    agent-service-app:<version | SHA>\nNote: If you don’t provide the version or SHA in above command, agent-service-app will be installed with the latest tagged binary of esw-agent-service-app","title":"3. Install agent-service-app"},{"location":"/technical/apps/agent-service-app.html#4-run-agent-service-app","text":"Once agent-service-app is installed, one can simply run agent-service-app by executing start command\n//cd to installation directory\ncd /tmt/apps\n\n// run agent service app\n./agent-service-app start","title":"4. Run agent-service-app"},{"location":"/technical/apps/agent-service-app.html#setting-the-default-log-level","text":"The default log level for any component is specified in the application.conf file of the component. Use the java -J-D option to override configuration values at runtime. For log level, the format is:\n-J-Dcsw-logging.component-log-levels.<Subsystem>.<ComponentName>=<LEVEL>\nFor example, using the example above:\n//cd to installation directory\ncd /tmt/apps\n\n// run Sequence Manager\n./agent-service-app -J-Dcsw-logging.component-log-levels.ESW.agent_service=TRACE start","title":"Setting the default log level"},{"location":"/technical/apps/agent-app.html","text":"","title":"Agent App"},{"location":"/technical/apps/agent-app.html#agent-app","text":"This application will start the Agent actor.","title":"Agent App"},{"location":"/technical/apps/agent-app.html#running-agent-app-using-coursier","text":"The following steps should be followed to start Agent","title":"Running Agent App using Coursier"},{"location":"/technical/apps/agent-app.html#1-install-coursier-and-the-tmt-apps-channel","text":"The coursier application must be installed on your machine and the OCS Apps channel must be installed. The instructions for doing this are provided here.","title":"1. Install coursier and the TMT Apps Channel"},{"location":"/technical/apps/agent-app.html#2-start-any-needed-csw-services","text":"To run agent, the CSW Location Service must be running.\nInformation on starting CSW services is here","title":"2. Start Any Needed CSW Services"},{"location":"/technical/apps/agent-app.html#3-install-agent-app","text":"Following command creates an executable file named agent-app in the default installation directory.\ncs install agent-app:<version | SHA>\nOne can specify installation directory like following:\ncs install \\\n    --install-dir /tmt/apps \\\n    agent-app:<version | SHA>\nNote: If you don’t provide the version or SHA in above command, agent-app will be installed with the latest tagged binary of esw-agent-akka-app","title":"3. Install agent-app"},{"location":"/technical/apps/agent-app.html#4-run-agent-app","text":"Once agent-app is installed, one can simply run agent-app by executing start command\nStart command supports following arguments:\n-p: prefix of machine. For example, tcs.primary_machine, ocs.machine1 etc.\n//cd to installation directory\ncd /tmt/apps\n\n// run agent app\n./agent-app start -p \"tcs.primary_machine\"","title":"4. Run agent-app"},{"location":"/technical/apps/agent-app.html#setting-the-default-log-level","text":"The default log level for any component is specified in the application.conf file of the component. Use the java -J-D option to override configuration values at runtime. For log level, the format is:\n-J-Dcsw-logging.component-log-levels.<Subsystem>.<ComponentName>=<LEVEL>\nFor example, using the example above:\n//cd to installation directory\ncd /tmt/apps\n\n// run Sequence Manager\n./agent-app -J-Dcsw-logging.component-log-levels.TCS.primary_machine=TRACE start -p \"tcs.primary_machine\"","title":"Setting the default log level"}]}