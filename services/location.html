<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Location service · TMT Common Software (CSW)</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='docs'/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/groups.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/normalize.css/normalize.css"/>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>

<!--
<link rel="shortcut icon" href="../images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>TMT Common Software (CSW)
</a>
<div class="version-number">
0.1*
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../manuals.html" class="page">Manuals</a></li>
  <li><a href="../apps.html" class="page">Applications</a>
  <ul>
    <li><a href="../apps/cswclusterseed.html" class="page">csw-cluster-seed</a></li>
    <li><a href="../apps/cswlocationagent.html" class="page">csw-location-agent</a></li>
    <li><a href="../apps/cswonfigserverapp.html" class="page">csw-config-server</a></li>
    <li><a href="../apps/cswconfigclientcli.html" class="page">csw-config-client-cli</a></li>
  </ul></li>
  <li><a href="../services.html" class="page">Services</a>
  <ul>
    <li><a href="../services/location.html" class="active page">Location service</a></li>
    <li><a href="../services/config.html" class="page">Configuration service</a></li>
    <li><a href="../services/logging.html" class="page">Logging service</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="../index.html">TMT Common Software (CSW)</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>TMT Common Software (CSW)
</a>
<div class="version-number">
0.1*
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../manuals.html" class="page">Manuals</a></li>
  <li><a href="../apps.html" class="page">Applications</a>
  <ul>
    <li><a href="../apps/cswclusterseed.html" class="page">csw-cluster-seed</a></li>
    <li><a href="../apps/cswlocationagent.html" class="page">csw-location-agent</a></li>
    <li><a href="../apps/cswonfigserverapp.html" class="page">csw-config-server</a></li>
    <li><a href="../apps/cswconfigclientcli.html" class="page">csw-config-client-cli</a></li>
  </ul></li>
  <li><a href="../services.html" class="page">Services</a>
  <ul>
    <li><a href="../services/location.html" class="active page">Location service</a></li>
    <li><a href="../services/config.html" class="page">Configuration service</a></li>
    <li><a href="../services/logging.html" class="page">Logging service</a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="../index.html">TMT Common Software (CSW)</a></li>
  <li><a href="../services.html">Services</a></li>
  <li>Location service</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#location-service" name="location-service" class="anchor"><span class="anchor-link"></span></a>Location service</h1>
<p>Location Service handles component (i.e., Applications, Sequencers, Assemblies, HCDs, and Services) registration and discovery in the distributed TMT software system. A component’s location information can be utilized by other component/service to connect or use it. Example of location information is</p>
<ul>
  <li>host address/port pairs</li>
  <li>URL/URIs</li>
  <li>connection protocols</li>
</ul><div class="callout note "><div class="callout-title">async handling in scala and java examples.</div>
<ul>
  <li>
  <p><strong>Scala:</strong> <code>async</code> marks a block of asynchronous code and allows to <code>await</code> the computation till the Future is complete.  For more info, please refer: <a href="https://github.com/scala/async">https://github.com/scala/async</a></p></li>
  <li>
  <p><strong>Java non-blocking example:</strong> The code snippets use <code>CompletiableFuture</code> and it&rsquo;s <code>thenAsync</code>, <code>thenApply</code> methods. This style allows to compose multiple Futures and not block the calling thread till Futures are complete. </p></li>
  <li>
  <p><strong>Java blocking example:</strong> The code snippets use <code>CompletableFuture</code> using <code>get</code> blocking call. This style blocks the calling thread till the Future is complete.</p></li>
</ul></div>
<h2><a href="#artifacts" name="artifacts" class="anchor"><span class="anchor-link"></span></a>Artifacts</h2>
<dl>
  <dt>sbt</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;org.tmt&quot; %% &quot;csw-location_2.12&quot; % &quot;0.1-SNAPSHOT&quot;
</code></pre></dd>
  <dt>maven</dt>
  <dd>
  <pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
 &lt;groupId&gt;org.tmt&lt;/groupId&gt;
 &lt;artifactId&gt;csw-location_2.12&lt;/artifactId&gt;
 &lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;
 &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;
</code></pre></dd>
  <dt>gradle</dt>
  <dd>
  <pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: &quot;org.tmt&quot;, name: &quot;csw-location_2.12&quot;, version: &quot;0.1-SNAPSHOT&quot;
}
</code></pre></dd>
</dl>
<h2><a href="#create-locationservice" name="create-locationservice" class="anchor"><span class="anchor-link"></span></a>Create LocationService</h2>
<p>LocationServiceFactory exposes a make method to create an instance of LocationService. However, the make call will look for configuration settings managed using ClusterSettings. Verify <a href="https://tmtsoftware.github.io/csw-prod/api/scala/csw/services/location/commons/ClusterSettings.html">ClusterSettings</a> to ensure that LocationService behavior is as expected.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">private val locationService = LocationServiceFactory.make()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">private ILocationService locationService = JLocationServiceFactory.make();</code></pre></dd>
</dl>
<h2><a href="#shutdown-locationservice" name="shutdown-locationservice" class="anchor"><span class="anchor-link"></span></a>Shutdown LocationService</h2>
<p>This example demonstrates how to shutdown a location service. Shutdown will terminate the ActorSystem and will leave the cluster. </p>
<p><strong>Note:</strong> All the services registered via this instance of LocationService will continue to be available for other cluster members. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">Await.result(locationService.shutdown(), 20.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">locationService.shutdown().get();</code></pre></dd>
</dl>
<h2><a href="#creating-components-connections-and-registrations" name="creating-components-connections-and-registrations" class="anchor"><span class="anchor-link"></span></a>Creating components, connections and registrations</h2>
<p>An Application, Sequencer, Assembly, HCD, or Service component may need to be used by another component as part of normal observatory operations. It must register its location information with Location service so that other components can find it.</p>
<p><strong>Components</strong> are OMOA entities. They have a name identifier and type such as Container, HCD, Assembly, Service.</p>
<p><strong>Connections</strong> are the means to reach to components and are categorized as Akka, HTTP, Tcp connection.</p>
<p><strong>Registrations</strong> are service endpoints stored in LocationService.</p>
<p><code>register</code> API takes a <code>Registration</code> parameter and returns a handle to registration result. The success of <code>register</code> API can be validated by checking the <code>Location</code> instance pointed by registration result.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala"><br/>// add some dummy registrations for illustrative purposes

// dummy http connection
val httpPort = 8080
val httpConnection = HttpConnection(ComponentId(&quot;configuration&quot;, ComponentType.Service))
val httpRegistration = HttpRegistration(httpConnection, httpPort, &quot;path123&quot;)
val httpRegResultF = async {
  await(locationService.register(httpRegistration))
}
val httpRegResult = Await.result(httpRegResultF, 2.seconds)

// dummy HCD connection
val hcdConnection = AkkaConnection(ComponentId(&quot;hcd1&quot;, ComponentType.HCD))
val hcdRegistration = AkkaRegistration(hcdConnection, context.actorOf(Props(new Actor {
  override def receive: Receive = {
    case &quot;print&quot; =&gt; log.info(&quot;hello world&quot;)
  }
}), name = &quot;my-actor-1&quot;))
val hcdRegResultF = async {
  await(locationService.register(hcdRegistration))
}
val hcdRegResult = Await.result(hcdRegResultF, 2.seconds)

//register the client &quot;assembly&quot; created in this example
val assemblyConnection = AkkaConnection(ComponentId(&quot;assembly1&quot;, ComponentType.Assembly))
val assemblyRegistration = AkkaRegistration(assemblyConnection, self)
val assemblyRegResultF = async {
  await(locationService.register(assemblyRegistration))
}
val assemblyRegResult = Await.result(assemblyRegResultF, 2.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">// dummy http connection
HttpConnection httpConnection   = new HttpConnection(new ComponentId(&quot;configuration&quot;, JComponentType.Service));
HttpRegistration httpRegistration = new HttpRegistration(httpConnection, 8080, &quot;path123&quot;);
httpRegResult = locationService.register(httpRegistration).get();

// dummy HCD connection
AkkaConnection hcdConnection = new AkkaConnection(new ComponentId(&quot;hcd1&quot;, JComponentType.HCD));
AkkaRegistration hcdRegistration = new AkkaRegistration(hcdConnection, getContext().actorOf(Props.create(AbstractActor.class, () -&gt; new AbstractActor() {
            @Override
            public Receive createReceive() {
                return ReceiveBuilder.create().build();
            }
        }),
        &quot;my-actor-1&quot;
));
hcdRegResult = locationService.register(hcdRegistration).get();

//. register the client &quot;assembly&quot; created in this example
AkkaConnection assemblyConnection = new AkkaConnection(new ComponentId(&quot;assembly1&quot;, JComponentType.Assembly));
AkkaRegistration assemblyRegistration = new AkkaRegistration(assemblyConnection, getSelf());
assemblyRegResult = locationService.register(assemblyRegistration).get();</code></pre></dd>
</dl>
<h2><a href="#creating-actorref-for-registration" name="creating-actorref-for-registration" class="anchor"><span class="anchor-link"></span></a>Creating ActorRef for registration</h2>
<p>While creating <code>akkaRegistration</code> in above example, make sure the ActorSystem used for creating <code>actorRef</code>,  is created using <code>ActorSystemFactory</code> as follows :</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">implicit val system: ActorSystem = ActorSystemFactory.remote(&quot;csw-examples-locationServiceClient&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">ActorSystem actorSystem = ActorSystemFactory.remote(&quot;csw-examples-locationServiceClient&quot;);</code></pre></dd>
</dl>
<p>This is required to start a remote ActorSystem on the interface where csw-cluster is running. All the ActorRefs created using this ActorSystem will now be available for communication from other components that are part of csw-cluster.</p>
<h2><a href="#resolving-connections" name="resolving-connections" class="anchor"><span class="anchor-link"></span></a>Resolving Connections</h2>
<p><code>register</code> API takes a <code>Registration</code> parameter and returns a handle to registration result. The success of <code>register</code> API can be validated by checking the <code>Location</code> instance pointed by registration result.</p>
<p>The <code>list</code> API returns a list of alive connections with LocationService.</p>
<p>A connection of interest, can be checked if available using the <code>resolve</code> or <code>find</code> API. </p>
<p><code>resolve</code> will find the location for a connection from the local cache, if not found waits for the event to arrive within specified time limit. Returns None if both fail. </p>
<p><code>find</code> will return the location for a connection from the local cache and if not found then returns None. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// find connection to LocationServiceExampleComponent in location service
// [do this before starting LocationServiceExampleComponent.  this should return Future[None]]
private val exampleConnection = LocationServiceExampleComponent.connection

log.info(Map(&quot;@msg&quot; → &quot;Attempting to find connection&quot;, &quot;exampleConnection&quot; → exampleConnection.toString))
val findResultF = async {
  await(locationService.find(exampleConnection))
}
val findResult = Await.result(findResultF, timeout)

log.info(s&quot;Result of the find call: $findResult&quot;)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">// find connection to LocationServiceExampleComponent in location service
// [do this before starting LocationServiceExampleComponent.  this should return Future[None]]

jLogger.info(() -&gt; {
    HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;@msg&quot;, &quot;Attempting to find connection&quot;);
    map.put(&quot;exampleConnection&quot;, exampleConnection.toString());
    return map;
});

Optional&lt;Location&gt; findResult = locationService.find(exampleConnection).get();
if (findResult.isPresent()) {
    jLogger.info(() -&gt; &quot;Find result: &quot; + connectionInfo(findResult.get().connection()));
} else {
    jLogger.info(() -&gt; &quot;Result of the find call : None&quot;);
}</code></pre></dd>
</dl>
<p>The output for this find operation when the compoment being search for is not registered should be:</p>
<pre><code>Attempting to find connection AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly)) ...
Find result: None
</code></pre>
<p>An example of the resolve command is shown in the following: </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// resolve connection to LocationServiceExampleComponent
// [start LocationServiceExampleComponent after this command but before timeout]
log.info(s&quot;Attempting to resolve $exampleConnection with a wait of $waitForResolveLimit ...&quot;)

val resolveResultF = async {
  await(locationService.resolve(exampleConnection, waitForResolveLimit))
}
private val resolveResult = Await.result(resolveResultF, waitForResolveLimit + timeout)
resolveResult match {
  case Some(result) ⇒ log.info(s&quot;Resolve result: ${locationInfoToString(result)}&quot;)
  case None ⇒ log.info(s&quot;Timeout waiting for location $exampleConnection to resolve.&quot;)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">// resolve connection to LocationServiceExampleComponent
// [start LocationServiceExampleComponent after this command but before timeout]
FiniteDuration waitForResolveLimit = new FiniteDuration(30, TimeUnit.SECONDS);
jLogger.info(() -&gt; &quot;Attempting to resolve &quot; + exampleConnection + &quot; with a wait of &quot; + waitForResolveLimit + &quot;...&quot;);
Optional&lt;Location&gt; resolveResult = locationService.resolve(exampleConnection, waitForResolveLimit).get();
if (resolveResult.isPresent()) {
    jLogger.info(() -&gt; &quot;Resolve result: &quot; + connectionInfo(resolveResult.get().connection()));
} else {
    jLogger.info(() -&gt; &quot;Timeout waiting for location &quot; + exampleConnection + &quot; to resolve.&quot;);
}</code></pre></dd>
</dl>
<p>The output should be:</p>
<pre><code>Attempting to resolve AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly)) with a wait of 30 seconds ...
</code></pre>
<p>If you then start the LocationServiceExampleComponentApp, the following line will be outputted:</p>
<pre><code>Resolve result: LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType
</code></pre>
<p>If not, eventually the operation will timeout and the output read:</p>
<pre><code>Timeout waiting for location AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly)) to resolve.
</code></pre>
<h2><a href="#filtering" name="filtering" class="anchor"><span class="anchor-link"></span></a>Filtering</h2>
<p>The <code>list</code> API and its variants offer means to inquire about available connections with LocationService. The <strong>parameter-less</strong> <code>list</code> returns all available connections</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// list connections in location service
val listF = async {
  await(locationService.list)
}
private val connectionList = Await.result(listF, timeout)
log.info(&quot;All Registered Connections:&quot;)
connectionList.foreach(c =&gt; log.info(s&quot;--- ${locationInfoToString(c)}&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">// list connections in location service
List&lt;Location&gt; connectionList = locationService.list().get();
jLogger.info(() -&gt; &quot;All Registered Connections:&quot;);
for (Location loc: connectionList) {
    jLogger.info(() -&gt; &quot;--- &quot; + connectionInfo(loc.connection()));
}</code></pre></dd>
</dl>
<p>The output should be:</p>
<pre><code>All Registered Connections:
--- hcd1-hcd-akka, component type=HCD, connection type=AkkaType
--- assembly1-assembly-akka, component type=Assembly, connection type=AkkaType
--- redis-service-tcp, component type=Service, connection type=TcpType
--- configuration-service-http, component type=Service, connection type=HttpType
--- LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType
</code></pre>
<p>Other variants are filters using <code>ConnectionType</code>, <code>ComponentType</code>, and <code>hostname</code>.</p>
<p>Filtering by component type is shown below:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// filter connections based on component type
val filterListF = async {
  await(locationService.list(ComponentType.Assembly))
}
private val componentList = Await.result(filterListF, timeout)
log.info(&quot;Registered Assemblies:&quot;)
componentList.foreach(c =&gt; log.info(s&quot;--- ${locationInfoToString(c)}&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">// filter connections based on component type
List&lt;Location&gt; componentList = locationService.list(JComponentType.Assembly).get();
jLogger.info(() -&gt; &quot;Registered Assemblies:&quot;);
for (Location loc: componentList) {
    jLogger.info(() -&gt; &quot;--- &quot; + connectionInfo(loc.connection()));
}</code></pre></dd>
</dl>
<p>The output should be:</p>
<pre><code>Registered Assemblies:
--- assembly1-assembly-akka, component type=Assembly, connection type=AkkaType
--- LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType
</code></pre>
<p>Filtering by connection type is shown below:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// filter connections based on connection type
val akkaListF = async {
 await(locationService.list(ConnectionType.AkkaType))
}
private val akkaList = Await.result(akkaListF, timeout)
log.info(&quot;Registered Akka connections:&quot;)
akkaList.foreach(c =&gt; log.info(s&quot;--- ${locationInfoToString(c)}&quot;))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">// filter connections based on connection type
List&lt;Location&gt; akkaList = locationService.list(JConnectionType.AkkaType).get();
jLogger.info(() -&gt; &quot;Registered Akka connections:&quot;);
for (Location loc : akkaList) {
    jLogger.info(() -&gt; &quot;--- &quot; + connectionInfo(loc.connection()));
}</code></pre></dd>
</dl>
<p>The output should be:</p>
<pre><code>Registered Akka connections:
--- hcd1-hcd-akka, component type=HCD, connection type=AkkaType
--- assembly1-assembly-akka, component type=Assembly, connection type=AkkaType
--- LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType
</code></pre>
<h2><a href="#tracking-and-subscribing" name="tracking-and-subscribing" class="anchor"><span class="anchor-link"></span></a>Tracking and Subscribing</h2>
<p>The lifecycle of a connection of interest can be followed using either the <code>track</code> API or the <code>subscribe</code> API. </p>
<p>These methods take a <code>Connection</code> instance as a parameter. <strong>A <code>Connection</code> need not already be registered with LocationService.</strong> It&rsquo;s alright to track connections that will be registered in future. </p>
<p>A <code>track</code> API returns two values:<br/>* A <strong>source</strong> that will emit stream of <code>TrackingEvents</code> for the connection.<br/>* A <strong>Killswitch</strong> to turn off the stream when no longer needed. </p>
<p>Akka stream API provides many building blocks to process this stream such as Flow and Sink. In example, Sink is used to print each incoming <code>TrackingEvent</code>.</p>
<p>Consumer can shut down the stream using Killswitch.</p>
<p>The <code>subscribe</code> API allows the caller to track a connetion and receive the TrackingEvent notifications via a callback. </p>
<p>The API expects following parameters :<br/>* An existing connection or a connection to be registered in future.<br/>* A callback that implements <code>Consumer</code>, receives TrackEvent as parameter. </p>
<p>In return it gives a Killswitch that can be used to turn off the event notifications and release the supplied callback, if required.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// the following two methods are examples of two ways to track a connection.
// both are implemented but only one is really needed.


// Method1: track connection to LocationServiceExampleComponent
// Calls track method for example connection and forwards location messages to this actor
//
log.info(s&quot;Starting to track $exampleConnection&quot;)
locationService.track(exampleConnection).to(Sink.actorRef(self, AllDone)).run()
//track returns a Killswitch, that can be used to turn off notifications arbitarily
//in this case track a connection for 5 seconds, after that schedule switching off the stream
val killswitch = locationService.track(httpConnection).toMat(Sink.foreach(println))(Keep.left).run()
context.system.scheduler.scheduleOnce(5.seconds) {
  killswitch.shutdown()
}

// Method2: subscribe to LocationServiceExampleComponent events
log.info(s&quot;Starting a subscription to $exampleConnection&quot;)
locationService.subscribe(exampleConnection, trackingEvent =&gt; {
  // the following println is to distinguish subscription events from tracking events
  log.info(&quot;subscription event&quot;)
  self ! trackingEvent
})</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">// the following two methods are examples of two ways to track a connection.
// both are implemented but only one is really needed.

// track connection to LocationServiceExampleComponent
// Calls track method for example connection and forwards location messages to this actor
Materializer mat = ActorMaterializer.create(getContext());
jLogger.info(() -&gt; &quot;Starting to track &quot; + exampleConnection);
locationService.track(exampleConnection).toMat(Sink.actorRef(getSelf(), AllDone.class), Keep.both()).run(mat);

//track returns a Killswitch, that can be used to turn off notifications arbitarily
//in this case track a connection for 5 seconds, after that schedule switching off the stream
Pair pair = (Pair)locationService.track(exampleConnection).toMat(Sink.ignore(), Keep.both()).run(mat);
context().system().scheduler().scheduleOnce(Duration.create(5, TimeUnit.SECONDS), new Runnable() {
    @Override
    public void run() {
        ((KillSwitch)pair.first()).shutdown();
    }
}, context().system().dispatcher());

// subscribe to LocationServiceExampleComponent events
jLogger.info(() -&gt; &quot;Starting a subscription to &quot; + exampleConnection);
locationService.subscribe(exampleConnection, trackingEvent -&gt; {
    jLogger.info(() -&gt; &quot;subscription event&quot;);
    getSelf().tell(trackingEvent, ActorRef.noSender());
});</code></pre></dd>
</dl>
<p>The output should be:</p>
<pre><code>Starting to track AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))
Starting a subscription to AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))
subscription event
Location updated LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType
Location updated LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType
</code></pre>
<p>If you now stop the LocationServiceExampleComponentApp, it would print to the screen:</p>
<pre><code>subscription event
Location removed AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))
Location removed AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))
</code></pre>
<p>If you start the LocationServiceExampleComponentApp again, the output should be:</p>
<pre><code>Location updated LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType
subscription event
Location updated LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType
</code></pre>
<p>Note: the line after the words &ldquo;subscription event&rdquo; in our example is generated by the subscription, and the other line is from tracking. These two events could come in any order.</p>
<h2><a href="#unregistering" name="unregistering" class="anchor"><span class="anchor-link"></span></a>Unregistering</h2>
<p>One of the ways to <code>unregister</code> a service is by calling unregister on registration result received from <code>register</code> API.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val unregisterF = async {
  httpRegResult.unregister()
  hcdRegResult.unregister()
  assemblyRegResult.unregister()
}
Await.result(unregisterF, 5.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">httpRegResult.unregister();
hcdRegResult.unregister();
assemblyRegResult.unregister();</code></pre></dd>
</dl>
<h2><a href="#source-code-for-examples" name="source-code-for-examples" class="anchor"><span class="anchor-link"></span></a>Source code for examples</h2>
<ul>
  <li><a href="https://github.com/tmtsoftware/csw-prod/tree/master/examples/src/main/scala/csw/services/location/LocationServiceExampleClientApp.scala">Scala Example</a></li>
  <li><a href="https://github.com/tmtsoftware/csw-prod/tree/master/examples/src/main/java/csw/services/location/JLocationServiceExampleClient.java">JavaBlocking Example</a></li>
</ul>
<div class="source-github">
The source code for this page can be found <a href="https://github.com/tmtsoftware/csw-prod/tree/master/docs/src/main/services/location.md">here</a>.
</div>

<div class="nav-next">
<p><strong>Next:</strong> <a href="../services/config.html">Configuration service</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="../services/location.html#location-service" class="header">Location service</a>
  <ul>
    <li><a href="../services/location.html#artifacts" class="header">Artifacts</a></li>
    <li><a href="../services/location.html#create-locationservice" class="header">Create LocationService</a></li>
    <li><a href="../services/location.html#shutdown-locationservice" class="header">Shutdown LocationService</a></li>
    <li><a href="../services/location.html#creating-components-connections-and-registrations" class="header">Creating components, connections and registrations</a></li>
    <li><a href="../services/location.html#creating-actorref-for-registration" class="header">Creating ActorRef for registration</a></li>
    <li><a href="../services/location.html#resolving-connections" class="header">Resolving Connections</a></li>
    <li><a href="../services/location.html#filtering" class="header">Filtering</a></li>
    <li><a href="../services/location.html#tracking-and-subscribing" class="header">Tracking and Subscribing</a></li>
    <li><a href="../services/location.html#unregistering" class="header">Unregistering</a></li>
    <li><a href="../services/location.html#source-code-for-examples" class="header">Source code for examples</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2017</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>

</html>
