<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="docs">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="docs">
<link rel="shortcut icon" href="../assets/tmt_favicon.ico">
<title>Creating a Component Â· TMT Common Software (CSW)</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="TMT Common Software (CSW)" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
TMT Common Software (CSW)
</span>
<span class="md-header-nav__topic">
Creating a Component
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/tmtsoftware/csw"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
tmtsoftware/csw
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="TMT Common Software (CSW)" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="TMT Common Software (CSW)">
TMT Common Software (CSW)
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/tmtsoftware/csw"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
tmtsoftware/csw
</div>
</a>

</div>
<ul>
  <li><a href="../commons/getting-started.html" class="page">Getting Started</a></li>
  <li><a href="../commons/create-component.html" class="active page">Creating a Component</a></li>
  <li><a href="../commons/multiple-components.html" class="page">Multiple Components</a></li>
  <li><a href="../commons/using-alarms.html" class="page">Using Alarms</a></li>
  <li><a href="../commons/unit-tests.html" class="page">Adding Unit Tests</a></li>
  <li><a href="../commons/params.html" class="page">Params</a>
  <ul>
    <li><a href="../params/keys-parameters.html" class="page">Keys and Parameters</a></li>
    <li><a href="../params/units.html" class="page">Units</a></li>
    <li><a href="../params/subsystem.html" class="page">Subsystem</a></li>
    <li><a href="../params/commands.html" class="page">Commands</a></li>
    <li><a href="../params/events.html" class="page">Events</a></li>
    <li><a href="../params/states.html" class="page">State Variables</a></li>
    <li><a href="../params/result.html" class="page">Result</a></li>
  </ul></li>
  <li><a href="../commons/framework.html" class="page">Framework for creating components (HCD, Assembly, Container)</a>
  <ul>
    <li><a href="../framework/describing-components.html" class="page">ComponentInfo</a></li>
    <li><a href="../framework/creating-components.html" class="page">Creating an Assembly or Hcd Component</a></li>
    <li><a href="../framework/handling-lifecycle.html" class="page">Component Handlers</a></li>
    <li><a href="../framework/managing-command-state.html" class="page">Managing Command State</a></li>
    <li><a href="../framework/tracking-connections.html" class="page">Tracking Connections</a></li>
    <li><a href="../framework/publishing-state.html" class="page">Publishing State</a></li>
    <li><a href="../framework/handling-exceptions.html" class="page">Handling Exceptions</a></li>
    <li><a href="../framework/deploying-components.html" class="page">Deploying Components</a></li>
  </ul></li>
  <li><a href="../commons/command.html" class="page">Communication using Commands</a></li>
  <li><a href="../commons/logging_aggregator.html" class="page">Logging Aggregator</a></li>
  <li><a href="../commons/services.html" class="page">Services</a>
  <ul>
    <li><a href="../services/location.html" class="page">Location Service</a></li>
    <li><a href="../services/config.html" class="page">Configuration Service</a></li>
    <li><a href="../services/logging.html" class="page">Logging Service</a></li>
    <li><a href="../services/event.html" class="page">Event Service</a></li>
    <li><a href="../services/alarm.html" class="page">Alarm Service</a></li>
    <li><a href="../services/time.html" class="page">Time Service</a></li>
    <li><a href="../services/database.html" class="page">Database Service</a></li>
    <li><a href="../services/aas.html" class="page">Authentication and Authorization Service (AAS)</a></li>
    <li><a href="../services/sequencer-command-service.html" class="page">Sequencer Command Service</a></li>
  </ul></li>
  <li><a href="../commons/apps.html" class="page">Applications</a>
  <ul>
    <li><a href="../apps/cswlocationserver.html" class="page">csw-location-server</a></li>
    <li><a href="../apps/cswlocationagent.html" class="page">csw-location-agent</a></li>
    <li><a href="../apps/cswonfigserverapp.html" class="page">csw-config-server</a></li>
    <li><a href="../apps/cswconfigcli.html" class="page">csw-config-cli</a></li>
    <li><a href="../apps/csweventcli.html" class="page">csw-event-cli</a></li>
    <li><a href="../apps/cswalarmcli.html" class="page">csw-alarm-cli</a></li>
    <li><a href="../apps/hostconfig.html" class="page">csw-host-config</a></li>
  </ul></li>
  <li><a href="../commons/deployment.html" class="page">Deployment</a>
  <ul>
    <li><a href="../deployment/env-vars.html" class="page">Environment variables</a></li>
  </ul></li>
  <li><a href="../commons/testing.html" class="page">Testing</a></li>
  <li><a href="../commons/sbt-tasks.html" class="page">sbt Tasks</a></li>
  <li><a href="../commons/manuals.html" class="page">Manuals</a></li>
  <li><a href="../migration_guide/migration-guides.html" class="page">Migration Guides</a>
  <ul>
    <li><a href="../migration_guide/migration_guide_1.0.0_to_2.0.0/migration-guide-1.0.0-to-2.0.0.html" class="page">Migration Guide from 1.0.0 to 2.0.0</a></li>
  </ul></li>
  <li><a href="../commons/contract.html" class="page">CSW Service contract</a></li>
  <li><a href="../technical/technical.html" class="page">Technical Design Documents</a>
  <ul>
    <li><a href="../technical/framework/framework.html" class="page">Framework</a></li>
    <li><a href="../technical/command/command.html" class="page">Command</a></li>
    <li><a href="../technical/params/params.html" class="page">Params</a></li>
    <li><a href="../technical/location/location.html" class="page">Location Service</a></li>
    <li><a href="../technical/configuration/configuration.html" class="page">Configuration Service</a></li>
    <li><a href="../technical/logging/logging.html" class="page">Logging Service</a></li>
    <li><a href="../technical/event/event.html" class="page">Event Service</a></li>
    <li><a href="../technical/alarm/alarm.html" class="page">Alarm Service</a></li>
    <li><a href="../technical/time/time.html" class="page">Time Service</a></li>
    <li><a href="../technical/database/database.html" class="page">Database Service</a></li>
    <li><a href="../technical/aas/aas.html" class="page">Authentication and Authorization Service</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../commons/create-component.html#creating-a-component" class="header">Creating a Component</a>
  <ul>
    <li><a href="../commons/create-component.html#" class="header"><em>Tutorial: Developing an HCD</em></a></li>
    <li><a href="../commons/create-component.html#anatomy-of-component" class="header">Anatomy of Component</a></li>
    <li><a href="../commons/create-component.html#supervisor" class="header">Supervisor</a></li>
    <li><a href="../commons/create-component.html#top-level-actor" class="header">Top Level Actor</a></li>
    <li><a href="../commons/create-component.html#handlers" class="header">Handlers</a></li>
    <li><a href="../commons/create-component.html#constructing-the-component" class="header">Constructing the Component</a></li>
    <li><a href="../commons/create-component.html#component-configuration-componentinfo-" class="header">Component Configuration (ComponentInfo)</a></li>
    <li><a href="../commons/create-component.html#lifecycle" class="header">Lifecycle</a></li>
    <li><a href="../commons/create-component.html#csw-services-injection" class="header">CSW Services Injection</a></li>
    <li><a href="../commons/create-component.html#logging" class="header">Logging</a></li>
    <li><a href="../commons/create-component.html#receiving-commands" class="header">Receiving Commands</a></li>
    <li><a href="../commons/create-component.html#validation" class="header">Validation</a></li>
    <li><a href="../commons/create-component.html#command-response" class="header">Command Response</a></li>
    <li><a href="../commons/create-component.html#events" class="header">Events</a></li>
    <li><a href="../commons/create-component.html#starting-csw-services" class="header">Starting CSW Services</a></li>
    <li><a href="../commons/create-component.html#building-and-running-component-in-standalone-mode" class="header">Building and Running component in standalone mode</a></li>
    <li><a href="../commons/create-component.html#enhanced-tutorial-versions" class="header">Enhanced Tutorial Versions</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.1.0*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../commons/create-component.html#creating-a-component" class="header">Creating a Component</a>
  <ul>
    <li><a href="../commons/create-component.html#" class="header"><em>Tutorial: Developing an HCD</em></a></li>
    <li><a href="../commons/create-component.html#anatomy-of-component" class="header">Anatomy of Component</a></li>
    <li><a href="../commons/create-component.html#supervisor" class="header">Supervisor</a></li>
    <li><a href="../commons/create-component.html#top-level-actor" class="header">Top Level Actor</a></li>
    <li><a href="../commons/create-component.html#handlers" class="header">Handlers</a></li>
    <li><a href="../commons/create-component.html#constructing-the-component" class="header">Constructing the Component</a></li>
    <li><a href="../commons/create-component.html#component-configuration-componentinfo-" class="header">Component Configuration (ComponentInfo)</a></li>
    <li><a href="../commons/create-component.html#lifecycle" class="header">Lifecycle</a></li>
    <li><a href="../commons/create-component.html#csw-services-injection" class="header">CSW Services Injection</a></li>
    <li><a href="../commons/create-component.html#logging" class="header">Logging</a></li>
    <li><a href="../commons/create-component.html#receiving-commands" class="header">Receiving Commands</a></li>
    <li><a href="../commons/create-component.html#validation" class="header">Validation</a></li>
    <li><a href="../commons/create-component.html#command-response" class="header">Command Response</a></li>
    <li><a href="../commons/create-component.html#events" class="header">Events</a></li>
    <li><a href="../commons/create-component.html#starting-csw-services" class="header">Starting CSW Services</a></li>
    <li><a href="../commons/create-component.html#building-and-running-component-in-standalone-mode" class="header">Building and Running component in standalone mode</a></li>
    <li><a href="../commons/create-component.html#enhanced-tutorial-versions" class="header">Enhanced Tutorial Versions</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#creating-a-component" name="creating-a-component" class="anchor"><span class="anchor-link"></span></a>Creating a Component</h1>
<p>This walk-through helps in creating a CSW component in Scala/Java. CSW components depend on the <code>csw-framework</code> package, which can be found <a href="framework.html">here</a>. This section discusses constructing an HCD, but the principles apply to an Assembly as well. We will be constructing the Assembly in the next section <a href="multiple-components.html">Working with Multiple Components</a>. </p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>This tutorial shows code written in Scala and Java, based on code generated by the giter8 templates with the default values.</p><div class="callout note "><div class="callout-title">Async handling in Scala and Java examples.</div>
<p>Most of CSW is written using asynchronous programming. Therefore, in the examples, you may find constructs that deal with Futures and other asynchronous code in various ways. The following constructs are commonly used throughout this manual:</p>
<ul>
  <li>
    <p><strong>Scala:</strong> The Scala async package is used extensively. <code>async</code> marks a block of asynchronous code and allows  to <code>await</code> the computation until the Future is complete. For more info, please refer to: <a href="https://github.com/scala/scala-async">https://github.com/scala/scala-async</a>.</p>
    <p>Sometimes, an example may use the <code>Await.result</code> construct. While this is often used in tests, it is a blocking call  and typically should not be used in production code.</p>
  </li>
  <li>
  <p><strong>Java non-blocking example:</strong> The code snippets use <code>CompletableFuture</code> and its <code>thenAsync</code>, <code>thenApply</code> methods. This style allows to compose multiple Futures and not block the calling thread until Futures are complete. </p></li>
  <li>
  <p><strong>Java blocking example:</strong> The code snippets use <code>CompletableFuture</code> using <code>get</code> blocking call. This style also blocks the calling thread until the Future is complete, and it should only be prudently used.</p></li>
</ul></div>
<h2><a href="#anatomy-of-component" name="anatomy-of-component" class="anchor"><span class="anchor-link"></span></a>Anatomy of Component</h2>
<p>A component consists of a Supervisor actor, a Top Level Actor (TLA) that provides <em>component handlers</em>, and one or more worker actors. The <code>csw-framework</code> provides the Supervisor actor, the Top Level Actor and an abstract class of handlers. Component developers are expected to implement these handlers, which collectively act as the gateway from the framework to the developer&rsquo;s component code. </p>
<h2><a href="#supervisor" name="supervisor" class="anchor"><span class="anchor-link"></span></a>Supervisor</h2>
<p>A Supervisor actor is the actor first started for any component. The main responsibilities that the Supervisor performs is as follows:</p>
<ul>
  <li>Creation of the TLA when the component starts up</li>
  <li>Implement and manage the component lifecycle for the TLA and for the component (see <a href="create-component.html#lifecycle">Lifecycle</a> below).</li>
  <li>Register the component with the Location Service.</li>
  <li>Provide an administrative interface to the component to the rest of the system. For instance, the Container can perform some administrative communication with the Supervisor such as restart or shutdown of the component.</li>
  <li>Allow components outside of the Supervisor and TLA to monitor the lifecycle state of the TLA. This is particularly useful for testing, when the test needs to know that the component is ready before performing its test actions.</li>
  <li>Supports the locking functionality for the component (see <a href="create-component.html#lock">Locking</a>)</li>
  <li>Receives external commands and passes them to the correct component handlers.</li>
</ul>
<p>The source code of the Supervisor actor can be found <a href="https://github.com/tmtsoftware/csw/blob/master/csw-framework/src/main/scala/csw/framework/internal/supervisor/SupervisorBehavior.scala">here</a></p>
<h2><a href="#top-level-actor" name="top-level-actor" class="anchor"><span class="anchor-link"></span></a>Top Level Actor</h2>
<p>While the Supervisor works as the external interface for the component and the manager of its lifecycle, the functional implementation of a component is implemented in a Top Level Actor (TLA), spawned by the Supervisor actor for each component. However, the developer is not expected to implement a TLA code entirely. Instead, the component-specific functionality of the TLA is added by implementing the <code>ComponentHandlers</code> abstract class, consisting of a set of methods, or <code>hooks</code>, called by the TLA during specific lifecycle and command events (see <a href="create-component.html#handlers">Handlers</a>). The <code>ComponentHandlers</code> implementation is specified during construction using a factory (see <a href="create-component.html#constructing-the-component">Constructing The Component</a>) </p>
<p>The source code of the Top Level Actor can be found <a href="https://github.com/tmtsoftware/csw/blob/master/csw-framework/src/main/scala/csw/framework/internal/component/ComponentBehavior.scala">here</a>.</p>
<h2><a href="#handlers" name="handlers" class="anchor"><span class="anchor-link"></span></a>Handlers</h2>
<p>The following hooks may be overridden in your ComponentHandlers implementation class:</p>
<ul>
  <li><code>initialize</code>: called when the component is starting up, prior to be put into the Running state.</li>
  <li><code>validateCommand</code>: called when the component receives a command to determine if the command is valid and can be executed. (see <a href="create-component.html#validation">Validation</a>)</li>
  <li><code>onSubmit</code>: called on Submit command if validateCommand returns <code>Accepted</code>.</li>
  <li><code>onOneway</code>: called on Oneway command if validateCommand returns <code>Accepted</code>.</li>
  <li><code>onGoOffline</code>: called when the component receives an external message from an administrative client to go offline.</li>
  <li><code>onGoOnline</code>: called when the component receives an external message from an administrative client to go online.</li>
  <li><code>onDiagnosticMode</code>: called when the component receives an external message from a client to enter a specified diagnostic behavior.</li>
  <li><code>onOperationsMode</code>: called when the component receives an external message from a client to exit any diagnostic behavior and return to normal, operations behavior.</li>
  <li><code>onLocationTrackingEvent</code>: called when a tracked dependency changes location state. (see <a href="multiple-components.html#tracking-dependencies">Tracking Dependencies</a>)</li>
  <li><code>onShutdown</code>: called when the component is shutting down.</li>
</ul>
<p>The source code of <code>ComponentHandlers</code> can be found <a href="https://github.com/tmtsoftware/csw/blob/master/csw-framework/src/main/scala/csw/framework/scaladsl/ComponentHandlers.scala">here</a>. </p>
<p>More details about handler significance and invocation can be found <a href="../framework/handling-lifecycle.html">here</a></p><div class="callout note "><div class="callout-title">Component Handlers in Java</div>
<p>If the component developer wishes to write the component handler implementation in Java, they need to implement the Java version of <code>ComponentHandlers</code> called <code>JComponentHandlers</code>. The source code of <code>JComponentHandlers</code> can be found <a href="https://github.com/tmtsoftware/csw/blob/master/csw-framework/src/main/scala/csw/framework/javadsl/JComponentHandlers.scala">here</a>. Any further reference to <code>ComponentHandlers</code> should be inferred as also applying to <code>JComponentHandlers</code>.</p></div>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>As seen in the <a href="getting-started.html">Getting Started</a> page, if you are using the giter8 template, component handler classes for both the HCD and Assembly are written for you, with implementations stubbed out. We will walk-through filling them in below.</p>
<h2><a href="#constructing-the-component" name="constructing-the-component" class="anchor"><span class="anchor-link"></span></a>Constructing the Component</h2>
<p>After writing the component handlers, a developer needs to wire it up with the framework. In order to do this, the developer needs to first implement a <code>ComponentBehaviorFactory</code>. This factory should be specified in a ComponentInfo configuration file for the component (see example below). The <code>csw-framework</code> picks up the full class path of the <code>ComponentBehaviorFactory</code> from the file and the Supervisor spawns the component handlers using this factory in the process of booting the component. The factory is instantiated using Java reflection.</p>
<p>Additional sample code to implement the <code>ComponentBehaviorFactory</code> can be found <a href="../framework/creating-components.html">here</a> </p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>As seen in the <a href="getting-started.html">Getting Started</a> page, if using the template, this factory class will be implemented for you.</p>
<h2><a href="#component-configuration-componentinfo-" name="component-configuration-componentinfo-" class="anchor"><span class="anchor-link"></span></a>Component Configuration (ComponentInfo)</h2>
<p>The component configuration, called the ComponentInfo file, contains details needed to create a component. This configuration defines a few parameters needed for a particular component. The template creates one for our sample HCD as follows:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/resources/SampleHcdStandalone.conf" target="_blank" title="Go to snippet source"></a><code class="language-conf">prefix = &quot;nfiraos.SampleHcd&quot;
componentType = hcd
behaviorFactoryClassName = &quot;org.tmt.nfiraos.samplehcd.SampleHcdBehaviorFactory&quot;
locationServiceUsage = RegisterOnly</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/resources/JSampleHcdStandalone.conf" target="_blank" title="Go to snippet source"></a><code class="language-conf">prefix = &quot;nfiraos.JSampleHcd&quot;
componentType = hcd
behaviorFactoryClassName = &quot;org.tmt.nfiraos.samplehcd.JSampleHcdBehaviorFactory&quot;
locationServiceUsage = RegisterOnly</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">What is a behaviorFactoryClassName?</div>
<p><code>behaviorFactoryClassName</code> refers to class name of the a concrete implementation of <code>ComponentBehaviorFactory</code>, which is <code>SampleHcdBehaviorFactory</code> for Scala in above example, <code>JSampleHcdBehaviorFactory</code> for Java.</p></div>
<p>The <code>prefix</code> and <code>componentType</code> are used to create the <code>ComponentId</code> identifier, which must be unique within the control system and the Location Service. The <code>prefix</code> must begin with a valid TMT subsystem, which establishes a scope for the component name. The list of valid subsystems is <a href="https://github.com/tmtsoftware/csw/blob/master/csw-prefix/shared/src/main/scala/csw/prefix/models/Subsystem.scala">here</a>.</p>
<p>The <code>locationServiceUsage</code> is used by the Supervisor actor to decide whether to only register a component with the Location Service or to register and track other components. It is also possible to choose not register the component with the Location Service.</p>
<p>The ComponentInfo file is parsed to a <code>ComponentInfo</code> object and injected in the Supervisor actor. It is then injected in <code>ComponentHandlers</code> while spawning a component and the contents is available for the developer to access.</p><div class="callout note "><div class="callout-title">Using Prefix</div>
<p><code>ComponentInfo</code> includes the <code>Prefix</code> for the component. Developers should try to use this prefix value rather than defining a new one to reduce errors. </p></div>
<p>The ComponentInfo file can also contain a list of components and services it wishes to track as dependencies. See <a href="multiple-components.html#tracking-dependencies">Tracking Dependencies</a>.</p>
<p>More details about <code>ComponentInfo</code> can be found <a href="../framework/describing-components.html">here</a>.</p>
<p>An additional sample configuration file can be found <a href="https://github.com/tmtsoftware/csw/blob/master/csw-benchmark/src/main/resources/container.conf">here</a>.</p>
<h2><a href="#lifecycle" name="lifecycle" class="anchor"><span class="anchor-link"></span></a>Lifecycle</h2>
<p>The Supervisor of a component manages its lifecycle state, which can be one of the following:</p>
<ul>
  <li>Idle</li>
  <li>Running</li>
  <li>RunningOffline</li>
  <li>Restart</li>
  <li>Shutdown</li>
  <li>Lock</li>
</ul>
<p>The state the component is in dictates the actions it can take when it receives a message or command, and whether those actions are carried out.</p>
<h3><a href="#idle" name="idle" class="anchor"><span class="anchor-link"></span></a>Idle</h3>
<p>The component initializes in the idle state. The Top Level Actor calls the <code>initialize</code> hook of <code>ComponentHandlers</code> as the first thing on boot-up. Component developers write their initialization logic in this hook. The logic can also do things like accessing the Configuration Service to fetch information such as hardware configurations to set the hardware to default positions.</p>
<p>After initialization, if the component would have configured <code>RegisterAndTrack</code> for <code>locationServiceUsage</code>, then the Top Level Actor will start tracking the <code>connections</code> configured for that component. This use case is mostly applicable for Sequencers and Assemblies. HCDs should have <code>RegisterOnly</code> configured for <code>locationServiceUsage</code> in most all cases.</p>
<p>If <code>initialize</code> is successful, the Supervisor will register the component with the Location Service. Registering with the Location Service will notify other components tracking this component with a <code>LocationUpdated</code> event containing a <code>Location</code> with a reference to the Supervisor of the component.</p>
<p>After successful registration, the component will transition to the <code>Running</code> state. </p>
<h3><a href="#running" name="running" class="anchor"><span class="anchor-link"></span></a>Running</h3>
<p>When the Supervisor actor receives <code>Initialized</code> message from the Top Level Actor after successful initialization, it registers itself with the Location Service and transitions the component to the <code>Running</code> state. Running state signifies that the component is accessible via the Location Service, which allows other entities to communicate with it by sending commands via messages. Any commands received by the Supervisor actor will be forwarded to the Top Level Actor for processing once the component is in the <code>Running</code> state.</p><div class="callout note "><div class="callout-title">What does Running mean?</div>
<p>A component <strong>should be ready</strong> for operation after successfully leaving the <code>initialize</code> handler and entering <code>Running</code>. A component should ready to process <strong>any</strong> command after initialization and must not require specific commands to be issued by users in order to become ready.</p></div>
<h3><a href="#runningoffline" name="runningoffline" class="anchor"><span class="anchor-link"></span></a>RunningOffline</h3>
<p>When the Supervisor actor receives a <code>GoOffline</code> message, it transitions the component to the <code>RunningOffline</code> state and forwards it to the Top Level Actor. The Top Level Actor then calls the <code>onGoOffline</code> hook of <code>ComponentHandlers</code>.</p>
<p>If a <code>GoOnline</code> message is received by the Supervisor actor, it transitions the component back to the <code>Running</code> state and forwards it to the Top Level Actor. The Top Level Actor then calls the <code>onGoOnline</code> hook of <code>ComponentHandlers</code>.</p><div class="callout note "><div class="callout-title">Handling RunningOffline</div>
<p>In the <code>RunningOffline</code> state, if any command is received, it is forwarded to the underlying component hook through the Top Level Actor. It is then the responsibility of the component developer to check the <code>isOnline</code> flag provided by <code>csw-framework</code> and process the command according to whether the command is appropriate for the command when offline. </p></div>
<h3><a href="#restart" name="restart" class="anchor"><span class="anchor-link"></span></a>Restart</h3>
<p>When the Supervisor actor receives a <code>Restart</code> message, it will transition the component to the <code>Restart</code> state. Then, it will unregister itself from the Location Service so that other components tracking this component will be notified and no commands are received while restart is in progress.</p>
<p>Then, the Top Level Actor is stopped and the <code>postStop</code> hook of the Top Level Actor will call the <code>onShutdown</code> hook of <code>ComponentHandlers</code>. Component developers are expected to write any cleanup of resources or other logic that should be executed for the graceful shutdown of the component. </p>
<p>After successful shutdown of component, the Supervisor actor will re-create the Top Level Actor again from scratch. This will cause the <code>initialize</code> hook of <code>ComponentHandlers</code> to be called again. After successful initialization of the component, the Supervisor actor will register itself with the Location Service once more.</p>
<h3><a href="#shutdown" name="shutdown" class="anchor"><span class="anchor-link"></span></a>Shutdown</h3>
<p>When the Supervisor actor receives a <code>Shutdown</code> message, it transitions the component to the <code>Shutdown</code> state. Any commands received while a shutdown is in progress will be ignored. Then, it will stop the Top Level Actor. The <code>postStop</code> hook of the Top Level Actor will call the <code>onShutdown</code> hook of <code>ComponentHandlers</code>. Component developers are expected to write any cleanup of resources or other logic that should be executed for the graceful shutdown of component. The component, including the Supervisor, exits after <code>onShutdown</code> completes. </p>
<h3><a href="#lock" name="lock" class="anchor"><span class="anchor-link"></span></a>Lock</h3>
<p>When the Supervisor actor receives a <code>Lock</code> message, it transitions the component to the <code>Lock</code> state. When locked, the Supervisor will only accept commands received from the component that originally locked the component and ignore commands from all others.</p>
<p>In the <code>Lock</code> state, messages like <code>Shutdown</code> and <code>Restart</code> will also be ignored. A component must first be unlocked to accept these commands.</p>
<p><code>Lock</code> messages are constructed with a duration value specified. When this duration expires, the component will automatically be unlocked. In order to retain the Lock on the component, sender of the orginal Lock must resend the <code>Lock</code> message.</p>
<p>There are two ways component can be unlocked:</p>
<ol>
  <li>Sending <code>Unlock</code> message (Note: This message should be sent by the same component that locked the component.)</li>
  <li>Sending <code>Unlock</code> message with an administrative Prefix.</li>
</ol>
<h2><a href="#csw-services-injection" name="csw-services-injection" class="anchor"><span class="anchor-link"></span></a>CSW Services Injection</h2>
<p>Common Software provides a set of CSW Services provided through the TLA. They are injected into the <code>ComponentHandlers</code> class in the constructor in a <code>CswContext</code> object. This object provides the following services through their respective APIs:</p>
<ul>
  <li>Location Service</li>
  <li>Event Service</li>
  <li>Alarm Service (Client API)</li>
  <li>Time Service (Scheduler)</li>
  <li>Configuration Service (Client API)</li>
  <li>Logging Service (Logger Factory)</li>
</ul>
<p>And the following information and support utilities:</p>
<ul>
  <li>Component Configuration (ComponentInfo)</li>
  <li>Command Service Command Response Manager</li>
  <li>Current State Publisher Actor (intended for HCDs)</li>
</ul>
<h2><a href="#logging" name="logging" class="anchor"><span class="anchor-link"></span></a>Logging</h2>
<p><code>csw-framework</code> provides a <code>LoggerFactory</code> in the <code>CswContext</code> injected in the constructor of <code>ComponentHandlers</code>. The <code>LoggerFactory</code> will have the component&rsquo;s Prefix predefined so long messages have a clear source. The component developer is expected to and must use this factory to log messages that work with the centralized logging facility.</p>
<p>Logging works much like other popular loggers such as <em>log4j</em>. However, with the development of log management tools such as <em>logstash</em>, the emphasis on log message formatting has been to write <em>structured logging</em> messages in JSON format, so that they can easily be ingested, stored, and searched. Plain text writing to stdout is also supported.<br/>More details on how to use logging can be found <a href="../services/logging.html#log-statements">here</a>. </p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>Let&rsquo;s use logging to flesh out some of our command handlers. The template will instantiate a logger for you to use by constructing one from the <code>LoggerFactory</code> from in the <code>CswContext</code> passed in the constructor, instantiated as a <code>log</code> object.</p>
<p>Add some simple log messages in the <code>initialize</code> and <code>onShutdown</code> hooks, and to the <code>onLocationTrackingEvent</code> hook as well, although we won&rsquo;t be using it for this HCD:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/nfiraos/samplehcd/SampleHcdHandlers.scala#L56-L70" target="_blank" title="Go to snippet source"></a><code class="language-scala">var maybePublishingGenerator: Option[Cancellable] = None
override def initialize(): Future[Unit] = {
  log.info(&quot;In HCD initialize&quot;)
  maybePublishingGenerator = Some(publishCounter())
  Future.unit
}

override def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = {
  log.debug(s&quot;TrackingEvent received: ${trackingEvent.connection.name}&quot;)
}

override def onShutdown(): Future[Unit] = {
  log.info(&quot;HCD is shutting down&quot;)
  Future.unit
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/nfiraos/samplehcd/JSampleHcdHandlers.java#L87-L105" target="_blank" title="Go to snippet source"></a><code class="language-java">private Optional&lt;Cancellable&gt; maybePublishingGenerator = Optional.empty();

@Override
public CompletableFuture&lt;Void&gt; jInitialize() {
    return CompletableFuture.runAsync(() -&gt; {
        log.info(&quot;In HCD initialize&quot;);
        maybePublishingGenerator = Optional.of(publishCounter());
    });
}

@Override
public void onLocationTrackingEvent(TrackingEvent trackingEvent) {
    log.debug(() -&gt; &quot;TrackingEvent received: &quot; + trackingEvent.connection().name());
}

@Override
public CompletableFuture&lt;Void&gt; jOnShutdown() {
    return CompletableFuture.runAsync(() -&gt; log.info(&quot;HCD is shutting down&quot;));
}</code></pre></dd>
</dl>
<p>In the example code, you&rsquo;ll notice we have added some functionality to start publishing events. We will cover the Event Service later. You can leave that code out for now.</p>
<p>Next we&rsquo;ll discuss handling commands.</p>
<h2><a href="#receiving-commands" name="receiving-commands" class="anchor"><span class="anchor-link"></span></a>Receiving Commands</h2>
<p>A command is something that carries some metadata and a set of parameters. A component sends <code>commands</code> to other components to execute actions. CSW defines three kinds of commands as follows:</p>
<ul>
  <li>Setup : Contains goal, command, or demand information to be used to  configure the target OMOA component.</li>
  <li>Observe: Contains goal or demand information to be used by a detector.  system. Properties and their value types will be standardized  by the ESW subsystem.</li>
  <li>Wait: Sequencer only. Instructs a sequencer to pause until told to continue.</li>
</ul>
<p>A Sequencer receives a Sequence, which is a list of the above commands that are executed sequentially.</p>
<p>More details about creating commands can be found <a href="../params/commands.html#setup-command">here</a>.</p>
<p>Whenever a command is sent to a component, it is sent using a Command Service method. There are two general ways to send a command:</p>
<ul>
  <li>submit: A command is sent using submit when a completion result is expected from the destination component. There are two options: <code>submit</code> and <code>submitAndWait</code>.</li>
  <li>oneway: A command is sent using oneway when the completion of command is not expected from the destination component.</li>
</ul>
<h2><a href="#validation" name="validation" class="anchor"><span class="anchor-link"></span></a>Validation</h2>
<p>When any command is received by a component using <code>submit</code> or <code>oneway</code>, the Top Level Actor will first call the <code>validateCommand</code> hook of <code>ComponentHandlers</code>. Component developers are expected to perform appropriate validation of a command to determine if it is valid to execute the requested actions and then return a <code>ValidateCommandResponse</code>. The <code>ValidateCommandResponse</code> returned from this handler will be returned to the sender directly by <code>csw-framework</code> if the command fails validation.</p>
<p>The component developer should return either an <code>Accepted</code> response or an or <code>Invalid</code> response specifying whether the command is valid to be executed or not. CSW defines a set of <code>CommandIssues</code> for use in validation <a href="https://github.com/tmtsoftware/csw/blob/master/csw-params/shared/src/main/scala/csw/params/commands/CommandIssue.scala">here</a> that should be used within <code>Invalid</code> responses.</p>
<p>If the handler is being called as part of a <code>submit</code> or <code>oneway</code> call, the command will automatically be passed on to the <code>onSubmit</code> or <code>onOneway</code> handlers (see <a href="create-component.html#command-response">Command Response</a>) only if the validation handler returns a <code>ValidationCommandResponse</code> of <code>Accepted</code>. Otherwise, the <code>Invalid</code> response is returned to the caller immediately.</p>
<p>Different types of command responses and their significance can be found <a href="command.html#command-based-communication-between-components">here</a>.</p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>Let&rsquo;s add some command validation to our HCD. For our sample HCD, we will only handle one command, <code>sleep</code>, in which we will cause the HCD to sleep for the time specified in a parameter of the command. This will simulate a long-running command.</p>
<p>Add some code to ensure the command we receive is the <code>sleep</code> command, and return an <code>Invalid</code> response if not. You could imagine much more checking could be added, such as checking the types and values of the parameters of our <code>sleep</code> command, but we will keep it simple for our demonstration.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/nfiraos/samplehcd/SampleHcdHandlers.scala#L94-L100" target="_blank" title="Go to snippet source"></a><code class="language-scala">override def validateCommand(runId: Id, controlCommand: ControlCommand): ValidateCommandResponse = {
  log.info(s&quot;Validating command: ${controlCommand.commandName.name}&quot;)
  controlCommand.commandName.name match {
    case &quot;sleep&quot; =&gt; Accepted(runId)
    case x       =&gt; Invalid(runId, CommandIssue.UnsupportedCommandIssue(s&quot;Command $x. not supported.&quot;))
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/nfiraos/samplehcd/JSampleHcdHandlers.java#L129-L137" target="_blank" title="Go to snippet source"></a><code class="language-java">@Override
public CommandResponse.ValidateCommandResponse validateCommand(Id runId, ControlCommand controlCommand) {
    String commandName = controlCommand.commandName().name();
    log.info(() -&gt; &quot;Validating command: &quot; + commandName);
    if (commandName.equals(&quot;sleep&quot;)) {
        return new CommandResponse.Accepted(runId);
    }
    return new CommandResponse.Invalid(runId, new CommandIssue.UnsupportedCommandIssue(&quot;Command &quot; + commandName + &quot;. not supported.&quot;));
}</code></pre></dd>
</dl>
<h2><a href="#command-response" name="command-response" class="anchor"><span class="anchor-link"></span></a>Command Response</h2>
<p>The response returned from <code>validateCommand</code> handler of <code>ComponentHandlers</code> will be received by the Supervisor. If the response returned was <code>Accepted</code>, then it either calls the <code>onSubmit</code> hook or the <code>onOneway</code> hook of <code>ComponentHandlers</code> depending on the whether submit, submitAndWait, or oneway was used to send the command.</p>
<p>If sent with <code>submit</code> or <code>submitAndWait</code> and the validation response is <code>Accepted</code>, the framework calls the <code>onSubmit</code> hook of <code>ComponentHandlers</code>. The return value of <code>onSubmit</code> is then returned to the sender, which can be a <code>Completed</code> for commands that return quickly, or <code>Started</code> for long running commands. If the response from validation was <code>Invalid</code>, this is returned to the sender of the command without calling the <code>onSubmit</code> or <code>onOneway</code> handler.</p>
<p>If <code>onSubmit</code> returns <code>Started</code>, the component&rsquo;s <code>CommandResponseManager</code> keeps track of the status of long-running submit commands. The sender of a <code>Started</code> command (and any component, really) can query a <code>Started</code> command&rsquo;s status or wait for the final response using <code>queryFinal</code> of the <code>CommandService</code> API.</p>
<p>If a command is sent using <code>oneway</code>, the validation handler if called first. The <code>onOneway</code> handler of <code>ComponentHandlers</code> is also called when the validation result is <code>Accepted</code>.<br/>The validation response is always sent back to the sender as the response for a <code>oneway</code> command. There is no final response from a <code>ownway</code> command and no way to wait for it using <code>query</code> or <code>queryFinal</code>.</p>
<p>The <code>CommandService</code> class provides convenient API methods for communicating with other components, and should be the primary means of sending commands to other components. This will be described in the next tutorial section, <a href="multiple-components.html#sending-commands">Sending Commands</a>.</p>
<p>When the <code>onSubmit</code> hook is called and <code>Started</code> is returned, it is the responsibility of the component developer to update the sender with the final status of the <code>Started</code> command when the actions complete using the <code>CommandResponseManager</code> API. An instance of <code>CommandResponseManager</code> is provided in the <code>CswContext</code> object in <code>ComponentHandlers</code> and should be injected in any worker actor or other actor/class created for the component that needs it. </p>
<p>More details on the methods available in <code>CommandResponseManager</code> can be found <a href="../framework/managing-command-state.html">here</a>.</p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>We will implement command handling in the <code>onSubmit</code> hook. Note that this hook actually receives a <code>ControlCommand</code> as an argument, which can be either a <code>Setup</code> or an <code>Observe</code>. We will use pattern matching to handle the command if it is a <code>Setup</code> and forward to an <code>onSetup</code> handling method. <code>Observe</code> commands will be ignored and returned with as Invalid. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/nfiraos/samplehcd/SampleHcdHandlers.scala#L104-L128" target="_blank" title="Go to snippet source"></a><code class="language-scala">override def onSubmit(runId: Id, controlCommand: ControlCommand): SubmitResponse = {
  log.info(s&quot;Handling command: ${controlCommand.commandName}&quot;)

  controlCommand match {
    case setupCommand: Setup =&gt; onSetup(runId, setupCommand)
    case observeCommand: Observe =&gt; // implement (or not)
      Error(runId, &quot;Observe not supported&quot;)
  }
}

def onSetup(runId: Id, setup: Setup): SubmitResponse = {
  val sleepTimeKey: Key[Long] = KeyType.LongKey.make(&quot;SleepTime&quot;)

  // get param from the Parameter Set in the Setup
  val sleepTimeParam: Parameter[Long] = setup(sleepTimeKey)

  // values of parameters are arrays. Get the first one (the only one in our case) using `head` method available as a convenience method on `Parameter`.
  val sleepTimeInMillis: Long = sleepTimeParam.head

  log.info(s&quot;command payload: ${sleepTimeParam.keyName} = $sleepTimeInMillis&quot;)

  workerActor ! Sleep(runId, sleepTimeInMillis)

  Started(runId)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/nfiraos/samplehcd/JSampleHcdHandlers.java#L142-L170" target="_blank" title="Go to snippet source"></a><code class="language-java">@Override
public CommandResponse.SubmitResponse onSubmit(Id runId, ControlCommand controlCommand) {
    log.info(() -&gt; &quot;Handling command: &quot; + controlCommand.commandName());

    if (controlCommand instanceof Setup) {
        onSetup(runId, (Setup) controlCommand);
        return new CommandResponse.Started(runId);
    } else if (controlCommand instanceof Observe) {
        // implement (or not)
    }
    return new CommandResponse.Error(runId, &quot;Observe command not supported&quot;);
}

private void onSetup(Id runId, Setup setup) {
    Key&lt;Long&gt; sleepTimeKey = JKeyType.LongKey().make(&quot;SleepTime&quot;);

    // get param from the Parameter Set in the Setup
    Optional&lt;Parameter&lt;Long&gt;&gt; sleepTimeParamOption = setup.jGet(sleepTimeKey);

    // values of parameters are arrays.  Get the first one (the only one in our case) using `head` method available as a convenience method on `Parameter`.
    if (sleepTimeParamOption.isPresent()) {
        Parameter&lt;Long&gt; sleepTimeParam = sleepTimeParamOption.orElseThrow();
        long sleepTimeInMillis = sleepTimeParam.head();

        log.info(() -&gt; &quot;command payload: &quot; + sleepTimeParam.keyName() + &quot; = &quot; + sleepTimeInMillis);

        workerActor.tell(new Sleep(runId, sleepTimeInMillis));
    }
}</code></pre></dd>
</dl>
<p>In our example, the <code>sleep</code> command has one parameter called <code>SleepTime</code>. We retrieve this parameter from the <code>Setup</code> by creating a <code>Key</code> to this parameter using the name and type, and then calling an <code>apply</code> method on the <code>Setup</code> (the <code>setup(sleepKey)</code> shorthand) which finds the matching <code>Parameter</code> in the <code>Setup</code>&rsquo;s <code>ParameterSet</code> (use the <code>Setup.jget()</code> method in Java). By doing this, the <code>Parameter</code> is returned with the proper typing, and so the values retrieved from the <code>Parameter</code> are typed as well. Note, all values are stored as an array, so we get our single value for <code>sleepTime</code> by using the <code>head</code> method available as a convenience method on <code>ParameterSet</code>.</p>
<p>At this point, to prevent our HCD from blocking and simulate a long-running command, we pass the sleep function off to a worker actor, which we will specify elsewhere in this class.</p><div class="callout note "><div class="callout-title">Use of an External Class</div>
<p>The worker actor can be defined in a separate class, but writing it as an internal class allows us to use the logging facility and <code>CommandResponseManager</code> without having to inject them into a new actor class. Additional versions of the tutorial code show a separate, enhanced worker actor class.</p></div>
<p>Note that our <code>onSetup</code> command handling logic returns a <code>Started</code> response. This indicates that the command is a long-running command and will be finished after some time, and that the final result will be posted to the <code>CommandResponseManager</code>. The <code>submitAndWait</code> command in the CommandService is implemented such that when it receives a <code>Started</code> response, it automatically issues a <code>queryFinal</code> to the commanded component to await the final completion response. When the command is updated using the <code>CommandResponseManager</code>, the Future returned by <code>submitAndWait</code> command is completed with this value. Note that in this code, there is a chance that there is no sleepTime parameter. Good validation code would ensure this so <code>onSetup</code> does not need to worry. Enhanced versions of the tutorial code show this.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/nfiraos/samplehcd/SampleHcdHandlers.scala#L33-L52" target="_blank" title="Go to snippet source"></a><code class="language-scala">sealed trait WorkerCommand
case class Sleep(runId: Id, timeInMillis: Long) extends WorkerCommand

private val workerActor =
  ctx.spawn(
    Behaviors.receiveMessage[WorkerCommand](msg =&gt; {
      msg match {
        case sleep: Sleep =&gt;
          log.trace(s&quot;WorkerActor received sleep command with time of ${sleep.timeInMillis} ms&quot;)
          // simulate long running command
          val when: UTCTime = UTCTime.after(FiniteDuration(sleep.timeInMillis, MILLISECONDS))
          timeServiceScheduler.scheduleOnce(when) {
            commandResponseManager.updateCommand(CommandResponse.Completed(sleep.runId))
          }
        case _ =&gt; log.error(&quot;Unsupported message type&quot;)
      }
      Behaviors.same
    }),
    &quot;WorkerActor&quot;
  )</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/nfiraos/samplehcd/JSampleHcdHandlers.java#L53-L83" target="_blank" title="Go to snippet source"></a><code class="language-java">private interface WorkerCommand {
}

private static final class Sleep implements WorkerCommand {
    private final Id runId;
    private final long timeInMillis;

    private Sleep(Id runId, long timeInMillis) {
        this.runId = runId;
        this.timeInMillis = timeInMillis;
    }
}

private ActorRef&lt;WorkerCommand&gt; createWorkerActor() {
    return actorContext.spawn(
            Behaviors.receiveMessage(msg -&gt; {
                if (msg instanceof Sleep) {
                    Sleep sleep = (Sleep) msg;
                    log.trace(() -&gt; &quot;WorkerActor received sleep command with time of &quot; + sleep.timeInMillis + &quot; ms&quot;);
                    UTCTime when = UTCTime.after(new FiniteDuration(sleep.timeInMillis, MILLISECONDS));
                    Runnable task = () -&gt; cswCtx.commandResponseManager().updateCommand(new CommandResponse.Completed(sleep.runId));
                    // simulate long running command that updates CRM when completed
                    cswCtx.timeServiceScheduler().scheduleOnce(when, task);
                } else {
                    log.error(&quot;Unsupported message type&quot;);
                }
                return Behaviors.same();
            }),
            &quot;WorkerActor&quot;
    );
}</code></pre></dd>
</dl>
<p>This worker actor takes the time passed in the message and sleeps that amount using the TimeService scheduling API. When the time is expired, the worker updates the <code>CommandResponseManager</code> that the command is <code>Completed</code>. </p>
<h2><a href="#events" name="events" class="anchor"><span class="anchor-link"></span></a>Events</h2>
<p>CSW <code>Events</code> have a similar structure to commands in that along with a name and a prefix (used to represent the source of the event), they include data represented in the <code>Event</code> in a set of parameters. More details about events can be found <a href="../params/events.html">here</a>.</p>
<p>Access to the Event Service is in the <code>CswContext</code> object passed in to the handlers class in the constructor. The Event Service provides a factory method to create a &ldquo;default&rdquo; publisher and subscriber, which can be accessed in various parts of your code to reuse a single connection to the service. In most cases, reusing this connection will provide the performance needed.<br/>But if you prefer to create new connections, custom publishers and subscribers can be constructed. See the manual on the <a href="../services/event.html">Event Service</a> for more information.</p>
<p>Publishers have an API that allows the publishing of a single event, a stream of events, or periodic events created by an <code>EventGenerator</code>, which is simply a function that returns an <code>Event</code>. </p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>Let&rsquo;s add a publisher to our component. We will use the default publisher that will periodically publish events generated by an <code>EventGenerator</code>. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/nfiraos/samplehcd/SampleHcdHandlers.scala#L74-L90" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.concurrent.duration._
private def publishCounter(): Cancellable = {
  var counter = 0
  def incrementCounterEvent() = Option {
    counter += 1
    val param: Parameter[Int] = KeyType.IntKey.make(&quot;counter&quot;).set(counter)
    SystemEvent(componentInfo.prefix, EventName(&quot;HcdCounter&quot;)).add(param)
  }

  log.info(&quot;Starting publish stream.&quot;)
  eventService.defaultPublisher.publish(incrementCounterEvent(), 2.second, err =&gt; log.error(err.getMessage, ex = err))
}

private def stopPublishingGenerator(): Unit = {
  log.info(&quot;Stopping publish stream&quot;)
  maybePublishingGenerator.foreach(_.cancel)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/nfiraos/samplehcd/JSampleHcdHandlers.java#L109-L125" target="_blank" title="Go to snippet source"></a><code class="language-java">private int counter = 0;

private Optional&lt;Event&gt; incrementCounterEvent() {
    counter += 1;
    Parameter&lt;Integer&gt; param = JKeyType.IntKey().make(&quot;counter&quot;).set(counter);
    return Optional.of(new SystemEvent(cswCtx.componentInfo().prefix(), new EventName(&quot;HcdCounter&quot;)).add(param));
}

private Cancellable publishCounter() {
    log.info(&quot;Starting publish stream.&quot;);
    return cswCtx.eventService().defaultPublisher().publish(this::incrementCounterEvent, java.time.Duration.ofSeconds(2));
}

private void stopPublishingGenerator() {
    log.info(&quot;Stopping publish stream&quot;);
    maybePublishingGenerator.ifPresent(Cancellable::cancel);
}</code></pre></dd>
</dl>
<p>We encapsulate the starting of the publishing in our method <code>publishCounter</code>. Our <code>EventGenerator</code> is the <code>incrementCounterEvent</code> method which increments our integer variable <code>counter</code> and stores it in the <code>ParameterSet</code> of a new <code>SystemEvent</code> and returns it. Once our <code>defaultPublisher</code> is resolved, we pass in a reference to <code>incrementCounterEvent</code> and specify a period of 2 seconds. We log a message when publishing the event so that it can be observed when running the component.</p>
<p>The <code>publish</code> method returns a <code>Cancellable</code> type in a future. When the publishing is set up, the <code>Cancellable</code> can be used to stop the event generator. We demonstrate its usage in the <code>stopPublishingGenerator</code> method, although this method is not called in our tutorial.</p>
<p>We will start this publishing when our component initializes, so we return to our <code>initialize</code> method and add a call to our <code>publishCounter</code> method. We save a reference to the <code>Cancellable</code> object for future use in our <code>stopPublishingGenerator</code> method. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/nfiraos/samplehcd/SampleHcdHandlers.scala#L56-L70" target="_blank" title="Go to snippet source"></a><code class="language-scala">var maybePublishingGenerator: Option[Cancellable] = None
override def initialize(): Future[Unit] = {
  log.info(&quot;In HCD initialize&quot;)
  maybePublishingGenerator = Some(publishCounter())
  Future.unit
}

override def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = {
  log.debug(s&quot;TrackingEvent received: ${trackingEvent.connection.name}&quot;)
}

override def onShutdown(): Future[Unit] = {
  log.info(&quot;HCD is shutting down&quot;)
  Future.unit
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/nfiraos/samplehcd/JSampleHcdHandlers.java#L87-L105" target="_blank" title="Go to snippet source"></a><code class="language-java">private Optional&lt;Cancellable&gt; maybePublishingGenerator = Optional.empty();

@Override
public CompletableFuture&lt;Void&gt; jInitialize() {
    return CompletableFuture.runAsync(() -&gt; {
        log.info(&quot;In HCD initialize&quot;);
        maybePublishingGenerator = Optional.of(publishCounter());
    });
}

@Override
public void onLocationTrackingEvent(TrackingEvent trackingEvent) {
    log.debug(() -&gt; &quot;TrackingEvent received: &quot; + trackingEvent.connection().name());
}

@Override
public CompletableFuture&lt;Void&gt; jOnShutdown() {
    return CompletableFuture.runAsync(() -&gt; log.info(&quot;HCD is shutting down&quot;));
}</code></pre></dd>
</dl>
<h2><a href="#starting-csw-services" name="starting-csw-services" class="anchor"><span class="anchor-link"></span></a>Starting CSW Services</h2>
<p>Before we run our application, we must first start the Location Service and the Event Service. A script has been provided to simplify the starting and stopping of CSW services, and is included in the application bundle that comes with each release. The application bundle is called </p>
<p>csw-apps-0.1.0-SNAPSHOT.zip </p>
<p>and the script is named <code>csw-services.sh</code>. The version must match the CSW release in use!</p>
<p>The <code>csw-services.sh</code> script has two basic commands: <code>start</code> and <code>stop</code>. The start command can start specific services using passed in flags, or all services without any. Services are started on default ports but those ports can be overridden using command line arguments. It is important to pass in a network interface name that is appropriate for your system. These can be obtained using <code>ifconfig</code> on Linux and Mac computers. <code>en0</code> typically works for most machines. This can alternatively be set using the environment variable <code>INTERFACE_NAME</code>. Setting the interface name at the command with this script also sets this environment variable.</p><div class="callout note "><div class="callout-title">Environment Variables used by CSW</div>
<p>There are several environment variables that are used by the CSW framework and services. The environment variables used by CSW services are specified <a href="../deployment/env-vars.html">here</a>. </p></div>
<p>To get information on the arguments for the tool, use <code>csw-services.sh --help</code>.</p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>Let&rsquo;s go ahead and start our CSW Services using the script. Go to the <a href="https://github.com/tmtsoftware/csw/releases">release page</a> and download and unpack the CSW application bundle. Then go into the <code>bin</code> directory and enter the command</p>
<pre><code>./csw-services.sh start -i &lt;iname&gt;
</code></pre>
<p>where <code>&lt;iname&gt;</code> is your interface name (e.g. <code>en0</code>).</p>
<h2><a href="#building-and-running-component-in-standalone-mode" name="building-and-running-component-in-standalone-mode" class="anchor"><span class="anchor-link"></span></a>Building and Running component in standalone mode</h2>
<p>Once the component is ready, it is started using the <code>ContainerCmd</code> object in standalone mode. The details for starting the <code>ContainerCmd</code> in standalone mode can be found <a href="../framework/deploying-components.html">here</a>.</p>
<p>There are various ways to build and run the project. A simple way during development is to to use sbt to run it. The sbt command <code>runMain</code> can be used to specify an application with a main method and run it with arguments specified at the command line. When this command is executed, sbt will take care of any downloading of dependencies, compiling, or building necessary to run your application. </p>
<p>Our template includes a wrapper application around ContainerCmd that we can use in the deployment module. To run our HCD in standalone mode, go to the project root directory and type <code>sbt &quot;&lt;deploy-module&gt;/runMain &lt;mainClass&gt; --local --standalone &lt;path-to-config-file&gt;&quot;</code>, where</p>
<ul>
  <li><code>&lt;deploy-module&gt;</code> is the name of the deployment module created by the template (<code>sample-deploy</code> if using defaults)</li>
  <li><code>&lt;mainClass&gt;</code> is the full class name of our ContainerCmd application, which the template names <code>&lt;package&gt;.&lt;name&gt;deploy.&lt;Name&gt;ContainerCmdApp</code>. If you accept the defaults for the template, it will be <code>org.tmt.esw.sampledeploy.SampleContainerCmdApp</code>. If you are having problems determining the class name, use <code>sbt &lt;deploy-module&gt;/run</code> and it will prompt you the possibilities.</li>
  <li><code>&lt;path-to-config-file&gt;</code> is the filename, which can be an absolute path or relative to the directory of the deployment module. If using defaults, this would be <code>src/main/resources/SampleHcdStandalone.conf</code> for Scala, and <code>src/main/resources/JSampleHcdStandalone.conf</code> for Java.</li>
</ul>
<p>So if using the template defaults, the full command would be </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre><code>sbt &quot;sample-deploy/runMain org.tmt.esw.sampledeploy.SampleContainerCmdApp --local --standalone src/main/resources/SampleHcdStandalone.conf&quot;
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre><code>sbt &quot;sample-deploy/runMain org.tmt.esw.sampledeploy.SampleContainerCmdApp --local --standalone src/main/resources/JSampleHcdStandalone.conf&quot;
</code></pre></dd>
</dl>
<p>To run the component using the deployment package, perform the following steps:</p>
<ul>
  <li>Run <code>sbt &lt;project&gt;/universal:packageBin</code>, where <code>&lt;project&gt;</code> is your deployment module (e.g. <code>sample-deploy</code>). This will create self contained zip in <code>&lt;project&gt;/target/universal</code> directory</li>
  <li>Unzip generated zip file and enter into bin directory</li>
  <li>Run the <code>./&lt;project&gt;-cmd-app --local --standalone &lt;path-to-local-config-file-to-start-the-component&gt;</code></li>
</ul>
<p>Alternatively, you can run <code>sbt stage</code>, which installs the application under target/universal/stage/bin.</p>
<h2><a href="#enhanced-tutorial-versions" name="enhanced-tutorial-versions" class="anchor"><span class="anchor-link"></span></a>Enhanced Tutorial Versions</h2>
<p>There are three supplemental versions of the tutorial Assembly and HCD called: basic, moderate, and full. The basic version is similar to the tutorial example here with possible best practices. Two other versions are included that introduce ways of programming components along with increasing functionality. The following table shows the features of each version. Moderate adds functionality to Basic, and Full adds functionality to Moderate.</p>
<p>The code for the enhanced tutorials is in the CSW distribution at the following locations:</p>
<p>Scala versions are <a href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/example/tutorial/">here</a><br/> Scala test code is <a href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/scala/example/tutorial/">here</a><br/> Java version of basic is <a href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/example/tutorial/">here</a><br/> Java test code is <a href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/java/example/tutorial/">here</a></p>
<p>At this time there is no Java versions of moderate and full.</p>
<h3><a href="#basic" name="basic" class="anchor"><span class="anchor-link"></span></a>Basic</h3>
<h4><a href="#basic-hcd" name="basic-hcd" class="anchor"><span class="anchor-link"></span></a>Basic HCD</h4>
<ul>
  <li>Implements a simple sleep worker in HCD using Time Service scheduler.</li>
  <li>Provides basic command validation.</li>
  <li>Shows one way to write onSetup handler.</li>
  <li>Shows how to publish events.</li>
</ul>
<h4><a href="#basic-assembly" name="basic-assembly" class="anchor"><span class="anchor-link"></span></a>Basic Assembly</h4>
<ul>
  <li>Provides simple validation in HCD and Assembly.</li>
  <li>Assembly shows how to use onTrackEvent to manage CommandService creation and loss of HCD.</li>
  <li>Code shows how to send a command while noticing if HCD is available.</li>
  <li>Simulates different commands that use the sleep functinoality of HCD.</li>
  <li>Shows how to use CommandResponseManager to update a long-running command.</li>
  <li>Shows a &ldquo;complex&rdquo; command that uses CommandResponseManager queryFinalAll call.</li>
  <li>Shows how to subscribe to events and process events.</li>
</ul>
<p>Includes standalone HCD tests and Assembly+HCD integration tests that start a container with both components.</p>
<h3><a href="#moderate" name="moderate" class="anchor"><span class="anchor-link"></span></a>Moderate</h3>
<h4><a href="#moderate-hcd" name="moderate-hcd" class="anchor"><span class="anchor-link"></span></a>Moderate HCD</h4>
<ul>
  <li>Sleep worker is interruptable allowing sleep command to be cancelled.</li>
  <li>Supports command that will cancel the &ldquo;long command&rdquo;.</li>
  <li>Uses validation code shared with Assembly.</li>
  <li>Uses &ldquo;info&rdquo; file that is shared between HCD and Assembly.</li>
</ul>
<h4><a href="#moderate-assembly" name="moderate-assembly" class="anchor"><span class="anchor-link"></span></a>Moderate Assembly</h4>
<ul>
  <li>Adds command to cancel &ldquo;long command&rdquo;. Keeps track of long command runId.</li>
  <li>Uses validation code shared with Assembly.</li>
  <li>Uses &ldquo;info&rdquo; file that is shared between HCD and Assembly.</li>
</ul>
<p>Includes standalone HCD tests and Assembly+HCD integration tests that start a container with both components. Adds test to start a long command and cancel it.</p>
<h3><a href="#full" name="full" class="anchor"><span class="anchor-link"></span></a>Full</h3>
<h4><a href="#full-hcd" name="full-hcd" class="anchor"><span class="anchor-link"></span></a>Full HCD</h4>
<ul>
  <li>Adds a worker monitor that tracks data allowing any sleep command to be cancelled.</li>
  <li>Sleep worker enhanced to work with worker monitor.</li>
  <li>Implements cancel &ldquo;long command&rdquo; using new functionality.</li>
</ul>
<h4><a href="#full-assembly" name="full-assembly" class="anchor"><span class="anchor-link"></span></a>Full Assembly</h4>
<ul>
  <li>Uses worker monitor to associate runIds with sub-commandIds.</li>
  <li>Imlements cancel &ldquo;long command&rdquo; using worker monitor.</li>
</ul>
<p>Includes standalone HCD tests and Assembly+HCD integration tests that start a container with both components. Integration test to start a long command and cancel it.</p>
</div>
<div>
<a href="https://github.com/tmtsoftware/csw/tree/master/docs/src/main/commons/create-component.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.1.0*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../commons/getting-started.html" title="Getting Started" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Getting Started
</span>
</div>
</a>
<a href="../commons/multiple-components.html" title="Multiple Components" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Multiple Components
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
