<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="docs">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="docs">
<link rel="shortcut icon" href="../assets/tmt_favicon.ico">
<title>Creating a Component Â· TMT Common Software (CSW)</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="TMT Common Software (CSW)" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
TMT Common Software (CSW)
</span>
<span class="md-header-nav__topic">
Creating a Component
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/tmtsoftware/csw"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
tmtsoftware/csw
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="TMT Common Software (CSW)" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="TMT Common Software (CSW)">
TMT Common Software (CSW)
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/tmtsoftware/csw"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
tmtsoftware/csw
</div>
</a>

</div>
<ul>
  <li><a href="../commons/getting-started.html" class="page">Getting Started</a></li>
  <li><a href="../commons/create-component.html" class="active page">Creating a Component</a></li>
  <li><a href="../commons/multiple-components.html" class="page">Multiple Components</a></li>
  <li><a href="../commons/using-alarms.html" class="page">Using Alarms</a></li>
  <li><a href="../commons/unit-tests.html" class="page">Adding Unit Tests</a></li>
  <li><a href="../commons/messages.html" class="page">Messages</a>
  <ul>
    <li><a href="../messages/keys-parameters.html" class="page">Keys and Parameters</a></li>
    <li><a href="../messages/units.html" class="page">Units</a></li>
    <li><a href="../messages/subsystem.html" class="page">Subsystem</a></li>
    <li><a href="../messages/commands.html" class="page">Commands</a></li>
    <li><a href="../messages/events.html" class="page">Events</a></li>
    <li><a href="../messages/states.html" class="page">State Variables</a></li>
    <li><a href="../messages/result.html" class="page">Result</a></li>
  </ul></li>
  <li><a href="../commons/framework.html" class="page">Framework for creating components (HCD, Assembly, Container)</a>
  <ul>
    <li><a href="../framework/describing-components.html" class="page">ComponentInfo</a></li>
    <li><a href="../framework/creating-components.html" class="page">Creating an Assembly or Hcd Component</a></li>
    <li><a href="../framework/handling-lifecycle.html" class="page">Component Handlers</a></li>
    <li><a href="../framework/managing-command-state.html" class="page">Managing Command State</a></li>
    <li><a href="../framework/tracking-connections.html" class="page">Tracking Connections</a></li>
    <li><a href="../framework/publishing-state.html" class="page">Publishing State</a></li>
    <li><a href="../framework/handling-exceptions.html" class="page">Handling Exceptions</a></li>
    <li><a href="../framework/deploying-components.html" class="page">Deploying Components</a></li>
  </ul></li>
  <li><a href="../commons/command.html" class="page">Communication using Commands</a></li>
  <li><a href="../commons/services.html" class="page">Services</a>
  <ul>
    <li><a href="../services/location.html" class="page">Location Service</a></li>
    <li><a href="../services/config.html" class="page">Configuration Service</a></li>
    <li><a href="../services/logging.html" class="page">Logging Service</a></li>
    <li><a href="../services/event.html" class="page">Event Service</a></li>
    <li><a href="../services/alarm.html" class="page">Alarm Service</a></li>
    <li><a href="../services/time.html" class="page">Time Service</a></li>
    <li><a href="../services/database.html" class="page">Database Service</a></li>
    <li><a href="../services/aas.html" class="page">Authentication and Authorization Service (AAS)</a></li>
  </ul></li>
  <li><a href="../commons/apps.html" class="page">Applications</a>
  <ul>
    <li><a href="../apps/cswlocationserver.html" class="page">csw-location-server</a></li>
    <li><a href="../apps/cswadminserver.html" class="page">csw-admin-server</a></li>
    <li><a href="../apps/cswlocationagent.html" class="page">csw-location-agent</a></li>
    <li><a href="../apps/cswonfigserverapp.html" class="page">csw-config-server</a></li>
    <li><a href="../apps/cswconfigcli.html" class="page">csw-config-cli</a></li>
    <li><a href="../apps/csweventcli.html" class="page">csw-event-cli</a></li>
    <li><a href="../apps/cswalarmcli.html" class="page">csw-alarm-cli</a></li>
    <li><a href="../apps/hostconfig.html" class="page">csw-host-config</a></li>
  </ul></li>
  <li><a href="../commons/testing.html" class="page">Testing</a></li>
  <li><a href="../commons/sbt-tasks.html" class="page">sbt Tasks</a></li>
  <li><a href="../commons/manuals.html" class="page">Manuals</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../commons/create-component.html#creating-a-component" class="header">Creating a Component</a>
  <ul>
    <li><a href="../commons/create-component.html#" class="header"><em>Tutorial: Developing an HCD</em></a></li>
    <li><a href="../commons/create-component.html#anatomy-of-component" class="header">Anatomy of Component</a></li>
    <li><a href="../commons/create-component.html#supervisor" class="header">Supervisor</a></li>
    <li><a href="../commons/create-component.html#top-level-actor" class="header">Top level actor</a></li>
    <li><a href="../commons/create-component.html#handlers" class="header">Handlers</a></li>
    <li><a href="../commons/create-component.html#constructing-the-component" class="header">Constructing the Component</a></li>
    <li><a href="../commons/create-component.html#component-configuration-componentinfo-" class="header">Component Configuration (ComponentInfo)</a></li>
    <li><a href="../commons/create-component.html#lifecycle" class="header">Lifecycle</a></li>
    <li><a href="../commons/create-component.html#csw-services-injection" class="header">CSW Services Injection</a></li>
    <li><a href="../commons/create-component.html#logging" class="header">Logging</a></li>
    <li><a href="../commons/create-component.html#receiving-commands" class="header">Receiving Commands</a></li>
    <li><a href="../commons/create-component.html#validation" class="header">Validation</a></li>
    <li><a href="../commons/create-component.html#command-response" class="header">Command Response</a></li>
    <li><a href="../commons/create-component.html#events" class="header">Events</a></li>
    <li><a href="../commons/create-component.html#starting-csw-services" class="header">Starting CSW Services</a></li>
    <li><a href="../commons/create-component.html#building-and-running-component-in-standalone-mode" class="header">Building and Running component in standalone mode</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.1*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../commons/create-component.html#creating-a-component" class="header">Creating a Component</a>
  <ul>
    <li><a href="../commons/create-component.html#" class="header"><em>Tutorial: Developing an HCD</em></a></li>
    <li><a href="../commons/create-component.html#anatomy-of-component" class="header">Anatomy of Component</a></li>
    <li><a href="../commons/create-component.html#supervisor" class="header">Supervisor</a></li>
    <li><a href="../commons/create-component.html#top-level-actor" class="header">Top level actor</a></li>
    <li><a href="../commons/create-component.html#handlers" class="header">Handlers</a></li>
    <li><a href="../commons/create-component.html#constructing-the-component" class="header">Constructing the Component</a></li>
    <li><a href="../commons/create-component.html#component-configuration-componentinfo-" class="header">Component Configuration (ComponentInfo)</a></li>
    <li><a href="../commons/create-component.html#lifecycle" class="header">Lifecycle</a></li>
    <li><a href="../commons/create-component.html#csw-services-injection" class="header">CSW Services Injection</a></li>
    <li><a href="../commons/create-component.html#logging" class="header">Logging</a></li>
    <li><a href="../commons/create-component.html#receiving-commands" class="header">Receiving Commands</a></li>
    <li><a href="../commons/create-component.html#validation" class="header">Validation</a></li>
    <li><a href="../commons/create-component.html#command-response" class="header">Command Response</a></li>
    <li><a href="../commons/create-component.html#events" class="header">Events</a></li>
    <li><a href="../commons/create-component.html#starting-csw-services" class="header">Starting CSW Services</a></li>
    <li><a href="../commons/create-component.html#building-and-running-component-in-standalone-mode" class="header">Building and Running component in standalone mode</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#creating-a-component" name="creating-a-component" class="anchor"><span class="anchor-link"></span></a>Creating a Component</h1>
<p>This walkthrough helps in creating a CSW component in Scala/Java. CSW components depend on the <code>csw-framework</code> package, which can be found <a href="framework.html">here</a>. This section discusses constructing a HCD, but the principles apply to an Assembly as well. We will be constructing the Assembly in the next section <a href="multiple-components.html">Working with Multiple Components</a>. </p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>This tutorial shows code written in Scala and Java, based on code generated by the giter8 templates with the default values.</p>
<h2><a href="#anatomy-of-component" name="anatomy-of-component" class="anchor"><span class="anchor-link"></span></a>Anatomy of Component</h2>
<p>A component consists of a supervisor actor, a Top Level Actor, a component handler and one or more worker actors. From all these, <code>csw-framework</code> provides supervisor actor, a Top Level Actor and abstract class of handlers. Component developers are expected to implement this handler which also acts as a gateway from framework to component code. </p>
<h2><a href="#supervisor" name="supervisor" class="anchor"><span class="anchor-link"></span></a>Supervisor</h2>
<p>A Supervisor actor is the actor first started for any component. The main responsibilities that supervisor performs is as follows:</p>
<ul>
  <li>Implement and manage the component lifecycle for the TLA and for the rest of the system (see <a href="#lifecycle">Lifecycle</a> below).</li>
  <li>Register itself with location service.</li>
  <li>Provide an administrative interface to the component to the rest of the system. For instance, the Container can perform certain administrative communication with the Supervisor such as restart or shutdown.</li>
  <li>Allow components outside of the Supervisor and TLA to monitor the lifecycle state of the TLA. This is particularly useful for testing. The test needs to know that the component is ready before it starts its test actions.</li>
</ul><div class="callout note "><div class="callout-title">Note</div>
<p>Because the Supervisor registers itself with location service, it serves as the gateway for all incoming communications from external components/entities.</p></div>
<p>The source code of supervisor actor can be found <a href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/main/scala/csw/framework/internal/supervisor/SupervisorBehavior.scala">here</a></p>
<h2><a href="#top-level-actor" name="top-level-actor" class="anchor"><span class="anchor-link"></span></a>Top level actor</h2>
<p>While the Supervisor works as the external interface for the component and the manager of Lifecycle, the functional implementation of a component is implemented in a Top Level Actor (TLA), spawned by supervisor actor for any component. However, the developer is not expected to implement TLA code directly. Instead, the functionality of the TLA is added by implementing the <code>ComponentHandlers</code> abstract class, consisting of a list of a methods, or <code>hooks</code>, called by the TLA during specific lifecycle and command events (see <a href="#handlers">Handlers</a>). The <code>ComponentHandlers</code> implementation is specified during constructing using that factory (see <a href="#constructing-the-component">Constructing The Component</a>) </p>
<p>The source code of the Top Level Actor can be found <a href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/main/scala/csw/framework/internal/component/ComponentBehavior.scala">here</a>.</p>
<h2><a href="#handlers" name="handlers" class="anchor"><span class="anchor-link"></span></a>Handlers</h2>
<p>The following hooks should be overridden in your ComponentHandlers implementation class:</p>
<ul>
  <li><code>initialize</code>: called when component is starting up, prior to be put into the Running state.</li>
  <li><code>validateCommand</code>: called when component receives a command. (see <a href="#validation">Validation</a>)</li>
  <li><code>onSubmit</code>: called on Submit command if validateCommand returns <code>Accepted</code>.</li>
  <li><code>onOneway</code>: called on Oneway command if validateCommand returns <code>Accepted</code>.</li>
  <li><code>onGoOffline</code>: called when component receives external message from an administrative client to go offline.</li>
  <li><code>onGoOnline</code>: called when component receives external message from an administrative client to go online.</li>
  <li><code>onLocationTrackingEvent</code>: called when a tracked dependency changes location state. (see <a href="multiple-components.html#tracking-dependencies">Tracking Dependencies</a>)</li>
  <li><code>onShutdown</code>: called when component is shutting down.</li>
</ul>
<p>The source code of <code>ComponentHandlers</code> can be found <a href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/main/scala/csw/framework/scaladsl/ComponentHandlers.scala">here</a>. </p>
<p>More details about handler significance and invocation can be found <a href="framework.html#handling-lifecycle">here</a></p><div class="callout note "><div class="callout-title">Note</div>
<p>If the component developer wishes to write the handler implementation in java, then he/she needs to implement the java version of <code>ComponentHandlers</code> which is <code>JComponentHandlers</code>. The source code of <code>JComponentHandlers</code> can be found <a href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/main/scala/csw/framework/javadsl/JComponentHandlers.scala">here</a>. Any further reference to <code>ComponentHandlers</code> should implicitly also apply to <code>JComponentHandlers</code>.</p></div>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>As seen in the <a href="getting-started.html">Getting Started</a> page, if you are using the giter8 template, handler classes for both the HCD and Assembly are written for you, with handler implementations stubbed out. We will walkthough filling them in below.</p>
<h2><a href="#constructing-the-component" name="constructing-the-component" class="anchor"><span class="anchor-link"></span></a>Constructing the Component</h2>
<p>After writing the handlers, component developer needs to wire it up with framework. In order to do this, developer needs to implement a <code>ComponentBehaviorFactory</code>. This factory should to be configured in configuration file for the component (see example below). The <code>csw-framework</code> then picks up the full path of <code>ComponentBehaviorFactory</code> from configuration file and spawns the component handlers using this factory as a process of booting a component. The factory is instantiated using Java reflection.</p>
<p>Additional sample code to implement the <code>ComponentBehaviorFactory</code> can be found <a href="framework.html#creating-components">here</a> </p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>As seen in the <a href="getting-started.html">Getting Started</a> page, if using the template, this factory class will be implemented for you.</p>
<h2><a href="#component-configuration-componentinfo-" name="component-configuration-componentinfo-" class="anchor"><span class="anchor-link"></span></a>Component Configuration (ComponentInfo)</h2>
<p>Component configuration contains details needed to spawn a component. This configuration resides in a configuration file for a particular component. The template creates one for our sample HCD as follows:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/resources/SampleHcdStandalone.conf" target="_blank" title="Go to snippet source"></a><code class="language-conf">name = &quot;SampleHcd&quot;
componentType = hcd
behaviorFactoryClassName = &quot;org.tmt.nfiraos.samplehcd.SampleHcdBehaviorFactory&quot;
prefix = &quot;nfiraos.samplehcd&quot;
locationServiceUsage = RegisterOnly</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/resources/JSampleHcdStandalone.conf" target="_blank" title="Go to snippet source"></a><code class="language-conf">name = &quot;JSampleHcd&quot;
componentType = hcd
behaviorFactoryClassName = &quot;org.tmt.nfiraos.samplehcd.JSampleHcdBehaviorFactory&quot;
prefix = &quot;nfiraos.samplehcd&quot;
locationServiceUsage = RegisterOnly</code></pre></dd>
</dl><div class="callout note "><div class="callout-title">Note</div>
<p><code>behaviorFactoryClassName</code> refers to class name of the concrete implementation of <code>ComponentBehaviorFactory</code>, which is <code>SampleHcdBehaviorFactory</code> for Scala in above example, <code>JSampleHcdBehaviorFactory</code> for Java.</p></div>
<p>The <code>name</code> and <code>componentType</code> is used to create the <code>ComponentId</code> representing a unique component in location service.</p>
<p>The <code>locationServiceUsage</code> is used by the Supervisor actor to decide whether to only register a component with location service or register and track other components.</p>
<p>The configuration file is parsed to a <code>ComponentInfo</code> object and injected in the Supervisor actor. It is then injected in <code>ComponentHandlers</code> while spawning a component.</p>
<p>The configuration can also contain a list of components and services it wishes to track as dependencies. See <a href="multiple-components.html#tracking-dependencies">Tracking Dependencies</a>.</p>
<p>More details about <code>ComponentInfo</code> can be found <a href="framework.html#describing-components">here</a>.</p>
<p>An additional sample configuration file can be found <a href="https://github.com/tmtsoftware/csw/tree/master/csw-benchmark/src/main/resources/container.conf">here</a>.</p>
<h2><a href="#lifecycle" name="lifecycle" class="anchor"><span class="anchor-link"></span></a>Lifecycle</h2>
<p>The Supervisor of a component manages its lifecycle state, which can be one of the following:</p>
<ul>
  <li>Idle</li>
  <li>Running</li>
  <li>RunningOffline</li>
  <li>Restart</li>
  <li>Shutdown</li>
  <li>Lock</li>
</ul>
<p>The state the component is in dictates the actions it can take when it receives a message or command, and how those actions are carried out.</p>
<h3><a href="#idle" name="idle" class="anchor"><span class="anchor-link"></span></a>Idle</h3>
<p>The component initializes in the idle state. Top level actor calls the <code>initialize</code> hook of <code>ComponentHandlers</code> as first thing on boot-up. Component developers write their initialization logic in this hook. The logic could also do things like accessing the configuration service to fetch the hardware configurations to set the hardware to default positions.</p>
<p>After the initialization, if the component would have configured <code>RegisterAndTrack</code> for <code>locationServiceUsage</code> then the Top Level Actor will start tracking the <code>connections</code> configured for that component. This use case is mostly applicable for Sequencers and Assemblies. HCDs mostly will have <code>RegisterOnly</code> configured for <code>locationServiceUsage</code>.</p>
<p>The Supervisor actor will now register itself with location service. Registering with location service will notify other components tracking this component with a <code>LocationUpdated</code> event containing a <code>Location</code> with a reference to the Supervisor actor.</p>
<p>After successful registration, the component will transition to <code>Running</code> state. </p>
<h3><a href="#running" name="running" class="anchor"><span class="anchor-link"></span></a>Running</h3>
<p>When the supervisor actor receives <code>Initialized</code> message from the Top Level Actor after successful initialization, it registers itself with location service and transitions the component to <code>Running</code> state. Running state signifies that the component is accessible via location service, which allows other entities to communicate with it by sending commands via messages. Any commands received by supervisor actor will be forwarded to the Top Level Actor for processing.</p>
<h3><a href="#runningoffline" name="runningoffline" class="anchor"><span class="anchor-link"></span></a>RunningOffline</h3>
<p>When the Supervisor actor receives <code>GoOffline</code> message, it transitions the component to <code>RunningOffline</code> state and forwards it to the Top Level Actor. The Top Level Actor then calls <code>onGoOffline</code> hook of <code>ComponentHandlers</code>.</p>
<p>If <code>GoOnline</code> message is received by the Supervisor actor then it transits the component back to <code>Running</code> state and forwards it to the Top Level Actor. The Top Level Actor then calls <code>onGoOnline</code> hook of <code>ComponentHandlkers</code>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>In <code>RunningOffline</code> state, if any command is received, it is forwarded to underlying component hook through the Top Level Actor. It is then the responsibility of the component developer to check the <code>isOnline</code> flag provided by <code>csw-framework</code> and process the command accordingly. </p></div>
<h3><a href="#restart" name="restart" class="anchor"><span class="anchor-link"></span></a>Restart</h3>
<p>When the Supervisor actor receives a <code>Restart</code> message, it will transit the component to the <code>Restart</code> state. Then, it will unregister itself from location service so that other components tracking this component will be notified and no commands are received while restart is in progress.</p>
<p>Then, the Top Level Actor is stopped and postStop hook of the Top Level Actor will call the <code>onShutdown</code> hook of <code>ComponentHandlers</code>. Component developers are expected to write any cleanup of resources or logic that should be executed for graceful shutdown of component in this hook. </p>
<p>After successful shutdown of component, the Supervisor actor will create the Top Level Actor again from scratch. This will cause the <code>initialize</code> hook of <code>ComponentHandlers</code> to be called again. After successful initialization of component, the Supervisor actor will register itself with location service.</p>
<h3><a href="#shutdown" name="shutdown" class="anchor"><span class="anchor-link"></span></a>Shutdown</h3>
<p>When the Supervisor actor receives a <code>Shutdown</code> message, it transitions the component to the <code>Shutdown</code> state. Any commands received while shutdown is in progress will be ignored. Then, it will stop the Top Level Actor. The postStop hook of the Top Level Actor will call the <code>onShutdown</code> hook of <code>ComponentHandlers</code>. Component developers are expected to write any cleanup of resources or logic that should be executed for graceful shutdown of component in this hook.</p>
<h3><a href="#lock" name="lock" class="anchor"><span class="anchor-link"></span></a>Lock</h3>
<p>When the Supervisor actor receives a <code>Lock</code> message, it transitions the component to the <code>Lock</code> state. Upon locking, the Supervisor will only accept the commands received from the component that locked the component and ignore all others.</p>
<p>In the <code>Lock</code> state, messages like <code>Shutdown</code> and <code>Restart</code> will also be ignored. A component must first be unlocked to accept these commands.</p>
<p><code>Lock</code> messages are constructed with a duration value specified. When this duration expires, the component will automatically be unlocked. A component can be manually unlocked by sending an <code>Unlock</code> message.</p>
<h2><a href="#csw-services-injection" name="csw-services-injection" class="anchor"><span class="anchor-link"></span></a>CSW Services Injection</h2>
<p>To provide access to CSW Services, they are injected into the <code>ComponentHandlers</code> class in the constructor in a <code>CswContext</code> object. This object provides the following services:</p>
<ul>
  <li>Location Service</li>
  <li>Event Service</li>
  <li>Alarm Service (Client API)</li>
  <li>Configuration Service (Client API)</li>
  <li>Logging Service (Logger Factory)</li>
</ul>
<p>And the following utilities:</p>
<ul>
  <li>Component Configuration (ComponentInfo)</li>
  <li>Command Service Command Response Manager</li>
  <li>Current State Publisher Actor (intended for HCDs)</li>
</ul>
<h2><a href="#logging" name="logging" class="anchor"><span class="anchor-link"></span></a>Logging</h2>
<p><code>csw-framework</code> will provide a <code>LoggerFactory</code> in the <code>CswContext</code> injected in constructor of <code>ComponentHandlers</code>. The <code>LoggerFactory</code> will have the component&rsquo;s name predefined in it. The component developer is expected to use this factory to log statements.</p>
<p>Logging works much like other popular loggers such as <em>log4j</em>. However, with the development of log management tools such as <em>logstash</em>, the emphasis on log message formatting has been to write messages in JSON format, so that they can easily be ingested. Plain text writing to stdout is still supported. More details on how to use logging can be found <a href="../services/logging.html#log-statements">here</a>. </p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>Let&rsquo;s use logging to flesh out some of our command handlers. The template will instantiate a logger for you to use by constructing one from the <code>LoggerFactory</code> from in the <code>CswContext</code> passed in the constructor, instantiated as a <code>log</code> object.</p>
<p>Add some simple log messages in the <code>initialize</code> and <code>onShutdown</code> hooks, and to the <code>onLocationTrackingEvent</code> hook as well, although we won&rsquo;t be using it for this HCD:</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/nfiraos/samplehcd/SampleHcdHandlers.scala#L53-L67" target="_blank" title="Go to snippet source"></a><code class="language-scala">var maybePublishingGenerator: Option[Cancellable] = None
override def initialize(): Future[Unit] = {
  log.info(&quot;In HCD initialize&quot;)
  maybePublishingGenerator = Some(publishCounter())
  Future.unit
}

override def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = {
  log.debug(s&quot;TrackingEvent received: ${trackingEvent.connection.name}&quot;)
}

override def onShutdown(): Future[Unit] = {
  log.info(&quot;HCD is shutting down&quot;)
  Future.unit
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/nfiraos/samplehcd/JSampleHcdHandlers.java#L84-L101" target="_blank" title="Go to snippet source"></a><code class="language-java">private Optional&lt;Cancellable&gt; maybePublishingGenerator = Optional.empty();
@Override
public CompletableFuture&lt;Void&gt; jInitialize() {
    return CompletableFuture.runAsync(() -&gt; {
        log.info(&quot;In HCD initialize&quot;);
        maybePublishingGenerator = Optional.of(publishCounter());
    });
}

@Override
public void onLocationTrackingEvent(TrackingEvent trackingEvent) {
    log.debug(() -&gt; &quot;TrackingEvent received: &quot; + trackingEvent.connection().name());
}

@Override
public CompletableFuture&lt;Void&gt; jOnShutdown() {
    return CompletableFuture.runAsync(() -&gt; log.info(&quot;HCD is shutting down&quot;));
}</code></pre></dd>
</dl>
<p>In the example code, you&rsquo;ll notice we have added some functionality to start publishing events. We will cover the Event Service later. You can leave that code out for now.</p>
<p>Next we&rsquo;ll add some command handling.</p>
<h2><a href="#receiving-commands" name="receiving-commands" class="anchor"><span class="anchor-link"></span></a>Receiving Commands</h2>
<p>A command is something that carries some metadata and a set of parameters. A component sends message to other components using <code>commands</code>. Various kinds of commands are as follows:</p>
<ul>
  <li>Setup : Contains goal, command, or demand information to be used to  configure the target OMOA component.</li>
  <li>Observe: Contains goal or demand information to be used by a detector.  system. Properties and their value types will be standardized  by the ESW for the ESW PDR.</li>
  <li>Wait: Sequencer only. Instructs a sequencer to pause until told to continue.</li>
</ul>
<p>More details about creating commands can be found <a href="../messages/commands.html#setup-command">here</a>.</p>
<p>Whenever a command is sent to a component it is wrapped inside a command wrapper. There are two kinds of command wrapper:</p>
<ul>
  <li>Submit: A command is wrapped in submit when the completion result is expected from receiver component</li>
  <li>Oneway: A command is wrapped in oneway when the completion of command is not expected from receiver component but is determined by sender component by subscribing to receiver component&rsquo;s  state</li>
</ul>
<h2><a href="#validation" name="validation" class="anchor"><span class="anchor-link"></span></a>Validation</h2>
<p>When a command is received by a component, the Top Level Actor will call the <code>validateCommand</code> hook of <code>ComponentHandlers</code>. Component developers are expected to perform appropriate validation of command, whether it is valid to execute, and return a <code>CommandResponse</code>. The <code>CommandResponse</code> returned from this hook will be sent back to sender directly by <code>csw-framework</code>.</p>
<p>The logic in <code>validateCommand</code> hook can be used to handle commands of various durations. If the command can be executed immediately, then the component developer can return a final response directly in the validation step using a <code>CompletedWithResult</code> command response.<br/>This should be only used for commands that require a very small amount of time to execute. If the command will take longer, then component developer should return an intermediate response <code>Accepted</code> or <code>Invalid</code> specifying whether the command is valid to be executed or not, and process the command in the <code>onSubmit</code> or <code>onOneway</code> handlers (see <a href="#command-response">Command Response</a>).</p>
<p>Different types of command responses and their significance can be found <a href="command.html#command-based-communication-between-components">here</a>.</p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>Let&rsquo;s add some command validation to our HCD. For our sample HCD, we will only handle one command, <code>sleep</code>, in which we will cause the HCD to sleep for the time specified in a parameter of the command. This will simulate a long running command.</p>
<p>Add some code to ensure the command we receive is the <code>sleep</code> command, and return an <code>Invalid</code> response if not. You could imagine much more checking could be added, such as checking the types and values of the parameters of our <code>sleep</code> command, but we will keep it simple for our demonstration.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/nfiraos/samplehcd/SampleHcdHandlers.scala#L91-L97" target="_blank" title="Go to snippet source"></a><code class="language-scala">override def validateCommand(controlCommand: ControlCommand): ValidateCommandResponse = {
  log.info(s&quot;Validating command: ${controlCommand.commandName.name}&quot;)
  controlCommand.commandName.name match {
    case &quot;sleep&quot; =&gt; Accepted(controlCommand.runId)
    case x       =&gt; Invalid(controlCommand.runId, CommandIssue.UnsupportedCommandIssue(s&quot;Command $x. not supported.&quot;))
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/nfiraos/samplehcd/JSampleHcdHandlers.java#L124-L132" target="_blank" title="Go to snippet source"></a><code class="language-java">@Override
public CommandResponse.ValidateCommandResponse validateCommand(ControlCommand controlCommand) {
    String commandName = controlCommand.commandName().name();
    log.info(() -&gt; &quot;Validating command: &quot; + commandName);
    if (commandName.equals(&quot;sleep&quot;)) {
        return new CommandResponse.Accepted(controlCommand.runId());
    }
    return new CommandResponse.Invalid(controlCommand.runId(), new CommandIssue.UnsupportedCommandIssue(&quot;Command &quot; + commandName + &quot;. not supported.&quot;));
}</code></pre></dd>
</dl>
<h2><a href="#command-response" name="command-response" class="anchor"><span class="anchor-link"></span></a>Command Response</h2>
<p>The response returned from <code>validateCommand</code> hook of <code>ComponentHandlers</code> will be received by the Top Level Actor, who then sends the response back to sender. If the response returned was <code>Accepted</code>, then it either calls the <code>onSubmit</code> hook or the <code>onOneway</code> hook of <code>ComponentHandlers</code> depending on the wrapper(submit or oneway) in which the command was received. </p>
<p>If the command was received as a <code>Submit</code>, then the Top Level Actor adds the response returned from the <code>validateCommand</code> hook in the <code>CommandResponseManager</code>. If the response was <code>Accepted</code>, the TLA then calls the <code>onSubmit</code> hook of <code>ComponentHandlers</code>. </p>
<p>In case the command received by a component a <code>Oneway</code>, the response is not added to the <code>CommandResponseManager</code>, and the <code>onOneway</code> hook of <code>ComponentHandlers</code> is called.</p>
<p>The <code>CommandResponseManager</code> is responsible for managing and bookkeeping the command status of long running submit commands. The sender of the command (and any component, really) can query the command statuses or subscribe to changes in command statuses using <code>CommandService</code>. </p>
<p>The <code>CommandService</code> class provides helper methods for communicating with other components, and should be a component&rsquo;s primary means of sending commands to other components. This will be described in the next tutorial section, <a href="multiple-components.html#sending-commands">Sending Commands</a>.</p>
<p>When the <code>onSubmit</code> hook is called, it is the responsibility of component developers to update the status of the received command in the <code>CommandResponseManager</code> as it changes. The instance of commandResponseManager is provided in the <code>CswContext</code> object in <code>ComponentHandlers</code> and should be injected in any worker actor or other actor/class created for the component. </p>
<p>More details on methods available in <code>CommandResponseManager</code> can be found <a href="framework.html#managing-command-state">here</a>.</p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>We will implement command handling in the <code>onSubmit</code> hook. Note that this hook actually receives a <code>ControlCommand</code> as an argument, which can be either a <code>Setup</code> or an <code>Observe</code>. We will use pattern matching to handle the command if it is a <code>Setup</code> and forward to an <code>onSetup</code> handling method. <code>Observe</code> commands will be ignored. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/nfiraos/samplehcd/SampleHcdHandlers.scala#L101-L125" target="_blank" title="Go to snippet source"></a><code class="language-scala">override def onSubmit(controlCommand: ControlCommand): SubmitResponse = {
  log.info(s&quot;Handling command: ${controlCommand.commandName}&quot;)

  controlCommand match {
    case setupCommand: Setup =&gt; onSetup(setupCommand)
    case observeCommand: Observe =&gt; // implement (or not)
      Error(controlCommand.runId, &quot;Observe not supported&quot;)
  }
}

def onSetup(setup: Setup): SubmitResponse = {
  val sleepTimeKey: Key[Long] = KeyType.LongKey.make(&quot;SleepTime&quot;)

  // get param from the Parameter Set in the Setup
  val sleepTimeParam: Parameter[Long] = setup(sleepTimeKey)

  // values of parameters are arrays. Get the first one (the only one in our case) using `head` method available as a convenience method on `Parameter`.
  val sleepTimeInMillis: Long = sleepTimeParam.head

  log.info(s&quot;command payload: ${sleepTimeParam.keyName} = $sleepTimeInMillis&quot;)

  workerActor ! Sleep(setup.runId, sleepTimeInMillis)

  Started(setup.runId)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/nfiraos/samplehcd/JSampleHcdHandlers.java#L137-L165" target="_blank" title="Go to snippet source"></a><code class="language-java">@Override
public CommandResponse.SubmitResponse onSubmit(ControlCommand controlCommand) {
    log.info(() -&gt; &quot;Handling command: &quot; + controlCommand.commandName());

    if (controlCommand instanceof Setup) {
        onSetup((Setup) controlCommand);
        return new CommandResponse.Started(controlCommand.runId());
    } else if (controlCommand instanceof Observe) {
        // implement (or not)
    }
    return new CommandResponse.Error(controlCommand.runId(), &quot;Observe command not supported&quot;);
}

private void onSetup(Setup setup) {
    Key&lt;Long&gt; sleepTimeKey = JKeyType.LongKey().make(&quot;SleepTime&quot;);

    // get param from the Parameter Set in the Setup
    Optional&lt;Parameter&lt;Long&gt;&gt; sleepTimeParamOption = setup.jGet(sleepTimeKey);

    // values of parameters are arrays.  Get the first one (the only one in our case) using `head` method available as a convenience method on `Parameter`.
    if (sleepTimeParamOption.isPresent()) {
        Parameter&lt;Long&gt; sleepTimeParam = sleepTimeParamOption.get();
        long sleepTimeInMillis = sleepTimeParam.head();

        log.info(() -&gt; &quot;command payload: &quot; + sleepTimeParam.keyName() + &quot; = &quot; + sleepTimeInMillis);

        workerActor.tell(new Sleep(setup.runId(), sleepTimeInMillis));
    }
}</code></pre></dd>
</dl>
<p>In our example, the <code>sleep</code> command has one parameter called <code>SleepTime</code>. We retrieve this parameter from the <code>Setup</code> by creating a <code>Key</code> to this parameter using the name and type, and then calling an <code>apply</code> method on the <code>Setup</code> (the <code>setup(longkey)</code> shorthand) which finds the matching <code>Parameter</code> in the <code>Setup</code>&rsquo;s <code>ParameterSet</code> (use the <code>Setup.jget()</code> method in Java). By doing this, the <code>Parameter</code> is returned with the proper typing, and so the values retrieved from the <code>Parameter</code> are typed as well. Note, all values are stored as an array, so we get our single value for <code>SleepTime</code> by using the <code>head</code> method available as a convenience method on <code>ParameterSet</code>.</p>
<p>At this point, to prevent our HCD from blocking while handling the command, we pass it off to a worker actor, which we will specify somewhere in this class. This could be defined in a separate class, but writing it as an internal class allows us to use the logging facility and <code>CommandResponseManager</code> without having to inject them into our new Actor class.</p>
<p>Note that our <code>onSetup</code> command handling logic returns a <code>Started</code> response. This indicates that the command is a long-running command and will be finished after some time, and that the final result will be posted to the <code>CommandResponseManager</code>. The <code>submit</code> command in the CommandService is implemented such that when it receives the <code>Started</code> response, it automatically starts a subscription to the <code>CommandResponseManager</code> for the final response, and when it is published, the Future returned by <code>submit</code> command is completed with this value.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/nfiraos/samplehcd/SampleHcdHandlers.scala#L32-L49" target="_blank" title="Go to snippet source"></a><code class="language-scala">sealed trait WorkerCommand                      extends TMTSerializable
case class Sleep(runId: Id, timeInMillis: Long) extends WorkerCommand

private val workerActor =
  ctx.spawn(
    Behaviors.receiveMessage[WorkerCommand](msg =&gt; {
      msg match {
        case sleep: Sleep =&gt;
          log.trace(s&quot;WorkerActor received sleep command with time of ${sleep.timeInMillis} ms&quot;)
          // simulate long running command
          Thread.sleep(sleep.timeInMillis)
          commandResponseManager.addOrUpdateCommand(CommandResponse.Completed(sleep.runId))
        case _ =&gt; log.error(&quot;Unsupported message type&quot;)
      }
      Behaviors.same
    }),
    &quot;WorkerActor&quot;
  )</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/nfiraos/samplehcd/JSampleHcdHandlers.java#L50-L79" target="_blank" title="Go to snippet source"></a><code class="language-java">private interface WorkerCommand extends TMTSerializable {
}

private static final class Sleep implements WorkerCommand {
    private final Id runId;
    private final long timeInMillis;

    private Sleep(Id runId, long timeInMillis) {
        this.runId = runId;
        this.timeInMillis = timeInMillis;
    }
}

private ActorRef&lt;WorkerCommand&gt; createWorkerActor() {
    return actorContext.spawn(
            Behaviors.receiveMessage(msg -&gt; {
                if (msg instanceof Sleep) {
                    Sleep sleep = (Sleep) msg;
                    log.trace(() -&gt; &quot;WorkerActor received sleep command with time of &quot; + sleep.timeInMillis + &quot; ms&quot;);
                    // simulate long running command
                    Thread.sleep(sleep.timeInMillis);
                    cswCtx.commandResponseManager().addOrUpdateCommand(new CommandResponse.Completed(sleep.runId));
                } else {
                    log.error(&quot;Unsupported message type&quot;);
                }
                return Behaviors.same();
            }),
            &quot;WorkerActor&quot;
    );
}</code></pre></dd>
</dl>
<p>This worker actor simply takes the time passed in the message, sleeps that amount, and then updates the <code>CommandResponseManager</code> that the command is complete.</p><div class="callout note "><div class="callout-title">Note</div>
<p>If the component developer creates new set of messages for worker actor then it is mandatory that those messages extend <code>TMTSerializable</code> which will enable messages to serialize on wire.</p></div>
<h2><a href="#events" name="events" class="anchor"><span class="anchor-link"></span></a>Events</h2>
<p>CSW <code>Events</code> have a similar structure to commands, in that along with a name and a prefix (used to represent the source of the event), they include data represented in the <code>Event</code> in a set of parameters. </p>
<p>More details about events can be found <a href="../messages/events.html">here</a>.</p>
<p>Access to the Event Service is in the <code>CswContext</code> object passed in to the handlers class in the constructor. The Event Service provides a factory method to create a &ldquo;default&rdquo; publisher and subscriber, which can be accessed in various parts of your code to reuse a single connection to the service. In most cases, reusing this connection will provide the performance needed.<br/>But if you prefer to create new connections, custom publishers and subscribers can be constructed. See the manual on the <a href="../services/event.html">Event Service</a> for more information.</p>
<p>Publishers have an API that allows the publishing of a single event, a stream of events, or periodic events created by an <code>EventGenerator</code>, which is simply a function that returns an event. </p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>Let&rsquo;s add a publisher to our component. We will use the default publisher that will periodically publish events generated by an <code>EventGenerator</code>. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/nfiraos/samplehcd/SampleHcdHandlers.scala#L71-L87" target="_blank" title="Go to snippet source"></a><code class="language-scala">import scala.concurrent.duration._
private def publishCounter(): Cancellable = {
  var counter = 0
  def incrementCounterEvent() = {
    counter += 1
    val param: Parameter[Int] = KeyType.IntKey.make(&quot;counter&quot;).set(counter)
    SystemEvent(componentInfo.prefix, EventName(&quot;HcdCounter&quot;)).add(param)
  }

  log.info(&quot;Starting publish stream.&quot;)
  eventService.defaultPublisher.publish(incrementCounterEvent(), 2.second, err =&gt; log.error(err.getMessage, ex = err))
}

private def stopPublishingGenerator(): Unit = {
  log.info(&quot;Stopping publish stream&quot;)
  maybePublishingGenerator.foreach(_.cancel)
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/nfiraos/samplehcd/JSampleHcdHandlers.java#L105-L120" target="_blank" title="Go to snippet source"></a><code class="language-java">private int counter = 0;
private Event incrementCounterEvent() {
    counter += 1;
    Parameter&lt;Integer&gt; param = JKeyType.IntKey().make(&quot;counter&quot;).set(counter);
    return new SystemEvent(cswCtx.componentInfo().prefix(), new EventName(&quot;HcdCounter&quot;)).add(param);
}

private Cancellable publishCounter() {
    log.info(&quot;Starting publish stream.&quot;);
    return cswCtx.eventService().defaultPublisher().publish(this::incrementCounterEvent, java.time.Duration.ofSeconds(2));
}

private void stopPublishingGenerator() {
    log.info(&quot;Stopping publish stream&quot;);
    maybePublishingGenerator.ifPresent(Cancellable::cancel);
}</code></pre></dd>
</dl>
<p>We encapsulate the starting of the publishing in our method <code>publishCounter</code>. Our <code>EventGenerator</code> is the <code>incrementCounterEvent</code> method which increments our integer variable <code>counter</code> and stores it in the <code>ParameterSet</code> of a new <code>SystemEvent</code> and returns it. Once our <code>defaultPublisher</code> is resolved, we pass in a reference to <code>incrementCounterEvent</code> and specify a period of 2 seconds. We log a message when publishing the event so that it can be observed when running the component.</p>
<p>The <code>publish</code> method returns a <code>Cancellable</code> type in a future. When the publishing is set up, the <code>Cancellable</code> can be used to stop the event generator. We demonstrate its usage in the <code>stopPublishingGenerator</code> method, although this method is not called in our tutorial.</p>
<p>We will start this publishing when our component initializes, so we return to our <code>initialize</code> method and add a call to our <code>publishCounter</code> method. We save a reference to the <code>Cancellable</code> object for future use in our <code>stopPublishingGenerator</code> method. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/nfiraos/samplehcd/SampleHcdHandlers.scala#L53-L67" target="_blank" title="Go to snippet source"></a><code class="language-scala">var maybePublishingGenerator: Option[Cancellable] = None
override def initialize(): Future[Unit] = {
  log.info(&quot;In HCD initialize&quot;)
  maybePublishingGenerator = Some(publishCounter())
  Future.unit
}

override def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = {
  log.debug(s&quot;TrackingEvent received: ${trackingEvent.connection.name}&quot;)
}

override def onShutdown(): Future[Unit] = {
  log.info(&quot;HCD is shutting down&quot;)
  Future.unit
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/nfiraos/samplehcd/JSampleHcdHandlers.java#L84-L101" target="_blank" title="Go to snippet source"></a><code class="language-java">private Optional&lt;Cancellable&gt; maybePublishingGenerator = Optional.empty();
@Override
public CompletableFuture&lt;Void&gt; jInitialize() {
    return CompletableFuture.runAsync(() -&gt; {
        log.info(&quot;In HCD initialize&quot;);
        maybePublishingGenerator = Optional.of(publishCounter());
    });
}

@Override
public void onLocationTrackingEvent(TrackingEvent trackingEvent) {
    log.debug(() -&gt; &quot;TrackingEvent received: &quot; + trackingEvent.connection().name());
}

@Override
public CompletableFuture&lt;Void&gt; jOnShutdown() {
    return CompletableFuture.runAsync(() -&gt; log.info(&quot;HCD is shutting down&quot;));
}</code></pre></dd>
</dl>
<h2><a href="#starting-csw-services" name="starting-csw-services" class="anchor"><span class="anchor-link"></span></a>Starting CSW Services</h2>
<p>Before we run our application, we must first start the Location Service and the Event Service. A script has been provided to simplify the starting and stopping of CSW services, and is included in the application bundle that comes with each release. The application bundle is called </p>
<p>csw-apps-0.1-SNAPSHOT.zip </p>
<p>and the script is named <code>csw-services.sh</code>.</p>
<p>The <code>csw-services.sh</code> script has two basic commands: <code>start</code> and <code>stop</code>. The start command can start specific services using passed in flags, or all services without any. Services are started on default ports but those ports can be overridden using command line arguments. It is important to pass in a network interface name that is appropriate for your system. These can be obtained using <code>ifconfig</code> on Linux and Mac computers. <code>en0</code> typically works for most machines.</p>
<p>To get information on the arguments for the tool, use <code>csw-services.sh --help</code>.</p>
<h4><a href="#" name="" class="anchor"><span class="anchor-link"></span></a><em>Tutorial: Developing an HCD</em></h4>
<p>Let&rsquo;s go ahead and start our CSW Services using the script. Go to the <a href="https://github.com/tmtsoftware/csw/releases">release page</a> and download and unpack the CSW application bundle. Then go into the <code>bin</code> directory and enter the command</p>
<pre><code>./csw-services.sh start -i &lt;iname&gt;
</code></pre>
<p>where <code>&lt;iname&gt;</code> is your interface name (e.g. <code>en0</code>).</p>
<h2><a href="#building-and-running-component-in-standalone-mode" name="building-and-running-component-in-standalone-mode" class="anchor"><span class="anchor-link"></span></a>Building and Running component in standalone mode</h2>
<p>Once the component is ready, it is started using the <code>ContainerCmd</code> object in standalone mode. The details about starting the <code>ContainerCmd</code> in standalone mode can be found <a href="../framework/deploying-components.html">here</a>.</p>
<p>There are various ways to build and run the project. A simple way during development is to to use sbt to run it. The sbt command <code>runMain</code> can be used to specify an application with a main method and run it with arguments specified at the command line. When this command is executed, sbt will take care of any downloading of dependencies, compiling, or building necessary to run your application. </p>
<p>Our template includes a wrapper application around ContainerCmd that we can use in the deployment module. To run our HCD in standalone mode, go to the project root directory and type <code>sbt &quot;&lt;deploy-module&gt;/runMain &lt;mainClass&gt; --local --standalone &lt;path-to-config-file&gt;&quot;</code>, where</p>
<ul>
  <li><code>&lt;deploy-module&gt;</code> is the name of the deployment module created by the template (<code>sample-deploy</code> if using defaults)</li>
  <li><code>&lt;mainClass&gt;</code> is the full class name of our ContainerCmd application, which the template names <code>&lt;package&gt;.&lt;name&gt;deploy.&lt;Name&gt;ContainerCmdApp</code>. If you accept the defaults for the template, it will be <code>org.tmt.nfiraos.sampledeploy.SampleContainerCmdApp</code>. If you are having problems determining the class name, use <code>sbt &lt;deploy-module&gt;/run</code> and it will prompt you the possibilities.</li>
  <li><code>&lt;path-to-config-file&gt;</code> is the filename, which can be an absolute path or relative to the directory of the deployment module. If using defaults, this would be <code>src/main/resources/SampleHcdStandalone.conf</code> for Scala, and <code>src/main/resources/JSampleHcdStandalone.conf</code> for Java.</li>
</ul>
<p>So if using the template defaults, the full command would be </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre><code>sbt &quot;sample-deploy/runMain org.tmt.nfiraos.sampledeploy.SampleContainerCmdApp --local --standalone src/main/resources/SampleHcdStandalone.conf&quot;
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre><code>sbt &quot;sample-deploy/runMain org.tmt.nfiraos.sampledeploy.SampleContainerCmdApp --local --standalone src/main/resources/JSampleHcdStandalone.conf&quot;
</code></pre></dd>
</dl>
<p>To run the component using the deployment package, perform the following steps:</p>
<ul>
  <li>Run <code>sbt &lt;project&gt;/universal:packageBin</code>, where <code>&lt;project&gt;</code> is your deployment module (e.g. <code>sample-deploy</code>). This will create self contained zip in <code>&lt;project&gt;/target/universal</code> directory</li>
  <li>Unzip generated zip file and enter into bin directory</li>
  <li>Run the <code>./&lt;project&gt;-cmd-app --local --standalone &lt;path-to-local-config-file-to-start-the-component&gt;</code></li>
</ul>
<p>Alternatively, you can run <code>sbt stage</code>, which installs the application under target/universal/stage/bin.</p>
</div>
<div>
<a href="https://github.com/tmtsoftware/csw/tree/master/docs/src/main/commons/create-component.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.1*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../commons/getting-started.html" title="Getting Started" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Getting Started
</span>
</div>
</a>
<a href="../commons/multiple-components.html" title="Multiple Components" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Multiple Components
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
