<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="docs">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="docs">
<link rel="shortcut icon" href="../assets/tmt_favicon.ico">
<title>Communication using Commands Â· TMT Common Software (CSW)</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="TMT Common Software (CSW)" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
TMT Common Software (CSW)
</span>
<span class="md-header-nav__topic">
Communication using Commands
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/tmtsoftware/csw"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
tmtsoftware/csw
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="TMT Common Software (CSW)" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="TMT Common Software (CSW)">
TMT Common Software (CSW)
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/tmtsoftware/csw"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
tmtsoftware/csw
</div>
</a>

</div>
<ul>
  <li><a href="../commons/getting-started.html" class="page">Getting Started</a></li>
  <li><a href="../commons/create-component.html" class="page">Creating a Component</a></li>
  <li><a href="../commons/multiple-components.html" class="page">Multiple Components</a></li>
  <li><a href="../commons/using-alarms.html" class="page">Using Alarms</a></li>
  <li><a href="../commons/unit-tests.html" class="page">Adding Unit Tests</a></li>
  <li><a href="../commons/messages.html" class="page">Messages</a>
  <ul>
    <li><a href="../messages/keys-parameters.html" class="page">Keys and Parameters</a></li>
    <li><a href="../messages/units.html" class="page">Units</a></li>
    <li><a href="../messages/subsystem.html" class="page">Subsystem</a></li>
    <li><a href="../messages/commands.html" class="page">Commands</a></li>
    <li><a href="../messages/events.html" class="page">Events</a></li>
    <li><a href="../messages/states.html" class="page">State Variables</a></li>
    <li><a href="../messages/result.html" class="page">Result</a></li>
  </ul></li>
  <li><a href="../commons/framework.html" class="page">Framework for creating components (HCD, Assembly, Container)</a>
  <ul>
    <li><a href="../framework/describing-components.html" class="page">ComponentInfo</a></li>
    <li><a href="../framework/creating-components.html" class="page">Creating an Assembly or Hcd Component</a></li>
    <li><a href="../framework/handling-lifecycle.html" class="page">Component Handlers</a></li>
    <li><a href="../framework/managing-command-state.html" class="page">Managing Command State</a></li>
    <li><a href="../framework/tracking-connections.html" class="page">Tracking Connections</a></li>
    <li><a href="../framework/publishing-state.html" class="page">Publishing State</a></li>
    <li><a href="../framework/handling-exceptions.html" class="page">Handling Exceptions</a></li>
    <li><a href="../framework/deploying-components.html" class="page">Deploying Components</a></li>
  </ul></li>
  <li><a href="../commons/command.html" class="active page">Communication using Commands</a></li>
  <li><a href="../commons/services.html" class="page">Services</a>
  <ul>
    <li><a href="../services/location.html" class="page">Location Service</a></li>
    <li><a href="../services/config.html" class="page">Configuration Service</a></li>
    <li><a href="../services/logging.html" class="page">Logging Service</a></li>
    <li><a href="../services/event.html" class="page">Event Service</a></li>
    <li><a href="../services/alarm.html" class="page">Alarm Service</a></li>
    <li><a href="../services/time.html" class="page">Time Service</a></li>
    <li><a href="../services/database.html" class="page">Database Service</a></li>
    <li><a href="../services/aas.html" class="page">Authentication and Authorization Service (AAS)</a></li>
  </ul></li>
  <li><a href="../commons/apps.html" class="page">Applications</a>
  <ul>
    <li><a href="../apps/cswlocationserver.html" class="page">csw-location-server</a></li>
    <li><a href="../apps/cswadminserver.html" class="page">csw-admin-server</a></li>
    <li><a href="../apps/cswlocationagent.html" class="page">csw-location-agent</a></li>
    <li><a href="../apps/cswonfigserverapp.html" class="page">csw-config-server</a></li>
    <li><a href="../apps/cswconfigcli.html" class="page">csw-config-cli</a></li>
    <li><a href="../apps/csweventcli.html" class="page">csw-event-cli</a></li>
    <li><a href="../apps/cswalarmcli.html" class="page">csw-alarm-cli</a></li>
    <li><a href="../apps/hostconfig.html" class="page">csw-host-config</a></li>
  </ul></li>
  <li><a href="../commons/testing.html" class="page">Testing</a></li>
  <li><a href="../commons/sbt-tasks.html" class="page">sbt Tasks</a></li>
  <li><a href="../commons/manuals.html" class="page">Manuals</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../commons/command.html#communication-using-commands" class="header">Communication using Commands</a>
  <ul>
    <li><a href="../commons/command.html#dependencies" class="header">Dependencies</a></li>
    <li><a href="../commons/command.html#command-based-communication-between-components" class="header">Command-based Communication Between Components</a></li>
    <li><a href="../commons/command.html#commandservice" class="header">CommandService</a></li>
    <li><a href="../commons/command.html#matching-state-for-command-completion" class="header">Matching state for command completion</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.1*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../commons/command.html#communication-using-commands" class="header">Communication using Commands</a>
  <ul>
    <li><a href="../commons/command.html#dependencies" class="header">Dependencies</a></li>
    <li><a href="../commons/command.html#command-based-communication-between-components" class="header">Command-based Communication Between Components</a></li>
    <li><a href="../commons/command.html#commandservice" class="header">CommandService</a></li>
    <li><a href="../commons/command.html#matching-state-for-command-completion" class="header">Matching state for command completion</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#communication-using-commands" name="communication-using-commands" class="anchor"><span class="anchor-link"></span></a>Communication using Commands</h1>
<p><strong>csw-command</strong> library provides support for command based communication between components. </p>
<p>This section describes how to communicate with any other component using commands. To check how to manage commands received, please visit <a href="../framework/managing-command-state.html">Managing Command State</a></p>
<h2><a href="#dependencies" name="dependencies" class="anchor"><span class="anchor-link"></span></a>Dependencies</h2>
<dl>
  <dt>sbt</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;com.github.tmtsoftware.csw&quot; %% &quot;csw-command&quot; % &quot;0.1-SNAPSHOT&quot;
</code></pre></dd>
</dl>
<h2><a href="#command-based-communication-between-components" name="command-based-communication-between-components" class="anchor"><span class="anchor-link"></span></a>Command-based Communication Between Components</h2>
<p>A component can send <a href="../messages/commands.html">Commands</a> to other components. The commands can be sent as following with three types of messages: </p>
<ul>
  <li><strong>submit</strong> - A command is sent as Submit when the result of completion is desired.</li>
  <li><strong>oneway</strong> - A command is sent as Oneway when the result of completion is not desired.</li>
  <li><strong>validate</strong> - A command is sent, but it is only validated with no actions started.</li>
</ul>
<p>A <code>submit</code> is the typical way of sending a command from one component to another. When received, a <code>submit</code> command is validated and if accepted, the actions associated with the command are executed or started. <code>submit</code> has a different responses that allow for different scenarios. When the actions started are long-running, the caller can wait for the actions to complete if needed.</p>
<p>A <code>oneway</code> is primarily meant to be used between an Assembly and an HCD when no completion information is desired. It is also useful when tracking completion using a Matcher and current state values (see below) or events.</p>
<p>A <code>validate</code> message is used to ask a destination component to validate a command and determine if the command can be executed. But it does not execute the command and returns the result of validation. In some scenarios, it may be useful to test to see if a command can be executed prior to trying to execute the command.</p><div class="callout warning "><div class="callout-title">Significant Update to Command Service</div>
<p>Thanks to an issue brought up by a user of Release 0.4, the Command Service API and command-related component handlers have been modified in this release. The result is a much improved, simplified API that is easier to understand, and refines the responsibilities of the handlers. Code that has been written for 0.5 or 0.4 will need to be updated.</p></div>
<h3><a href="#command-validation" name="command-validation" class="anchor"><span class="anchor-link"></span></a>Command Validation</h3>
<p>The first step in processing a command&ndash;either <code>submit</code> or <code>oneway</code>&ndash;is validation. If not locked, the component&rsquo;s supervisor calls the <code>validateCommand</code> handler of the Top Level Actor. The developer code evaluates and returns a <code>ValidateCommandResponse</code> as shown in the following table. </p>
<table>
  <thead>
    <tr>
      <th align="center">ValidateCommandResponse </th>
      <th>Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="center">Accepted </td>
      <td>The command is valid and can be executed by the component. </td>
    </tr>
    <tr>
      <td align="center">Invalid </td>
      <td>The command is not valid and cannot be executed. The response includes a reason in the form of a <code>CommandIssue</code> </td>
    </tr>
    <tr>
      <td align="center">Locked </td>
      <td>The component is locked by some other command sender. The validation could not occur.</td>
    </tr>
  </tbody>
</table>
<p>Note that the developer code does not need to return <code>Locked</code>. If the component has been Locked, the component&rsquo;s Supervisor returns the <code>Locked</code> response to the caller and the <code>validateCommand</code> handler is not called.</p>
<h3><a href="#the-submit-message" name="the-submit-message" class="anchor"><span class="anchor-link"></span></a>The Submit Message</h3>
<p>A <code>submit</code> message is sent with its <a href="../messages/commands.html">command</a> to a component destination. A <code>SubmitResponse</code> is returned to the caller when the <code>submit</code> message is used. If the <code>validateCommand</code> handler returns <code>Accepted</code>, the framework calls the <code>onSubmit</code> handler of the Top Level Actor. The <code>onSubmit</code> handler always returns a <code>SubmitResponse</code>.</p>
<h4><a href="#immediate-completion-scenario" name="immediate-completion-scenario" class="anchor"><span class="anchor-link"></span></a>Immediate Completion Scenario</h4>
<p>If the actions of the <code>submit</code> command take a very short time to complete they may be completed by the <code>onSubmit</code> handler. This is called <em>immediate completion</em>. The time for the actions to complete should be less than 1 second. (Note: The framework will timeout if the onSubmit handler does not return a response within 1 second.) In this scenario with <code>onSubmit</code>, the values of <code>SubmitResponse</code> can be <code>Completed</code>, <code>CompletedWithResult</code>, or <code>Error</code>. <code>Error</code> is returned when the actions could not be accomplished. This is different than <code>Invalid</code>, which indicates that the command could not be validated.</p>
<p>The immediate completion behavior is similar to a remote procedure call although the execution is entirely asynchronous. If the actions do not produce a value for the client, the <code>Completed</code> <code>SubmitResponse</code> is returned. If there is a result, the <code>CompletedWithResult</code> <code>SubmitResult</code> is returned with a parameter set of <code>Result</code> type.</p>
<h4><a href="#long-running-actions-scenario" name="long-running-actions-scenario" class="anchor"><span class="anchor-link"></span></a>Long Running Actions Scenario</h4>
<p>When actions take longer than 1 second, <code>onSubmit</code> should start the actions and return the <code>Started</code> <code>SubmitResponse</code>. The <code>Started</code> response indicates to the framework that long running actions have been started. In this case, the <code>Started</code> is returned to the sender of the command. Note, however, that the response returned to the sender by <code>submit</code> in the Command Service API is the final <code>SubmitResponse</code> returned when the actions are finished, not <code>Started</code>.</p>
<p>Once the long running actions have started, the client code must notify the framework when the actions are completed. This is done be updating the <a href="../framework/managing-command-state.html">Command Response Manager</a>.</p>
<p>In addition to the values returned for immediate completion, long running actions can return <code>Cancelled</code>. If the component supports a special command to cancel actions, the cancelled command should return <code>Cancelled</code> when successfully cancelled and the command that cancels a command should return <code>Completed</code>.</p>
<p>The following table summarizes all the possible values for <code>SubmitResponse</code>.</p>
<table>
  <thead>
    <tr>
      <th align="center">SubmitResponse </th>
      <th>Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="center">Invalid </td>
      <td>The command is not valid and cannot be executed. The response includes a reason in the form of a <code>CommandIssue</code>. <code>onSubmit</code> is not executed. </td>
    </tr>
    <tr>
      <td align="center">Completed </td>
      <td>This response is returned when the actions associated with a command are complete. </td>
    </tr>
    <tr>
      <td align="center">CompletedWithResult </td>
      <td>This response is returned when the actions associated with a command are complete and a result is returned. </td>
    </tr>
    <tr>
      <td align="center">Started </td>
      <td>Returned when long running actions have been started. </td>
    </tr>
    <tr>
      <td align="center">Error </td>
      <td>Error is returned the the actions started by a command do not complete properly. A message is returned explaining the error. </td>
    </tr>
    <tr>
      <td align="center">Cancelled </td>
      <td>The actions associated with a long running command have been cancelled. </td>
    </tr>
    <tr>
      <td align="center">Locked </td>
      <td>The component is locked by some other command sender. The validation could not occur. </td>
    </tr>
  </tbody>
</table>
<h3><a href="#the-oneway-message" name="the-oneway-message" class="anchor"><span class="anchor-link"></span></a>The Oneway Message</h3>
<p>The other option for sending a <a href="../messages/commands.html">command</a> to a component destination is the <code>oneway</code> message. The central difference between <code>submit</code> and <code>oneway</code> is that <code>oneway</code> does not track or allow reporting of completion information. It supports a <em>fire and forget</em> type of communication approach.</p>
<p>A <code>OnewayResponse</code> is returned to the caller when the <code>oneway</code> message is used. <code>Oneway</code> does validate the command. If the component is not locked, the <code>validateCommand</code> handler is called.<br/>If the <code>validateCommand</code> handler returns <code>Accepted</code>, the framework calls the <code>onOneway</code> handler of the Top Level Actor. However, the <code>onOneway</code> handler does not return a value. The sender of the <code>oneway</code> message receives the result of the validation or the Locked indication. </p>
<p>The following table summarizes all the possible values for <code>OnewayResponse</code>.</p>
<table>
  <thead>
    <tr>
      <th align="center">OnewayResponse </th>
      <th>Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="center">Invalid </td>
      <td>The command is not valid and cannot be executed. The response includes a reason in the form of a <code>CommandIssue</code>. <code>onSubmit</code> is not executed. </td>
    </tr>
    <tr>
      <td align="center">Accepted </td>
      <td>Returned when validation succeeds and the command was passed to the <code>onOneway</code> handler. </td>
    </tr>
    <tr>
      <td align="center">Locked </td>
      <td>The component is locked by some other command sender. The validation could not occur. </td>
    </tr>
  </tbody>
</table>
<p><code>Oneway</code> is available as a higher performance option when an Assembly needs to send commands to an HCD but doesn&rsquo;t really care about completion such as the case when demands are being sent to a motor. Validation is still present to ensure the HCD supports the standalone operation requirement and can check that it is not getting out of range values.</p>
<p><code>Oneway</code> is can be used with a <em>matcher</em>. The matcher can use CurrentState or even events from Event Service to determine completion. This is more complicated than <code>submit</code> but may be useful in some scenarios.</p>
<h3><a href="#the-validate-message" name="the-validate-message" class="anchor"><span class="anchor-link"></span></a>The Validate Message</h3>
<p>The <code>validate</code> message is available when the sender wants to validate a <a href="../messages/commands.html">command</a> but does not want to execute any associated actions. <code>Validate</code> returns a <code>ValidateResponse</code>. If the component is not locked, the <code>validateCommand</code> handler of the Top Level Actor is called and the developer code evaluates the command and returns a <code>ValidateResponse</code> as shown in the following table. </p>
<table>
  <thead>
    <tr>
      <th align="center">ValidateResponse </th>
      <th>Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="center">Accepted </td>
      <td>The command is valid and can be executed by the component. </td>
    </tr>
    <tr>
      <td align="center">Invalid </td>
      <td>The command is not valid and cannot be executed. The response includes a reason in the form of a <code>CommandIssue</code> </td>
    </tr>
    <tr>
      <td align="center">Locked </td>
      <td>The component is locked by some other command sender. The validation could not occur.</td>
    </tr>
  </tbody>
</table>
<p><code>Validate</code> could be used by an Assembly when it needs to send multiple commands to different HCDs and it wants to first check that all the HCDs can execute their commands before sending a command to any of the HCDs. </p>
<h2><a href="#commandservice" name="commandservice" class="anchor"><span class="anchor-link"></span></a>CommandService</h2>
<p>A helper/wrapper is provided called <code>CommandService</code> that provides a convenient way to use the Command Service with a component from the Location Service. </p>
<p>A <code>CommandService</code> instance is created using an <code>AkkaLocation</code> discovered from the Location Service. This <code>CommandService</code> instance will has methods for communicating with the component. A new <code>CommandService</code> is created for each component for which commands are to be sent.</p>
<p>The API can be exercised as follows for different scenarios of command-based communication:</p>
<h3><a href="#submit" name="submit" class="anchor"><span class="anchor-link"></span></a>submit</h3>
<p>Sending a <code>submit</code> message with a command returns a <code>SubmitResponse</code> as a Future. The Future returned by <code>submit</code> will always be the final response, which may be a positive completion (Completed or CompletedWithResult) or a negative completion (<code>Invalid</code>, <code>Error</code>, <code>Cancelled</code>, <code>Locked</code>). The <code>Started</code> response is never seen by the programmer when using the <code>submit</code> of <code>CommandService</code>.</p>
<p>This example shows an immediate completion command using <code>submit</code> that returns <code>Completed</code>.</p>
<dl>
  <dt>Scala/submit w/immediate-response
  </dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L164-L174" target="_blank" title="Go to snippet source"></a><code class="language-scala">val immediateSetup = Setup(prefix, immediateCmd, obsId)
val immediateCommandF = async {
  await(assemblyCmdService.submit(immediateSetup)) match {
    case response: Completed â
      //do something with completed result
      response
    case otherResponse â
      // do something with other response which is not expected
      otherResponse
  }
}</code></pre></dd>
  <dt>Java/submit w/immediate-response
  </dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L126-L138" target="_blank" title="Go to snippet source"></a><code class="language-java">CompletableFuture&lt;CommandResponse.SubmitResponse&gt; immediateCommandF =
        hcdCmdService
                .submit(immediateCmd, timeout)
                .thenApply(
                        response -&gt; {
                            if (response instanceof CommandResponse.Completed) {
                                //do something with completed result
                            } else {
                                // do something with unexpected response
                            }
                            return response;
                        }
                );</code></pre></dd>
</dl>
<p>Note that the Scala examples are using <code>async/await</code> which simplifies handling the Futures, but is not necessary. The <code>async/await</code> library is not available in Java. If using <code>submit</code> and the validation fails in the destination component, the <code>Invalid</code> response is returned.</p>
<dl>
  <dt>Scala/submit w/invalid response</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L146-L158" target="_blank" title="Go to snippet source"></a><code class="language-scala">val invalidSetup    = Setup(prefix, invalidCmd, obsId)
val invalidCommandF = assemblyCmdService.submit(invalidSetup)
async {
  await(invalidCommandF) match {
    case Completed(runId) =&gt;
    // Do Completed thing
    case Invalid(runId, issue) =&gt;
      issue shouldBe a[Invalid]
    case other =&gt;
      // Unexpected result
      log.error(s&quot;Some other response: $other&quot;)
  }
}</code></pre></dd>
  <dt>Java/submit w/invalid response</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L145-L158" target="_blank" title="Go to snippet source"></a><code class="language-java">Setup invalidSetup = new Setup(prefix(), invalidCmd(), Optional.empty()).add(intParameter2);
CompletableFuture&lt;CommandResponse.SubmitResponse&gt; invalidCommandF =
        hcdCmdService.submit(invalidSetup, timeout).thenApply(
                response -&gt; {
                    if (response instanceof CommandResponse.Completed) {
                        //do something with completed result
                    } else if (response instanceof CommandResponse.Invalid) {
                        // Cast the response to get the issue
                        CommandResponse.Invalid invalid = (CommandResponse.Invalid) response;
                        assert (invalid.issue().reason().contains(&quot;failure&quot;));
                    }
                    return response;
                }
        );</code></pre></dd>
</dl>
<p>The handling of long-running and immediate completion commands look the same from the command sender&rsquo;s perspective. The following example shows a long-running command that returns a value when the command action completes with a result.</p>
<dl>
  <dt>Scala/submit long running</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L179-L190" target="_blank" title="Go to snippet source"></a><code class="language-scala">val longRunningSetup1 = Setup(prefix, longRunningCmd, obsId)

val longRunningResultF = async {
  await(assemblyCmdService.submit(longRunningSetup1)) match {
    case CompletedWithResult(_, result) =&gt;
      Some(result(encoder).head)

    case otherResponse =&gt;
      // log a message?
      None
  }
}</code></pre></dd>
  <dt>Java/submit long running</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L169-L184" target="_blank" title="Go to snippet source"></a><code class="language-java">Setup longRunningSetup1 = new Setup(prefix(), longRunningCmd(), Optional.empty()).add(intParameter1);
Key&lt;Integer&gt; encoder = JKeyType.IntKey().make(&quot;encoder&quot;);
CompletableFuture&lt;Optional&lt;Integer&gt;&gt; longRunningResultF =
        hcdCmdService.submit(longRunningSetup1, timeout)
                .thenCompose(response -&gt; {
                    if (response instanceof CommandResponse.CompletedWithResult) {
                        // This extracts and returns the the first value of parameter encoder
                        Result result = ((CommandResponse.CompletedWithResult) response).result();
                        Optional&lt;Integer&gt; rvalue = Optional.of(result.jGet(encoder).get().head());
                        return CompletableFuture.completedFuture(rvalue);
                    } else {
                        // For some other response, return empty
                        return CompletableFuture.completedFuture(Optional.empty());
                    }

                });</code></pre></dd>
</dl>
<p>If a command is long-running and the sender needs to determine that the actions have started properly, the <code>query</code> method of <code>CommandService</code> can be used as shown in the following example without using the Future returned by <code>submit</code>, which provides the final completion notification.</p>
<dl>
  <dt>Scala/submit long running/query</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L198-L221" target="_blank" title="Go to snippet source"></a><code class="language-scala">val longRunningSetup2 = longRunningSetup1.cloneCommand
val longRunningQueryResultF = async {
  // The following val is set so we can do query and work and complete later
  val longRunningF = assemblyCmdService.submit(longRunningSetup2)

  await(assemblyCmdService.query(longRunningSetup2.runId)) match {
    case Started(runId) =&gt;
    // happy case - no action needed
    // Do some other work
    case a =&gt;
    // log.error. This indicates that the command probably failed to start.
  }

  // Now wait for completion and result
  await(longRunningF) match {
    case CompletedWithResult(_, result) =&gt;
      Some(result(encoder).head)

    case otherResponse =&gt;
      // log a message?
      None
  }
}
Await.result(longRunningQueryResultF, timeout.duration) shouldBe Some(20)</code></pre></dd>
  <dt>Java/submit long running/query</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L191-L218" target="_blank" title="Go to snippet source"></a><code class="language-java">Setup longRunningSetup2 = longRunningSetup1.cloneCommand();
CompletableFuture&lt;CommandResponse.SubmitResponse&gt; longRunningQueryResultF =
        hcdCmdService.submit(longRunningSetup2, timeout);

// do some work before querying for the result of above command as needed
CompletableFuture&lt;CommandResponse.QueryResponse&gt; queryResponseF = hcdCmdService.query(longRunningSetup2.runId(), timeout);
queryResponseF.thenAccept(r -&gt; {
    if (r instanceof CommandResponse.Started) {
        // happy case - no action needed
        // Do some other work
    } else {
        // log.error. This indicates that the command probably failed to start.
    }
});

CompletableFuture&lt;Optional&lt;Integer&gt;&gt; intF =
        longRunningQueryResultF.thenCompose(response -&gt; {
    if (response instanceof CommandResponse.CompletedWithResult) {
        // This extracts and returns the the first value of parameter encoder
        Result result = ((CommandResponse.CompletedWithResult) response).result();
        Optional&lt;Integer&gt; rvalue = Optional.of(result.jGet(encoder).get().head());
        return CompletableFuture.completedFuture(rvalue);
    } else {
        // For some other response, return empty
        return CompletableFuture.completedFuture(Optional.empty());
    }
});
Assert.assertEquals(Optional.of(20), intF.get());</code></pre></dd>
</dl>
<p>It&rsquo;s also possible to use the runId of the <code>Setup</code> with <code>queryFinal</code> to determine when the actions are completed. This is equivalent to using the Future returned by <code>submit</code>, but in this case, the original Future from <code>submit</code> is not available.</p>
<dl>
  <dt>Scala/submit long running/queryFinal</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L226-L241" target="_blank" title="Go to snippet source"></a><code class="language-scala">val longRunningSetup3 = longRunningSetup1.cloneCommand
val queryFinalF = async {
  // The following submit is made without saving the Future!
  assemblyCmdService.submit(longRunningSetup3)

  // Use queryFinal and runId to wait for completion and result
  await(assemblyCmdService.queryFinal(longRunningSetup3.runId)) match {
    case CompletedWithResult(_, result) =&gt;
      Some(result(encoder).head)

    case otherResponse =&gt;
      // log a message?
      None
  }
}
Await.result(queryFinalF, timeout.duration) shouldBe Some(20)</code></pre></dd>
  <dt>Java/submit long running/queryFinal</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L222-L237" target="_blank" title="Go to snippet source"></a><code class="language-java">Setup longRunningSetup3 = longRunningSetup1.cloneCommand();
hcdCmdService.submit(longRunningSetup3, timeout);

CompletableFuture&lt;Optional&lt;Integer&gt;&gt; int3F =
        hcdCmdService.queryFinal(longRunningSetup3.runId(), timeout).thenCompose(response -&gt; {
            if (response instanceof CommandResponse.CompletedWithResult) {
                // This extracts and returns the the first value of parameter encoder
                Result result = ((CommandResponse.CompletedWithResult) response).result();
                Optional&lt;Integer&gt; rvalue = Optional.of(result.jGet(encoder).get().head());
                return CompletableFuture.completedFuture(rvalue);
            } else {
                // For some other response, return empty
                return CompletableFuture.completedFuture(Optional.empty());
            }
        });
Assert.assertEquals(Optional.of(20), int3F.get());</code></pre></dd>
</dl>
<h3><a href="#oneway" name="oneway" class="anchor"><span class="anchor-link"></span></a>oneway</h3>
<p><code>Oneway</code> does not provide completion information but does return the result of <code>validateCommand</code> handler in the Top-Level-Actor (<code>Accepted</code>, <code>Invalid</code>, or <code>Locked</code>). When sending a command as a <code>oneway</code> message, a <code>OnewayResponse</code> is returned as a Future that can be used to check that it was validated. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L245-L256" target="_blank" title="Go to snippet source"></a><code class="language-scala">// `onewayCmd` is a sample to demonstrate oneway without any actions
val onewaySetup = Setup(prefix, onewayCmd, obsId)
// Don&#39;t care about the futures from async
val oneWayF = async {
  await(assemblyCmdService.oneway(onewaySetup)) match {
    case invalid: Invalid â
    // Log an error here
    case _ â
    // Ignore anything other than invalid
  }
}
Await.ready(oneWayF, timeout.duration)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L241-L250" target="_blank" title="Go to snippet source"></a><code class="language-java">Setup onewaySetup = new Setup(prefix(), onewayCmd(), Optional.empty()).add(intParameter1);
CompletableFuture onewayF = hcdCmdService
        .oneway(onewaySetup, timeout)
        .thenAccept(onewayResponse -&gt; {
            if (onewayResponse instanceof CommandResponse.Invalid) {
                // log an error here
            } else {
                // Ignore anything other than invalid
            }
        });</code></pre></dd>
</dl>
<h3><a href="#validate" name="validate" class="anchor"><span class="anchor-link"></span></a>validate</h3>
<p>Sometimes it may be useful to test whether or not a component can execute a command without committing to executing its actions. The <code>validate</code> message can be used for this purpose. <code>Validate</code> returns a <code>ValidateResponse</code> of <code>Accepted</code>, <code>Invalid</code>, or <code>Locked</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L260-L270" target="_blank" title="Go to snippet source"></a><code class="language-scala">val validateCommandF = async {
  await(assemblyCmdService.validate(immediateSetup)) match {
    case response: Accepted â true
    case Invalid(_, issue)  â
      // do something with other response which is not expected
      log.error(s&quot;Command failed to validate with issue: $issue&quot;)
      false
    case l: Locked =&gt; false
  }
}
Await.result(validateCommandF, timeout.duration) shouldBe true</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L241-L250" target="_blank" title="Go to snippet source"></a><code class="language-java">Setup onewaySetup = new Setup(prefix(), onewayCmd(), Optional.empty()).add(intParameter1);
CompletableFuture onewayF = hcdCmdService
        .oneway(onewaySetup, timeout)
        .thenAccept(onewayResponse -&gt; {
            if (onewayResponse instanceof CommandResponse.Invalid) {
                // log an error here
            } else {
                // Ignore anything other than invalid
            }
        });</code></pre></dd>
</dl>
<h3><a href="#query" name="query" class="anchor"><span class="anchor-link"></span></a>query</h3>
<p>At any time, the <code>query</code> call of <code>CommandService</code> can be used to check the current status of a command that has been sent via the <code>submit</code> message using the command&rsquo;s <code>runId</code>. This is most useful with a long-running command but all commands that use <code>submit</code> are available.</p>
<p>The <code>query</code> message returns a <code>QueryResponse</code>, which includes all of the values of <code>SubmitResponse</code> plus the <code>CommandNotAvailable</code> response. This response occurs when the framework has no knowledge of the command associated with the <code>runId</code> passed with the <code>query</code>. The previous long-running example above showed the use of <code>query</code> to check that the actions associated with a command that had started. Another usage is to check the final value of a command that is already completed using its <code>runId</code>.</p>
<dl>
  <dt>Scala/query usage</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L277-L279" target="_blank" title="Go to snippet source"></a><code class="language-scala">// Check on a command that was completed in the past
val queryValue = Await.result(assemblyCmdService.query(longRunningSetup2.runId), timeout.duration)
queryValue shouldBe a[CompletedWithResult]</code></pre></dd>
  <dt>Java/query usage</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L277-L278" target="_blank" title="Go to snippet source"></a><code class="language-java">CompletableFuture&lt;CommandResponse.QueryResponse&gt; queryResponseF2 = hcdCmdService.query(longRunningSetup2.runId(), timeout);
Assert.assertTrue(queryResponseF2.get() instanceof CommandResponse.CompletedWithResult);</code></pre></dd>
</dl>
<h3><a href="#submitall" name="submitall" class="anchor"><span class="anchor-link"></span></a>submitAll</h3>
<p><code>SubmitAll</code> can be used to send multiple commands sequentially to the same component. This could be used to send initialization commands to an HCD, for instance. The argument for <code>submitAll</code> is a list of commands. <code>SubmitAll</code> returns a list of <code>SubmitResponse</code>s&ndash;one for each command in the list. While <code>submit</code> returns a <code>SubmitResponse</code> as a Future, <code>submitAll</code> returns a list of <code>SubmitResponse</code>s as a future, which completes when all the commands in the list have completed. </p>
<dl>
  <dt>Scala/query usage</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L287-L294" target="_blank" title="Go to snippet source"></a><code class="language-scala">val submitAllF = async {
  await(assemblyCmdService.submitAll(List(submitAllSetup1, submitAllSetup2, submitAllinvalidSetup)))
}
val submitAllResponse = Await.result(submitAllF, timeout.duration)
submitAllResponse.length shouldBe 3
submitAllResponse(0) shouldBe a[Completed]
submitAllResponse(1) shouldBe a[CompletedWithResult]
submitAllResponse(2) shouldBe a[Invalid]</code></pre></dd>
  <dt>Java/query usage</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L284-L298" target="_blank" title="Go to snippet source"></a><code class="language-java">Setup submitAllSetup1 = new Setup(prefix(), immediateCmd(), Optional.empty()).add(encoderParam);
Setup submitAllSetup2 = new Setup(prefix(), longRunningCmd(), Optional.empty()).add(encoderParam);
Setup submitAllSetup3 = new Setup(prefix(), invalidCmd(), Optional.empty()).add(encoderParam);

CompletableFuture&lt;List&lt;CommandResponse.SubmitResponse&gt;&gt; submitAllF = hcdCmdService
        .submitAll(
                Arrays.asList(submitAllSetup1, submitAllSetup2, submitAllSetup3),
                timeout
        );

List&lt;CommandResponse.SubmitResponse&gt; submitAllResponse = submitAllF.get();
Assert.assertEquals(submitAllResponse.size(), 3);
Assert.assertTrue(submitAllResponse.get(0) instanceof CommandResponse.Completed);
Assert.assertTrue(submitAllResponse.get(1) instanceof CommandResponse.CompletedWithResult);
Assert.assertTrue(submitAllResponse.get(2) instanceof CommandResponse.Invalid);</code></pre></dd>
</dl>
<p>In the first example, three commands are sent and the result is a list with three <code>SubmitResponse</code>s. The last one returned invalid and was not executed.</p>
<p>The commands in <code>submitAll</code> will execute sequentially, but each one must complete successfully for the subsequent commands to be executed. If any one of the commands fails, <code>submitAll</code> stops and the list is returned with the commands that are completed up to and including the command that failed. This is shown in the following example by making the invalidCmd second in the list.</p>
<dl>
  <dt>Scala/query usage</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L298-L304" target="_blank" title="Go to snippet source"></a><code class="language-scala">val submitAllF2 = async {
  await(assemblyCmdService.submitAll(List(submitAllSetup1, submitAllinvalidSetup, submitAllSetup2)))
}
val submitAllResponse2 = Await.result(submitAllF2, timeout.duration)
submitAllResponse2.length shouldBe 2
submitAllResponse2(0) shouldBe a[Completed]
submitAllResponse2(1) shouldBe a[Invalid]</code></pre></dd>
  <dt>Java/query usage</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L302-L311" target="_blank" title="Go to snippet source"></a><code class="language-java">CompletableFuture&lt;List&lt;CommandResponse.SubmitResponse&gt;&gt; submitAllF2 = hcdCmdService
        .submitAll(
                Arrays.asList(submitAllSetup1, submitAllSetup3, submitAllSetup2),
                timeout
        );

List&lt;CommandResponse.SubmitResponse&gt; submitAllResponse2 = submitAllF2.get();
Assert.assertEquals(submitAllResponse2.size(), 2);
Assert.assertTrue(submitAllResponse2.get(0) instanceof CommandResponse.Completed);
Assert.assertTrue(submitAllResponse2.get(1) instanceof CommandResponse.Invalid);</code></pre></dd>
</dl>
<p>In this case, the returned list is of length 2 rather than 3.</p>
<h3><a href="#subscribecurrentstate" name="subscribecurrentstate" class="anchor"><span class="anchor-link"></span></a>subscribeCurrentState</h3>
<p>This method provided by <code>CommandService</code> can be used to subscribe to the <a href="../messages/states.html">CurrentState</a> of a component by providing a callback that is called with the arrival of every <code>CurrentState</code> item.  <code>SubscribeCurrentState</code> returns a handle of <code>CurrentStateSubscription</code> which should be used to unsubscribe the subscription.</p>
<p>The following example code shows an Assembly that subscribes to all <code>CurrentState</code> of an HCD. The example sends a <code>Setup</code> with an encoder parameter value to the HCD as a <code>oneway</code> message.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L308-L324" target="_blank" title="Go to snippet source"></a><code class="language-scala">// Subscriber code
val expectedEncoderValue = 234
val currStateSetup       = Setup(prefix, hcdCurrentStateCmd, obsId).add(encoder.set(expectedEncoderValue))
// Setup a callback response to CurrentState
var cstate: CurrentState = CurrentState(prefix, StateName(&quot;no cstate&quot;), Set.empty)
val subscription         = hcdCmdService.subscribeCurrentState(cs =&gt; cstate = cs)
// Send a oneway to the HCD that will cause it to publish a CurrentState with the encoder value
// in the command parameter &quot;encoder&quot;. Callback will store value into cstate.
hcdCmdService.oneway(currStateSetup)

// Wait for a bit for callback
Thread.sleep(100)
// Test to see if value was received
cstate(encoder).head shouldBe expectedEncoderValue

// Unsubscribe to CurrentState
subscription.unsubscribe()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L315-L481" target="_blank" title="Go to snippet source"></a><code class="language-java">// Subscriber code
int expectedEncoderValue = 234;
Setup currStateSetup = new Setup(prefix(), hcdCurrentStateCmd(), Optional.empty()).add(encoder.set(expectedEncoderValue));
// Setup a callback response to CurrentState - use AtomicInteger to capture final value
final AtomicInteger cstate = new AtomicInteger((1));
CurrentStateSubscription subscription = hcdCmdService.subscribeCurrentState(cs -&gt; {
    // Example sets variable outside scope of closure
    cstate.set(cs.jGet(encoder).get().head());
});
// Send a oneway to the HCD that will cause a publish of a CurrentState with the encoder value
// in the command parameter &quot;encoder&quot;
hcdCmdService.oneway(currStateSetup, timeout);

// Wait for a bit for the callback
Thread.sleep(200);
// Check to see if CurrentState has the value we sent
Assert.assertEquals(expectedEncoderValue, cstate.get());

// Unsubscribe from CurrentState
subscription.unsubscribe();
// subscribe to the current state of an assembly component and use a callback which forwards each received
// element to a test probe actor
CurrentStateSubscription subscription = hcdCmdService.subscribeCurrentState(currentState -&gt; probe.ref().tell(currentState));</code></pre></dd>
</dl>
<p>The second part of the example shows the code in the HCD. When the HCD receives the <code>oneway</code> message, it extracts the encoder value and publishes a CurrentState item with the encoder parameter. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/scala/csw/common/components/command/ComponentHandlerForCommand.scala#L85-L86" target="_blank" title="Go to snippet source"></a><code class="language-scala">val currentState = CurrentState(prefix, StateName(&quot;HCDState&quot;), controlCommand.paramSet)
cswCtx.currentStatePublisher.publish(currentState)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/javadsl/components/JSampleComponentHandlers.java#L157-L161" target="_blank" title="Go to snippet source"></a><code class="language-java">Key&lt;Integer&gt; encoder = JKeyType.IntKey().make(&quot;encoder&quot;);
int expectedEncoderValue = setup.jGet(encoder).get().head();

CurrentState currentState = new CurrentState(prefix(), new StateName(&quot;HCDState&quot;)).add(encoder().set(expectedEncoderValue));
currentStatePublisher.publish(currentState);</code></pre></dd>
</dl>
<p>There are two <code>subscribeCurrentState</code> methods in <code>CommandService</code>. The method shown in the above examples subscribes the caller to <em>all</em> CurrentState published. Each <code>CurrentState</code> item has a <code>StateName</code>. A second signature for <code>subscribeCurrentState</code> can include a Set of <code>StateName</code> when the caller only needs some of the CurrentState published by a component. </p>
<h2><a href="#matching-state-for-command-completion" name="matching-state-for-command-completion" class="anchor"><span class="anchor-link"></span></a>Matching state for command completion</h2>
<p>The <code>matcher</code> is provided to allow a component sending a command to use <code>CurrentState</code> published by a component to determine when actions are complete. The expected case is an Assembly using the <code>CurrentState</code> published by an HCD. When using a <code>submit</code> completion is determined in the destination. In some scenarios, the Assembly may want to determine when actions are complete. This is what the  <code>matcher</code> allows.</p>
<p>To use this feature, the <code>oneway</code> message is used rather than <code>submit</code>. A <code>oneway</code> command is  validated but the framework does not provide completion. Doing a query with the <code>runId</code> of a <code>oneway</code>  will always return <code>CommandNotAvailable</code>, but <code>oneway</code> is perfect for use with a <code>matcher</code>.</p>
<p>The <code>matcher</code> is created with the ActorRef of the component that is the source of <code>CurrentState</code> and an instance of <code>StateMatcher</code>, which defines the state and criteria for matching. </p>
<p>Several types of <code>StateMatcher</code> are provided as part of CSW for common use. These are <code>DemandMatcherAll</code> for matching the entire <code>DemandState</code> against the current state, <code>DemandMatcher</code> for matching state with or without units against the current state, and <code>PresenceMatcher</code> which checks if a matching state is found with a provided prefix. </p>
<p>The developer is not limited to these <code>StateMatcher</code>s. Any class the implements the <code>StateMatcher</code> interface can be provided to a <code>Matcher</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L331-L369" target="_blank" title="Go to snippet source"></a><code class="language-scala">val param: Parameter[Int] = encoder.set(100)
val setupWithMatcher      = Setup(prefix, matcherCmd, obsId)

// create a StateMatcher which specifies the desired algorithm and state to be matched.
val demandMatcher: StateMatcher =
  DemandMatcher(DemandState(prefix, StateName(&quot;testStateName&quot;)).add(param), withUnits = false, timeout)

// create matcher instance
val matcher = new Matcher(assemblyLocation.componentRef, demandMatcher)

// start the matcher so that it is ready to receive state published by the source
val matcherResponseF: Future[MatcherResponse] = matcher.start

// Submit command as a oneway and if the command is successfully validated,
// check for matching of demand state against current state
val matchResponseF: Future[MatchingResponse] = async {
  val onewayResponse: OnewayResponse = await(assemblyCmdService.oneway(setupWithMatcher))
  onewayResponse match {
    case Accepted(runId) â
      val matcherResponse = await(matcherResponseF)
      // create appropriate response if demand state was matched from among the published state or otherwise
      // this would allow the response to be used to complete a command received by the Assembly
      matcherResponse match {
        case MatchCompleted =&gt;
          Completed(setupWithMatcher.runId)
        case mf: MatchFailed =&gt;
          Error(setupWithMatcher.runId, mf.throwable.getMessage)
      }
    case invalid: Invalid â
      matcher.stop()
      invalid
    case locked: Locked =&gt;
      matcher.stop()
      locked
  }
}

val commandResponse = Await.result(matchResponseF, timeout.duration)
commandResponse shouldBe Completed(setupWithMatcher.runId)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L341-L374" target="_blank" title="Go to snippet source"></a><code class="language-java">Parameter&lt;Integer&gt; param = JKeyType.IntKey().make(&quot;encoder&quot;).set(100);
Setup setupWithMatcher = new Setup(prefix(), matcherCmd(), Optional.empty()).add(param);

// create a StateMatcher which specifies the desired algorithm and state to be matched.
DemandMatcher demandMatcher = new DemandMatcher(new DemandState(prefix(), new StateName(&quot;testStateName&quot;)).add(param), false, timeout);

// create the matcher instance
Matcher matcher = new Matcher(AkkaLocationExt.RichAkkaLocation(hcdLocation).componentRef().narrow(), demandMatcher, ec, mat);

// start the matcher so that it is ready to receive state published by the source
CompletableFuture&lt;MatcherResponse&gt; matcherResponseFuture = matcher.jStart();

// Submit command as a oneway and if the command is successfully validated,
// check for matching of demand state against current state
CompletableFuture&lt;CommandResponse.MatchingResponse&gt; matchResponseF = hcdCmdService
        .oneway(setupWithMatcher, timeout)
        .thenCompose(initialCommandResponse -&gt; {
            if (initialCommandResponse instanceof CommandResponse.Accepted) {
                return matcherResponseFuture.thenApply(matcherResponse -&gt; {
                    if (matcherResponse.getClass().isAssignableFrom(MatcherResponses.jMatchCompleted().getClass()))
                        return new CommandResponse.Completed(initialCommandResponse.runId());
                    else
                        return new CommandResponse.Error(initialCommandResponse.runId(), &quot;Match not completed&quot;);
                });

            } else {
                matcher.stop();
                return CompletableFuture.completedFuture(new CommandResponse.Error(initialCommandResponse.runId(), &quot;Matcher failed&quot;));
            }
        });

CommandResponse.MatchingResponse actualResponse = matchResponseF.get();
CommandResponse.Completed expectedResponse = new CommandResponse.Completed(setupWithMatcher.runId());
Assert.assertEquals(expectedResponse, actualResponse);</code></pre></dd>
</dl>
<p>One important point is that the <code>matcher</code> is created and must be shutdown when you are finished with it using the <code>stop</code> method of the matcher as shown in the example.</p>
<h3><a href="#onewayandmatch" name="onewayandmatch" class="anchor"><span class="anchor-link"></span></a>onewayAndMatch</h3>
<p><code>CommandService</code> provides a short-cut called <code>onewayAndMatch</code> that combines a <code>oneway</code> and a <code>matcher</code>  and implements much of the boilerplate of the previous example. This can be often be used saving code. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/multi-jvm/scala/csw/framework/command/CommandServiceTest.scala#L373-L393" target="_blank" title="Go to snippet source"></a><code class="language-scala">val onewayMatchF = async {
  await(assemblyCmdService.onewayAndMatch(setupWithMatcher, demandMatcher)) match {
    case i: Invalid =&gt;
      // Command was not accepted
      log.error(s&quot;Oneway match was not accepted: ${i.issue}&quot;)
      i
    case c: Completed =&gt;
      // Do some completed work
      c
    case e: Error =&gt;
      // Match failed and timedout generating an error - log a message
      println(&quot;Error&quot;)
      log.error(s&quot;Oeway match produced an error: ${e.message}&quot;)
      e
    case l: Locked =&gt;
      // Destination component was locked, log a message
      log.error(s&quot;Destination component was locked&quot;)
      l
  }
}
Await.result(onewayMatchF, timeout.duration) shouldBe Completed(setupWithMatcher.runId)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><a class="icon go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/csw-framework/src/test/java/csw/framework/command/JCommandIntegrationTest.java#L378-L389" target="_blank" title="Go to snippet source"></a><code class="language-java"> // create a DemandMatcher which specifies the desired state to be matched.
 StateMatcher stateMatcher = new DemandMatcher(new DemandState(prefix(), new StateName(&quot;testStateName&quot;)).add(param), false, timeout);

 // create matcher instance
 //Matcher matcher1 = new Matcher(AkkaLocationExt.RichAkkaLocation(hcdLocation).componentRef().narrow(), demandMatcher, ec, mat);

 // start the matcher so that it is ready to receive state published by the source
// CompletableFuture&lt;MatcherResponse&gt; matcherResponse = matcher1.jStart();

 CompletableFuture&lt;CommandResponse.MatchingResponse&gt; matchedCommandResponse =
         hcdCmdService.onewayAndMatch(setupWithMatcher, stateMatcher, timeout);
</code></pre></dd>
</dl>
</div>
<div>
<a href="https://github.com/tmtsoftware/csw/tree/master/docs/src/main/commons/command.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.1*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../framework/deploying-components.html" title="Deploying Components" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Deploying Components
</span>
</div>
</a>
<a href="../commons/services.html" title="Services" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Services
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
