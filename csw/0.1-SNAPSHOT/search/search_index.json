{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/messages/protobuf-support.html","text":"","title":"Protobuf support"},{"location":"/messages/protobuf-support.html#protobuf-support","text":"","title":"Protobuf support"},{"location":"/index.html","text":"","title":"TMT Common Software (CSW)"},{"location":"/index.html#tmt-common-software-csw-","text":"Common Software is the package of services and infrastructure software that integrates the TMT software systems.\nVisit TMT website to know more about Thirty Meter Telescope.","title":"TMT Common Software (CSW)"},{"location":"/index.html#common-software-architecture","text":"CSW is designed to support the Observing Mode-Oriented Architecture (OMOA). An observing mode is a well-defined instrument observing task and an associated set of owned resources, procedures, and capabilities that implement the mode. An example observing mode is: IRIS multi-filter integral field spectroscopy using the NFIRAOS adaptive optics unit with AO laser guide star correction. An instrument will generally have several associated observing modes for acquisition, science objects, and calibrations. Examples of observing mode resources could be an instrument’s hardware devices, or the use of a larger system such as the Laser Guide Star Facility.\nOMOA structures the software as the layers in the following figure. Each layer contains components with specific responsibilities described in the following sections. OMOA bypasses the use of standalone “subsystems” (large principal systems) for a flatter system that requires less code and allows the software system for an observing mode to optionally be more flexibly composed at run-time.","title":"Common Software Architecture"},{"location":"/index.html#layer-0-obseratory-hardware","text":"Layer 0 represents the actual hardware being controlled and the hardware controllers that interface the hardware to the computer systems.","title":"Layer 0 - Obseratory Hardware"},{"location":"/index.html#layer-1-hardware-control-layer","text":"The lowest layer in the OMOA software system, the Hardware Control Layer, consists of all the controllable hardware that is available for use by higher levels of software. A sea of similar software components called Hardware Control Daemons (HCD) at layer 1 controls the low-level hardware of the telescope, adaptive optics, and instruments.\nAn HCD is similar to the device driver found in many systems. Each HCD is associated with a networked motion controller, a PLC/PAC, or other low-level hardware controller present in Layer 0. Some hardware controllers will support multiple channels. An HCD may support a highly cohesive, related set of functionality. For instance, one motion controller with 8 axes might handle all the slow moving filters and gratings of an instrument. In other cases, the channels of the controller hardware could be associated with unrelated devices. If the hardware controller has multiple channels, the HCD supports access to all the channels and must multiplex access to the controller and coordinate requests and replies among the clients.","title":"Layer 1 - Hardware Control Layer"},{"location":"/index.html#layer-2-assembly-layer","text":"The Assembly Layer exists just above the Hardware Control Layer at Layer 2. Software at this layer consists of components called Assemblies. In OMOA, an Assembly represents a device as a collection of hardware that makes sense at the user level. Examples of instrument devices are a filter wheel, a deformable mirror, or a detector controller. Assemblies often represent user-oriented devices in the software system, but it is not necessary that an Assembly control HCDs.","title":"Layer 2 - Assembly Layer"},{"location":"/index.html#layer-3-sequencing-layer","text":"The Sequencing Layer is Layer 3 in the figure above. Components at this level are called Sequencers or Sequence Components because they take complex descriptions of tasks and control and synchronize the actions of the Assemblies to accomplish the tasks.\nSequence Components in this layer share a software interface that allows them to be plugged together to form the sequencing hierarchy for a specific observing mode. Individual Sequencers can provide higher-level control of a set of distributed hardware (e.g., init). Individual sequencers can be programmable using scripts. There can be one or many Sequence Components in an observing mode sequencer.","title":"Layer 3 - Sequencing Layer"},{"location":"/index.html#layer-4-monitoring-and-control-layer","text":"The Monitoring/Control Layer is the layer of software that contains the user interface programs that are used to observe with the telescope. At TMT there will be graphical user interfaces for use by observers during observing. These applications use the CSW services to control and monitor the system.","title":"Layer 4 - Monitoring and Control Layer"},{"location":"/index.html#csw-services","text":"CSW or Common Software provides a shared software infrastructure based on a set of services and associated software for integrating individual components in the large observatory software architecture. The components and client applications use a set of loosely coupled services, each autonomous with a well-defined interface that hides the service implementation. It also provides a standardized communication with the services.","title":"CSW Services"},{"location":"/index.html#","text":"The Location Service of TMT Common Software handles application, component, and service registration and discovery in the distributed TMT software system. When a component (i.e. an Sequencer, Assembly, or HCD) is initializing, it registers its name along with other information such as interface type and connection information to the Location Service. The important feature and reason for the Location Service is that details of connection information should not be hardwired, they should be discovered at runtime.\nLocation Service is most obviously needed when one component commands another component. In this case the first component uses the Location Service to get information about the second component, and uses that information to make a connection. Discovered information might include a protocol (e.g., HTTP), interface type (e.g., command), or host and port.","title":"Location Service"},{"location":"/index.html#","text":"The Configuration Service (CS) provides a centralized persistent store for “configuration files” used in the TMT Software System. In this context, a configuration file is a set of values describing state, initialization values, or other information useful to a component or set of components. The TCS provides many examples such as look-up tables of various kinds or a set of pointing model parameters or parameters for setting up a motion controller. Another is the Alarm Service Configuration File. At the applications level, the GUI used by the Observing Assistant could provide a button to save offsets between an instrument science field and its acquisition camera origin. These are the kinds of scenarios that use the Configuration Service.\nThe Configuration Service provides the added feature of storing versions of configuration files. All versions of configuration files are retained providing a historical record of changes for each configuration file. Components can save today’s version without fear that yesterday’s version will be lost. If the configuration of a component is inadvertently lost, it will be possible to easily restore to the most recently saved version or a default version.","title":"Configuration Service"},{"location":"/index.html#","text":"Logging is the ability of a software component to output a message, usually for diagnostic purposes. TMT Common Software will provide a Logging Service. Logging should not be confused with “data logging”, which is usually collection of measured values.\nThis log message includes a time of the log message, a severity (INFO), the source of the log message as a package path in the software, and a formatted text message. The Logging Service provides the ability to log messages locally to a file or screen and optionally to a centralized logging aggregator.\nThe central logging aggregator (not part of this release) provides the capability for all components to log diagnostic information to a central and optionally persistent store. The logging information is then aggregated and ordered by timestamp. A coordinated, centralized log can be an extremely useful tool for diagnosing many types of distributed software problems. Structured logging will be used with the central logging aggregator.\nThe Logging Service is unique because it is required early in the lifecycle of a component and most components and CSW services themselves will want the ability to log information. It is often necessary to log messages while a component starts up. This means that the implementation of distributed logging must not depend upon other services (at least if the independence of services is desired). It also means that distributed logging will need to load quickly and provide proper behavior if the aggregating logging capability is needed.\nThe logging API provides familiar features similar to available logging libraries including logging levels and the ability to dynamically change the component’s logging configuration while the component is executing. This allows the ability to interactively log more detailed messages when a component encounters problems.","title":"Logging Service"},{"location":"/index.html#","text":"In the TMT software design, an Application or Sequence Component connects to Assemblies and causes actions by submitting commands. Assemblies connect to and command HCDs. The service that provides the command functionality called the Command Service (CCS).\nIn TMT, commands require peer-to-peer connections between the component sending a command and the component receiving the command. There is no reason to directly connect to a component unless that component will be commanded. The Location Service provides connection information for components sending commands with CCS.\nIn the system design each observing mode has a sequencer that consists of one or more OMOA Sequence Components. Commands flow down through the Sequence Components to the Assemblies, HCDs and hardware in a hierarchy.","title":"Command Service"},{"location":"/index.html#","text":"In an event-driven system, an event marks the occurrence of a state change, action, or activity that is of interest in the system. In TMT many interactions between systems are best viewed as being event-driven. For instance, Observe Events are used by a science detector to indicate when activities have occurred such as closing the shutter at the conclusion of a science observation. The TCS Pointing Assembly sends pointing demand events to mechanisms throughout the software system.\nThe Event Service is based on the publish/subscribe messaging paradigm. One component publishes an event and all components that have subscribed receive the event. The advantage of this type of message system is that publishers and subscribers are decoupled. Publishers can publish regardless of whether there are subscribers, and subscribers can subscribe even if there are no publishers. The relationship between publishers and subscribers can be one-to-one, one-to-many, many to one, or even many-to-many. Another advantage of publish-subscribe systems is that components and systems can startup and stop independently without requiring special interactions or startup sequences with other systems. The publish-subscribe pattern also allows the creation of event dependencies between systems that are difficult to track but must be managed. Dependencies can be passive or active. When a component subscribes to a topic, but takes no action based on the value it is called a passive dependency. For instance, a GUI display could subscribe to the current position of an instrument filter but take no action other than displaying the value.","title":"Event Service"},{"location":"/index.html#","text":"An alarm is published to mark an abnormal condition that requires the attention of an operator or other user. Alarms are not errors, they are conditions that occur asynchronously while components are executing or inactive. For instance, an alarm could be published to indicate a hardware limit. An example of this kind of alarm event is a detector temperature that is too high. Alarms are most valuable to operators and observers who monitor the status of the telescope systems and the instruments. The control GUIs will include standardized ways for displaying alarms if needed. The Executive Software provides the observer and operator interfaces for the purpose of displaying alarms relevant to observing from the instruments and telescope system.\nHowever, alarms are not a suitable or approved approach to hazard control as part of a TMT safety system. Alarms should provide additional information to operators and staff about systems monitored by the OSS and can provide early warning of future hazardous conditions, but should not be a sole, primary hazard control.","title":"Alarm Service"},{"location":"/index.html#","text":"The Database Service provides API to manage database connections and access data in the TMT software system. The service expects Postgres as database server. It uses Jooq library underneath to manage database access, connection pooling, etc. To describe JOOQ briefly, it is a java library that provides api for accessing data i.e. DDL support, DML support, fetch, batch execution, prepared statements, etc. safety against sql injection connection pooling, etc. To know more about JOOQ and it’s features please refer this link.","title":"Database Service"},{"location":"/index.html#","text":"The framework provides templates for creating and running the kind of software components defined by TMT as well as service access interfaces for these components. It also provides application support for running multiple components on a host machine.\nThe framework also contains the structures that are common to components, such as commands and event structures.","title":"Framework"},{"location":"/index.html#http-based-services-api-documentation-can-be-found-","text":"","title":"HTTP-based services API documentation can be found here."},{"location":"/commons/getting-started.html","text":"","title":"Getting Started"},{"location":"/commons/getting-started.html#getting-started","text":"In this tutorial, you’ll see how to create a Scala/Java project using a giter8 template for CSW (csw.g8) which contains sample handlers for creating HCD and Assembly. It also contains a deploy project which is responsible for starting multiple components or containers. You can use this as a starting point for your own projects for writing component. We’ll use the sbt build tool which compiles, runs, and tests your projects among other related tasks.","title":"Getting Started"},{"location":"/commons/getting-started.html#installation","text":"Supported Operating Systems are: CentOS and MacOS\nMake sure you have the Java 8 JDK (also known as 1.8) Run javac -version in the command line and make sure you see javac 1.8.___ If you don’t have version 1.8 or higher, install the JDK Install sbt Mac Linux Install IntelliJ MAC Linux Install following IntelliJ Plugins Scala Scalafmt Recommended testing frameworks/tools: ScalaTest JUnit, JUnit Interface Note: These frameworks are typically downloaded and made available by the sbt tool by specifying them as dependencies. If you are using the giter8 template (see below), these dependencies are specified by default, and the sbt will resolve them when it runs.","title":"Installation"},{"location":"/commons/getting-started.html#create-project","text":"cd to an empty folder. Run the following command sbt new tmtsoftware/csw.g8. This pulls the ‘csw’ template from GitHub. Provide input details when prompted. Follow the template readme.md for detailed information about input parameters.\nTo open the project in IntelliJ, start IntelliJ and click on Import Project in the Intro dialog. If you have a project already open, click on File -> New -> Project from Existing Sources…\nThen select the directory created by the template and click Open.\nYou will then see a dialog asking how to import the project.\nBe sure the Import project from external model radio button and sbt options are selected and click Next. Then click Finish on the next dialog to accept the defaults.\nLet’s take a look at what just got generated:\nIn this example, a project was created with default parameters. The complete project structure looks like this:\nAs you can see in below snapshot, template will create three projects: sample-assembly sample-hcd sample-deploy\nsample-deploy project is used to create a concrete implementation. This allows for the construction of a complete binary package bundled with all dependencies, and a launching application.\n3. Template comes with csw and other useful library dependencies. It also includes bunch of plugins as explained in below snapshot","title":"Create project"},{"location":"/commons/getting-started.html#add-new-sbt-project-module","text":"If you want to add another component to the project, for example, with the name sample-io, you have to create a new sbt module:\nAdd external library dependencies required by sample-io in Libs.scala file, if it does not exist. val `akka-actor` = \"com.typesafe.akka\" %% \"akka-actor\" % \"2.5.11\"\n Map new/existing library dependencies in Dependencies.scala file against new project. val SampleIO = Seq( Libs.`akka-actor` )\n Include below snippet in build.sbt file, this will create new sbt project module. lazy val `sample-io` = project\n  .settings( libraryDependencies ++= Dependencies.SampleIO )\n If your new module depends on code from other modules within this project, use .dependsOn in your build.sbt file: lazy val `sample-io` = project\n  .settings( libraryDependencies ++= Dependencies.SampleIO )\n  .dependsOn(\n`sample-assembly`,\n`sample-hcd`\n  )\n Update the deployment dependencies: lazy val `sample-deploy` = project\n  .dependsOn(\n`sample-assembly`,\n`sample-hcd`,\n`sample-io`\n  )","title":"Add new sbt project module"},{"location":"/commons/create-component.html","text":"","title":"Creating a Component"},{"location":"/commons/create-component.html#creating-a-component","text":"This walkthrough helps in creating a CSW component in Scala/Java. CSW components depend on the csw-framework package, which can be found here. This section discusses constructing a HCD, but the principles apply to an Assembly as well. We will be constructing the Assembly in the next section Working with Multiple Components.","title":"Creating a Component"},{"location":"/commons/create-component.html#","text":"This tutorial shows code written in Scala and Java, based on code generated by the giter8 templates with the default values.","title":"Tutorial: Developing an HCD"},{"location":"/commons/create-component.html#anatomy-of-component","text":"A component consists of a supervisor actor, a Top Level Actor, a component handler and one or more worker actors. From all these, csw-framework provides supervisor actor, a Top Level Actor and abstract class of handlers. Component developers are expected to implement this handler which also acts as a gateway from framework to component code.","title":"Anatomy of Component"},{"location":"/commons/create-component.html#supervisor","text":"A Supervisor actor is the actor first started for any component. The main responsibilities that supervisor performs is as follows:\nImplement and manage the component lifecycle for the TLA and for the rest of the system (see Lifecycle below). Register itself with location service. Provide an administrative interface to the component to the rest of the system. For instance, the Container can perform certain administrative communication with the Supervisor such as restart or shutdown. Allow components outside of the Supervisor and TLA to monitor the lifecycle state of the TLA. This is particularly useful for testing. The test needs to know that the component is ready before it starts its test actions.\nNote Because the Supervisor registers itself with location service, it serves as the gateway for all incoming communications from external components/entities.\nThe source code of supervisor actor can be found here","title":"Supervisor"},{"location":"/commons/create-component.html#top-level-actor","text":"While the Supervisor works as the external interface for the component and the manager of Lifecycle, the functional implementation of a component is implemented in a Top Level Actor (TLA), spawned by supervisor actor for any component. However, the developer is not expected to implement TLA code directly. Instead, the functionality of the TLA is added by implementing the ComponentHandlers abstract class, consisting of a list of a methods, or hooks, called by the TLA during specific lifecycle and command events (see Handlers). The ComponentHandlers implementation is specified during constructing using that factory (see Constructing The Component)\nThe source code of the Top Level Actor can be found here.","title":"Top level actor"},{"location":"/commons/create-component.html#handlers","text":"The following hooks should be overridden in your ComponentHandlers implementation class:\ninitialize: called when component is starting up, prior to be put into the Running state. validateCommand: called when component receives a command. (see Validation) onSubmit: called on Submit command if validateCommand returns Accepted. onOneway: called on Oneway command if validateCommand returns Accepted. onGoOffline: called when component receives external message from an administrative client to go offline. onGoOnline: called when component receives external message from an administrative client to go online. onLocationTrackingEvent: called when a tracked dependency changes location state. (see Tracking Dependencies) onShutdown: called when component is shutting down.\nThe source code of ComponentHandlers can be found here.\nMore details about handler significance and invocation can be found here\nNote If the component developer wishes to write the handler implementation in java, then he/she needs to implement the java version of ComponentHandlers which is JComponentHandlers. The source code of JComponentHandlers can be found here. Any further reference to ComponentHandlers should implicitly also apply to JComponentHandlers.","title":"Handlers"},{"location":"/commons/create-component.html#","text":"As seen in the Getting Started page, if you are using the giter8 template, handler classes for both the HCD and Assembly are written for you, with handler implementations stubbed out. We will walkthough filling them in below.","title":"Tutorial: Developing an HCD"},{"location":"/commons/create-component.html#constructing-the-component","text":"After writing the handlers, component developer needs to wire it up with framework. In order to do this, developer needs to implement a ComponentBehaviorFactory. This factory should to be configured in configuration file for the component (see example below). The csw-framework then picks up the full path of ComponentBehaviorFactory from configuration file and spawns the component handlers using this factory as a process of booting a component. The factory is instantiated using Java reflection.\nAdditional sample code to implement the ComponentBehaviorFactory can be found here","title":"Constructing the Component"},{"location":"/commons/create-component.html#","text":"As seen in the Getting Started page, if using the template, this factory class will be implemented for you.","title":"Tutorial: Developing an HCD"},{"location":"/commons/create-component.html#component-configuration-componentinfo-","text":"Component configuration contains details needed to spawn a component. This configuration resides in a configuration file for a particular component. The template creates one for our sample HCD as follows:\nScala name = \"SampleHcd\"\ncomponentType = hcd\nbehaviorFactoryClassName = \"org.tmt.nfiraos.samplehcd.SampleHcdBehaviorFactory\"\nprefix = \"nfiraos.samplehcd\"\nlocationServiceUsage = RegisterOnly Java name = \"JSampleHcd\"\ncomponentType = hcd\nbehaviorFactoryClassName = \"org.tmt.nfiraos.samplehcd.JSampleHcdBehaviorFactory\"\nprefix = \"nfiraos.samplehcd\"\nlocationServiceUsage = RegisterOnly\nNote behaviorFactoryClassName refers to class name of the concrete implementation of ComponentBehaviorFactory, which is SampleHcdBehaviorFactory for Scala in above example, JSampleHcdBehaviorFactory for Java.\nThe name and componentType is used to create the ComponentId representing a unique component in location service.\nThe locationServiceUsage is used by the Supervisor actor to decide whether to only register a component with location service or register and track other components.\nThe configuration file is parsed to a ComponentInfo object and injected in the Supervisor actor. It is then injected in ComponentHandlers while spawning a component.\nThe configuration can also contain a list of components and services it wishes to track as dependencies. See Tracking Dependencies.\nMore details about ComponentInfo can be found here.\nAn additional sample configuration file can be found here.","title":"Component Configuration (ComponentInfo)"},{"location":"/commons/create-component.html#lifecycle","text":"The Supervisor of a component manages its lifecycle state, which can be one of the following:\nIdle Running RunningOffline Restart Shutdown Lock\nThe state the component is in dictates the actions it can take when it receives a message or command, and how those actions are carried out.","title":"Lifecycle"},{"location":"/commons/create-component.html#idle","text":"The component initializes in the idle state. Top level actor calls the initialize hook of ComponentHandlers as first thing on boot-up. Component developers write their initialization logic in this hook. The logic could also do things like accessing the configuration service to fetch the hardware configurations to set the hardware to default positions.\nAfter the initialization, if the component would have configured RegisterAndTrack for locationServiceUsage then the Top Level Actor will start tracking the connections configured for that component. This use case is mostly applicable for Sequencers and Assemblies. HCDs mostly will have RegisterOnly configured for locationServiceUsage.\nThe Supervisor actor will now register itself with location service. Registering with location service will notify other components tracking this component with a LocationUpdated event containing a Location with a reference to the Supervisor actor.\nAfter successful registration, the component will transition to Running state.","title":"Idle"},{"location":"/commons/create-component.html#running","text":"When the supervisor actor receives Initialized message from the Top Level Actor after successful initialization, it registers itself with location service and transitions the component to Running state. Running state signifies that the component is accessible via location service, which allows other entities to communicate with it by sending commands via messages. Any commands received by supervisor actor will be forwarded to the Top Level Actor for processing.","title":"Running"},{"location":"/commons/create-component.html#runningoffline","text":"When the Supervisor actor receives GoOffline message, it transitions the component to RunningOffline state and forwards it to the Top Level Actor. The Top Level Actor then calls onGoOffline hook of ComponentHandlers.\nIf GoOnline message is received by the Supervisor actor then it transits the component back to Running state and forwards it to the Top Level Actor. The Top Level Actor then calls onGoOnline hook of ComponentHandlkers.\nNote In RunningOffline state, if any command is received, it is forwarded to underlying component hook through the Top Level Actor. It is then the responsibility of the component developer to check the isOnline flag provided by csw-framework and process the command accordingly.","title":"RunningOffline"},{"location":"/commons/create-component.html#restart","text":"When the Supervisor actor receives a Restart message, it will transit the component to the Restart state. Then, it will unregister itself from location service so that other components tracking this component will be notified and no commands are received while restart is in progress.\nThen, the Top Level Actor is stopped and postStop hook of the Top Level Actor will call the onShutdown hook of ComponentHandlers. Component developers are expected to write any cleanup of resources or logic that should be executed for graceful shutdown of component in this hook.\nAfter successful shutdown of component, the Supervisor actor will create the Top Level Actor again from scratch. This will cause the initialize hook of ComponentHandlers to be called again. After successful initialization of component, the Supervisor actor will register itself with location service.","title":"Restart"},{"location":"/commons/create-component.html#shutdown","text":"When the Supervisor actor receives a Shutdown message, it transitions the component to the Shutdown state. Any commands received while shutdown is in progress will be ignored. Then, it will stop the Top Level Actor. The postStop hook of the Top Level Actor will call the onShutdown hook of ComponentHandlers. Component developers are expected to write any cleanup of resources or logic that should be executed for graceful shutdown of component in this hook.","title":"Shutdown"},{"location":"/commons/create-component.html#lock","text":"When the Supervisor actor receives a Lock message, it transitions the component to the Lock state. Upon locking, the Supervisor will only accept the commands received from the component that locked the component and ignore all others.\nIn the Lock state, messages like Shutdown and Restart will also be ignored. A component must first be unlocked to accept these commands.\nLock messages are constructed with a duration value specified. When this duration expires, the component will automatically be unlocked. A component can be manually unlocked by sending an Unlock message.","title":"Lock"},{"location":"/commons/create-component.html#csw-services-injection","text":"To provide access to CSW Services, they are injected into the ComponentHandlers class in the constructor in a CswContext object. This object provides the following services:\nLocation Service Event Service Alarm Service (Client API) Configuration Service (Client API) Logging Service (Logger Factory)\nAnd the following utilities:\nComponent Configuration (ComponentInfo) Command Service Command Response Manager Current State Publisher Actor (intended for HCDs)","title":"CSW Services Injection"},{"location":"/commons/create-component.html#logging","text":"csw-framework will provide a LoggerFactory in the CswContext injected in constructor of ComponentHandlers. The LoggerFactory will have the component’s name predefined in it. The component developer is expected to use this factory to log statements.\nLogging works much like other popular loggers such as log4j. However, with the development of log management tools such as logstash, the emphasis on log message formatting has been to write messages in JSON format, so that they can easily be ingested. Plain text writing to stdout is still supported. More details on how to use logging can be found here.","title":"Logging"},{"location":"/commons/create-component.html#","text":"Let’s use logging to flesh out some of our command handlers. The template will instantiate a logger for you to use by constructing one from the LoggerFactory from in the CswContext passed in the constructor, instantiated as a log object.\nAdd some simple log messages in the initialize and onShutdown hooks, and to the onLocationTrackingEvent hook as well, although we won’t be using it for this HCD:\nScala var maybePublishingGenerator: Option[Cancellable] = None\noverride def initialize(): Future[Unit] = {\n  log.info(\"In HCD initialize\")\n  maybePublishingGenerator = Some(publishCounter())\n  Future.unit\n}\n\noverride def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = {\n  log.debug(s\"TrackingEvent received: ${trackingEvent.connection.name}\")\n}\n\noverride def onShutdown(): Future[Unit] = {\n  log.info(\"HCD is shutting down\")\n  Future.unit\n} Java private Optional<Cancellable> maybePublishingGenerator = Optional.empty();\n@Override\npublic CompletableFuture<Void> jInitialize() {\n    return CompletableFuture.runAsync(() -> {\n        log.info(\"In HCD initialize\");\n        maybePublishingGenerator = Optional.of(publishCounter());\n    });\n}\n\n@Override\npublic void onLocationTrackingEvent(TrackingEvent trackingEvent) {\n    log.debug(() -> \"TrackingEvent received: \" + trackingEvent.connection().name());\n}\n\n@Override\npublic CompletableFuture<Void> jOnShutdown() {\n    return CompletableFuture.runAsync(() -> log.info(\"HCD is shutting down\"));\n}\nIn the example code, you’ll notice we have added some functionality to start publishing events. We will cover the Event Service later. You can leave that code out for now.\nNext we’ll add some command handling.","title":"Tutorial: Developing an HCD"},{"location":"/commons/create-component.html#receiving-commands","text":"A command is something that carries some metadata and a set of parameters. A component sends message to other components using commands. Various kinds of commands are as follows:\nSetup : Contains goal, command, or demand information to be used to configure the target OMOA component. Observe: Contains goal or demand information to be used by a detector. system. Properties and their value types will be standardized by the ESW for the ESW PDR. Wait: Sequencer only. Instructs a sequencer to pause until told to continue.\nMore details about creating commands can be found here.\nWhenever a command is sent to a component it is wrapped inside a command wrapper. There are two kinds of command wrapper:\nSubmit: A command is wrapped in submit when the completion result is expected from receiver component Oneway: A command is wrapped in oneway when the completion of command is not expected from receiver component but is determined by sender component by subscribing to receiver component’s state","title":"Receiving Commands"},{"location":"/commons/create-component.html#validation","text":"When a command is received by a component, the Top Level Actor will call the validateCommand hook of ComponentHandlers. Component developers are expected to perform appropriate validation of command, whether it is valid to execute, and return a CommandResponse. The CommandResponse returned from this hook will be sent back to sender directly by csw-framework.\nThe logic in validateCommand hook can be used to handle commands of various durations. If the command can be executed immediately, then the component developer can return a final response directly in the validation step using a CompletedWithResult command response. This should be only used for commands that require a very small amount of time to execute. If the command will take longer, then component developer should return an intermediate response Accepted or Invalid specifying whether the command is valid to be executed or not, and process the command in the onSubmit or onOneway handlers (see Command Response).\nDifferent types of command responses and their significance can be found here.","title":"Validation"},{"location":"/commons/create-component.html#","text":"Let’s add some command validation to our HCD. For our sample HCD, we will only handle one command, sleep, in which we will cause the HCD to sleep for the time specified in a parameter of the command. This will simulate a long running command.\nAdd some code to ensure the command we receive is the sleep command, and return an Invalid response if not. You could imagine much more checking could be added, such as checking the types and values of the parameters of our sleep command, but we will keep it simple for our demonstration.\nScala override def validateCommand(controlCommand: ControlCommand): ValidateCommandResponse = {\n  log.info(s\"Validating command: ${controlCommand.commandName.name}\")\n  controlCommand.commandName.name match {\n    case \"sleep\" => Accepted(controlCommand.runId)\n    case x       => Invalid(controlCommand.runId, CommandIssue.UnsupportedCommandIssue(s\"Command $x. not supported.\"))\n  }\n} Java @Override\npublic CommandResponse.ValidateCommandResponse validateCommand(ControlCommand controlCommand) {\n    String commandName = controlCommand.commandName().name();\n    log.info(() -> \"Validating command: \" + commandName);\n    if (commandName.equals(\"sleep\")) {\n        return new CommandResponse.Accepted(controlCommand.runId());\n    }\n    return new CommandResponse.Invalid(controlCommand.runId(), new CommandIssue.UnsupportedCommandIssue(\"Command \" + commandName + \". not supported.\"));\n}","title":"Tutorial: Developing an HCD"},{"location":"/commons/create-component.html#command-response","text":"The response returned from validateCommand hook of ComponentHandlers will be received by the Top Level Actor, who then sends the response back to sender. If the response returned was Accepted, then it either calls the onSubmit hook or the onOneway hook of ComponentHandlers depending on the wrapper(submit or oneway) in which the command was received.\nIf the command was received as a Submit, then the Top Level Actor adds the response returned from the validateCommand hook in the CommandResponseManager. If the response was Accepted, the TLA then calls the onSubmit hook of ComponentHandlers.\nIn case the command received by a component a Oneway, the response is not added to the CommandResponseManager, and the onOneway hook of ComponentHandlers is called.\nThe CommandResponseManager is responsible for managing and bookkeeping the command status of long running submit commands. The sender of the command (and any component, really) can query the command statuses or subscribe to changes in command statuses using CommandService.\nThe CommandService class provides helper methods for communicating with other components, and should be a component’s primary means of sending commands to other components. This will be described in the next tutorial section, Sending Commands.\nWhen the onSubmit hook is called, it is the responsibility of component developers to update the status of the received command in the CommandResponseManager as it changes. The instance of commandResponseManager is provided in the CswContext object in ComponentHandlers and should be injected in any worker actor or other actor/class created for the component.\nMore details on methods available in CommandResponseManager can be found here.","title":"Command Response"},{"location":"/commons/create-component.html#","text":"We will implement command handling in the onSubmit hook. Note that this hook actually receives a ControlCommand as an argument, which can be either a Setup or an Observe. We will use pattern matching to handle the command if it is a Setup and forward to an onSetup handling method. Observe commands will be ignored.\nScala override def onSubmit(controlCommand: ControlCommand): SubmitResponse = {\n  log.info(s\"Handling command: ${controlCommand.commandName}\")\n\n  controlCommand match {\n    case setupCommand: Setup => onSetup(setupCommand)\n    case observeCommand: Observe => // implement (or not)\n      Error(controlCommand.runId, \"Observe not supported\")\n  }\n}\n\ndef onSetup(setup: Setup): SubmitResponse = {\n  val sleepTimeKey: Key[Long] = KeyType.LongKey.make(\"SleepTime\")\n\n  // get param from the Parameter Set in the Setup\n  val sleepTimeParam: Parameter[Long] = setup(sleepTimeKey)\n\n  // values of parameters are arrays. Get the first one (the only one in our case) using `head` method available as a convenience method on `Parameter`.\n  val sleepTimeInMillis: Long = sleepTimeParam.head\n\n  log.info(s\"command payload: ${sleepTimeParam.keyName} = $sleepTimeInMillis\")\n\n  workerActor ! Sleep(setup.runId, sleepTimeInMillis)\n\n  Started(setup.runId)\n} Java @Override\npublic CommandResponse.SubmitResponse onSubmit(ControlCommand controlCommand) {\n    log.info(() -> \"Handling command: \" + controlCommand.commandName());\n\n    if (controlCommand instanceof Setup) {\n        onSetup((Setup) controlCommand);\n        return new CommandResponse.Started(controlCommand.runId());\n    } else if (controlCommand instanceof Observe) {\n        // implement (or not)\n    }\n    return new CommandResponse.Error(controlCommand.runId(), \"Observe command not supported\");\n}\n\nprivate void onSetup(Setup setup) {\n    Key<Long> sleepTimeKey = JKeyType.LongKey().make(\"SleepTime\");\n\n    // get param from the Parameter Set in the Setup\n    Optional<Parameter<Long>> sleepTimeParamOption = setup.jGet(sleepTimeKey);\n\n    // values of parameters are arrays.  Get the first one (the only one in our case) using `head` method available as a convenience method on `Parameter`.\n    if (sleepTimeParamOption.isPresent()) {\n        Parameter<Long> sleepTimeParam = sleepTimeParamOption.get();\n        long sleepTimeInMillis = sleepTimeParam.head();\n\n        log.info(() -> \"command payload: \" + sleepTimeParam.keyName() + \" = \" + sleepTimeInMillis);\n\n        workerActor.tell(new Sleep(setup.runId(), sleepTimeInMillis));\n    }\n}\nIn our example, the sleep command has one parameter called SleepTime. We retrieve this parameter from the Setup by creating a Key to this parameter using the name and type, and then calling an apply method on the Setup (the setup(longkey) shorthand) which finds the matching Parameter in the Setup’s ParameterSet (use the Setup.jget() method in Java). By doing this, the Parameter is returned with the proper typing, and so the values retrieved from the Parameter are typed as well. Note, all values are stored as an array, so we get our single value for SleepTime by using the head method available as a convenience method on ParameterSet.\nAt this point, to prevent our HCD from blocking while handling the command, we pass it off to a worker actor, which we will specify somewhere in this class. This could be defined in a separate class, but writing it as an internal class allows us to use the logging facility and CommandResponseManager without having to inject them into our new Actor class.\nNote that our onSetup command handling logic returns a Started response. This indicates that the command is a long-running command and will be finished after some time, and that the final result will be posted to the CommandResponseManager. The submit command in the CommandService is implemented such that when it receives the Started response, it automatically starts a subscription to the CommandResponseManager for the final response, and when it is published, the Future returned by submit command is completed with this value.\nScala sealed trait WorkerCommand                      extends TMTSerializable\ncase class Sleep(runId: Id, timeInMillis: Long) extends WorkerCommand\n\nprivate val workerActor =\n  ctx.spawn(\n    Behaviors.receiveMessage[WorkerCommand](msg => {\n      msg match {\n        case sleep: Sleep =>\n          log.trace(s\"WorkerActor received sleep command with time of ${sleep.timeInMillis} ms\")\n          // simulate long running command\n          Thread.sleep(sleep.timeInMillis)\n          commandResponseManager.addOrUpdateCommand(CommandResponse.Completed(sleep.runId))\n        case _ => log.error(\"Unsupported message type\")\n      }\n      Behaviors.same\n    }),\n    \"WorkerActor\"\n  ) Java private interface WorkerCommand extends TMTSerializable {\n}\n\nprivate static final class Sleep implements WorkerCommand {\n    private final Id runId;\n    private final long timeInMillis;\n\n    private Sleep(Id runId, long timeInMillis) {\n        this.runId = runId;\n        this.timeInMillis = timeInMillis;\n    }\n}\n\nprivate ActorRef<WorkerCommand> createWorkerActor() {\n    return actorContext.spawn(\n            Behaviors.receiveMessage(msg -> {\n                if (msg instanceof Sleep) {\n                    Sleep sleep = (Sleep) msg;\n                    log.trace(() -> \"WorkerActor received sleep command with time of \" + sleep.timeInMillis + \" ms\");\n                    // simulate long running command\n                    Thread.sleep(sleep.timeInMillis);\n                    cswCtx.commandResponseManager().addOrUpdateCommand(new CommandResponse.Completed(sleep.runId));\n                } else {\n                    log.error(\"Unsupported message type\");\n                }\n                return Behaviors.same();\n            }),\n            \"WorkerActor\"\n    );\n}\nThis worker actor simply takes the time passed in the message, sleeps that amount, and then updates the CommandResponseManager that the command is complete.\nNote If the component developer creates new set of messages for worker actor then it is mandatory that those messages extend TMTSerializable which will enable messages to serialize on wire.","title":"Tutorial: Developing an HCD"},{"location":"/commons/create-component.html#events","text":"CSW Events have a similar structure to commands, in that along with a name and a prefix (used to represent the source of the event), they include data represented in the Event in a set of parameters.\nMore details about events can be found here.\nAccess to the Event Service is in the CswContext object passed in to the handlers class in the constructor. The Event Service provides a factory method to create a “default” publisher and subscriber, which can be accessed in various parts of your code to reuse a single connection to the service. In most cases, reusing this connection will provide the performance needed. But if you prefer to create new connections, custom publishers and subscribers can be constructed. See the manual on the Event Service for more information.\nPublishers have an API that allows the publishing of a single event, a stream of events, or periodic events created by an EventGenerator, which is simply a function that returns an event.","title":"Events"},{"location":"/commons/create-component.html#","text":"Let’s add a publisher to our component. We will use the default publisher that will periodically publish events generated by an EventGenerator.\nScala import scala.concurrent.duration._\nprivate def publishCounter(): Cancellable = {\n  var counter = 0\n  def incrementCounterEvent() = {\n    counter += 1\n    val param: Parameter[Int] = KeyType.IntKey.make(\"counter\").set(counter)\n    SystemEvent(componentInfo.prefix, EventName(\"HcdCounter\")).add(param)\n  }\n\n  log.info(\"Starting publish stream.\")\n  eventService.defaultPublisher.publish(incrementCounterEvent(), 2.second, err => log.error(err.getMessage, ex = err))\n}\n\nprivate def stopPublishingGenerator(): Unit = {\n  log.info(\"Stopping publish stream\")\n  maybePublishingGenerator.foreach(_.cancel)\n} Java private int counter = 0;\nprivate Event incrementCounterEvent() {\n    counter += 1;\n    Parameter<Integer> param = JKeyType.IntKey().make(\"counter\").set(counter);\n    return new SystemEvent(cswCtx.componentInfo().prefix(), new EventName(\"HcdCounter\")).add(param);\n}\n\nprivate Cancellable publishCounter() {\n    log.info(\"Starting publish stream.\");\n    return cswCtx.eventService().defaultPublisher().publish(this::incrementCounterEvent, java.time.Duration.ofSeconds(2));\n}\n\nprivate void stopPublishingGenerator() {\n    log.info(\"Stopping publish stream\");\n    maybePublishingGenerator.ifPresent(Cancellable::cancel);\n}\nWe encapsulate the starting of the publishing in our method publishCounter. Our EventGenerator is the incrementCounterEvent method which increments our integer variable counter and stores it in the ParameterSet of a new SystemEvent and returns it. Once our defaultPublisher is resolved, we pass in a reference to incrementCounterEvent and specify a period of 2 seconds. We log a message when publishing the event so that it can be observed when running the component.\nThe publish method returns a Cancellable type in a future. When the publishing is set up, the Cancellable can be used to stop the event generator. We demonstrate its usage in the stopPublishingGenerator method, although this method is not called in our tutorial.\nWe will start this publishing when our component initializes, so we return to our initialize method and add a call to our publishCounter method. We save a reference to the Cancellable object for future use in our stopPublishingGenerator method.\nScala var maybePublishingGenerator: Option[Cancellable] = None\noverride def initialize(): Future[Unit] = {\n  log.info(\"In HCD initialize\")\n  maybePublishingGenerator = Some(publishCounter())\n  Future.unit\n}\n\noverride def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = {\n  log.debug(s\"TrackingEvent received: ${trackingEvent.connection.name}\")\n}\n\noverride def onShutdown(): Future[Unit] = {\n  log.info(\"HCD is shutting down\")\n  Future.unit\n} Java private Optional<Cancellable> maybePublishingGenerator = Optional.empty();\n@Override\npublic CompletableFuture<Void> jInitialize() {\n    return CompletableFuture.runAsync(() -> {\n        log.info(\"In HCD initialize\");\n        maybePublishingGenerator = Optional.of(publishCounter());\n    });\n}\n\n@Override\npublic void onLocationTrackingEvent(TrackingEvent trackingEvent) {\n    log.debug(() -> \"TrackingEvent received: \" + trackingEvent.connection().name());\n}\n\n@Override\npublic CompletableFuture<Void> jOnShutdown() {\n    return CompletableFuture.runAsync(() -> log.info(\"HCD is shutting down\"));\n}","title":"Tutorial: Developing an HCD"},{"location":"/commons/create-component.html#starting-csw-services","text":"Before we run our application, we must first start the Location Service and the Event Service. A script has been provided to simplify the starting and stopping of CSW services, and is included in the application bundle that comes with each release. The application bundle is called\ncsw-apps-0.1-SNAPSHOT.zip\nand the script is named csw-services.sh.\nThe csw-services.sh script has two basic commands: start and stop. The start command can start specific services using passed in flags, or all services without any. Services are started on default ports but those ports can be overridden using command line arguments. It is important to pass in a network interface name that is appropriate for your system. These can be obtained using ifconfig on Linux and Mac computers. en0 typically works for most machines.\nTo get information on the arguments for the tool, use csw-services.sh --help.","title":"Starting CSW Services"},{"location":"/commons/create-component.html#","text":"Let’s go ahead and start our CSW Services using the script. Go to the release page and download and unpack the CSW application bundle. Then go into the bin directory and enter the command\n./csw-services.sh start -i <iname>\nwhere <iname> is your interface name (e.g. en0).","title":"Tutorial: Developing an HCD"},{"location":"/commons/create-component.html#building-and-running-component-in-standalone-mode","text":"Once the component is ready, it is started using the ContainerCmd object in standalone mode. The details about starting the ContainerCmd in standalone mode can be found here.\nThere are various ways to build and run the project. A simple way during development is to to use sbt to run it. The sbt command runMain can be used to specify an application with a main method and run it with arguments specified at the command line. When this command is executed, sbt will take care of any downloading of dependencies, compiling, or building necessary to run your application.\nOur template includes a wrapper application around ContainerCmd that we can use in the deployment module. To run our HCD in standalone mode, go to the project root directory and type sbt \"<deploy-module>/runMain <mainClass> --local --standalone <path-to-config-file>\", where\n<deploy-module> is the name of the deployment module created by the template (sample-deploy if using defaults) <mainClass> is the full class name of our ContainerCmd application, which the template names <package>.<name>deploy.<Name>ContainerCmdApp. If you accept the defaults for the template, it will be org.tmt.nfiraos.sampledeploy.SampleContainerCmdApp. If you are having problems determining the class name, use sbt <deploy-module>/run and it will prompt you the possibilities. <path-to-config-file> is the filename, which can be an absolute path or relative to the directory of the deployment module. If using defaults, this would be src/main/resources/SampleHcdStandalone.conf for Scala, and src/main/resources/JSampleHcdStandalone.conf for Java.\nSo if using the template defaults, the full command would be\nScala sbt \"sample-deploy/runMain org.tmt.nfiraos.sampledeploy.SampleContainerCmdApp --local --standalone src/main/resources/SampleHcdStandalone.conf\"\n Java sbt \"sample-deploy/runMain org.tmt.nfiraos.sampledeploy.SampleContainerCmdApp --local --standalone src/main/resources/JSampleHcdStandalone.conf\"\nTo run the component using the deployment package, perform the following steps:\nRun sbt <project>/universal:packageBin, where <project> is your deployment module (e.g. sample-deploy). This will create self contained zip in <project>/target/universal directory Unzip generated zip file and enter into bin directory Run the ./<project>-cmd-app --local --standalone <path-to-local-config-file-to-start-the-component>\nAlternatively, you can run sbt stage, which installs the application under target/universal/stage/bin.","title":"Building and Running component in standalone mode"},{"location":"/commons/multiple-components.html","text":"","title":"Multiple Components"},{"location":"/commons/multiple-components.html#multiple-components","text":"In this part of the tutorial, we will demonstrate functionality involving multiple components. We will do this by creating an Assembly, demonstrating how to deploy start the Assembly and an HCD in a container, and having them communicate with each other.","title":"Multiple Components"},{"location":"/commons/multiple-components.html#creating-an-assembly","text":"Similar to the HCD in the previous page, to create an assembly, the component developer needs to implement the ComponentHandlers. More details about implementing ComponentHandlers can be found here.","title":"Creating an Assembly"},{"location":"/commons/multiple-components.html#","text":"If using the giter8 template with the default parameters, our ComponentHandlers class will be the SampleAssemblyHandlers class (JSampleAssemblyHandlers in Java), and the factory will be SampleAssemblyBehaviorFactory (JSampleAssemblyBehaviorFactory in Java).\nLike we did for the HCD, let’s add some log messages for the initialize and onShutdown hooks, but not the onTrackingLocationEvent hook. We’ll cover that in more detail later.\nScala private var maybeEventSubscription: Option[EventSubscription] = None\noverride def initialize(): Future[Unit] = {\n  log.info(\"In Assembly initialize\")\n  maybeEventSubscription = Some(subscribeToHcd())\n  Future.unit\n}\n\noverride def onShutdown(): Future[Unit] = {\n  log.info(\"Assembly is shutting down.\")\n  Future.unit\n} Java private Optional<IEventSubscription> maybeEventSubscription = Optional.empty();\n@Override\npublic CompletableFuture<Void> jInitialize() {\n    return CompletableFuture.runAsync(() -> {\n        log.info(\"In Assembly initialize\");\n        maybeEventSubscription = Optional.of(subscribeToHcd());\n    });\n}\n\n@Override\npublic CompletableFuture<Void> jOnShutdown() {\n    return CompletableFuture.runAsync(() -> log.info(\"Assembly is shutting down.\"));\n}\nOnce again, ignore the code about setting up the subscription. This will be covered later when we discuss subscribing to events.","title":"Tutorial: Developing an Assembly"},{"location":"/commons/multiple-components.html#component-configuration-componentinfo-","text":"Also similar to the HCD, we will need to create a ComponentInfo file for the Assembly. The following shows an example of ComponentInfo file for an Assembly:\nScala name = \"SampleAssembly\"\ncomponentType = assembly\nbehaviorFactoryClassName = \"org.tmt.nfiraos.sampleassembly.SampleAssemblyBehaviorFactory\"\nprefix = \"nfiraos.sample\"\nlocationServiceUsage = RegisterAndTrackServices\nconnections = [\n  {\n    name: \"SampleHcd\"\n    componentType: hcd\n    connectionType: akka\n  }\n]\n Java name = \"JSampleAssembly\"\ncomponentType = assembly\nbehaviorFactoryClassName = \"org.tmt.nfiraos.sampleassembly.JSampleAssemblyBehaviorFactory\"\nprefix = \"nfiraos.sample\"\nlocationServiceUsage = RegisterAndTrackServices\nconnections = [\n  {\n    name: \"JSampleHcd\"\n    componentType: hcd\n    connectionType: akka\n  }\n]\nNote There is a section for listing connections. These are the connections that the component will automatically track, and can be other components or services. When available, it may make sense to track things like the Event Service. These connections can also be specified for HCDs, but of course, they should not have any component dependencies.\nThe above shows a configuration file for running in standalone mode. If we want to run both the assembly and HCD in a container, the file would look like this:\nScala name = \"SampleContainer\"\ncomponents: [\n  {\n    name = \"SampleAssembly\"\n    componentType = assembly\n    behaviorFactoryClassName = \"org.tmt.nfiraos.sampleassembly.SampleAssemblyBehaviorFactory\"\n    prefix = \"nfiraos.sample\"\n    locationServiceUsage = RegisterAndTrackServices\n    connections = [\n      {\n        name: \"SampleHcd\"\n        componentType: hcd\n        connectionType: akka\n      }\n    ]\n  },\n  {\n    name = \"SampleHcd\"\n    componentType = hcd\n    behaviorFactoryClassName = \"org.tmt.nfiraos.samplehcd.SampleHcdBehaviorFactory\"\n    prefix = \"nfiraos.samplehcd\"\n    locationServiceUsage = RegisterOnly\n  }\n] Java name = \"JSampleContainer\"\ncomponents: [\n  {\n    name = \"JSampleAssembly\"\n    componentType = assembly\n    behaviorFactoryClassName = \"org.tmt.nfiraos.sampleassembly.JSampleAssemblyBehaviorFactory\"\n    prefix = \"nfiraos.sample\"\n    locationServiceUsage = RegisterAndTrackServices\n    connections = [\n      {\n        name: \"JSampleHcd\"\n        componentType: hcd\n        connectionType: akka\n      }\n    ]\n  },\n  {\n    name = \"JSampleHcd\"\n    componentType = hcd\n    behaviorFactoryClassName = \"org.tmt.nfiraos.samplehcd.JSampleHcdBehaviorFactory\"\n    prefix = \"nfiraos.samplehcd\"\n    locationServiceUsage = RegisterOnly\n  }\n]\nMore details about each configuration and its significance can be found here.\nAnother sample container configuration file can be found here.","title":"Component Configuration (ComponentInfo)"},{"location":"/commons/multiple-components.html#tracking-dependencies","text":"The connections that are defined in the configuration file for an assembly will be tracked by the csw-framework. For each connection the following details are configured:\nScala {\nname: \"SampleHcd\"\ncomponentType: hcd\nconnectionType: akka\n}\n Java {\nname: \"JSampleHcd\"\ncomponentType: hcd\nconnectionType: akka\n}\nThe name of the component, the type(hcd, service, etc) and the connection(akka, http, tcp) will be used to create a Connection object. The Connection object will be then used to track the location of a component using location service.\nThe Location object has one of the following types:\nAkkaLocation: Contains the remote address of the actorRef. The actorRef will be the Supervisor actor of a component. HttpLocation: Holds the HTTP URI of the web server, e.g. Configuration Service TcpLocation: Represents a TCP URI of the server, e.g. Event Service\nMore details about tracking a component using the location service can be found here.","title":"Tracking Dependencies"},{"location":"/commons/multiple-components.html#onlocationtrackingevent-handler","text":"For all the tracked connections, whenever a location is changed, added, or removed, one of the following events is generated:\nLocationUpdated: a location was added or changed LocationRemoved: a location is no longer available on the network\nWhenever such an event is generated, the Top level actor will call the onLocationTrackingEvent hook of ComponentHandlers with the event(LocationUpdated or LocationRemoved) as parameter of the hook.\nMore details about tracking connections can be found here.","title":"onLocationTrackingEvent Handler"},{"location":"/commons/multiple-components.html#","text":"For our sample component, we will set it up so that when the HCD is found by the location service, we will immediately send a command to it. We will do this by using the location to obtain a CommandService reference (see below) to the HCD, and then pass this reference to a worker actor to send and monitor the command (we will get more into this command actor later), so that we don’t block our Assembly from receiving messages. If we are notified that the HCD is removed, log a message.\nScala override def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = {\n  log.debug(s\"onLocationTrackingEvent called: $trackingEvent\")\n  trackingEvent match {\n    case LocationUpdated(location) =>\n      val hcd = CommandServiceFactory.make(location.asInstanceOf[AkkaLocation])(ctx.system)\n      commandSender ! SendCommand(hcd)\n    case LocationRemoved(_) => log.info(\"HCD no longer available\")\n  }\n} Java @Override\npublic void onLocationTrackingEvent(TrackingEvent trackingEvent) {\n    log.debug(() -> \"onLocationTrackingEvent called: \" + trackingEvent.toString());\n    if (trackingEvent instanceof LocationUpdated) {\n        LocationUpdated updated = (LocationUpdated) trackingEvent;\n        Location location = updated.location();\n        ICommandService hcd = CommandServiceFactory.jMake((AkkaLocation) (location), actorContext.getSystem());\n        commandSender.tell(new SendCommand(hcd));\n    } else if (trackingEvent instanceof LocationRemoved) {\n        log.info(\"HCD no longer available\");\n    }\n}","title":"Tutorial: Developing an Assembly"},{"location":"/commons/multiple-components.html#trackconnection","text":"If the component developer wants to track a connection that is not configured in its configuration file then it can use the trackConnection method provided by csw-framework in ComponentHandlers. The trackConnection method will take the Connection instance. Information on how to create a connection instance can be found here.\nNote Connections tracked by csw-framework (from a configuration file) or by a component developer using the trackConnection method both will be received in the onLocationTrackingEvent hook of ComponentHandlers.","title":"trackConnection"},{"location":"/commons/multiple-components.html#sending-commands","text":"From the location information obtained either by tracking dependencies or manually resolving a location, a CommandService instance can be created to provide a command interface to the component. The following snippet, not from our tutorial, shows how to obtain a CommandService reference using by resolving a location using the Location Service.\nScala implicit val system: ActorSystem[Nothing] = ctx.system\n\nval eventualCommandService: Future[CommandService] =\n  cswCtx.locationService.resolve(hcdConnection.of[AkkaLocation], 5.seconds).map {\n    case Some(hcdLocation: AkkaLocation) => CommandServiceFactory.make(hcdLocation)\n    case _                               => throw HcdNotFoundException()\n  }\n\neventualCommandService.foreach { commandService ⇒\n  hcd = commandService\n} Java CompletableFuture<Optional<AkkaLocation>> resolvedHcdLocation = locationService.resolve(hcdConnection, Duration.ofSeconds(5));\n\nCompletableFuture<ICommandService> eventualCommandService = resolvedHcdLocation.thenApply((Optional<AkkaLocation> hcdLocation) -> {\n    if (hcdLocation.isPresent())\n        return CommandServiceFactory.jMake(hcdLocation.get(), ctx.getSystem());\n    else\n        throw new HcdNotFoundException();\n});\n\neventualCommandService.thenAccept((jcommandService) -> hcd = jcommandService);\nIf a component wants to send a command to another component, it uses a CommandService instance. The creation of aCommandService instance and its usage can be found here.","title":"Sending Commands"},{"location":"/commons/multiple-components.html#tracking-long-running-commands","text":"The submit method has been written so that it will return a Future response encapsulating a SubmitResponse type. If the Future completes, no matter whether the command has an immediate response or is long-running, is invalid, or encounters an error at any point, the Future completes with the final response. If there is an exception, which may occur if the submit times out, that must be handled explicity using Future exception handling (this can be done many ways; an example is given below).","title":"Tracking Long Running Commands"},{"location":"/commons/multiple-components.html#","text":"We use our worker actor to submit the command to the HCD, and then subscribe to the HCD’s CommandResponseManager for command completion.\nScala sealed trait WorkerCommand                  extends TMTSerializable\ncase class SendCommand(hcd: CommandService) extends WorkerCommand\n\nprivate val commandSender =\n  ctx.spawn(\n    Behaviors.receiveMessage[WorkerCommand](msg => {\n      msg match {\n        case command: SendCommand =>\n          log.trace(s\"WorkerActor received SendCommand message.\")\n          handle(command.hcd)\n        case _ => log.error(\"Unsupported message type\")\n      }\n      Behaviors.same\n    }),\n    \"CommandSender\"\n  )\n\nimport scala.concurrent.duration._\nprivate implicit val sleepCommandTimeout: Timeout = Timeout(10000.millis)\ndef handle(hcd: CommandService): Unit = {\n\n  // Construct Setup command\n  val sleepTimeKey: Key[Long]         = KeyType.LongKey.make(\"SleepTime\")\n  val sleepTimeParam: Parameter[Long] = sleepTimeKey.set(5000).withUnits(Units.millisecond)\n  val setupCommand                    = Setup(componentInfo.prefix, CommandName(\"sleep\"), Some(ObsId(\"2018A-001\"))).add(sleepTimeParam)\n\n  // submit command and handle response\n  hcd.submit(setupCommand).onComplete {\n    case scala.util.Success(value) =>\n      value match {\n        case _: CommandResponse.Locked => log.error(\"Sleep command failed: HCD is locked.\")\n        case inv: CommandResponse.Invalid =>\n          log.error(s\"Command is invalid: (${inv.issue.getClass.getSimpleName}): ${inv.issue.reason}\")\n        case x: CommandResponse.Error     => log.error(s\"Command Completed with error: ${x.message}\")\n        case _: CommandResponse.Completed => log.info(\"Command completed successfully\")\n        case _                            => log.error(\"Command failed\")\n      }\n    case scala.util.Failure(ex) => log.error(s\"Exception occured when sending command: ${ex.getMessage}\")\n  }\n} Java private interface WorkerCommand extends TMTSerializable {\n}\n\nprivate static final class SendCommand implements WorkerCommand {\n    private final ICommandService hcd;\n\n    private SendCommand(ICommandService hcd) {\n        this.hcd = hcd;\n    }\n}\n\nprivate ActorRef<WorkerCommand> createWorkerActor() {\n    return actorContext.spawn(\n            Behaviors.receiveMessage(msg -> {\n                if (msg instanceof SendCommand) {\n                    SendCommand command = (SendCommand) msg;\n                    log.trace(\"WorkerActor received SendCommand message.\");\n                    handle(command.hcd);\n                } else {\n                    log.error(\"Unsupported messsage type\");\n                }\n                return Behaviors.same();\n            }),\n            \"CommandSender\"\n    );\n}\n\nprivate void handle(ICommandService hcd) {\n\n    // Construct Setup command\n    Key<Long> sleepTimeKey = JKeyType.LongKey().make(\"SleepTime\");\n    Parameter<Long> sleepTimeParam = sleepTimeKey.set(5000L).withUnits(JUnits.millisecond);\n\n    Setup setupCommand = new Setup(cswCtx.componentInfo().prefix(), new CommandName(\"sleep\"), Optional.of(new ObsId(\"2018A-001\"))).add(sleepTimeParam);\n\n    Timeout commandResponseTimeout = new Timeout(10, TimeUnit.SECONDS);\n\n    // Submit command and handle response\n    hcd.submit(setupCommand, commandResponseTimeout)\n            .exceptionally(ex -> new CommandResponse.Error(setupCommand.runId(), \"Exception occurred when sending command: \" + ex.getMessage()))\n            .thenAccept(commandResponse -> {\n                if (commandResponse instanceof CommandResponse.Locked) {\n                    log.error(\"Sleed command failed: HCD is locked\");\n                } else if (commandResponse instanceof CommandResponse.Invalid) {\n                    CommandResponse.Invalid inv = (CommandResponse.Invalid) commandResponse;\n                    log.error(\"Sleep command invalid (\" + inv.issue().getClass().getSimpleName() + \"): \" + inv.issue().reason());\n                } else if (commandResponse instanceof CommandResponse.Error) {\n                    CommandResponse.Error x = (CommandResponse.Error) commandResponse;\n                    log.error(() -> \"Command Completed with error: \" + x.message());\n                } else if (commandResponse instanceof CommandResponse.Completed) {\n                    log.info(\"Command completed successfully\");\n                } else {\n                    log.error(\"Command failed: \");\n                }\n            });\n}\nNote If the component developer creates new set of messages for worker actor then it is mandatory that those messages extend TMTSerializable which will enable messages to serialize on wire.","title":"Tutorial: Developing an Assembly"},{"location":"/commons/multiple-components.html#matchers","text":"When a component sends a command as Oneway to another component, it may be interested in knowing the receiver component’s CurrentState and match it against a desired state. In order to do that, the component developer can use the onewayAndMatch method of CommandService or use oneway and then use a Matcher explicitly to match a desired state with current state.\nMore details on how to use Matcher can be found here.","title":"Matchers"},{"location":"/commons/multiple-components.html#pubsub-connection","text":"A component might need to subscribe to the current state of any other component provided it knows the location of that component. In order to subscribe to current state, it may use the subscribeCurrentState method of the CommandService. More details about the usage of subscribeCurrentState can ber found here.\nIf a component wants to publish its current state then it can use the currentStatePublisher provided by csw-framework in the CswContext object passed into ComponentHandlers. More details about the usage of currentStatePublisher can be found here.","title":"PubSub Connection"},{"location":"/commons/multiple-components.html#subscribing-to-events","text":"To subscribe to events, a subscriber is accessed done in a similar way to publishing. Typically a defaultSubscriber is obtained, but additional subscribers with their own connection can be created.\nThe subscribe API specifies a set of Events to subscribe to and then specifies how the events should be handled. This can be a callback, an Actor reference to receive the Event as a message, or as a stream to allow flow operations to be applied.","title":"Subscribing to Events"},{"location":"/commons/multiple-components.html#","text":"We will setup our subscription to the counter events generated by our HCD in the subscribeToHCD method.\nScala private val counterEventKey = EventKey(Prefix(\"nfiraos.samplehcd\"), EventName(\"HcdCounter\"))\nprivate val hcdCounterKey   = KeyType.IntKey.make(\"counter\")\n\nprivate def processEvent(event: Event): Unit = {\n  log.info(s\"Event received: ${event.eventKey}\")\n  event match {\n    case e: SystemEvent =>\n      e.eventKey match {\n        case `counterEventKey` =>\n          val counter = e(hcdCounterKey).head\n          log.info(s\"Counter = $counter\")\n        case _ => log.warn(\"Unexpected event received.\")\n      }\n    case e: ObserveEvent => log.warn(\"Unexpected ObserveEvent received.\") // not expected\n  }\n}\n\nprivate def subscribeToHcd(): EventSubscription = {\n  log.info(\"Starting subscription.\")\n  eventService.defaultSubscriber.subscribeCallback(Set(counterEventKey), processEvent)\n}\n\nprivate def unsubscribeHcd(): Unit = {\n  log.info(\"Stopping subscription.\")\n  maybeEventSubscription.foreach(_.unsubscribe())\n} Java private EventKey counterEventKey = new EventKey(new Prefix(\"nfiraos.samplehcd\"), new EventName(\"HcdCounter\"));\nprivate Key<Integer> hcdCounterKey = JKeyType.IntKey().make(\"counter\");\n\nprivate void processEvent(Event event) {\n    log.info(\"Event received: \"+ event.eventKey());\n    if (event instanceof SystemEvent) {\n        SystemEvent sysEvent = (SystemEvent)event;\n        if (event.eventKey().equals(counterEventKey)) {\n            int counter = sysEvent.parameter(hcdCounterKey).head();\n            log.info(\"Counter = \" + counter);\n        } else {\n            log.warn(\"Unexpected event received.\");\n        }\n    } else {\n        // ObserveEvent, not expected\n        log.warn(\"Unexpected ObserveEvent received.\");\n    }\n}\n\nprivate IEventSubscription subscribeToHcd() {\n    log.info(\"Starting subscription.\");\n    return cswCtx.eventService().defaultSubscriber().subscribeCallback(Collections.singleton(counterEventKey), this::processEvent);\n}\n\nprivate void unsubscribeHcd() {\n    log.info(\"Stopping subscription.\");\n    maybeEventSubscription.ifPresent(IEventSubscription::unsubscribe);\n}\nWe use the subscribeCallback method from the API and specify the method processEvent as our callback, in which we unpack the event and log the counter value. The subscribe methods in the API return a EventSubscription object, which can be used to stop the subscription, as demonstrated in the unsubscribeHCD method (which again, is not called in our tutorial).\nAgain, we return to our initialize method to show how subscription is started, and the reference to the subscription is stored for later use.\nScala private var maybeEventSubscription: Option[EventSubscription] = None\noverride def initialize(): Future[Unit] = {\n  log.info(\"In Assembly initialize\")\n  maybeEventSubscription = Some(subscribeToHcd())\n  Future.unit\n}\n\noverride def onShutdown(): Future[Unit] = {\n  log.info(\"Assembly is shutting down.\")\n  Future.unit\n} Java private Optional<IEventSubscription> maybeEventSubscription = Optional.empty();\n@Override\npublic CompletableFuture<Void> jInitialize() {\n    return CompletableFuture.runAsync(() -> {\n        log.info(\"In Assembly initialize\");\n        maybeEventSubscription = Optional.of(subscribeToHcd());\n    });\n}\n\n@Override\npublic CompletableFuture<Void> jOnShutdown() {\n    return CompletableFuture.runAsync(() -> log.info(\"Assembly is shutting down.\"));\n}","title":"Tutorial: Developing an Assembly"},{"location":"/commons/multiple-components.html#deploying-and-running-components","text":"","title":"Deploying and Running Components"},{"location":"/commons/multiple-components.html#pre-requisite","text":"A project, for example with the name sample-deploy, contains applications (ContainerCmd and HostConfig coming from csw-framework) to run components. Make sure that the necessary dependencies are added in the sample-deploy.","title":"Pre-requisite"},{"location":"/commons/multiple-components.html#run","text":"To start the Assembly and HCD, sbt runMain can be used as with the HCD, but with slightly different options. Now, we do not want to run in standalone mode, and we need to make sure to pass the container configuration file.\nGo to the project root directory and type sbt \"<deploy-module>/runMain <mainClass> --local <path-to-config-file>\", where\n<deploy-module> is the name of the deployment module created by the template (sample-deploy if using defaults) <mainClass> is the full class name of our ContainerCmd application, which the template names <package>.<name>deploy.<Name>ContainerCmdApp. If you accept the defaults for the template, it will be org.tmt.nfiraos.sampledeploy.SampleContainerCmdApp. If you are having problems determining the class name, use sbt <deploy-module>/run and it will prompt you the possibilities. <path-to-config-file> is the filename, which can be an absolute path or relative to the directory of the deployment module. If using defaults, this would be src/main/resources/SampleContainer.conf for Scala, and src/main/resources/JSampleContainer.conf for Java.\nSo if using the template defaults, the full command would be\nScala sbt \"sample-deploy/runMain org.tmt.nfiraos.sampledeploy.SampleContainerCmdApp --local src/main/resources/SampleContainer.conf\"\n Java sbt \"sample-deploy/runMain org.tmt.nfiraos.sampledeploy.SampleContainerCmdApp --local src/main/resources/JSampleContainer.conf\"\nLike with the HCD, the sbt stage command can also be used to create binaries in the target/universal/stage/bin directories of the root project.\nTo run using the deployment packaging, follow the steps below:\nRun sbt sample-deploy/universal:packageBin, this will create self contained zip in sample-deploy/target/universal directory. Unzip the generated zip file and enter into bin directory. You will see four scripts in the bin directory (two bash scripts and two windows scripts). If you want to start multiple containers on a host machine, follow this guide here. If you want to start multiple components in container mode or single component in standalone mode, follow this guide here. Example to run container: ./sample-container-cmd-app --local ../../../../sample-deploy/src/main/resources/SampleContainer.conf Example to run host config: ./sample-host-config-app --local ../../../../sample-deploy/src/main/resources/SampleHostConfig.conf -s ./sample-container-cmd-app\nNote This assumes you still have the CSW Services running using the csw-services.sh script as described in the Create a Component tutorial page.","title":"Run"},{"location":"/commons/using-alarms.html","text":"","title":"Using Alarms"},{"location":"/commons/using-alarms.html#using-alarms","text":"Alarms are used to indicate when some condition has arisen that warrants operator intervention. In order to ensure the integrity of alarms, components are required to broadcast the state of each alarm periodically. When situations occur in which a component is unable to determine and/or broadcast the alarm state, the alarm severity is automatically set to Disconnected after some period of time. This is brought to the operator’s attention and the operator can then take appropriate action. This means even when situations are normal, the component must continue to publish each alarm with an Okay severity; otherwise, the alarm severity is automatically marked as Disconnected, prompting the operator to investigate.\nThe CSW Alarm Service provides two APIs: a “Client API” used by a component, and an “Admin API” used to manage the Alarm Store and for operator use (typically via HCMS user interfaces). The Client API consists of a single method call, setSeverity. The Admin API includes methods to set up the Alarm Store, get alarm severities and health of components or subsystems, acknowledge alarms, reset latched alarms, and other operator tasks.\nThe Admin API can be exercised using the command line tool provided with CSW: csw-alarm-cli. See the reference manual for more info.\nMore details about the Alarm Service are found in the Alarm Service manual.","title":"Using Alarms"},{"location":"/commons/using-alarms.html#","text":"We will use our sample Assembly to monitor the counter event it is subscribed to, published by our sample HCD. Our alarm is based on the value of the counter, with the normal (Okay) range of 0 to 10, Warning range of 11 to 15, Major range of 16 to 20, and any other value generating a Critical alarm severity.\nFirst, the Alarm Store must be initialized with our alarm using the CLI tool csw-alarm-cli. A configuration file must be written that describes every alarm that will be used in the system. For TMT operations, this configuration will be generated from the ICD-DB models. For our tutorial, we will use a configuration with only the alarm we will be using.\nalarms.conf alarms: [\n  {\n    subsystem = NFIRAOS\n    component = sampleAssembly\n    name = counterTooHighAlarm\n    description = \"Warns when counter value is too high\"\n    location = \"enclosure\"\n    alarmType = Absolute\n    supportedSeverities = [Warning, Major, Critical]\n    probableCause = \"Sample HCD has run for too long\"\n    operatorResponse = \"Restart HCD\"\n    isAutoAcknowledgeable = false\n    isLatchable = false\n    activationStatus = Active\n  }\n]\nFor our tutorial, let’s save this file to disk in our resources folder in the sample-deploy module (sample-deploy/src/main/resources/alarms.conf).\nNow, we will use the CLI tool. Find it in the bin directory of the CSW application package available with the release as csw-alarm-cli.\nUse the init command to initialize the Alarm Store (this assumes csw-services is running, which sets up the Redis store for alarms).\ncsw-alarm-cli init $PROJECTDIR/sample-deploy/src/main/resources/alarms.conf --local\nwhere $PROJECTDIR is the root directory of your sample project. The --local flag indicates the configuration file is obtains from disk; omitting it would attempt to find the file in the Configuration Service, as would be done during operations.\nNow we will add code to our assembly to publish an alarm severity on every counter event. Let’s create some logic to take the counter as an argument and generate an alarm:\nScala private val safeRange  = 0 to 10\nprivate val warnRange  = 11 to 15\nprivate val majorRange = 16 to 20\nprivate def getCounterSeverity(counter: Int) = counter match {\n  case x if safeRange contains x  => AlarmSeverity.Okay\n  case x if warnRange contains x  => AlarmSeverity.Warning\n  case x if majorRange contains x => AlarmSeverity.Major\n  case _                          => AlarmSeverity.Critical\n}\n\nprivate val counterAlarmKey = AlarmKey(NFIRAOS, componentInfo.name, \"CounterTooHighAlarm\")\nprivate def setCounterAlarm(counter: Int) = {\n  // fire alarm according to counter value\n  val severity = getCounterSeverity(counter)\n  alarmService.setSeverity(counterAlarmKey, severity).onComplete {\n    case Success(value) => log.info(s\"Severity for alarm ${counterAlarmKey.name} set to \" + severity.toString)\n    case Failure(ex)    => log.error(s\"Error setting severity for alarm ${counterAlarmKey.name}: ${ex.getMessage}\")\n  }\n} Java private AlarmSeverity getCounterSeverity(int counter) {\n    if (counter >= 0 && counter <= 10) {\n        return JAlarmSeverity.Okay;\n    } else if (counter >= 11 && counter <= 15) {\n        return JAlarmSeverity.Warning;\n    } else if (counter >= 16 && counter <= 20) {\n        return JAlarmSeverity.Major;\n    }\n    return JAlarmSeverity.Critical;\n}\n\nprivate void setCounterAlarm(int counter) {\n    AlarmKey counterAlarmKey = new AlarmKey(NFIRAOS, cswCtx.componentInfo().name(), \"CounterTooHighAlarm\");\n    AlarmSeverity severity = getCounterSeverity(counter);\n    cswCtx.alarmService().setSeverity(counterAlarmKey, severity)\n            .whenComplete((d, ex) -> {\n                if (ex != null) {\n                    log.error(\"Error setting severity for alarm \"+ counterAlarmKey.name() + \": \" + ex.getMessage());\n                } else {\n                    log.info(\"Severity for alarm \" + counterAlarmKey.name() + \" set to \" + severity.toString());\n                }\n            });\n}\nThis code determines the severity of the alarm based on the rules we established above:\nOkay: 0-10 Warning: 11-15 Major: 16-20 Critical: any other value\nNow, all we have to do is call this whenever we receive a counter event. We add a call to the setCounterAlarm method in the processEvent method:\nScala private def processEvent(event: Event): Unit = {\n  log.info(s\"Event received: ${event.eventKey}\")\n  event match {\n    case e: SystemEvent =>\n      e.eventKey match {\n        case `counterEventKey` =>\n          val counter = e(hcdCounterKey).head\n          log.info(s\"Counter = $counter\")\n          setCounterAlarm(counter)\n        case _ => log.warn(\"Unexpected event received.\")\n      }\n    case e: ObserveEvent => log.warn(\"Unexpected ObserveEvent received.\") // not expected\n  }\n} Java private void processEvent(Event event) {\n    log.info(\"Event received: \"+ event.eventKey());\n    if (event instanceof SystemEvent) {\n        SystemEvent sysEvent = (SystemEvent)event;\n        if (event.eventKey().equals(counterEventKey)) {\n            int counter = sysEvent.parameter(hcdCounterKey).head();\n            log.info(\"Counter = \" + counter);\n            setCounterAlarm(counter);\n        } else {\n            log.warn(\"Unexpected event received.\");\n        }\n    } else {\n        // ObserveEvent, not expected\n        log.warn(\"Unexpected ObserveEvent received.\");\n    }\n}\nTo see the effect, let’s use the CLI to set up a subscription to the alarm. Note the alarm key is composed of the subsystem (nfiraos), component name (SampleAssembly for Scala, JSampleAssembly for Java), and the alarm name (counterTooHighAlarm).\nScala csw-alarm-cli severity subscribe --subsystem NFIRAOS --component SampleAssembly --name counterTooHighAlarm\n Java csw-alarm-cli severity subscribe --subsystem NFIRAOS --component JSampleAssembly --name counterTooHighAlarm\nNote that the alarm severity is currently Disconnected. This is the appropriate state, since we are not running the components. Now, run the Assembly and HCD, and you will see the severity of our alarm updated in the CLI as the severity changes.","title":"Tutorial: Using alarms in a component"},{"location":"/commons/unit-tests.html","text":"","title":"Adding Unit Tests"},{"location":"/commons/unit-tests.html#adding-unit-tests","text":"Unit testing is a fundamental part of programming, and essential component of the TMT quality assurance policy. TMT CSW extensively uses unit testing for both Scala and Java code, using ScalaTest for the former, and primarily JUnit for the latter (TestNG is used in one instance for the Event Service). While this guide will not attempt to educate the reader on how to use these popular packages, it will serve to show some examples of how tests can be created for component code and demonstrate some tools provided by CSW to simplify and enable integration of TMT components and other software with CSW and its services.","title":"Adding Unit Tests"},{"location":"/commons/unit-tests.html#csw-test-kit","text":"CSW provides a set of tools for use by developers called the CSW Test Kit. This allows the developer to start CSW services within the testing environment, so that they can be accessed by the components and/or applications being tested, as well as the testing fixtures themselves. It also provides simple methods to start components or a set of components within a container, as well as an ActorContext to be used if other Actors are needed to be created in the tests.\nMore information about testing with CSW and the CSW Test Kit can be found here.","title":"CSW Test Kit"},{"location":"/commons/unit-tests.html#","text":"In this part of the tutorial, we will write a few unit tests for our components. These tests are in no way meant to be comprehensive, but hopefully, they show enough to get you started.\nThe giter8 template provides the required directory structure, and skeletons for tests of the HCD and Assembly in both Java and Scala. It also provides some Component Configuration (ComponentInfo) files for running each of the HCD and Assembly in standalone mode for both languages. They are there for convenience, but may not be required depending your deployment and testing strategy. We will be using them in our tutorial.\nWe will first look at the tests for the Assembly. As described on the Testing Manual page, the Scala version overrides the CSW-provided superclass csw.testkit.scaladsl.ScalaTestFrameworkTestKit to get access to the services it needs. By passing in the needed services in the constructor, those services are started in the superclass’s beforeAll method. In the Java version, we must create an instance of csw.testkit.javadsl.FrameworkTestKitJunitResource to get access to and start our services, with the services we want to start passed into the constructor of this object.\nScala class SampleAssemblyTest extends ScalaTestFrameworkTestKit(AlarmServer, EventServer) with FunSuiteLike {\n  import frameworkTestKit.frameworkWiring._ Java public class JSampleAssemblyTest extends JUnitSuite {\n    @ClassRule\n    public static final FrameworkTestKitJunitResource testKit =\n            new FrameworkTestKitJunitResource(Arrays.asList(JCSWService.AlarmServer, JCSWService.EventServer));\nFor our tests, we will want to run the Assembly first. We will do this in the beforeAll method in Scala, and in a method with a @BeforeClass annotation in Java, so that it is run only once, before any of the tests are run. The Component Configuration files use are the one provided by the giter8 template. Note that for Scala, we must call the superclass’s beforeAll method to ensure the services are run.\nNote This code has been provided as part of the giter8 template, so the relevant line only needs to be uncommented.\nScala override def beforeAll(): Unit = {\n  super.beforeAll()\n  spawnStandalone(com.typesafe.config.ConfigFactory.load(\"SampleAssemblyStandalone.conf\"))\n} Java @BeforeClass\npublic static void setup() {\n    testKit.spawnStandalone(com.typesafe.config.ConfigFactory.load(\"JSampleAssemblyStandalone.conf\"));\n}\nNext, let’s add a test. We will add a simple test that uses the Location Service to make sure the Assembly is running and resolve the registration information for it.\nNote This test has been provided as part of the giter8 template as an example.\nScala import scala.concurrent.duration._\ntest(\"Assembly should be locatable using Location Service\") {\n  val connection   = AkkaConnection(ComponentId(\"SampleAssembly\", ComponentType.Assembly))\n  val akkaLocation = Await.result(locationService.resolve(connection, 10.seconds), 10.seconds).get\n\n  akkaLocation.connection shouldBe connection\n} Java @Test\npublic void testAssemblyShouldBeLocatableUsingLocationService() throws ExecutionException, InterruptedException {\n    Connection.AkkaConnection connection = new Connection.AkkaConnection(new ComponentId(\"JSampleAssembly\", JComponentType.Assembly));\n    ILocationService locationService = testKit.jLocationService();\n    AkkaLocation location = locationService.resolve(connection, Duration.ofSeconds(10)).get().get();\n\n    Assert.assertEquals(location.connection(), connection);\n}\nYou can try running the test either using sbt (sbt test from the project root directory) or directly in the IDE. If you are using IntelliJ, you can run the test by right-clicking on the file in the project explorer and clicking on Run 'SampleAssemblyTest' or Run 'JSampleAssemblyTest'. You can also right-click in the class body or the specific test body, if you want to run a single test.\nThe Assembly we have written does not have much of a public API, so we’ll turn to the HCD now, which has a few additional things we can test, including the publishing of Events and the handling of commands.\nFirst, we will set up the test fixtures similarly as we did for the Assembly, and add a similar test to show the component registers itself with the Location Service on startup.\nNote This also has been provided in the giter8 template. Uncomment the line that launches the HCD before tests are run.\nScala class SampleHcdTest extends ScalaTestFrameworkTestKit(AlarmServer, EventServer) with FunSuiteLike with BeforeAndAfterEach {\n  import frameworkTestKit.frameworkWiring._\n\n  override def beforeAll(): Unit = {\n    super.beforeAll()\n    spawnStandalone(com.typesafe.config.ConfigFactory.load(\"SampleHcdStandalone.conf\"))\n  }\n\n  import scala.concurrent.duration._\n  test(\"HCD should be locatable using Location Service\") {\n    val connection   = AkkaConnection(ComponentId(\"SampleHcd\", ComponentType.HCD))\n    val akkaLocation = Await.result(locationService.resolve(connection, 10.seconds), 10.seconds).get\n\n    akkaLocation.connection shouldBe connection\n  } Java public class JSampleHcdTest extends JUnitSuite {\n\n    @ClassRule\n    public static final FrameworkTestKitJunitResource testKit =\n            new FrameworkTestKitJunitResource(Arrays.asList(JCSWService.AlarmServer, JCSWService.EventServer));\n\n\n    @BeforeClass\n    public static void setup() {\n        testKit.spawnStandalone(com.typesafe.config.ConfigFactory.load(\"JSampleHcdStandalone.conf\"));\n    }\n\n    @Test\n    public void testHCDShouldBeLocatableUsingLocationService() throws ExecutionException, InterruptedException {\n        Connection.AkkaConnection connection = new Connection.AkkaConnection(new ComponentId(\"JSampleHcd\", JComponentType.HCD));\n        ILocationService locationService = testKit.jLocationService();\n        AkkaLocation location = locationService.resolve(connection, Duration.ofSeconds(10)).get().get();\n\n        Assert.assertEquals(connection, location.connection());\n    }\nNow let’s add a test to verify our component is publishing. We will set up a test subscriber to the counterEvent Events publisihed by the HCD. Since we cannot guarantee the order in which the tests are run, we cannot be certain how long the component has been running when this specific test is run. Therefore, checking the contents of the Events received is tricky. We will wait a bit at the start of the test to ensure we don’t get a InvalidEvent, which would be returned if we start our subscription before the HCD publishes any Events. Then, after setting up the subscription, we wait 5 seconds to allow the HCD to publish two additional Events plus the one we receive when the subscription starts. We will look at the counter value of the first counterEvent to determine what the set of counter values we expect to get in our subscription.\nScala test(\"should be able to subscribe to HCD events\") {\n  val counterEventKey = EventKey(Prefix(\"nfiraos.samplehcd\"), EventName(\"HcdCounter\"))\n  val hcdCounterKey   = KeyType.IntKey.make(\"counter\")\n\n  val eventService = eventServiceFactory.make(locationService)(actorSystem)\n  val subscriber   = eventService.defaultSubscriber\n\n  // wait for a bit to ensure HCD has started and published an event\n  Thread.sleep(2000)\n\n  val subscriptionEventList = mutable.ListBuffer[Event]()\n  subscriber.subscribeCallback(Set(counterEventKey), { ev =>\n    subscriptionEventList.append(ev)\n  })\n\n  // Sleep for 5 seconds, to allow HCD to publish events\n  Thread.sleep(5000)\n\n  // Event publishing period is 2 seconds.\n  // Expecting 3 events: first event on subscription\n  // and two more events 2 and 4 seconds later.\n  subscriptionEventList.toList.size shouldBe 3\n\n  // extract counter values to a List for comparison\n  val counterList = subscriptionEventList.toList.map {\n    case sysEv: SystemEvent if sysEv.contains(hcdCounterKey) => sysEv(hcdCounterKey).head\n    case _                                                   => -1\n  }\n\n  // we don't know exactly how long HCD has been running when this test runs,\n  // so we don't know what the first value will be,\n  // but we know we should get three consecutive numbers\n  val expectedCounterList = (0 to 2).toList.map(_ + counterList.head)\n\n  counterList shouldBe expectedCounterList\n} Java @Test\npublic void testShouldBeAbleToSubscribeToHCDEvents() throws InterruptedException {\n    EventKey counterEventKey = new EventKey(new Prefix(\"nfiraos.samplehcd\"), new EventName(\"HcdCounter\"));\n    Key<Integer> hcdCounterKey = JKeyType.IntKey().make(\"counter\");\n\n    IEventService eventService = testKit.jEventService();\n    IEventSubscriber subscriber = eventService.defaultSubscriber();\n\n    // wait for a bit to ensure HCD has started and published an event\n    Thread.sleep(2500);\n\n\n    ArrayList<Event> subscriptionEventList = new ArrayList<>();\n    subscriber.subscribeCallback(Collections.singleton(counterEventKey), subscriptionEventList::add);\n\n    // Sleep for 5 seconds, to allow HCD to publish events\n    Thread.sleep(5000);\n\n    // Event publishing period is 2 seconds.\n    // Expecting 3 events: first event on subscription\n    // and two more events 2 and 4 seconds later.\n    Assert.assertEquals(3, subscriptionEventList.size());\n\n    // extract counter values to a List for comparison\n    List<Integer> counterList = subscriptionEventList.stream()\n            .map(ev -> {\n                SystemEvent sysEv = ((SystemEvent) ev);\n                if (sysEv.contains(hcdCounterKey)) {\n                    return sysEv.parameter(hcdCounterKey).head();\n                } else {\n                    return -1;\n                }\n            })\n            .collect(Collectors.toList());\n\n    // we don't know exactly how long HCD has been running when this test runs,\n    // so we don't know what the first value will be,\n    // but we know we should get three consecutive numbers\n    int counter0 = counterList.get(0);\n    List<Integer> expectedCounterList = Arrays.asList(counter0, counter0+1, counter0+2);\n\n    Assert.assertEquals(expectedCounterList, counterList);\n}\nNext, we’ll add a test for command handling in the HCD. The HCD supports a “sleep” command, which sleeps some amount of seconds as specified in the command payload, and then returns a CommandResponse.Completed. We will specify a sleep of 5 seconds, and then check that we get the expected response. Note that the obtaining a CommandService reference requires an Akka Typed Actor System, so our code will create one using the Actor System provided by the Test Kit.\nScala import akka.actor.typed.scaladsl.adapter.UntypedActorSystemOps\nimplicit val typedActorSystem: ActorSystem[_] = actorSystem.toTyped\ntest(\"should be able to send sleep command to HCD\") {\n  import scala.concurrent.duration._\n  implicit val sleepCommandTimeout: Timeout = Timeout(10000.millis)\n\n  // Construct Setup command\n  val sleepTimeKey: Key[Long]         = KeyType.LongKey.make(\"SleepTime\")\n  val sleepTimeParam: Parameter[Long] = sleepTimeKey.set(5000).withUnits(Units.millisecond)\n  val setupCommand                    = Setup(Prefix(\"test\"), CommandName(\"sleep\"), Some(ObsId(\"2018A-001\"))).add(sleepTimeParam)\n\n  val connection = AkkaConnection(ComponentId(\"SampleHcd\", ComponentType.HCD))\n\n  val akkaLocation = Await.result(locationService.resolve(connection, 10.seconds), 10.seconds).get\n\n  val hcd = CommandServiceFactory.make(akkaLocation)\n  // submit command and handle response\n  val responseF = hcd.submit(setupCommand)\n\n  Await.result(responseF, 10000.millis) shouldBe CommandResponse.Completed(setupCommand.runId)\n} Java private ActorSystem<Void> typedActorSystem = akka.actor.typed.javadsl.Adapter.toTyped(testKit.actorSystem());\n@Test\npublic void testShouldBeAbleToSendSleepCommandToHCD() throws ExecutionException, InterruptedException {\n\n    // Construct Setup command\n    Key<Long> sleepTimeKey = JKeyType.LongKey().make(\"SleepTime\");\n    Parameter<Long> sleepTimeParam = sleepTimeKey.set(5000L).withUnits(JUnits.millisecond);\n\n    Setup setupCommand = new Setup(new Prefix(\"test\"), new CommandName(\"sleep\"), Optional.of(new ObsId(\"2018A-001\"))).add(sleepTimeParam);\n\n    Timeout commandResponseTimeout = new Timeout(10, TimeUnit.SECONDS);\n\n    Connection.AkkaConnection connection = new Connection.AkkaConnection(new ComponentId(\"JSampleHcd\", JComponentType.HCD));\n    ILocationService locationService = testKit.jLocationService();\n    AkkaLocation location = locationService.resolve(connection, Duration.ofSeconds(10)).get().get();\n\n    ICommandService hcd = CommandServiceFactory.jMake(location, typedActorSystem);\n\n    Assert.assertEquals(hcd.submit(setupCommand, commandResponseTimeout).get(), new CommandResponse.Completed(setupCommand.runId()));\n}\nFinally, we will show an example of tests that check that exceptions are thrown when expected. We will do this by using the “sleep” command, but failing to wait long enough for the sleep to complete. This causes a TimeoutException in Scala, and an ExecutionException in Java, and our tests check to see that these types are in fact thrown.\nScala test(\"should get timeout exception if submit timeout is too small\") {\n  import scala.concurrent.duration._\n  implicit val sleepCommandTimeout: Timeout = Timeout(1000.millis)\n\n  // Construct Setup command\n  val sleepTimeKey: Key[Long]         = KeyType.LongKey.make(\"SleepTime\")\n  val sleepTimeParam: Parameter[Long] = sleepTimeKey.set(5000).withUnits(Units.millisecond)\n  val setupCommand                    = Setup(Prefix(\"test\"), CommandName(\"sleep\"), Some(ObsId(\"2018A-001\"))).add(sleepTimeParam)\n\n  val connection = AkkaConnection(ComponentId(\"SampleHcd\", ComponentType.HCD))\n\n  val akkaLocation = Await.result(locationService.resolve(connection, 10.seconds), 10.seconds).get\n\n  val hcd = CommandServiceFactory.make(akkaLocation)\n\n  // submit command and handle response\n  intercept[java.util.concurrent.TimeoutException] {\n    val responseF = hcd.submit(setupCommand)\n    Await.result(responseF, 10000.millis) shouldBe CommandResponse.Completed(setupCommand.runId)\n  }\n} Java @Rule\npublic ExpectedException thrown = ExpectedException.none();\n\n@Test\npublic void testShouldGetExecutionExceptionIfSubmitTimeoutIsTooSmall() throws ExecutionException, InterruptedException {\n\n    // Construct Setup command\n    Key<Long> sleepTimeKey = JKeyType.LongKey().make(\"SleepTime\");\n    Parameter<Long> sleepTimeParam = sleepTimeKey.set(5000L).withUnits(JUnits.millisecond);\n\n    Setup setupCommand = new Setup(new Prefix(\"test\"), new CommandName(\"sleep\"), Optional.of(new ObsId(\"2018A-001\"))).add(sleepTimeParam);\n\n    Timeout commandResponseTimeout = new Timeout(1, TimeUnit.SECONDS);\n\n    Connection.AkkaConnection connection = new Connection.AkkaConnection(new ComponentId(\"JSampleHcd\", JComponentType.HCD));\n    ILocationService locationService = testKit.jLocationService();\n    AkkaLocation location = locationService.resolve(connection, Duration.ofSeconds(10)).get().get();\n\n    ICommandService hcd = CommandServiceFactory.jMake(location, typedActorSystem);\n\n    thrown.expect(ExecutionException.class);\n    hcd.submit(setupCommand, commandResponseTimeout).get();\n}","title":"Tutorial: Writing unit tests for our components"},{"location":"/commons/messages.html","text":"","title":"Messages"},{"location":"/commons/messages.html#messages","text":"In the distributed environment of TMT observatory, Components communicate with each other by sending asynchronous Messages. These messages have a Command payload, which flows down through the Sequencer components to the Assemblies, HCDs and finally to the hardware. At each hop Commands are validated, interpreted and further propagated making their journey to its destination. Commands provide flexible placeholders to store values to convey precise intent of the sender component.","title":"Messages"},{"location":"/commons/messages.html#dependencies","text":"sbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-messages\" % \"0.1-SNAPSHOT\"\ncsw-messages library provides out of the box support to cater to the diverse communication requirements. Consumer of this library will be able to create Commands, Events, States to store ParameterSets.\nKeys and Parameters How to Create a Parameter Primitive Datatypes Arrays Matrices Domain Specific Types Source Code for Examples Units Default Units for Keys SI Units CGS Units Astrophysical Units Imperial Units Others - Engineering Usage Examples Source Code for Examples Subsystem List of Subsystems Usage Examples Commands ObsId Prefix CommandName Setup Command Observe Command Wait Command JSON serialization Unique Key constraint Cloning a Command Source Code for Examples Events EventTime System Event Observe Event JSON Serialization Unique Key Constraint Protobuf Source Code for Examples State Variables DemandState CurrentState JSON Serialization Unique Key Constraint Source Code for Examples Result JSON serialization Unique Key Constraint Source Code for Examples","title":"Dependencies"},{"location":"/messages/keys-parameters.html","text":"","title":"Keys and Parameters"},{"location":"/messages/keys-parameters.html#keys-and-parameters","text":"The library offers a flexible and typesafe means to create Parameters to store values like primitive types, collection types or domain specific types.\nA Parameter is a Key and Value where the Value must be from a set of defined primitive types including binary data. The Value of a Parameter is always considered to be an Array of the type (i.e. if a single value is stored it is at array location 0). A Parameter is immutable; a modification to an existing Parameter will return a new instance.\nA Value can also have Units, which must be of the defined types. See Units for more information. At this time Units are informational only–no calculation or conversion support is provided. Some systems may provide a key value with different units, and receiver can inspect the Units to make a decision on how to handle the value.\nA ParameterSet is a Set of Parameter. Various other message types include a ParameterSet (e.g. Setup, Event). A key is unique in a ParameterSet since it is a Set.","title":"Keys and Parameters"},{"location":"/messages/keys-parameters.html#how-to-create-a-parameter","text":"choose an appropriate KeyType from the tables below for your language(Scala/Java). calling the make method on KeyType and supplying a String keyName will return a suitably typed Key instance. explore the overloaded set and -> methods, which will allow you to store values of the based on chosen KeyType. e.g. JKeyTypes.BooleanKey will allow storing only java.lang.Boolean values.","title":"How to Create a Parameter"},{"location":"/messages/keys-parameters.html#primitive-datatypes","text":"Primitive Scala KeyType Java KeyType Boolean KeyType.BooleanKey JKeyTypes.BooleanKey Character KeyType.CharKey JKeyTypes.JCharKey Byte KeyType.ByteKey JKeyTypes.ByteKey Short KeyType.ShortKey JKeyTypes.ShortKey Long KeyType.LongKey JKeyTypes.LongKey Int KeyType.IntKey JKeyTypes.IntKey Float KeyType.FloatKey JKeyTypes.FloatKey Double KeyType.DoubleKey JKeyTypes.DoubleKey String KeyType.StringKey JKeyTypes.StringKey Timestamp KeyType.TimestampKey JKeyTypes.TimestampKey\nScala //declare keyname\nval s1: String = \"encoder\"\n\n//making 3 keys\nval k1: Key[Boolean] = KeyType.BooleanKey.make(s1)\nval k2: Key[Short]   = KeyType.ShortKey.make(\"RandomKeyName\")\nval k3: Key[String]  = KeyType.StringKey.make(s1)\n\n//storing a single value\nval booleanParam: Parameter[Boolean] = k1.set(true)\n\n//storing multiple values\nval paramWithShorts1: Parameter[Short] = k2.set(1, 2, 3, 4)\nval paramWithShorts2: Parameter[Short] = k2 -> (1, 2, 3, 4)\nval paramWithShorts3: Parameter[Short] = k2 -> Array[Short](1, 2, 3, 4)\n\n//associating units\nval weekDays: Array[String]            = Array(\"Sunday\", \"Monday\", \"Tuesday\")\nval paramWithUnits1: Parameter[String] = k3.set(weekDays, Units.day)\nval paramWithUnits2: Parameter[String] = k3 -> weekDays withUnits Units.day\n\n//deault unit is NoUnits\nassert(booleanParam.units === Units.NoUnits)\n\n//set units explicitly on an existing Parameter\nval paramWithUnits3: Parameter[Short] = paramWithShorts1.withUnits(Units.meter)\n\n//retrieve values from Parameter\nval allValues: Array[Short] = paramWithShorts1.values\n\n//retrieve just top value\nval head: Short = paramWithShorts1.head Java //making 3 keys\nString keyName = \"encoder\";\nKey<Boolean> k1 = JKeyType.BooleanKey().make(keyName);\nKey<Short> k2 = JKeyType.ShortKey().make(keyName);\nKey<String> k3 = JKeyType.StringKey().make(keyName);\n\n//storing a single value\nParameter<Boolean> booleanParam = k1.set(true);\n\n//storing multiple values\nShort[] shortArray = {1, 2, 3, 4};\nParameter<Short> paramWithManyShorts1 = k2.set(shortArray);\nParameter<Short> paramWithManyShorts2 = k2.set((short) 1, (short) 2, (short) 3, (short) 4);\n\n//associating units\nString[] weekDays = {\"Sunday\", \"Monday\", \"Tuesday\"};\nParameter<String> paramWithUnits1 = k3.set(weekDays, JUnits.day);\nParameter<String> paramWithUnits2 = k3.set(weekDays).withUnits(JUnits.day);\n\n//deault unit is NoUnits\nboolean hasDefaultUnit = booleanParam.units() == JUnits.NoUnits; //true\n\n//set units explicitly on an existing Parameter\nParameter<Short> paramWithUnits3 = paramWithManyShorts1.withUnits(JUnits.meter);\n\n//retrieve values from Parameter\nShort[] allValues = (Short[]) paramWithManyShorts1.values();\n\n//retrieve just top value\nShort head = paramWithManyShorts1.head();","title":"Primitive Datatypes"},{"location":"/messages/keys-parameters.html#arrays","text":"Primitive Scala KeyType Java KeyType ByteArray KeyType.ByteArrayKey JKeyTypes.ByteArrayKey ShortArray KeyType.ShortArrayKey JKeyTypes.ShortArrayKey LongArray KeyType.LongArrayKey JKeyTypes.LongArrayKey IntArray KeyType.IntArrayKey JKeyTypes.IntArrayKey FloatArray KeyType.FloatArrayKey JKeyTypes.FloatArrayKey DoubleArray KeyType.DoubleArrayKey JKeyTypes.DoubleArrayKey\nScala //make some arrays\nval arr1: Array[Double] = Array(1.0, 2.0, 3.0, 4.0, 5.0)\nval arr2: Array[Double] = Array(10.0, 20.0, 30.0, 40.0, 50.0)\n\n//keys\nval filterKey: Key[ArrayData[Double]] = KeyType.DoubleArrayKey.make(\"filter\")\n\n//Store some values using helper class ArrayData\nval p1: Parameter[ArrayData[Double]] = filterKey.set(ArrayData(arr1), ArrayData(arr2))\nval p2: Parameter[ArrayData[Double]] = filterKey -> ArrayData(arr1 ++ arr2) withUnits Units.liter\n\n//add units to existing parameters\nval p1AsCount = p1.withUnits(Units.count)\n\n//default unit is NoUnits\nassert(p1.units === Units.NoUnits)\n\n//retrieving values\nval head: Array[Double]                 = p1.head.data.toArray\nval allValues: Array[ArrayData[Double]] = p1.values Java //make some arrays\nDouble[] arr1 = {1.0, 2.0, 3.0, 4.0, 5.0};\nDouble[] arr2 = {10.0, 20.0, 30.0, 40.0, 50.0};\n\n//keys\nKey<ArrayData<Double>> filterKey = JKeyType.DoubleArrayKey().make(\"filter\");\n\n//Store some values using helper method in ArrayData\nParameter<ArrayData<Double>> p1 = filterKey.set(ArrayData.fromJavaArray(arr1), ArrayData.fromJavaArray(arr2));\nParameter<ArrayData<Double>> p2 = filterKey.set(ArrayData.fromJavaArray(arr2)).withUnits(JUnits.liter);\n\n//add units to existing parameters\nParameter<ArrayData<Double>> p1AsCount = p1.withUnits(JUnits.count);\n\n//default unit is NoUnits\nboolean bDefaultUnit = JUnits.NoUnits == p1.units();\n\n//retrieving values\nList<Double> head = p1.head().jValues();\nList<ArrayData<Double>> listOfArrayData = p1.jValues();\nDouble[] arrayOfDoubles = (Double[]) p2.jValues().get(0).values();","title":"Arrays"},{"location":"/messages/keys-parameters.html#matrices","text":"Primitive Scala KeyType Java KeyType ByteMatrix KeyType.ByteMatrixKey JKeyTypes.ByteMatrixKey ShortMatrix KeyType.ShortMatrixKey JKeyTypes.ShortMatrixKey LongMatrix KeyType.LongMatrixKey JKeyTypes.LongMatrixKey IntMatrix KeyType.IntMatrixKey JKeyTypes.IntMatrixKey FloatMatrix KeyType.FloatMatrixKey JKeyTypes.FloatMatrixKey DoubleMatrix KeyType.DoubleMatrixKey JKeyTypes.DoubleMatrixKey\nScala //make some arrays\nval m1: Array[Array[Byte]] = Array(Array[Byte](1, 2, 3), Array[Byte](4, 5, 6), Array[Byte](7, 8, 9))\nval m2: Array[Array[Byte]] = Array(Array[Byte](1, 2, 3, 4, 5), Array[Byte](10, 20, 30, 40, 50))\n\n//keys\nval encoderKey: Key[MatrixData[Byte]] = KeyType.ByteMatrixKey.make(\"encoder\")\n\n//Store some values using helper class MatrixData\nval p1: Parameter[MatrixData[Byte]] = encoderKey.set(MatrixData.fromArrays(m1))\nval p2: Parameter[MatrixData[Byte]] = encoderKey.set(m1, m2) withUnits Units.liter\n\n//add units to existing parameters\nval p1AsLiter = p1.withUnits(Units.liter)\n\n//default unit is NoUnits\nassert(p1.units === Units.NoUnits)\n\n//retrieving values\nval head: Array[Array[Byte]]           = p1.head.data.map(_.toArray).toArray\nval allValues: Array[MatrixData[Byte]] = p1.values Java //make some arrays\nByte[][] m1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\nByte[][] m2 = {{1, 2, 3, 4, 5}, {10, 20, 30, 40, 50}};\n\n//keys\nKey<MatrixData<Byte>> encoderKey = JKeyType.ByteMatrixKey().make(\"encoder\");\n\n//Store some values using helper method in ArrayData\nParameter<MatrixData<Byte>> p1 = encoderKey.set(\n        MatrixData.fromJavaArrays(Byte.class, m1),\n        MatrixData.fromJavaArrays(Byte.class, m2));\nParameter<MatrixData<Byte>> p2 = encoderKey.set(\n        MatrixData.fromJavaArrays(Byte.class, m2)\n).withUnits(JUnits.liter);\n\n//add units to existing parameters\nParameter<MatrixData<Byte>> p1AsLiter = p1.withUnits(JUnits.liter);\n\n//default unit is NoUnits\nboolean bDefaultUnit = JUnits.NoUnits == p1.units();\n\n//retrieving values\nMatrixData<Byte> head = p1.head();\nList<MatrixData<Byte>> matrixData1 = p1.jValues();\nList<MatrixData<Byte>> matrixData2 = p2.jValues();","title":"Matrices"},{"location":"/messages/keys-parameters.html#domain-specific-types","text":"Primitive Scala KeyType Java KeyType Choice KeyType.ChoiceKey JKeyTypes.ChoiceKey RaDec KeyType.RaDecKey JKeyTypes.RaDecKey Struct KeyType.StructKey JKeyTypes.StructKey","title":"Domain Specific Types"},{"location":"/messages/keys-parameters.html#choice","text":"A key for a choice item similar to an enumeration.\nScala //Choice\nval choices = Choices.from(\"A\", \"B\", \"C\")\n\n//keys\nval choice1Key: GChoiceKey = ChoiceKey.make(\"mode\", choices)\nval choice2Key: GChoiceKey = ChoiceKey.make(\n  \"mode-reset\",\n  Choices.fromChoices(Choice(\"c\"), Choice(\"b\"), Choice(\"a\"))\n)\n\n//store values\nval p1: Parameter[Choice] = choice1Key\n  .set(Array(Choice(\"A\")))\n  .withUnits(Units.foot)\nval p2: Parameter[Choice] = choice2Key.set(Array(Choice(\"c\")))\n\n//add units\nval paramWithFoot = p1.withUnits(Units.foot)\n\n//default unit is NoUnits\nassert(p2.units === Units.NoUnits)\n\n//retrieving values\nval head: Choice          = p1.head\nval values: Array[Choice] = p2.values\n Java //Choice\nfinal Choices choices = Choices.from(\"A\", \"B\", \"C\");\n\n//keys\nGChoiceKey choice1Key = JKeyType.ChoiceKey().make(\"mode\", choices);\nGChoiceKey choice2Key = JKeyType.ChoiceKey().make(\n        \"mode-reset\",\n        Choices.fromChoices(\n                new Choice(\"c\"),\n                new Choice(\"b\"),\n                new Choice(\"a\")));\n\n//store values\nParameter<Choice> p1 = choice1Key.set(new Choice(\"A\")).withUnits(JUnits.foot);\nParameter<Choice> p2 = choice2Key.set(new Choice(\"c\"));\n\n//add units\nParameter<Choice> paramWithFoot = p1.withUnits(JUnits.foot);\n\n//default unit is NoUnits\nboolean bDefaultUnit = JUnits.NoUnits == p2.units();\n\n//retrieving values\nChoice head = p1.head();\nList<Choice> values = p2.jValues();","title":"Choice"},{"location":"/messages/keys-parameters.html#radec","text":"Holds Ra(Right Ascension) and Dec(Declination) values\nNote This version of the radec parameter is a placeholder for testing. A more complete version will be added once details of positions are better defined.\nScala //RaDec\nval raDec1: RaDec = RaDec(1.0, 2.0)\nval raDec2: RaDec = RaDec(3.0, 4.0)\n\n//keys\nval raDecKey: Key[RaDec] = KeyType.RaDecKey.make(\"raDecKey\")\n\n//store values\nval p1: Parameter[RaDec] = raDecKey.set(raDec1)\nval p2: Parameter[RaDec] = raDecKey -> Array(raDec1, raDec2)\n\n//add units\nval paramWithDegree = p1.withUnits(Units.degree)\n\n//default unit is NoUnits\nassert(p2.units === Units.NoUnits)\n\n//retrieving values\nval head: RaDec          = p1.head\nval values: Array[RaDec] = p2.values\n Java //RaDec\nRaDec raDec1 = new RaDec(1.0, 2.0);\nRaDec raDec2 = new RaDec(3.0, 4.0);\n\n//keys\nKey<RaDec> raDecKey = JKeyType.RaDecKey().make(\"raDecKey\");\n\n//store values\nParameter<RaDec> p1 = raDecKey.set(raDec1);\nParameter<RaDec> p2 = raDecKey.set(raDec1, raDec2).withUnits(JUnits.degree);\n\n//add units\nParameter<RaDec> paramWithDegree = p1.withUnits(JUnits.degree);\n\n//default unit is NoUnits\nboolean bDefaultUnit = JUnits.NoUnits == p1.units();\n\n//retrieving values\nRaDec head = p1.head();\nList<RaDec> values = p2.jValues();","title":"RaDec"},{"location":"/messages/keys-parameters.html#struct","text":"Stores a set of Parameters for telescope and instrument control. Lot of utility functions available for store, add, remove, list Keys and Paramete\nScala //keys\nval skey: Key[Struct] = StructKey.make(\"myStruct\")\n\nval ra    = KeyType.StringKey.make(\"ra\")\nval dec   = KeyType.StringKey.make(\"dec\")\nval epoch = KeyType.DoubleKey.make(\"epoch\")\n\n//initialize struct\nval struct1: Struct = Struct().madd(ra.set(\"12:13:14.1\"), dec.set(\"32:33:34.4\"), epoch.set(1950.0))\nval struct2: Struct = Struct().madd(dec.set(\"32:33:34.4\"), ra.set(\"12:13:14.1\"), epoch.set(1970.0))\n\n//make parameters\nval p1: Parameter[Struct] = skey.set(struct1)\nval p2: Parameter[Struct] = skey.set(struct1, struct2)\n\n//add units\nval paramWithLightYear = p1.withUnits(Units.lightyear)\n\n//default unit is NoUnits\nassert(p2.units === Units.NoUnits)\n\n//retrieving values\nval head: Struct          = p1.head\nval values: Array[Struct] = p2.values\n\n//get individual keys\nval firstKey: Option[Parameter[String]]  = struct1.get(KeyType.StringKey.make(\"ra\"))\nval secondKey: Option[Parameter[String]] = struct1.get(\"dec\", KeyType.StringKey)\nval thirdKey: Option[Parameter[Double]]  = struct1.get(\"epoch\", KeyType.DoubleKey)\n\n//access parameter using 'parameter' or 'apply' method\nassert(struct1.parameter(ra) === struct1(ra))\n\n//remove a parameter and verify it doesn't exist\nval mutated1: Struct = struct1.remove(ra) //using key\nval mutated2         = struct1.remove(firstKey.get)\nassert(mutated1.exists(ra) === false)\nassert(mutated2.exists(ra) === false)\n\n//find out missing keys\nval missingKeySet: Set[String] = mutated1.missingKeys(ra, dec, epoch, KeyType.FloatKey.make(\"missingKey\"))\nassert(missingKeySet === Set(\"ra\", \"missingKey\"))\n Java //keys\nKey<Struct> skey = JKeyType.StructKey().make(\"myStruct\");\n\nKey<String> ra = JKeyType.StringKey().make(\"ra\");\nKey<String> dec = JKeyType.StringKey().make(\"dec\");\nKey<Double> epoch = JKeyType.DoubleKey().make(\"epoch\");\n\n//initialize struct\nStruct struct1 = new Struct().madd(\n        ra.set(\"12:13:14.1\"),\n        dec.set(\"32:33:34.4\"),\n        epoch.set(1950.0));\nStruct struct2 = new Struct().madd(\n        dec.set(\"32:33:34.4\"),\n        ra.set(\"12:13:14.1\"),\n        epoch.set(1970.0));\n\n//make parameters\nParameter<Struct> p1 = skey.set(struct1);\nParameter<Struct> p2 = skey.set(struct1, struct2);\n\n//add units\nParameter<Struct> paramWithLightYear = p1.withUnits(JUnits.lightyear);\n\n//default unit is NoUnits\nboolean bDefaultUnit = JUnits.NoUnits == p1.units();\n\n//retrieving values\nStruct head = p1.head();\nList<Struct> structs = p2.jValues();\n\n//get individual keys\nOptional<Parameter<String>> firstKey = struct1.jGet(JKeyType.StringKey().make(\"ra\"));\nOptional<Parameter<String>> secondKey = struct1.jGet(\"dec\", JKeyType.StringKey());\nOptional<Parameter<Double>> thirdKey = struct1.jGet(\"epoch\", JKeyType.DoubleKey());\n\n//access parameter using 'parameter' and 'apply' method\nboolean bSuccess = struct1.parameter(ra) == struct1.apply(ra);\n\n//remove a parameter and verify it doesn't exist\nStruct mutated1 = struct1.remove(ra); //using key\nStruct mutated2 = struct1.remove(firstKey.get());\n\n//find out missing keys\nSet<String> missingKeySet = mutated1.jMissingKeys(ra, dec, epoch, JKeyType.StringKey().make(\"someRandomKey\"));\nList<String> expectedMissingKeys = Arrays.asList(\"ra\", \"someRandomKey\");","title":"Struct"},{"location":"/messages/keys-parameters.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source Code for Examples"},{"location":"/messages/units.html","text":"","title":"Units"},{"location":"/messages/units.html#units","text":"Listed below are Units of Measurement, supported by TMT observatory framework and are available as Enumerated values. Units are optionally attached to Parameter Keys.\nNote Units are made available via separate files, for consumption in Scala and Java code. Import csw.messages.params.models.Units for Scala Import csw.messages.javadsl.JUnits for Java.\nNote The set of supported Units will be modified as more required Units are discovered.","title":"Units"},{"location":"/messages/units.html#default-units-for-keys","text":"The default unit for TimestampKey(in Scala and Java both) is second. For all the remaining keys, default unit is NoUnits.","title":"Default Units for Keys"},{"location":"/messages/units.html#si-units","text":"Name Abbreviation Description angstrom Angstrom 10 -1 nm arcmin arcmin arc minute; angular measurement arcsec arcsec arc second: angular measurement day d day - 24 hours degree deg degree: agular measurement 1/360 of full rotation elvolt eV electron volt 1.6022x10-19 J gram g gram 10-3 kg hour h hour 3.6x10+3 s hertz Hz frequency joule J Joule: energy N m kelvin K Kelvin: temperature with a null point at absolute zero kilogram kg kilogram, base unit of mass in SI kilometer km kilometers - 10+3 m liter l liter, metric unit of volume 10+3 cm+3 meter m meter: base unit of length in SI marcsec mas milli arc second: angular measurement 10-3 arcsec millimeter mm millimeters - 10-3 m millisecond ms milliseconds - 10-3 s micron µm micron: alias for micrometer micrometer µm micron: 10-6 m minute min minute 6x10+1 s newton N Newton: force pascal Pa Pascal: pressure radian rad radian: angular measurement of the ratio between the length of an arc and its radius second s second: base unit of time in SI sday sday sidereal day is the time of one rotation of the Earth: 8.6164x10+4 s steradian sr steradian: unit of solid angle in SI - rad+2 microarcsec µas micro arcsec: angular measurement volt V Volt: electric potential or electromotive force watt W Watt: power week wk week - 7 d year yr year - 3.6525x10+2 d","title":"SI Units"},{"location":"/messages/units.html#cgs-units","text":"Name Abbreviation Description coulomb C coulomb: electric charge centimeter cm centimeter erg erg erg: CGS unit of energy","title":"CGS Units"},{"location":"/messages/units.html#astrophysical-units","text":"Name Abbreviation Description au AU astronomical unit: approximately the mean Earth-Sun distance jansky Jy Jansky: spectral flux density - 10-26 W/Hz m+2 lightyear lyr light year - 9.4607x10+15 m mag mag stellar magnitude","title":"Astrophysical Units"},{"location":"/messages/units.html#imperial-units","text":"Name Abbreviation Description cal cal thermochemical calorie: pre-SI metric unit of energy foot ft international foot - 1.2x10+1 inch inch inch international inch - 2.54 cm pound lb international avoirdupois pound - 1.6x10+1 oz mile mi international mile - 5.28x10+3 ft ounce oz international avoirdupois ounce yard yd international yard - 3 ft","title":"Imperial Units"},{"location":"/messages/units.html#others-engineering","text":"Name Abbreviation Description NoUnits none scalar - no units specified encoder enc encoder counts count ct counts as for an encoder or detector pix pix pixel","title":"Others - Engineering"},{"location":"/messages/units.html#usage-examples","text":"Scala //declare keyname\nval s1: String = \"encoder\"\n\n//making 3 keys\nval k1: Key[Boolean] = KeyType.BooleanKey.make(s1)\nval k2: Key[Short]   = KeyType.ShortKey.make(\"RandomKeyName\")\nval k3: Key[String]  = KeyType.StringKey.make(s1)\n\n//storing a single value, default unit is NoUnits\nval bParam: Parameter[Boolean] = k1.set(true)\nval bDefaultUnitSet: Boolean   = bParam.units === Units.NoUnits //true\n\n//default unit for TimestampKey\nval tParam: Parameter[Instant] = KeyType.TimestampKey.make(\"now\").set(Instant.now())\nval defaultTimeUnit: Units     = tParam.units //is second\n\n//storing multiple values\nval paramOfShorts: Parameter[Short] = k2.set(1, 2, 3, 4)\n\n//values to store\nval weekDays: Array[String] = Array(\"Sunday\", \"Monday\", \"Tuesday\")\n\n//associating units via set\nval paramWithUnits1: Parameter[String] = k3.set(weekDays, Units.day)\n//associating units via withUnits\nval paramWithUnits2: Parameter[String] = k3 -> weekDays withUnits Units.count\n//change existing unit\nval paramWithUnits3: Parameter[Short] = paramOfShorts.withUnits(Units.meter) Java //declare keyname\nString s1 = \"encoder\";\n\n//making 3 keys\nKey<Boolean> k1 = JKeyType.BooleanKey().make(s1);\nKey<Short> k2 = JKeyType.ShortKey().make(\"RandomKeyName\");\nKey<String> k3 = JKeyType.StringKey().make(s1);\n\n//storing a single value, default unit is NoUnits\nParameter<Boolean> bParam = k1.set(true);\nboolean bDefaultUnitSet = bParam.units() == JUnits.NoUnits; //true\n\n//default unit for TimestampKey\nParameter<Instant> tParam = JKeyType\n        .TimestampKey()\n        .make(\"now\")\n        .set(Instant.now());\nUnits defaultTimeUnit = tParam.units(); //is second\n\n//storing multiple values\nParameter<Short> paramOfShorts = k2.set(\n        (short) 1,\n        (short) 2,\n        (short) 3,\n        (short) 4\n);\n\n//values to store\nString[] weekDays = {\"Sunday\", \"Monday\", \"Tuesday\"};\n\n//associating units via set\nParameter<String> paramWithUnits1 = k3.set(weekDays, JUnits.day);\n//associating units via withUnits\nParameter<String> paramWithUnits2 = k3.set(weekDays).withUnits(JUnits.day);\n//change existing unit\nParameter<Short> paramWithUnits3 = paramOfShorts.withUnits(JUnits.meter);","title":"Usage Examples"},{"location":"/messages/units.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source Code for Examples"},{"location":"/messages/subsystem.html","text":"","title":"Subsystem"},{"location":"/messages/subsystem.html#subsystem","text":"TMT Observatory system is composed of many subsystems. The subsystems that are known participants in the TMT Software System are predefined and the list is covered under the Subsystem enumeration. They are identified using a 3 or 4 letter abbreviation.\nSusbsystem values are used to construct Prefix and are used in communication vehicles such as Commands, Events and States.\nNote Subsystems are made available via separate files, for consumption in Scala and Java code. Import csw.messages.params.models.Subsystem for Scala Import csw.messages.javadsl.JSubsystem for Java.","title":"Subsystem"},{"location":"/messages/subsystem.html#list-of-subsystems","text":"Abbreviation Susbsystem name AOESW AO Executive Software APS Alignment and Phasing System CIS Communications and Information Systems CSW Common Software DMS Data Management System DPS Data Processing System ENC Enclosure ESEN Engineering Sensor System ESW Executive Software System GMS Global Metrology System Controls IRIS InfraRed Imaging Spectrometer IRMS Infrared Multi-Slit Spectrometer LGSF Lasert Guide Star Facility M1CS M1 Control System M2CS M2 Control System M3CS M3 Control System MCS Mount Control System NFIRAOS Narrow Field Infrared AO System NSCU NFIRAOS Science Calibration Unit OSS Observatory Safety System PFCS Prime Focus Camera Controls PSFR NFIRAOS AO PSF Reconstructor RTC NFIRAOS Real-time Controller RPG NFIRAOS AO Reconstructor Parameter Generator SCMS Site Conditions Monitoring System SOSS Science Operations Support System STR Telescope Structure SUM Summit Facility TCS Telescope Control System TINC Prime Focus Camera Controls WFOS Wide Field Optical Spectrometer TEST Testing System BAD Unknown/default Subsystem","title":"List of Subsystems"},{"location":"/messages/subsystem.html#usage-examples","text":"The usage examples can be found in Events, Commands, States","title":"Usage Examples"},{"location":"/messages/commands.html","text":"","title":"Commands"},{"location":"/messages/commands.html#commands","text":"Commands are parameter sets called Setup, Observe, and Wait. A command is created with the source of the command, given by a prefix, the name of the command, and an optional ObsId. Parameters are added to the command as needed. As the ESW design is developed, these command structures may evolve.","title":"Commands"},{"location":"/messages/commands.html#obsid","text":"An ObsID, or observation Id, indicates the observation the command is associated with. It can be constructed by creating an instance of ObsId.\nScala val obsId: ObsId = ObsId(\"Obs001\") Java ObsId obsId = new ObsId(\"Obs001\");","title":"ObsId"},{"location":"/messages/commands.html#prefix","text":"The source of the command is given by the prefix, which should be the full name of the component sending the command. A prefix can be constructed with a string, but must start with a valid subsystem as in Subsystem. A component developer should supply a valid prefix string and the subsystem will be automatically parsed from it. An example of a valid string prefix is “nfiraos.ncc.trombone”.\nSee below examples:\nScala //using constructor, supplying subsystem and prefix both\nval prefix1: Prefix = Prefix(\"nfiraos.ncc.trombone\")\n\n//just by supplying prefix\nval prefix2: Prefix = Prefix(\"tcs.mobie.blue.filter\")\n\n//invalid prefix string that cant be mapped to a valid subsystem,\n// will automatically get Subsystem.BAD\nval badPrefix: Prefix = Prefix(\"abcdefgh\")\n\n//use implicit conversion to convert from String to Prefix\nval prefix3: Prefix = Prefix(\"wfos.prog.cloudcover\") Java //using constructor, supplying subsystem and prefix both\nPrefix prefix1 = new Prefix(\"nfiraos.ncc.trombone\");\n\n//just by supplying prefix\nPrefix prefix2 = new Prefix(\"tcs.mobie.blue.filter\");\n\n//invalid prefix string that cant be mapped to a valid subsystem,\n// will automatically get Subsystem.BAD\nPrefix badPrefix = new Prefix(\"abcdefgh\");","title":"Prefix"},{"location":"/messages/commands.html#commandname","text":"Each command has a name given as a string. The CommandName object wraps the string name. The string should be continuous with no spaces.","title":"CommandName"},{"location":"/messages/commands.html#setup-command","text":"This command is used to describe a goal that a system should match. Component developer will require to supply following arguments to create a Setup command.\nPrefix: the source of the command as described above CommandName: a simple string name for the command (no spaces) ObsId: an optional observation Id. paramSet: Optional Set of Parameters. Default is empty.\nScala //keys\nval k1: Key[Int]    = KeyType.IntKey.make(\"encoder\")\nval k2: Key[String] = KeyType.StringKey.make(\"stringThing\")\nval k2bad: Key[Int] = KeyType.IntKey.make(\"missingKey\")\nval k3: Key[Int]    = KeyType.IntKey.make(\"filter\")\nval k4: Key[Float]  = KeyType.FloatKey.make(\"correction\")\n\n//prefix\nval prefix: Prefix = Prefix(\"wfos.red.detector\")\n\n//parameters\nval i1: Parameter[Int]    = k1.set(22)\nval i2: Parameter[String] = k2.set(\"A\")\n\n//create Setup, add sequentially using add\nval sc1: Setup = Setup(prefix, CommandName(\"move\"), Some(obsId)).add(i1).add(i2)\n\n//access keys\nval k1Exists: Boolean = sc1.exists(k1) //true\n\n//access parameters\nval tryParam1: Try[Parameter[Int]] = Try(sc1(k1))    //success\nval tryk2Bad: Try[Parameter[Int]]  = Try(sc1(k2bad)) //failure\n\n//add more than one parameters, using madd\nval sc2: Setup     = sc1.madd(k3.set(1, 2, 3, 4).withUnits(Units.day), k4.set(1.0f, 2.0f))\nval paramSize: Int = sc2.size\n\n//add binary payload\nval byteKey1: Key[Byte] = ByteKey.make(\"byteKey1\")\nval byteKey2: Key[Byte] = ByteKey.make(\"byteKey2\")\nval bytes1: Array[Byte] = Array[Byte](10, 20)\nval bytes2: Array[Byte] = Array[Byte](30, 40)\n\nval b1: Parameter[Byte] = byteKey1.set(bytes1)\nval b2: Parameter[Byte] = byteKey2.set(bytes2)\n\nval sc3: Setup = Setup(prefix, CommandName(\"move\"), Some(obsId), Set(b1, b2))\n\n//remove a key\nval sc4: Setup = sc3.remove(b1)\n\n//list all keys\nval allKeys: Set[String] = sc4.paramSet.map(_.keyName)\n Java //keys\nKey<Integer> k1 = JKeyType.IntKey().make(\"encoder\");\nKey<String> k2 = JKeyType.StringKey().make(\"stringThing\");\nKey<Integer> k2bad = JKeyType.IntKey().make(\"missingKey\");\nKey<Integer> k3 = JKeyType.IntKey().make(\"filter\");\nKey<Float> k4 = JKeyType.FloatKey().make(\"correction\");\n\n//prefix\nString prefixName = \"wfos.red.detector\";\n\n//parameters\nParameter<Integer> i1 = k1.set(22);\nParameter<String> i2 = k2.set(\"A\");\n\n//create setup, add sequentially using add\nSetup sc1 = new Setup(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(i1).add(i2);\n\n//access keys\nboolean k1Exists = sc1.exists(k1); //true\n\n//access parameters\nOptional<Parameter<Integer>> optParam1 = sc1.jGet(k1); //present\nOptional<Parameter<Integer>> optK2Bad = sc1.jGet(k2bad); //absent\n\n//add more than one parameters, using madd\nSetup sc2 = sc1.madd(k3.set(1, 2, 3, 4).withUnits(JUnits.day), k4.set(1.0f, 2.0f));\nint paramSize = sc2.size();\n\n//add binary payload\nKey<Byte> byteKey1 = JKeyType.ByteKey().make(\"byteKey1\");\nKey<Byte> byteKey2 = JKeyType.ByteKey().make(\"byteKey2\");\nByte[] bytes1 = {10, 20};\nByte[] bytes2 = {30, 40};\n\nParameter<Byte> b1 = byteKey1.set(bytes1);\nParameter<Byte> b2 = byteKey2.set(bytes2);\n\nSetup sc3 = new Setup(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(b1).add(b2);\n\n//remove a key\nSetup sc4 = sc3.remove(b1);\n\n//list all keys\njava.util.List<String> allKeys = sc4.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Setup Command"},{"location":"/messages/commands.html#observe-command","text":"This command describes a science observation. Sent only to Science Detector Assemblies and Sequencers.\nScala //keys\nval k1: Key[Boolean] = KeyType.BooleanKey.make(\"repeat\")\nval k2: Key[Int]     = KeyType.IntKey.make(\"expTime\")\nval k2bad: Key[Int]  = KeyType.IntKey.make(\"missingKey\")\nval k3: Key[Int]     = KeyType.IntKey.make(\"filter\")\nval k4: Key[Instant] = KeyType.TimestampKey.make(\"creation-time\")\n\n//prefix\nval prefix: Prefix = Prefix(\"wfos.red.detector\")\n\n//parameters\nval i1: Parameter[Boolean] = k1.set(true, false, true, false)\nval i2: Parameter[Int]     = k2.set(1, 2, 3, 4)\n\n//create Observe, add sequentially using add\nval oc1: Observe = Observe(prefix, CommandName(\"move\"), Some(obsId)).add(i1).add(i2)\n\n//access parameters using apply method\nval k1Param: Parameter[Boolean] = oc1.get(k1).get //true\nval values: Array[Boolean]      = k1Param.values\n\n//access parameters\nval tryParam1: Try[Parameter[Boolean]] = Try(oc1(k1))    //success\nval tryk2Bad: Try[Parameter[Int]]      = Try(oc1(k2bad)) //failure\n\n//add more than one parameters, using madd\nval oc2: Observe   = oc1.madd(k3.set(1, 2, 3, 4).withUnits(Units.day), k4.set(Instant.now()))\nval paramSize: Int = oc2.size\n\n//update existing key with set\nval oc3: Observe = oc1.add(k2.set(5, 6, 7, 8))\n\n//remove a key\nval oc4: Observe = oc2.remove(k4)\n Java //keys\nKey<Boolean> k1 = JKeyType.BooleanKey().make(\"repeat\");\nKey<Integer> k2 = JKeyType.IntKey().make(\"expTime\");\nKey<Integer> k2bad = JKeyType.IntKey().make(\"missingKey\");\nKey<Integer> k3 = JKeyType.IntKey().make(\"filter\");\nKey<Instant> k4 = JKeyType.TimestampKey().make(\"creation-time\");\n\n//prefix\nString prefixName = \"wfos.red.detector\";\n\n//parameters\nBoolean[] boolArray = {true, false, true, false};\nParameter<Boolean> i1 = k1.set(boolArray);\nParameter<Integer> i2 = k2.set(1, 2, 3, 4);\n\n//create Observe, add sequentially using add\nObserve oc1 = new Observe(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(i1).add(i2);\n\n//access parameters\nOptional<Parameter<Boolean>> k1Param = oc1.jGet(k1); //present\njava.util.List<Boolean> values = k1Param.get().jValues();\n\n//access parameters\nOptional<Parameter<ArrayData<Float>>> k2BadParam = oc1.jGet(k2bad.keyName(), JKeyType.FloatArrayKey());\n\n//add more than one parameters, using madd\nObserve oc2 = oc1.madd(k3.set(1, 2, 3, 4).withUnits(JUnits.day), k4.set(Instant.now()));\nint paramSize = oc2.size();\n\n//update existing key with set\nInteger[] intArray = {5, 6, 7, 8};\nObserve oc3 = oc1.add(k2.set(intArray));\n\n//remove a key\nObserve oc4 = oc2.remove(k4);\n\n//list all keys\njava.util.List<String> allKeys = oc4.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Observe Command"},{"location":"/messages/commands.html#wait-command","text":"This command causes a Sequencer to wait until notified.\nScala //keys\nval k1: Key[Boolean] = KeyType.BooleanKey.make(\"repeat\")\nval k2: Key[Int]     = KeyType.IntKey.make(\"expTime\")\nval k2bad: Key[Int]  = KeyType.IntKey.make(\"missingKey\")\nval k3: Key[Int]     = KeyType.IntKey.make(\"filter\")\nval k4: Key[Instant] = KeyType.TimestampKey.make(\"creation-time\")\n\n//parameters\nval i1: Parameter[Boolean] = k1.set(true, false, true, false)\nval i2: Parameter[Int]     = k2.set(1, 2, 3, 4)\n\n//prefix\nval prefix: Prefix = Prefix(\"wfos.red.detector\")\n\n//create wait, add sequentially using add\nval wc1: Wait = Wait(prefix, CommandName(\"move\"), Some(obsId)).add(i1).add(i2)\n\n//access params using get method\nval k1Param: Option[Parameter[Boolean]] = wc1.get(k1)\nval values: Array[Boolean]              = k1Param.map(_.values).getOrElse(Array.empty[Boolean])\n\n//access parameters\nval tryParam1: Try[Parameter[Boolean]] = Try(wc1(k1))    //success\nval tryk2Bad: Try[Parameter[Int]]      = Try(wc1(k2bad)) //failure\n\n//add more than one parameters, using madd\nval wc2: Wait      = wc1.madd(k3.set(1, 2, 3, 4).withUnits(Units.day), k4.set(Instant.now()))\nval paramSize: Int = wc2.size\n\n//update existing key with set\nval wc3: Wait = wc1.add(k2.set(5, 6, 7, 8))\n\n//remove a key\nval wc4: Wait = wc2.remove(k4)\n Java //keys\nKey<Boolean> k1 = JKeyType.BooleanKey().make(\"repeat\");\nKey<Integer> k2 = JKeyType.IntKey().make(\"expTime\");\nKey<Integer> k2bad = JKeyType.IntKey().make(\"missingKey\");\nKey<Integer> k3 = JKeyType.IntKey().make(\"filter\");\nKey<Instant> k4 = JKeyType.TimestampKey().make(\"creation-time\");\n\n//prefix\nString prefixName = \"wfos.red.detector\";\n\n//parameters\nBoolean[] boolArray = {true, false, true, false};\nParameter<Boolean> i1 = k1.set(boolArray);\nParameter<Integer> i2 = k2.set(1, 2, 3, 4);\n\n//create Wait, add sequentially using add\nWait wc1 = new Wait(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(i1).add(i2);\n\n//access parameters using jGet\nOptional<Parameter<Boolean>> k1Param = wc1.jGet(k1); //present\njava.util.List<Boolean> values = k1Param.get().jValues();\n\n//access parameters\nOptional<Parameter<ArrayData<Float>>> k2BadParam = wc1.jGet(\"absentKeyHere\", JKeyType.FloatArrayKey());\n\n//add more than one parameters, using madd\nWait wc2 = wc1.madd(k3.set(1, 2, 3, 4).withUnits(JUnits.day), k4.set(Instant.now()));\nint paramSize = wc2.size();\n\n//update existing key with set\nInteger[] intArray = {5, 6, 7, 8};\nWait wc3 = wc1.add(k2.set(intArray));\n\n//remove a key\nWait wc4 = wc2.remove(k4);\n\n//list all keys\njava.util.List<String> allKeys = wc4.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Wait Command"},{"location":"/messages/commands.html#json-serialization","text":"Commands can be serialized to JSON. The library has provided JsonSupport helper class and methods to serialize Setup, Observe and Wait commands.\nScala import play.api.libs.json.{JsValue, Json}\n\n//key\nval k1: Key[MatrixData[Double]] = DoubleMatrixKey.make(\"myMatrix\")\n//values\nval m1: MatrixData[Double] = MatrixData.fromArrays(\n  Array(1.0, 2.0, 3.0),\n  Array(4.1, 5.1, 6.1),\n  Array(7.2, 8.2, 9.2)\n)\n\n//prefix\nval prefix: Prefix = Prefix(\"wfos.red.detector\")\n\n//parameter\nval i1: Parameter[MatrixData[Double]] = k1.set(m1)\n\n//commands\nval sc: Setup   = Setup(prefix, CommandName(\"move\"), Some(obsId)).add(i1)\nval oc: Observe = Observe(prefix, CommandName(\"move\"), Some(obsId)).add(i1)\nval wc: Wait    = Wait(prefix, CommandName(\"move\"), Some(obsId)).add(i1)\n\n//json support - write\nval scJson: JsValue = JsonSupport.writeSequenceCommand(sc)\nval ocJson: JsValue = JsonSupport.writeSequenceCommand(oc)\nval wcJson: JsValue = JsonSupport.writeSequenceCommand(wc)\n\n//optionally prettify\nval str: String = Json.prettyPrint(scJson)\n\n//construct command from string\nval scFromPrettyStr = JsonSupport.readSequenceCommand[Setup](Json.parse(str))\n\n//json support - read\nval sc1: Setup   = JsonSupport.readSequenceCommand[Setup](scJson)\nval oc1: Observe = JsonSupport.readSequenceCommand[Observe](ocJson)\nval wc1: Wait    = JsonSupport.readSequenceCommand[Wait](wcJson) Java //key\nKey<MatrixData<Double>> k1 = JKeyType.DoubleMatrixKey().make(\"myMatrix\");\n\n//values\nDouble[][] doubles = {{1.0, 2.0, 3.0}, {4.1, 5.1, 6.1}, {7.2, 8.2, 9.2}};\nMatrixData<Double> m1 = MatrixData.fromJavaArrays(Double.class, doubles);\n\n//parameter\nParameter<MatrixData<Double>> i1 = k1.set(m1);\n\nString prefixName = \"wfos.blue.filter\";\n\n//commands\nSetup sc = new Setup(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(i1);\nObserve oc = new Observe(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(i1);\nWait wc = new Wait(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(i1);\n\n//json support - write\nJsValue scJson = JavaJsonSupport.writeSequenceCommand(sc);\nJsValue ocJson = JavaJsonSupport.writeSequenceCommand(oc);\nJsValue wcJson = JavaJsonSupport.writeSequenceCommand(wc);\n\n//optionally prettify\nString str = Json.prettyPrint(scJson);\n\n//construct command from string\nSetup sc1 = JavaJsonSupport.readSequenceCommand(Json.parse(str));\nObserve oc1 = JavaJsonSupport.readSequenceCommand(ocJson);\nWait wc1 = JavaJsonSupport.readSequenceCommand(wcJson);","title":"JSON serialization"},{"location":"/messages/commands.html#unique-key-constraint","text":"By design, a ParameterSet in a Setup, Observe, or Wait command is optimized to store only unique keys. When using add or madd methods on commands to add new parameters, if the parameter being added has a key which is already present in the paramSet, the already stored parameter will be replaced by the given parameter.\nNote If the Set is created by component developers and given directly while creating a command, then it will be the responsibility of component developers to maintain uniqueness with parameters based on key.\nHere are some examples that illustrate this point:\nScala //keys\nval encoderKey: Key[Int] = KeyType.IntKey.make(\"encoder\")\nval filterKey: Key[Int]  = KeyType.IntKey.make(\"filter\")\nval miscKey: Key[Int]    = KeyType.IntKey.make(\"misc.\")\n\n//prefix\nval prefix: Prefix = Prefix(\"wfos.red.detector\")\n\n//params\nval encParam1: Parameter[Int] = encoderKey.set(1)\nval encParam2: Parameter[Int] = encoderKey.set(2)\nval encParam3: Parameter[Int] = encoderKey.set(3)\n\nval filterParam1: Parameter[Int] = filterKey.set(1)\nval filterParam2: Parameter[Int] = filterKey.set(2)\nval filterParam3: Parameter[Int] = filterKey.set(3)\n\nval miscParam1 = miscKey.set(100)\n\n//Setup command with duplicate key via constructor\nval setup: Setup =\n  Setup(prefix,\n        CommandName(\"move\"),\n        Some(obsId),\n        Set(encParam1, encParam2, encParam3, filterParam1, filterParam2, filterParam3))\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nval uniqueKeys1 = setup.paramSet.toList.map(_.keyName)\n\n//try adding duplicate keys via add + madd\nval changedSetup: Setup = setup\n  .add(encParam3)\n  .madd(\n    filterParam1,\n    filterParam2,\n    filterParam3\n  )\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nval uniqueKeys2: List[String] = changedSetup.paramSet.toList.map(_.keyName)\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nval finalSetUp: Setup = setup.madd(Set(miscParam1, encParam1))\n//now contains encoderKey, filterKey, miscKey\nval uniqueKeys3: List[String] = finalSetUp.paramSet.toList.map(_.keyName) Java //keys\nKey<Integer> encoderKey = JKeyType.IntKey().make(\"encoder\");\nKey<Integer> filterKey = JKeyType.IntKey().make(\"filter\");\nKey<Integer> miscKey = JKeyType.IntKey().make(\"misc.\");\n\n//prefix\nString prefix = \"wfos.blue.filter\";\n\n//params\nParameter<Integer> encParam1 = encoderKey.set(1);\nParameter<Integer> encParam2 = encoderKey.set(2);\nParameter<Integer> encParam3 = encoderKey.set(3);\n\nParameter<Integer> filterParam1 = filterKey.set(1);\nParameter<Integer> filterParam2 = filterKey.set(2);\nParameter<Integer> filterParam3 = filterKey.set(3);\n\nParameter<Integer> miscParam1 = miscKey.set(100);\n\n//Setup command with duplicate key via madd\nSetup setup = new Setup(new Prefix(prefix), new CommandName(\"move\"), Optional.of(obsId)).madd(\n        encParam1,\n        encParam2,\n        encParam3,\n        filterParam1,\n        filterParam2,\n        filterParam3);\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nList<String> uniqueKeys1 = setup.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//try adding duplicate keys via add + madd\nSetup changedSetup = setup.add(encParam3).madd(filterParam1, filterParam2, filterParam3);\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nList<String> uniqueKeys2 = changedSetup.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nSetup finalSetUp = setup.madd(miscParam1, encParam1);\n//now contains encoderKey, filterKey, miscKey\nList<String> uniqueKeys3 = finalSetUp.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Unique Key constraint"},{"location":"/messages/commands.html#cloning-a-command","text":"In order to track the completion of a command, every command that is sent must have a unique RunId. If you wish to resubmit a previously sent Setup, the cloneCommand method must be used prior to submission to create a new command from existing parameters, but with a new RunId.\nScala val setup  = Setup(prefix, commandName, Some(obsId)).madd(i1)\nval setup2 = setup.cloneCommand\n\nval observe  = Observe(prefix, commandName, Some(obsId)).madd(i1)\nval observe2 = observe.cloneCommand\n\nval wait  = Wait(prefix, commandName, Some(obsId)).madd(i1)\nval wait2 = wait.cloneCommand Java Setup setup = new Setup(new Prefix(prefix), commandName, Optional.of(obsId)).add(encoderParam);\nSetup setup2 = setup.cloneCommand();\n\nObserve observe = new Observe(new Prefix(prefix), commandName, Optional.empty()).add(encoderParam);\nObserve observe2 = observe.cloneCommand();\n\nWait wait = new Wait(new Prefix(prefix), commandName, Optional.of(obsId)).add(encoderParam);\nWait wait2 = wait.cloneCommand();","title":"Cloning a Command"},{"location":"/messages/commands.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source Code for Examples"},{"location":"/messages/events.html","text":"","title":"Events"},{"location":"/messages/events.html#events","text":"Events are the most basic type of asynchronous notification in TMT when an activity occurs somewhere in the TMT system and other components need to be notified. Each type of event has a unique purpose and unique information, but they all share same structural features. All events have EventInfo and ParameterSet.\nNote csw-messages library offers out of the box support to serialize Events using Protobuf, so that events can be produced and consumed by JVM(Java virtual machine) as well as Non-JVM applications. For more on this Protobuf support section below.","title":"Events"},{"location":"/messages/events.html#eventtime","text":"Each event includes its time of creation in UTC format. To create an event instance at the current time use the default constructor. For other utility functions, see below examples:\nScala //default constructor will return current time in UTC\nval now: UTCTime = UTCTime.now()\n\n//using constructor\nval anHourAgo: UTCTime = UTCTime(Instant.now().minusSeconds(3600))\n\n//current event time using utility function\nval currentTime: UTCTime = UTCTime.now()\n\n//some past time using utility function\nval aDayAgo = UTCTime(Instant.now.minusSeconds(86400))\n Java //apply returns current time in UTC\nUTCTime now = UTCTime.now();\n\n//using constructor\nUTCTime anHourAgo = new UTCTime(Instant.now().minusSeconds(3600));\n\n//return current time in UTC\nUTCTime currentTime = UTCTime.now();\n\n//some past time using utility function\nUTCTime aDayAgo = new UTCTime(Instant.now().minusSeconds(86400));","title":"EventTime"},{"location":"/messages/events.html#system-event","text":"SystemEvent is the type used to describe the majority of events in the system. An example is a demand that is the output of an algorithm in one component that is used as an input to another. SystemEvent is also used to publish internal state or status values of a component that may be of interest to other components in the system.\nScala //keys\nval k1: Key[Int]    = KeyType.IntKey.make(\"encoder\")\nval k2: Key[Int]    = KeyType.IntKey.make(\"speed\")\nval k3: Key[String] = KeyType.StringKey.make(\"filter\")\nval k4: Key[Int]    = KeyType.IntKey.make(\"notUsed\")\n\n//prefixes\nval ck1   = Prefix(\"wfos.red.filter\")\nval name1 = EventName(\"filterWheel\")\nval ck3   = Prefix(\"iris.imager.filter\")\nval name3 = EventName(\"status\")\n\n//parameters\nval p1: Parameter[Int]    = k1.set(22)\nval p2: Parameter[Int]    = k2.set(44)\nval p3: Parameter[String] = k3.set(\"A\", \"B\", \"C\", \"D\")\n\n//Create SystemEvent using madd\nval se1: SystemEvent = SystemEvent(ck1, name1).madd(p1, p2)\n//Create SystemEvent using apply\nval se2: SystemEvent = SystemEvent(ck3, name3, Set(p1, p2))\n//Create SystemEvent and use add\nval se3: SystemEvent = SystemEvent(ck3, name3).add(p1).add(p2).add(p3)\n\n//access keys\nval k1Exists: Boolean = se1.exists(k1) //true\n\n//access Parameters\nval p4: Option[Parameter[Int]] = se1.get(k1)\n\n//access values\nval v1: Array[Int] = se1(k1).values\nval v2: Array[Int] = se2.parameter(k2).values\n//k4 is missing\nval missingKeys: Set[String] = se3.missingKeys(k1, k2, k3, k4)\n\n//remove keys\nval se4: SystemEvent = se3.remove(k3)\n\n//add more than one parameters, using madd\nval se5: SystemEvent = se4.madd(k3.set(\"X\", \"Y\", \"Z\").withUnits(Units.day), k4.set(99, 100))\nval paramSize: Int   = se5.size\n\n//update existing key with set\nval se6: SystemEvent = se5.add(k2.set(5, 6, 7, 8))\n Java //keys\nKey<Integer> k1 = JKeyType.IntKey().make(\"encoder\");\nKey<Integer> k2 = JKeyType.IntKey().make(\"speed\");\nKey<String> k3 = JKeyType.StringKey().make(\"filter\");\nKey<Integer> k4 = JKeyType.IntKey().make(\"notUsed\");\n\n//prefixes\nPrefix prefix1 = new Prefix(\"wfos.red.filter\");\nEventName name1 = new EventName(\"filterWheel\");\nPrefix prefix2 = new Prefix(\"iris.imager.filter\");\nEventName name2 = new EventName(\"status\");\n\n//parameters\nParameter<Integer> p1 = k1.set(22);\nParameter<Integer> p2 = k2.set(44);\nParameter<String> p3 = k3.set(\"A\", \"B\", \"C\", \"D\");\n\n//Create SystemEvent using madd\nSystemEvent se1 = new SystemEvent(prefix1, name1).madd(p1, p2);\n//Create SystemEvent using add\nSystemEvent se2 = new SystemEvent(prefix2, name2).add(p1).add(p2);\n//Create SystemEvent and use add\nSystemEvent se3 = new SystemEvent(prefix2, name2).add(p1).add(p2).add(p3);\n\n//access keys\nboolean k1Exists = se1.exists(k1); //true\n\n//access Parameters\nOptional<Parameter<Integer>> p4 = se1.jGet(k1);\n\n//access values\nList<Integer> v1 = se1.jGet(k1).get().jValues();\nList<Integer> v2 = se2.parameter(k2).jValues();\n//k4 is missing\nSet<String> missingKeys = se3.jMissingKeys(k1, k2, k3, k4);\n\n//remove keys\nSystemEvent se4 = se3.remove(k3);","title":"System Event"},{"location":"/messages/events.html#observe-event","text":"ObserveEvent are standardized events used to describe an activities within the data acquisition process. These events are ublished only by Science Detector Assemblies, which emit ObserveEvents during their exposures to signal the occurrence of specific activities/actions during the acquisition of data. Observe Events are published by the detector system using the Event Service.\nNote The current ObserveEvents do not match the descriptions of the ESW Phase 1 review. The model files and documents can be used to create standard ObserveEvents.\nScala //keys\nval k1: Key[Int]    = KeyType.IntKey.make(\"readoutsCompleted\")\nval k2: Key[Int]    = KeyType.IntKey.make(\"coaddsCompleted\")\nval k3: Key[String] = KeyType.StringKey.make(\"fileID\")\nval k4: Key[Int]    = KeyType.IntKey.make(\"notUsed\")\n\n//prefixes\nval ck1   = Prefix(\"iris.ifu.detectorAssembly\")\nval name1 = EventName(\"readoutEnd\")\nval ck3   = Prefix(\"wfos.red.detector\")\nval name3 = EventName(\"exposureStarted\")\n\n//parameters\nval p1: Parameter[Int]    = k1.set(4)\nval p2: Parameter[Int]    = k2.set(2)\nval p3: Parameter[String] = k3.set(\"WFOS-RED-0001\")\n\n//Create ObserveEvent using madd\nval se1: ObserveEvent = ObserveEvent(ck1, name1).madd(p1, p2)\n//Create ObserveEvent using apply\nval se2: ObserveEvent = ObserveEvent(ck3, name3, Set(p1, p2))\n//Create ObserveEvent and use add\nval se3: ObserveEvent = ObserveEvent(ck3, name3).add(p1).add(p2).add(p3)\n\n//access keys\nval k1Exists: Boolean = se1.exists(k1) //true\n\n//access Parameters\nval p4: Option[Parameter[Int]] = se1.get(k1)\n\n//access values\nval v1: Array[Int] = se1(k1).values\nval v2: Array[Int] = se2.parameter(k2).values\n//k4 is missing\nval missingKeys: Set[String] = se3.missingKeys(k1, k2, k3, k4)\n\n//remove keys\nval se4: ObserveEvent = se3.remove(k3)\n Java //keys\nKey<Integer> k1 = JKeyType.IntKey().make(\"readoutsCompleted\");\nKey<Integer> k2 = JKeyType.IntKey().make(\"coaddsCompleted\");\nKey<String> k3 = JKeyType.StringKey().make(\"fileID\");\nKey<Integer> k4 = JKeyType.IntKey().make(\"notUsed\");\n\n//prefixes\nPrefix prefix1 = new Prefix(\"iris.ifu.detectorAssembly\");\nEventName name1 = new EventName(\"readoutEnd\");\nPrefix prefix2 = new Prefix(\"wfos.red.detector\");\nEventName name2 = new EventName(\"exposureStarted\");\n\n//parameters\nParameter<Integer> p1 = k1.set(4);\nParameter<Integer> p2 = k2.set(2);\nParameter<String> p3 = k3.set(\"WFOS-RED-0001\");\n\n//Create ObserveEvent using madd\nObserveEvent oc1 = new ObserveEvent(prefix1, name1).madd(p1, p2);\n//Create ObserveEvent using add\nObserveEvent oc2 = new ObserveEvent(prefix2, name2).add(p1).add(p2);\n//Create ObserveEvent and use add\nObserveEvent oc3 = new ObserveEvent(prefix2, name2).add(p1).add(p2).add(p3);\n\n//access keys\nboolean k1Exists = oc1.exists(k1); //true\n\n//access Parameters\nOptional<Parameter<Integer>> p4 = oc1.jGet(k1);\n\n//access values\nList<Integer> v1 = oc1.jGet(k1).get().jValues();\nList<Integer> v2 = oc2.parameter(k2).jValues();\n//k4 is missing\nSet<String> missingKeys = oc3.jMissingKeys(k1, k2, k3, k4);\n\n//remove keys\nObserveEvent oc4 = oc3.remove(k3);","title":"Observe Event"},{"location":"/messages/events.html#json-serialization","text":"Events can be serialized to JSON. The library has provided JsonSupport helper class and methods to serialize Status, Observe and System events.\nScala import play.api.libs.json.{JsValue, Json}\n\n//key\nval k1: Key[MatrixData[Double]] = DoubleMatrixKey.make(\"myMatrix\")\n\nval name1  = EventName(\"correctionInfo\")\nval prefix = Prefix(\"aoesw.rpg\")\n\n//values\nval m1: MatrixData[Double] = MatrixData.fromArrays(\n  Array(1.0, 2.0, 3.0),\n  Array(4.1, 5.1, 6.1),\n  Array(7.2, 8.2, 9.2)\n)\n//parameter\nval i1: Parameter[MatrixData[Double]] = k1.set(m1)\n//events\nval observeEvent: ObserveEvent = ObserveEvent(prefix, name1).add(i1)\nval systemEvent: SystemEvent   = SystemEvent(prefix, name1).add(i1)\n\n//json support - write\nval observeJson: JsValue = JsonSupport.writeEvent(observeEvent)\nval systemJson: JsValue  = JsonSupport.writeEvent(systemEvent)\n\n//optionally prettify\nval str: String = Json.prettyPrint(systemJson)\n\n//construct command from string\nval systemEventFromPrettyStr: SystemEvent = JsonSupport.readEvent[SystemEvent](Json.parse(str))\n\n//json support - read\nval observeEvent1: ObserveEvent = JsonSupport.readEvent[ObserveEvent](observeJson)\nval systemEvent1: SystemEvent   = JsonSupport.readEvent[SystemEvent](systemJson) Java //key\nKey<MatrixData<Double>> k1 = JKeyType.DoubleMatrixKey().make(\"myMatrix\");\n\n//prefixes\nPrefix prefix1 = new Prefix(\"aoesw.rpg\");\nEventName name1 = new EventName(\"correctionInfo\");\n\n//values\nDouble[][] doubles = {{1.0, 2.0, 3.0}, {4.1, 5.1, 6.1}, {7.2, 8.2, 9.2}};\nMatrixData<Double> m1 = MatrixData.fromJavaArrays(Double.class, doubles);\n\n//parameter\nParameter<MatrixData<Double>> i1 = k1.set(m1);\n\n\n//events\nObserveEvent observeEvent = new ObserveEvent(prefix1, name1).add(i1);\nSystemEvent systemEvent = new SystemEvent(prefix1, name1).add(i1);\n\n//json support - write\nJsValue observeJson = JavaJsonSupport.writeEvent(observeEvent);\nJsValue systemJson = JavaJsonSupport.writeEvent(systemEvent);\n\n//optionally prettify\nString str = Json.prettyPrint(systemJson);\n\n//construct DemandState from string\nSystemEvent statusFromPrettyStr = JavaJsonSupport.readEvent(Json.parse(str));\n\n//json support - read\nObserveEvent observeEvent1 = JavaJsonSupport.readEvent(observeJson);\nSystemEvent systemEvent1 = JavaJsonSupport.readEvent(systemJson);","title":"JSON Serialization"},{"location":"/messages/events.html#unique-key-constraint","text":"By choice, a ParameterSet in either ObserveEvent or SystemEvent event will be optimized to store only unique keys. When using add or madd methods on events to add new parameters, if the parameter being added has a key which is already present in the paramSet, the already stored parameter will be replaced by the given parameter.\nNote If the Set is created by component developers and given directly while creating an event, then it will be the responsibility of component developers to maintain uniqueness with parameters based on key.\nHere are some examples that illustrate this point:\nScala //keys\nval encoderKey: Key[Int] = KeyType.IntKey.make(\"encoder\")\nval filterKey: Key[Int]  = KeyType.IntKey.make(\"filter\")\nval miscKey: Key[Int]    = KeyType.IntKey.make(\"misc\")\n\n//prefix\nval prefix = Prefix(\"wfos.blue.filter\")\n\nval name1 = EventName(\"filterWheel\")\n\n//params\nval encParam1 = encoderKey.set(1)\nval encParam2 = encoderKey.set(2)\n\nval encParam3    = encoderKey.set(3)\nval filterParam1 = filterKey.set(1)\nval filterParam2 = filterKey.set(2)\n\nval filterParam3 = filterKey.set(3)\n\nval miscParam1 = miscKey.set(100)\n//StatusEvent with duplicate key via constructor\nval systemEvent =\n  SystemEvent(prefix, name1, Set(encParam1, encParam2, encParam3, filterParam1, filterParam2, filterParam3))\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nval uniqueKeys1 = systemEvent.paramSet.toList.map(_.keyName)\n\n//try adding duplicate keys via add + madd\nval changedStatusEvent = systemEvent\n  .add(encParam3)\n  .madd(\n    filterParam1,\n    filterParam2,\n    filterParam3\n  )\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nval uniqueKeys2 = changedStatusEvent.paramSet.toList.map(_.keyName)\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nval finalStatusEvent = systemEvent.madd(Set(miscParam1, encParam1))\n//now contains encoderKey, filterKey, miscKey\nval uniqueKeys3 = finalStatusEvent.paramSet.toList.map(_.keyName) Java //keys\nKey<Integer> encoderKey = JKeyType.IntKey().make(\"encoder\");\nKey<Integer> filterKey = JKeyType.IntKey().make(\"filter\");\nKey<Integer> miscKey = JKeyType.IntKey().make(\"misc\");\n\n//prefix\nPrefix prefix1 = new Prefix(\"wfos.blue.filter\");\nEventName name1 = new EventName(\"filterWheel\");\n\n//params\nParameter<Integer> encParam1 = encoderKey.set(1);\nParameter<Integer> encParam2 = encoderKey.set(2);\nParameter<Integer> encParam3 = encoderKey.set(3);\n\nParameter<Integer> filterParam1 = filterKey.set(1);\nParameter<Integer> filterParam2 = filterKey.set(2);\nParameter<Integer> filterParam3 = filterKey.set(3);\n\nParameter<Integer> miscParam1 = miscKey.set(100);\n\n//StatusEvent with duplicate key via madd\nSystemEvent event = new SystemEvent(prefix1, name1).madd(\n        encParam1,\n        encParam2,\n        encParam3,\n        filterParam1,\n        filterParam2,\n        filterParam3);\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nList<String> uniqueKeys1 = event.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//try adding duplicate keys via add + madd\nSystemEvent changedEvent = event.add(encParam3).madd(filterParam1, filterParam2, filterParam3);\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nList<String> uniqueKeys2 = changedEvent.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nSystemEvent finalEvent = changedEvent.madd(miscParam1, encParam1);\n//now contains encoderKey, filterKey, miscKey\nList<String> uniqueKeys3 = finalEvent.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Unique Key Constraint"},{"location":"/messages/events.html#protobuf","text":"Protobuf aka Protocol buffers, are a language-neutral, platform-neutral extensible mechanism for serializing structured data. For more, visit Protobuf home page\nIn TMT observatory, subsystems and components could be running on JVM(Java virtual machine) and Non-JVM platform. This leads to solving a non-trivial problem of a Non-JVM component wanting to consume an Event produced by a JVM component. Amongst the available options for data over the wire, Protobuf was chosen for its performance, data compression and official/unofficial support many mainstream languages.\ncsw-messages library enhances the Protobuf support, by providing out of the box helper methods, to convert events from/to protobuf binary data.\nProtobuf Code generation for Non-JVM languages The protobuf schema is defined in csw_protobuf directory. The contained .proto files can be fed to a protoc compiler in the language of your choice and it will do the required code generation.\nHere are some examples:\nScala //Key\nval raDecKey = RaDecKey.make(\"raDecKey\")\n\n//values\nval raDec1 = RaDec(10.20, 40.20)\nval raDec2 = RaDec(11.20, 50.20)\n\n//parameters\nval param = raDecKey.set(raDec1, raDec2).withUnits(arcmin)\n\nval prefix = Prefix(\"tcs.pk\")\nval name   = EventName(\"targetCoords\")\n//events\nval observeEvent: ObserveEvent = ObserveEvent(prefix, name).add(param)\nval systemEvent1: SystemEvent  = SystemEvent(prefix, name).add(param)\nval systemEvent2: SystemEvent =\n  SystemEvent(prefix, name).add(param)\n\n//convert events to protobuf bytestring\nval byteArray2: PbEvent = PbConverter.toPbEvent(observeEvent)\nval byteArray3: PbEvent = PbConverter.toPbEvent(systemEvent1)\nval byteArray4: PbEvent = PbConverter.toPbEvent(systemEvent2)\n\n//convert protobuf bytestring to events\nval pbObserveEvent: ObserveEvent = PbConverter.fromPbEvent(byteArray2)\nval pbSystemEvent1: SystemEvent  = PbConverter.fromPbEvent(byteArray3)\nval pbSystemEvent2: SystemEvent  = PbConverter.fromPbEvent(byteArray4) Java //prefixes\nPrefix prefix1 = new Prefix(\"tcs.pk\");\nEventName name1 = new EventName(\"targetCoords\");\nPrefix prefix2 = new Prefix(\"tcs.cm\");\nEventName name2 = new EventName(\"guiderCoords\");\n\n//Key\nKey<RaDec> raDecKey = JKeyType.RaDecKey().make(\"raDecKey\");\n\n//values\nRaDec raDec1 = new RaDec(10.20, 40.20);\nRaDec raDec2 = new RaDec(11.20, 50.20);\n\n//parameters\nParameter<RaDec> param = raDecKey.set(raDec1, raDec2).withUnits(JUnits.arcmin);\n\n//events\nObserveEvent observeEvent = new ObserveEvent(prefix1, name1).add(param);\nSystemEvent systemEvent1 = new SystemEvent(prefix1, name1).add(param);\nSystemEvent systemEvent2 = new SystemEvent(prefix2, name2).add(param);\n\n//convert events to protobuf bytestring\nPbEvent byteArray2 = PbConverter.toPbEvent(observeEvent);\nPbEvent byteArray3 = PbConverter.toPbEvent(systemEvent1);\nPbEvent byteArray4 = PbConverter.toPbEvent(systemEvent2);\n\n//convert protobuf bytestring to events\nObserveEvent pbObserveEvent = PbConverter.fromPbEvent(byteArray2);\nSystemEvent pbSystemEvent1 =  PbConverter.fromPbEvent(byteArray3);\nSystemEvent pbSystemEvent2 =  PbConverter.fromPbEvent(byteArray4);","title":"Protobuf"},{"location":"/messages/events.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source Code for Examples"},{"location":"/messages/states.html","text":"","title":"State Variables"},{"location":"/messages/states.html#state-variables","text":"These state variables are used when an Assembly wants to track the status of a command sent to an HCD using a matcher. For more information, see Publishing State.\nA states represent a component’s internal state. There are two types called CurrentState and DemandState. They both share the same structural features. All state variables have Prefix and ParameterSet.\nThe PubSub feature of the HCD provides CurrentState values to the PubSub subscriber.","title":"State Variables"},{"location":"/messages/states.html#demandstate","text":"A state variable that indicates the demand or requested state.\nScala //prefix\nval prefix = Prefix(\"wfos.prog.cloudcover\")\n\n//key\nval charKey: Key[Char]         = KeyType.CharKey.make(\"charKey\")\nval intKey: Key[Int]           = KeyType.IntKey.make(\"intKey\")\nval booleanKey: Key[Boolean]   = KeyType.BooleanKey.make(\"booleanKey\")\nval timestampKey: Key[Instant] = KeyType.TimestampKey.make(\"timestampKey\")\nval notUsedKey: Key[String]    = KeyType.StringKey.make(\"notUsed\")\n\n//parameters\nval charParam: Parameter[Char]       = charKey.set('A', 'B', 'C').withUnits(NoUnits)\nval intParam: Parameter[Int]         = intKey.set(1, 2, 3).withUnits(meter)\nval booleanParam: Parameter[Boolean] = booleanKey.set(true, false)\nval timestamp: Parameter[Instant]    = timestampKey.set(Instant.now)\n\n//create DemandState and use sequential add\nval ds1: DemandState = DemandState(prefix, StateName(\"testStateName\")).add(charParam).add(intParam)\n//create DemandState and add more than one Parameters using madd\nval ds2: DemandState = DemandState(prefix, StateName(\"testStateName\")).madd(intParam, booleanParam)\n//create DemandState using apply\nval ds3: DemandState = DemandState(prefix, StateName(\"testStateName\"), Set(timestamp))\n\n//access keys\nval charKeyExists: Boolean = ds1.exists(charKey) //true\n\n//access Parameters\nval p1: Option[Parameter[Int]] = ds1.get(intKey)\n\n//access values\nval v1: Array[Char]    = ds1(charKey).values\nval v2: Array[Boolean] = ds2.parameter(booleanKey).values\nval missingKeys: Set[String] = ds3.missingKeys(\n  charKey,\n  intKey,\n  booleanKey,\n  timestampKey,\n  notUsedKey\n)\n\n//remove keys\nval ds4: DemandState = ds3.remove(timestampKey)\n\n//update existing keys - set it back by an hour\nval ds5: DemandState = ds3.add(timestampKey.set(Instant.now().minusSeconds(3600)))\n Java //prefix\nPrefix prefix = new Prefix(\"wfos.prog.cloudcover\");\n\n//keys\nKey<Character> charKey = JKeyType.CharKey().make(\"charKey\");\nKey<Integer> intKey = JKeyType.IntKey().make(\"intKey\");\nKey<Boolean> booleanKey = JKeyType.BooleanKey().make(\"booleanKey\");\nKey<Instant> timestampKey = JKeyType.TimestampKey().make(\"timestampKey\");\nKey<String> notUsedKey = JKeyType.StringKey().make(\"notUsed\");\n\n\nObsId obsId = new ObsId(\"Obs001\");\n\n//parameters\nParameter<Character> charParam = charKey.set('A', 'B', 'C').withUnits(NoUnits);\nParameter<Integer> intParam = intKey.set(1, 2, 3).withUnits(meter);\nParameter<Boolean> booleanParam = booleanKey.set(true, false);\nParameter<Instant> timestamp = timestampKey.set(Instant.now());\n\n//create DemandState and use sequential add\nDemandState ds1 = new DemandState(prefix, new StateName(\"testStateName\")).add(charParam).add(intParam);\n//create DemandState and add more than one Parameters using madd\nDemandState ds2 = new DemandState(prefix, new StateName(\"testStateName\")).madd(intParam, booleanParam);\n//create DemandState using apply\nDemandState ds3 = new DemandState(prefix, new StateName(\"testStateName\")).add(timestamp);\n\n//access keys\nboolean charKeyExists = ds1.exists(charKey); //true\n\n//access Parameters\nOptional<Parameter<Integer>> p1 = ds1.jGet(intKey);\n\n//access values\nList<Character> v1 = ds1.jGet(charKey).get().jValues();\nList<Boolean> v2 = ds2.parameter(booleanKey).jValues();\nSet<String> missingKeys = ds3.jMissingKeys(charKey,\n        intKey,\n        booleanKey,\n        timestampKey,\n        notUsedKey);\n\n//remove keys\nDemandState ds4 = ds3.remove(timestampKey);\n\n//update existing keys - set it back by an hour\nDemandState ds5 = ds3.add(timestampKey.set(Instant.now().minusSeconds(3600)));","title":"DemandState"},{"location":"/messages/states.html#currentstate","text":"A state variable that is published by a component that describes its internal state. Used by Assemblies to determine command completion in Command Service.\nScala //prefix\nval prefix = Prefix(\"wfos.prog.cloudcover\")\n\n//key\nval charKey      = KeyType.CharKey.make(\"charKey\")\nval intKey       = KeyType.IntKey.make(\"intKey\")\nval booleanKey   = KeyType.BooleanKey.make(\"booleanKey\")\nval timestampKey = KeyType.TimestampKey.make(\"timestampKey\")\nval notUsedKey   = KeyType.StringKey.make(\"notUsed\")\n\n//parameters\nval charParam    = charKey.set('A', 'B', 'C').withUnits(NoUnits)\nval intParam     = intKey.set(1, 2, 3).withUnits(meter)\nval booleanParam = booleanKey.set(true, false)\nval timestamp    = timestampKey.set(Instant.now)\n\n//create CurrentState and use sequential add\nval cs1 = CurrentState(prefix, StateName(\"testStateName\")).add(charParam).add(intParam)\n//create CurrentState and add more than one Parameters using madd\nval cs2 = CurrentState(prefix, StateName(\"testStateName\")).madd(intParam, booleanParam)\n//create CurrentState using apply\nval cs3 = CurrentState(prefix, StateName(\"testStateName\"), Set(timestamp))\n\n//access keys\nval charKeyExists = cs1.exists(charKey) //true\n\n//access Parameters\nval p1: Option[Parameter[Int]] = cs1.get(intKey)\n\n//access values\nval v1: Array[Char]    = cs1(charKey).values\nval v2: Array[Boolean] = cs2.parameter(booleanKey).values\nval missingKeys: Set[String] = cs3.missingKeys(\n  charKey,\n  intKey,\n  booleanKey,\n  timestampKey,\n  notUsedKey\n)\n\n//remove keys\nval cs4 = cs3.remove(timestampKey)\n\n//update existing keys - set it back by an hour\nval cs5 = cs3.add(timestampKey.set(Instant.now().minusSeconds(3600)))\n Java //prefix\nPrefix prefix = new Prefix(\"wfos.prog.cloudcover\");\n\n//keys\nKey<Character> charKey = JKeyType.CharKey().make(\"charKey\");\nKey<Integer> intKey = JKeyType.IntKey().make(\"intKey\");\nKey<Boolean> booleanKey = JKeyType.BooleanKey().make(\"booleanKey\");\nKey<Instant> timestampKey = JKeyType.TimestampKey().make(\"timestampKey\");\nKey<String> notUsedKey = JKeyType.StringKey().make(\"notUsed\");\n\n\nObsId obsId = new ObsId(\"Obs001\");\n\n//parameters\nParameter<Character> charParam = charKey.set('A', 'B', 'C').withUnits(NoUnits);\nParameter<Integer> intParam = intKey.set(1, 2, 3).withUnits(meter);\nParameter<Boolean> booleanParam = booleanKey.set(true, false);\nParameter<Instant> timestamp = timestampKey.set(Instant.now());\n\n//create CurrentState and use sequential add\nCurrentState cs1 = new CurrentState(prefix, new StateName(\"testStateName\")).add(charParam).add(intParam);\n//create CurrentState and add more than one Parameters using madd\nCurrentState cs2 = new CurrentState(prefix, new StateName(\"testStateName\")).madd(intParam, booleanParam);\n//create CurrentState using apply\nCurrentState cs3 = new CurrentState(prefix, new StateName(\"testStateName\")).add(timestamp);\n\n//access keys\nboolean charKeyExists = cs1.exists(charKey); //true\n\n//access Parameters\nOptional<Parameter<Integer>> p1 = cs1.jGet(intKey);\n\n//access values\nList<Character> v1 = cs1.jGet(charKey).get().jValues();\nList<Boolean> v2 = cs2.parameter(booleanKey).jValues();\nSet<String> missingKeys = cs3.jMissingKeys(charKey,\n        intKey,\n        booleanKey,\n        timestampKey,\n        notUsedKey);\n\n//remove keys\nCurrentState cs4 = cs3.remove(timestampKey);\n\n//update existing keys - set it back by an hour\nCurrentState cs5 = cs3.add(timestampKey.set(Instant.now().minusSeconds(3600)));","title":"CurrentState"},{"location":"/messages/states.html#json-serialization","text":"State variables can be serialized to JSON. The library has provided JsonSupport helper class and methods to serialize DemandState and CurrentState.\nScala import play.api.libs.json.{JsValue, Json}\n\n//key\nval k1: Key[MatrixData[Double]] = DoubleMatrixKey.make(\"myMatrix\")\n//values\nval m1: MatrixData[Double] = MatrixData.fromArrays(\n  Array(1.0, 2.0, 3.0),\n  Array(4.1, 5.1, 6.1),\n  Array(7.2, 8.2, 9.2)\n)\n\n//parameter\nval p1: Parameter[MatrixData[Double]] = k1.set(m1)\n\n//state variables\nval ds: DemandState  = DemandState(Prefix(\"wfos.blue.filter\"), StateName(\"testStateName\")).add(p1)\nval cs: CurrentState = CurrentState(Prefix(\"wfos.blue.filter\"), StateName(\"testStateName\")).add(p1)\n\n//json support - write\nval dsJson: JsValue = JsonSupport.writeStateVariable(ds)\nval csJson: JsValue = JsonSupport.writeStateVariable(cs)\n\n//optionally prettify\nval str: String = Json.prettyPrint(dsJson)\n\n//construct command from string\nval scFromPrettyStr = JsonSupport.readStateVariable[DemandState](Json.parse(str))\n\n//json support - read\nval ds1: DemandState  = JsonSupport.readStateVariable[DemandState](dsJson)\nval cs1: CurrentState = JsonSupport.readStateVariable[CurrentState](csJson) Java //key\nKey<MatrixData<Double>> k1 = JKeyType.DoubleMatrixKey().make(\"myMatrix\");\n\n//values\nDouble[][] doubles = {{1.0, 2.0, 3.0}, {4.1, 5.1, 6.1}, {7.2, 8.2, 9.2}};\nMatrixData<Double> m1 = MatrixData.fromJavaArrays(Double.class, doubles);\n\n//parameter\nParameter<MatrixData<Double>> i1 = k1.set(m1);\n\n//state variables\nDemandState ds = new DemandState(new Prefix(\"wfos.blue.filter\"), new StateName(\"testStateName\")).add(i1);\nCurrentState cs = new CurrentState(new Prefix(\"wfos.blue.filter\"), new StateName(\"testStateName\")).add(i1);\n\n//json support - write\nJsValue dsJson = JavaJsonSupport.writeStateVariable(ds);\nJsValue csJson = JavaJsonSupport.writeStateVariable(cs);\n\n//optionally prettify\nString str = Json.prettyPrint(dsJson);\n\n//construct DemandState from string\nDemandState dsFromPrettyStr = JavaJsonSupport.readStateVariable(Json.parse(str));\n\n//json support - read\nDemandState ds1 = JavaJsonSupport.readStateVariable(dsJson);\nCurrentState cs1 = JavaJsonSupport.readStateVariable(csJson);","title":"JSON Serialization"},{"location":"/messages/states.html#unique-key-constraint","text":"By design, a ParameterSet in either DemandState or CurrentState will be optimized to store only unique keys. When using add or madd methods on events to add new parameters, if the parameter being added has a key which is already present in the paramSet, the already stored parameter will be replaced by the given parameter.\nNote If the Set is created by component developers and given directly while creating an event, then it will be the responsibility of component developers to maintain uniqueness with parameters based on key.\nHere are some examples that illustrate this point:\nScala //keys\nval encoderKey: Key[Int] = KeyType.IntKey.make(\"encoder\")\nval filterKey: Key[Int]  = KeyType.IntKey.make(\"filter\")\nval miscKey: Key[Int]    = KeyType.IntKey.make(\"misc.\")\n\n//prefix\nval prefix = Prefix(\"wfos.blue.filter\")\n\n//params\nval encParam1 = encoderKey.set(1)\nval encParam2 = encoderKey.set(2)\nval encParam3 = encoderKey.set(3)\n\nval filterParam1 = filterKey.set(1)\nval filterParam2 = filterKey.set(2)\nval filterParam3 = filterKey.set(3)\n\nval miscParam1 = miscKey.set(100)\n\n//DemandState with duplicate key via constructor\nval statusEvent = DemandState(\n  prefix,\n  StateName(\"testStateName\"),\n  Set(encParam1, encParam2, encParam3, filterParam1, filterParam2, filterParam3)\n)\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nval uniqueKeys1 = statusEvent.paramSet.toList.map(_.keyName)\n\n//try adding duplicate keys via add + madd\nval changedStatusEvent = statusEvent\n  .add(encParam3)\n  .madd(\n    filterParam1,\n    filterParam2,\n    filterParam3\n  )\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nval uniqueKeys2 = changedStatusEvent.paramSet.toList.map(_.keyName)\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nval finalStatusEvent = statusEvent.madd(Set(miscParam1, encParam1))\n//now contains encoderKey, filterKey, miscKey\nval uniqueKeys3 = finalStatusEvent.paramSet.toList.map(_.keyName) Java //keys\nKey<Integer> encoderKey = JKeyType.IntKey().make(\"encoder\");\nKey<Integer> filterKey = JKeyType.IntKey().make(\"filter\");\nKey<Integer> miscKey = JKeyType.IntKey().make(\"misc.\");\n\n//prefix\nPrefix prefix = new Prefix(\"wfos.blue.filter\");\n\n//params\nParameter<Integer> encParam1 = encoderKey.set(1);\nParameter<Integer> encParam2 = encoderKey.set(2);\nParameter<Integer> encParam3 = encoderKey.set(3);\n\nParameter<Integer> filterParam1 = filterKey.set(1);\nParameter<Integer> filterParam2 = filterKey.set(2);\nParameter<Integer> filterParam3 = filterKey.set(3);\n\nParameter<Integer> miscParam1 = miscKey.set(100);\n\n//Demand state with duplicate key via madd\nDemandState state = new DemandState(prefix, new StateName(\"testStateName\")).madd(\n        encParam1,\n        encParam2,\n        encParam3,\n        filterParam1,\n        filterParam2,\n        filterParam3);\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nList<String> uniqueKeys1 = state.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//try adding duplicate keys via add + madd\nDemandState changedState = state.add(encParam3).madd(filterParam1, filterParam2, filterParam3);\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nList<String> uniqueKeys2 = changedState.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nDemandState finalState = changedState.madd(miscParam1, encParam1);\n//now contains encoderKey, filterKey, miscKey\nList<String> uniqueKeys3 = finalState.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Unique Key Constraint"},{"location":"/messages/states.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source Code for Examples"},{"location":"/messages/result.html","text":"","title":"Result"},{"location":"/messages/result.html#result","text":"Components use Results to return results in the form of a ParameterSet. Result is the value that is returned as an argument to the CompletedWithResult SubmitResponse.\nCreating a Result Requires:\nPrefix Set[Parameter]\nScala //keys\nval k1: Key[Int]    = KeyType.IntKey.make(\"encoder\")\nval k2: Key[Int]    = KeyType.IntKey.make(\"windspeed\")\nval k3: Key[String] = KeyType.StringKey.make(\"filter\")\nval k4: Key[Int]    = KeyType.IntKey.make(\"notUsed\")\n\n//prefixes\nval prefix = Prefix(\"wfos.prog.cloudcover\")\n\n//parameters\nval p1: Parameter[Int]    = k1.set(22)\nval p2: Parameter[Int]    = k2.set(44)\nval p3: Parameter[String] = k3.set(\"A\", \"B\", \"C\", \"D\")\n\n//Create Result using madd\nval r1: Result = Result(prefix).madd(p1, p2)\n//Create Result using apply\nval r2: Result = Result(prefix, Set(p1, p2))\n//Create Result and use add\nval r3: Result = Result(prefix).add(p1).add(p2).add(p3)\n\n//access keys\nval k1Exists: Boolean = r1.exists(k1) //true\n\n//access Parameters\nval p4: Option[Parameter[Int]] = r1.get(k1)\n\n//access values\nval v1: Array[Int] = r1(k1).values\nval v2: Array[Int] = r2.parameter(k2).values\n//k4 is missing\nval missingKeys: Set[String] = r3.missingKeys(k1, k2, k3, k4)\n\n//remove keys\nval r4: Result = r3.remove(k3) Java //keys\nKey<Integer> k1 = JKeyType.IntKey().make(\"encoder\");\nKey<Integer> k2 = JKeyType.IntKey().make(\"windspeed\");\nKey<String> k3 = JKeyType.StringKey().make(\"filter\");\nKey<Integer> k4 = JKeyType.IntKey().make(\"notUsed\");\n\n//prefix\nString prefix = \"wfos.prog.cloudcover\";\n\nObsId obsId = new ObsId(\"Obs001\");\n\n//parameters\nParameter<Integer> p1 = k1.set(22);\nParameter<Integer> p2 = k2.set(44);\nParameter<String> p3 = k3.set(\"A\", \"B\", \"C\", \"D\");\n\n//Create Result using madd\nResult r1 = new Result(prefix).madd(p1, p2);\n//Create Result using madd\nResult r2 = new Result(prefix).madd(p1, p2);\n//Create Result and use madd, add\nResult r3 = new Result(prefix).madd(p1, p2).add(p3);\n\n//access keys\nboolean k1Exists = r1.exists(k1); //true\n\n//access Parameters\nOptional<Parameter<Integer>> p4 = r1.jGet(k1);\n\n//access values\nList<Integer> v1 = r1.jGet(k1).get().jValues();\nList<Integer> v2 = r2.parameter(k2).jValues();\n\n//k4 is missing\nSet<String> missingKeys = r3.jMissingKeys(k1, k2, k3, k4);\n\n//remove keys\nResult r4 = r3.remove(k3);","title":"Result"},{"location":"/messages/result.html#json-serialization","text":"State variables can be serialized to JSON. The library has provided JsonSupport helper class and methods to serialize DemandState and CurrentState.\nScala import play.api.libs.json.{JsValue, Json}\n\n//key\nval k1: Key[MatrixData[Double]] = DoubleMatrixKey.make(\"myMatrix\")\n//values\nval m1: MatrixData[Double] = MatrixData.fromArrays(\n  Array(1.0, 2.0, 3.0),\n  Array(4.1, 5.1, 6.1),\n  Array(7.2, 8.2, 9.2)\n)\n\n//prefixes\nval prefix = Prefix(\"wfos.prog.cloudcover\")\n\n//parameter\nval i1: Parameter[MatrixData[Double]] = k1.set(m1)\n\n//result\nval result: Result = Result(prefix).add(i1)\n\n//json support - write\nval resultJson: JsValue = JsonSupport.writeResult(result)\n\n//optionally prettify\nval str: String = Json.prettyPrint(resultJson)\n\n//construct result from string\nval scFromPrettyStr: Result = JsonSupport.readResult(Json.parse(str))\n\n//json support - read\nval result1: Result = JsonSupport.readResult(resultJson) Java //key\nKey<MatrixData<Double>> k1 = JKeyType.DoubleMatrixKey().make(\"myMatrix\");\n\n//values\nDouble[][] doubles = {{1.0, 2.0, 3.0}, {4.1, 5.1, 6.1}, {7.2, 8.2, 9.2}};\nMatrixData<Double> m1 = MatrixData.fromJavaArrays(Double.class, doubles);\n\n//parameter\nParameter<MatrixData<Double>> i1 = k1.set(m1);\n\n//ObsId\nObsId obsId = new ObsId(\"Obs001\");\n\n//prefix\nString prefix = \"wfos.prog.cloudcover\";\n\n//result\nResult result = new Result(prefix).add(i1);\n\n//json support - write\nJsValue resultJson = JavaJsonSupport.writeResult(result);\n\n//optionally prettify\nString str = Json.prettyPrint(resultJson);\n\n//construct result from string\nResult result1 = JavaJsonSupport.readResult(Json.parse(str));","title":"JSON serialization"},{"location":"/messages/result.html#unique-key-constraint","text":"By choice, a ParameterSet in Result will be optimized to store only unique keys. In other words, trying to store multiple keys with same name, will be automatically optimized by removing duplicates.\nNote Parameters are stored in a Set, which is an unordered collection of items. Hence, it’s not predictable whether first or last duplicate copy will be retained. Hence, cautiously avoid adding duplicate keys.\nHere are some examples that illustrate this point:\nScala //keys\nval encoderKey: Key[Int] = KeyType.IntKey.make(\"encoder\")\nval filterKey: Key[Int]  = KeyType.IntKey.make(\"filter\")\nval miscKey: Key[Int]    = KeyType.IntKey.make(\"misc.\")\n\n//prefix\nval prefix = Prefix(\"wfos.blue.filter\")\n\n//params\nval encParam1 = encoderKey.set(1)\nval encParam2 = encoderKey.set(2)\nval encParam3 = encoderKey.set(3)\n\nval filterParam1 = filterKey.set(1)\nval filterParam2 = filterKey.set(2)\nval filterParam3 = filterKey.set(3)\n\nval miscParam1 = miscKey.set(100)\n\n//Setup command with duplicate key via constructor\nval result = Result(prefix, Set(encParam1, encParam2, encParam3, filterParam1, filterParam2, filterParam3))\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nval uniqueKeys1 = result.paramSet.toList.map(_.keyName)\n\n//try adding duplicate keys via add + madd\nval changedResult = result\n  .add(encParam3)\n  .madd(\n    filterParam1,\n    filterParam2,\n    filterParam3\n  )\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nval uniqueKeys2 = changedResult.paramSet.toList.map(_.keyName)\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nval finalResult = result.madd(Set(miscParam1, encParam1))\n//now contains encoderKey, filterKey, miscKey\nval uniqueKeys3 = finalResult.paramSet.toList.map(_.keyName) Java //keys\nKey<Integer> encoderKey = JKeyType.IntKey().make(\"encoder\");\nKey<Integer> filterKey = JKeyType.IntKey().make(\"filter\");\nKey<Integer> miscKey = JKeyType.IntKey().make(\"misc.\");\n\n//ObsId\nObsId obsId = new ObsId(\"Obs001\");\n\n//prefix\nString prefix = \"wfos.blue.filter\";\n\n//params\nParameter<Integer> encParam1 = encoderKey.set(1);\nParameter<Integer> encParam2 = encoderKey.set(2);\nParameter<Integer> encParam3 = encoderKey.set(3);\n\nParameter<Integer> filterParam1 = filterKey.set(1);\nParameter<Integer> filterParam2 = filterKey.set(2);\nParameter<Integer> filterParam3 = filterKey.set(3);\n\nParameter<Integer> miscParam1 = miscKey.set(100);\n\n//Setup command with duplicate key via madd\nResult result = new Result(prefix).madd(encParam1, encParam2, encParam3, filterParam1, filterParam2, filterParam3);\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nList<String> uniqueKeys1 = result.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//try adding duplicate keys via add + madd\nResult changedResult = result.add(encParam3).madd(filterParam1, filterParam2, filterParam3);\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nList<String> uniqueKeys2 = changedResult.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nResult finalResult = result.madd(miscParam1, encParam1);\n//now contains encoderKey, filterKey, miscKey\nList<String> uniqueKeys3 = finalResult.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Unique Key Constraint"},{"location":"/messages/result.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source Code for Examples"},{"location":"/commons/framework.html","text":"","title":"Framework for creating components (HCD, Assembly, Container)"},{"location":"/commons/framework.html#framework-for-creating-components-hcd-assembly-container-","text":"csw-framework library provides support for creating a component as defined by the TMT.","title":"Framework for creating components (HCD, Assembly, Container)"},{"location":"/commons/framework.html#dependencies","text":"sbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-framework\" % \"0.1-SNAPSHOT\"\nSource code for examples ComponentInfo Creating an Assembly or Hcd Component Component Handlers Component Lifecycle Shutting Down Component Online and Offline Handling commands Managing Command State Updating a Long-running Command Using the CRM with Subcommands addSubCommand updateSubCommand Tracking Connections onLocationTrackingEvent Publishing State Handling Exceptions Deploying Components ContainerCmd Container for deployment Standalone components","title":"Dependencies"},{"location":"/commons/framework.html#source-code-for-examples","text":"Assembly Scala Example HCD Scala Example Assembly Java Example HCD Java Example","title":"Source code for examples"},{"location":"/framework/describing-components.html","text":"","title":"ComponentInfo"},{"location":"/framework/describing-components.html#componentinfo","text":"ComponentInfo model describes a component by specifying following details It is usually described as a configuration file but can also be created programmatically.\nAssemblyInfo name = \"Sample_Assembly\"\ncomponentType = assembly\nbehaviorFactoryClassName = package.component.SampleAssembly\nprefix = abc.sample.prefix\nlocationServiceUsage = RegisterAndTrackServices\nconnections = [\n    {\n      name: \"Sample_Assembly\"\n      componentType: assembly\n      connectionType: akka\n    }\n  ]\n HcdInfo name = \"Sample_Hcd\"\ncomponentType = hcd\nbehaviorFactoryClassName = package.component.SampleHcd\nprefix = abc.sample.prefix\nlocationServiceUsage = RegisterOnly\nFollowing is the summary of properties in the ComponentInfo config/model:\nname : The name of the component componentType : The type of the component which could be Container, Assembly, Hcd or Service behaviorFactoryClassName : The fully qualified name of the class which extends the factory class ComponentBehaviorFactory prefix : A valid subsystem to which this component belongs. connections : A collection of connections of the components or services which will be used by this component. This information can be used in accordance with the locationServiceUsage property to track these components or services by the framework. locationServiceUsage : Indicates how the location service should be leveraged for this component by the framework. Following values are supported: DoNotRegister : Do not register this component with location service RegisterOnly : Register this component with location service RegisterAndTrackServices : Register this component with location service as well as track the components/services mentioned against connections property","title":"ComponentInfo"},{"location":"/framework/creating-components.html","text":"","title":"Creating an Assembly or Hcd Component"},{"location":"/framework/creating-components.html#creating-an-assembly-or-hcd-component","text":"An Assembly or HCD is implemented by extending the ComponentHandlers base class. These handlers are executed by an Akka Actor (Top Level Actor or TLA) defined in the framework which handles the lifecycle and supervision of this component.\nAssembly/Scala class AssemblyComponentHandlers(ctx: ActorContext[TopLevelActorMessage], cswCtx: CswContext)\n    extends ComponentHandlers(ctx, cswCtx) Assembly/Java public class JAssemblyComponentHandlers extends JComponentHandlers {\n\n    private final ActorContext<TopLevelActorMessage> ctx;\n    private final ComponentInfo componentInfo;\n    private final CommandResponseManager commandResponseManager;\n    private final CurrentStatePublisher currentStatePublisher;\n    private final ILocationService locationService;\n    private final IEventService eventService;\n    private ILogger log;\n    private IConfigClientService configClient;\n    private Map<Connection, Optional<ICommandService>> runningHcds;\n    private ActorRef<DiagnosticPublisherMessages> diagnosticPublisher;\n    private ActorRef<CommandResponse.SubmitResponse> commandResponseAdapter;\n\n    public JAssemblyComponentHandlers(akka.actor.typed.javadsl.ActorContext<TopLevelActorMessage> ctx, JCswContext cswCtx) {\n        super(ctx, cswCtx);\n        this.ctx = ctx;\n        this.componentInfo = cswCtx.componentInfo();\n        this.commandResponseManager = cswCtx.commandResponseManager();\n        this.currentStatePublisher = cswCtx.currentStatePublisher();\n        this.locationService = cswCtx.locationService();\n        this.eventService = cswCtx.eventService();\n        log = cswCtx.loggerFactory().getLogger(this.getClass());\n        configClient = JConfigClientFactory.clientApi(Adapter.toUntyped(ctx.getSystem()), locationService);\n\n        runningHcds = new HashMap<>();\n        commandResponseAdapter = TestProbe.<CommandResponse.SubmitResponse>create(ctx.getSystem()).ref();\n        commandResponseAdapter = TestProbe.<CommandResponse.SubmitResponse>create(ctx.getSystem()).ref();\n    } Hcd/Scala class HcdComponentHandlers(ctx: ActorContext[TopLevelActorMessage], cswCtx: CswContext)\n    extends ComponentHandlers(ctx, cswCtx) Hcd/Java public class JHcdComponentHandlers extends JComponentHandlers {\n\n    private final ActorContext<TopLevelActorMessage> ctx;\n    private final ComponentInfo componentInfo;\n    private final CommandResponseManager commandResponseManager;\n    private final CurrentStatePublisher currentStatePublisher;\n    private final ILocationService locationService;\n    private final IEventService eventService;\n    private ILogger log;\n    private IConfigClientService configClient;\n    private ConfigData hcdConfig;\n    private ActorRef<WorkerActorMsg> worker;\n    private int current;\n    private int stats;\n\n    public JHcdComponentHandlers(\n            akka.actor.typed.javadsl.ActorContext<TopLevelActorMessage> ctx,\n            JCswContext cswCtx\n    ) {\n        super(ctx, cswCtx);\n        this.ctx = ctx;\n        this.componentInfo = cswCtx.componentInfo();\n        this.commandResponseManager = cswCtx.commandResponseManager();\n        this.currentStatePublisher = cswCtx.currentStatePublisher();\n        this.locationService = cswCtx.locationService();\n        this.eventService = cswCtx.eventService();\n        log = cswCtx.loggerFactory().getLogger(this.getClass());\n    }\nNote Converting a typed actor system to an untyped actor system The ctx available to the component is of type akka.actor.typed.scaladsl.ActorContext in Scala or akka.actor.typed.javadsl.ActorContext in Java. This context can be used to get resources such as actor system which is also typed. In order to get the untyped version of an actor system or actor references, Akka has provided some implicit extension methods in Scala and static methods in Java which can be used by adding the following import: import akka.actor.typed.scaladsl.adapter._ for Scala and, import akka.actor.typed.javadsl.Adapter.* for Java\nA component can be created by a factory which extends ComponentBehaviorFactory base class and provides a definition of handlers method to return the appropriate implementation of ComponentHandlers.\nAssembly/Scala class AssemblyComponentBehaviorFactory extends ComponentBehaviorFactory {\n  protected override def handlers(ctx: ActorContext[TopLevelActorMessage], cswCtx: CswContext): ComponentHandlers =\n    new AssemblyComponentHandlers(ctx, cswCtx)\n} Assembly/Java public class JAssemblyComponentBehaviorFactory extends JComponentBehaviorFactory {\n    @Override\n    public JComponentHandlers jHandlers(ActorContext<TopLevelActorMessage> ctx, JCswContext cswCtx) {\n        return new JAssemblyComponentHandlers(ctx, cswCtx);\n    }\n} Hcd/Scala class HcdComponentBehaviorFactory extends ComponentBehaviorFactory {\n  protected override def handlers(ctx: ActorContext[TopLevelActorMessage], cswCtx: CswContext): ComponentHandlers =\n    new HcdComponentHandlers(ctx, cswCtx)\n} Hcd/Java public class JHcdComponentBehaviorFactory extends JComponentBehaviorFactory {\n    @Override\n    public JComponentHandlers jHandlers(ActorContext<TopLevelActorMessage> ctx, JCswContext cswCtx) {\n        return new JHcdComponentHandlers(ctx, cswCtx);\n    }\n}","title":"Creating an Assembly or Hcd Component"},{"location":"/framework/handling-lifecycle.html","text":"","title":"Component Handlers"},{"location":"/framework/handling-lifecycle.html#component-handlers","text":"A component developer creates a Top Level Actor (TLA) by inheriting from an abstract class ComponentHandlers or JComponentHandlers for Scala or Java, respectively. Each of these abstract classes provides several handler methods that can be overridden by the developer to provide component-specific code as described below.","title":"Component Handlers"},{"location":"/framework/handling-lifecycle.html#component-lifecycle","text":"For each component, the CSW framework creates a Supervisor that creates the TLA, and along with the abstract behavior class provided by the framework, it starts up and intiailizes the component in a standardized way. At the conclusion of the startup of the component, it is ready to receive commands from the outside world. The following figure is used to describe the startup lifecycle interactions between the framework and the TLA.\nAs described in Creating a Component, in either standalone or when running within a container, a Supervisor is created with a ComponentInfo file. The figure shows that the Supervisor in the framework creates the specified TLA. Once the TLA is created, the framework calls the initialize handler. This is the oportunity for the component to perform initialization needed before it is ready to receive commands.\nThe TLA indicates a successful initialize by returning. If it cannot initialize, it can throw an exception, which will be caught and logged. The Supervisor will retry the creation and initialization of the TLA three times. If it fails after three times processing stops.\nNote After failing to create and initialize three times, the Supervisor will log a message and stop. In the future when the Alarm Service exists, there will probably be an alarm that will be set to notify the operator of a failure since there is serious problem.\nWhen initialize succeeds, the Supervisor in the framework and the component itself enter the Running state. When in the Running state, commands received from outside the component are passed to the TLA (see below).","title":"Component Lifecycle"},{"location":"/framework/handling-lifecycle.html#initialize","text":"The initialize handler is invoked when the component is created. This is different than constructor initialization to allow non-blocking asynchronous operations. The component can initialize state such as configuration to be fetched from Configuration Service, location of components or services to be fetched from Location Service etc. These vary from component to component.\nAssembly/Scala override def initialize(): Future[Unit] = async {\n\n  // Initialization could include following steps :\n\n  // 1. fetch config (preferably from configuration service)\n  val calculationConfig = await(getAssemblyConfig)\n\n  // 2. create a worker actor which is used by this assembly\n  val worker: ActorRef[WorkerActorMsg] = ctx.spawnAnonymous(WorkerActor.make(calculationConfig))\n\n  // 3. find a Hcd connection from the connections provided in componentInfo\n  val maybeConnection =\n    componentInfo.connections.find(connection ⇒ connection.componentId.componentType == ComponentType.HCD)\n\n  // 4. If an Hcd is found as a connection, resolve its location from location service and create other\n  // required worker actors required by this assembly\n\n  maybeConnection match {\n    case Some(_) ⇒\n      resolveHcd().map {\n        case Some(hcd) ⇒\n          runningHcds = runningHcds.updated(maybeConnection.get, Some(CommandServiceFactory.make(hcd)(ctx.system)))\n          diagnosticsPublisher = ctx.spawnAnonymous(DiagnosticsPublisher.make(runningHcds(maybeConnection.get).get, worker))\n          commandHandler = ctx.spawnAnonymous(CommandHandler.make(calculationConfig, runningHcds(maybeConnection.get)))\n        case None ⇒ // do something\n      }\n    case None ⇒ Future.successful(Unit)\n  }\n\n} Assembly/Java @Override\npublic CompletableFuture<Void> jInitialize() {\n\n    // fetch config (preferably from configuration service)\n    CompletableFuture<ConfigData> configDataCompletableFuture = getAssemblyConfig();\n\n    // create a worker actor which is used by this assembly\n    CompletableFuture<ActorRef<WorkerActorMsg>> worker =\n            configDataCompletableFuture.thenApply(config -> ctx.spawnAnonymous(WorkerActor.make(config)));\n\n    // find a Hcd connection from the connections provided in componentInfo\n    Optional<Connection> mayBeConnection = componentInfo.getConnections().stream()\n            .filter(connection -> connection.componentId().componentType() == JComponentType.HCD)\n            .findFirst();\n\n    // If an Hcd is found as a connection, resolve its location from location service and create other\n    // required worker actors required by this assembly, also subscribe to HCD's filter wheel event stream\n    return mayBeConnection.map(connection ->\n            worker.thenAcceptBoth(resolveHcd(), (workerActor, hcdLocation) -> {\n                if (!hcdLocation.isPresent())\n                    throw new HcdNotFoundException();\n                else {\n                    runningHcds.put(connection, Optional.of(CommandServiceFactory.jMake(hcdLocation.get(), ctx.getSystem())));\n                }\n                diagnosticPublisher = ctx.spawnAnonymous(JDiagnosticsPublisherFactory.make(CommandServiceFactory.jMake(hcdLocation.get(), ctx.getSystem()), workerActor));\n            })).get();\n\n} Hcd/Scala override def initialize(): Future[Unit] = async {\n\n  // fetch config (preferably from configuration service)\n  val hcdConfig = await(getHcdConfig)\n\n  // create a worker actor which is used by this hcd\n  val worker: ActorRef[WorkerActorMsg] = ctx.spawnAnonymous(WorkerActor.make(hcdConfig))\n\n  // initialise some state by using the worker actor created above\n  current = await(worker ? InitialState)\n  stats = await(worker ? GetStatistics)\n\n} Hcd/Java @Override\npublic CompletableFuture<Void> jInitialize() {\n\n    // fetch config (preferably from configuration service)\n    getConfig().thenAccept(config -> hcdConfig = config);\n\n    // create a worker actor which is used by this hcd\n    worker = ctx.spawnAnonymous(WorkerActor.make(hcdConfig));\n\n    // initialise some state by using the worker actor created above\n    CompletionStage<Integer> askCurrent = AskPattern.ask(worker, WorkerActorMsgs.JInitialState::new, Duration.ofSeconds(5), ctx.getSystem().scheduler());\n    CompletableFuture<Void> currentFuture = askCurrent.thenAccept(c -> current = c).toCompletableFuture();\n\n    CompletionStage<Integer> askStats = AskPattern.ask(worker, WorkerActorMsgs.JInitialState::new, Duration.ofSeconds(5), ctx.getSystem().scheduler());\n    CompletableFuture<Void> statsFuture = askStats.thenAccept(s -> stats = s).toCompletableFuture();\n\n    return CompletableFuture.allOf(currentFuture, statsFuture);\n}","title":"initialize"},{"location":"/framework/handling-lifecycle.html#creation-timeout","text":"The Supervisor waits for the initialize to complete. If it times out, it will retry the creation of the TLA 3 times in the same way as with initialize failures. The timeout value is configurable by the TLA by setting the initializeTimeout value in ComponentInfo.","title":"Creation Timeout"},{"location":"/framework/handling-lifecycle.html#location-service-interactions","text":"Once the Supervisor and TLA are in the Running state, the Supervisor registers the component with the Location Service. This allows the component to be located so it can be contacted. Registration with Location Service happens only if locationServiceUsage in ComponentInfo is not set to DoNotRegister.\nIf the component has connections and locationServiceUsage in ComponentInfo is set to RegisterAndTrackServices, the framework will resolve the components and deliver TrackingEvents to the TLA through the onTrackingEvent onTrackingEvent handler.","title":"Location Service Interactions"},{"location":"/framework/handling-lifecycle.html#shutting-down","text":"A component may be shutdown by an external administrative program whether it is deployed in a container or standalone. Shutting down may occur when the component is Running/onLine or offLine (see below).\nThe TLA provides a handler called onShutdown that is called by the Supervisor when shutting down to give the TLA an opportunity to perform any clean up it may require such as freeing resources.\nAs with initialize the framework will only wait for 10 seconds for the component to return from doShutdown. If it does not return, it is assumed the TLA is damaged. After successful return from doShutdown, the Supervisor deletes the component. The doShutdown timeout cannot be changed.","title":"Shutting Down"},{"location":"/framework/handling-lifecycle.html#onshutdown","text":"The onShutdown handler can be used for carrying out the tasks which will allow the component to shutdown gracefully.\nAssembly/Scala override def onShutdown(): Future[Unit] = async {\n  // clean up resources\n} Assembly/Java @Override\npublic CompletableFuture<Void> jOnShutdown() {\n    // clean up resources\n    return new CompletableFuture<>();\n} Hcd/Scala override def onShutdown(): Future[Unit] = async {\n  // clean up resources\n} Hcd/Java @Override\npublic CompletableFuture<Void> jOnShutdown() {\n    return CompletableFuture.runAsync(() -> {\n        // clean up resources\n    });\n}","title":"onShutdown"},{"location":"/framework/handling-lifecycle.html#restarting","text":"A component may be restarted by an external administrative program whether it is deployed in a container or standalone. A restart may occur when the component is Running/onLine or offLine (see below).\nA restart causes the component to be destroyed and re-created with a new TLA. The onShutdown handler is called to allow the component to tidy up before it is destroyed. Then the Supervisor creates a new TLA and the startup proceeds as with initialize above.","title":"Restarting"},{"location":"/framework/handling-lifecycle.html#component-online-and-offline","text":"Online describes a component that is currently part of the observing system that is in use. When a component enters the Running state it is also “online”.\nA component is offline when it is operating and available for active observing but is not currently in use.\nIf a component is to transition from the online state to the offline state, the onGoOffLine handler is called. The component should make any changes in its operation for offline use.\nIf a component is to transition from the offline state to the online state, the onGoOnline handler is called. The component should make any changes in its operation needed for online use.","title":"Component Online and Offline"},{"location":"/framework/handling-lifecycle.html#isonline","text":"A component has access to the isOnline boolean flag, which can be used to determine if the component is in the online or offline state.","title":"isOnline"},{"location":"/framework/handling-lifecycle.html#ongooffline","text":"A component can be notified to run in offline mode in case it is not in use. The component can change its behavior if needed as a part of this handler.\nAssembly/Scala override def onGoOffline(): Unit = {\n  // do something when going offline\n} Assembly/Java @Override\npublic void onGoOffline() {\n    // do something when going offline\n} Hcd/Scala override def onGoOffline(): Unit = {\n  // do something when going offline\n} Hcd/Java @Override\npublic void onGoOffline() {\n    // do something when going offline\n}","title":"onGoOffline"},{"location":"/framework/handling-lifecycle.html#ongoonline","text":"A component can be notified to run in online mode again in case it was put to run in offline mode. The component can change its behavior if needed as a part of this handler.\nAssembly/Scala override def onGoOnline(): Unit = {\n  // do something when going online\n} Assembly/Java @Override\npublic void onGoOnline() {\n    // do something when going online\n} Hcd/Scala override def onGoOnline(): Unit = {\n  // do something when going online\n} Hcd/Java @Override\npublic void onGoOnline() {\n    // do something when going online\n}","title":"onGoOnline"},{"location":"/framework/handling-lifecycle.html#handling-commands","text":"The remaining handlers are associated with handling incoming commands. There is a handler for submit commands called onSubmit and a handler for oneway called onOneway.","title":"Handling commands"},{"location":"/framework/handling-lifecycle.html#validatecommand","text":"Whenever a command is received by a component it is first validated. The component should inspect the command and its parameters to determine if the actions related to the command can be executed or started. For instance, if an Assembly or HCD can only handle one command at a time, validateCommand should return an return Invalid if a second command is received.\nA command can be sent as a Submit or Oneway message to the component. The onSubmit and onOneway handlers are only called if validateCommand returns Accepted. Oneway messages return their validation response or indicate the component is currently locked as a OnewayResponse. The onSubmit handler can complete the actions immediately by returning a SubmitResponse indicating the final response (Completed, CompletedWithResult, Error). If the command actions require time for processing, the onSubmit handler returns Started indicating to the framework that there are long-running actions. More information about sending commands using CommandService is here\nAssembly/Scala override def validateCommand(controlCommand: ControlCommand): ValidateCommandResponse = controlCommand match {\n  case _: Setup   ⇒ Accepted(controlCommand.runId) // validation for setup goes here\n  case _: Observe ⇒ Accepted(controlCommand.runId) // validation for observe goes here\n} Assembly/Java @Override\npublic CommandResponse.ValidateCommandResponse validateCommand(ControlCommand controlCommand) {\n    if (controlCommand instanceof Setup) {\n        // validation for setup goes here\n        return new CommandResponse.Accepted(controlCommand.runId());\n    } else if (controlCommand instanceof Observe) {\n        // validation for observe goes here\n        return new CommandResponse.Accepted(controlCommand.runId());\n    } else {\n        return new CommandResponse.Invalid(controlCommand.runId(), new CommandIssue.AssemblyBusyIssue(\"Command not supported\"));\n    }\n} Hcd/Scala override def validateCommand(controlCommand: ControlCommand): ValidateCommandResponse = controlCommand match {\n  case _: Setup   ⇒ Accepted(controlCommand.runId) // validation for setup goes here\n  case _: Observe ⇒ Accepted(controlCommand.runId) // validation for observe goes here\n} Hcd/Java @Override\npublic CommandResponse.ValidateCommandResponse validateCommand(ControlCommand controlCommand) {\n    if (controlCommand instanceof Setup) {\n        // validation for setup goes here\n        return new CommandResponse.Accepted(controlCommand.runId());\n    } else if (controlCommand instanceof Observe) {\n        // validation for observe goes here\n        return new CommandResponse.Accepted(controlCommand.runId());\n    } else {\n        return new CommandResponse.Invalid(controlCommand.runId(), new CommandIssue.UnsupportedCommandIssue(controlCommand.commandName().name()));\n    }\n}\nIf a response can be provided immediately, a final CommandResponse such as CommandCompleted or Error can be sent from this handler.","title":"validateCommand"},{"location":"/framework/handling-lifecycle.html#onsubmit","text":"On receiving a command sent using the submit message, the onSubmit handler is invoked for a component only if the validateCommand handler returns Accepted. The onSubmit handler returns a SubmitResponse indicating if the command is completed immediately, or if it is long-running by returning a Started response. The example shows one way to process Setup and Observe commands separately.\nAssembly/Scala override def onSubmit(controlCommand: ControlCommand): SubmitResponse = controlCommand match {\n  case setup: Setup     ⇒ submitSetup(setup) // includes logic to handle Submit with Setup config command\n  case observe: Observe ⇒ submitObserve(observe) // includes logic to handle Submit with Observe config command\n} Assembly/Java @Override\npublic CommandResponse.SubmitResponse onSubmit(ControlCommand controlCommand) {\n    if (controlCommand instanceof Setup)\n        return submitSetup((Setup) controlCommand); // includes logic to handle Submit with Setup config command\n    else if (controlCommand instanceof Observe)\n        return submitObserve((Observe) controlCommand); // includes logic to handle Submit with Observe config command\n    else\n        return new CommandResponse.Error(controlCommand.runId(), \"Submitted command not supported: \" + controlCommand.commandName().name());\n}","title":"onSubmit"},{"location":"/framework/handling-lifecycle.html#ononeway","text":"On receiving a command as oneway, the onOneway handler is invoked for a component only if the validateCommand handler returns Accepted. The onOneway handler does not return a value and a command submitted with the oneway does not track completion of actions.\nAssembly/Scala override def onOneway(controlCommand: ControlCommand): Unit = controlCommand match {\n  case setup: Setup     ⇒ onewaySetup(setup) // includes logic to handle Oneway with Setup config command\n  case observe: Observe ⇒ onewayObserve(observe) // includes logic to handle Oneway with Observe config command\n} Assembly/Java @Override\npublic void onOneway(ControlCommand controlCommand) {\n    if (controlCommand instanceof Setup)\n        onewaySetup((Setup) controlCommand); // includes logic to handle Oneway with Setup config command\n    else if (controlCommand instanceof Observe)\n        onewayObserve((Observe) controlCommand); // includes logic to handle Oneway with Observe config command\n}\nMore information on handling commands is provided here.","title":"onOneway"},{"location":"/framework/managing-command-state.html","text":"","title":"Managing Command State"},{"location":"/framework/managing-command-state.html#managing-command-state","text":"A component has access to commandResponseManager which is used to manage the state of commands during its execution. On receiving a command as a part of onSubmit and if the command is accepted by the component, the framework adds the command to an internal CommandResponseManager (CRM). The framework also uses the SubmitResponse returned by the onSubmit handler to update the CommandResponseManager. In many cases, this is adequate and no other information is required to handle completion information.\nThe CommandResponseManager can provide additional support in the following scenarios. These scenarios require the developer to update the CRM.\nThe command received in onSubmit returns Started indicating a long-running command that requires notification of completion at a later time. To process an onSubmit that starts long-running actions, the component needs to send one or more commands to other components that may also take time to complete.","title":"Managing Command State"},{"location":"/framework/managing-command-state.html#updating-a-long-running-command","text":"In the first scenario, the developer has a long-running command and does not start any sub-commands or does not with to use the CRM to help manage subcommands. In this case, once the actions are completed, addOrUpdateCommand is used to notify the CRM that the actions are complete. This will cause the original sender to be notified of completion using the SubmitResponse passed to addOrUpdateCommand.","title":"Updating a Long-running Command"},{"location":"/framework/managing-command-state.html#addorupdatecommand","text":"AddOrUpdateCommand is used to add a new command or update the status of an existing command. The following example simulates a worker that takes some time to complete. The onSubmit handler returns Started and later the actions complete with Completed, which completes the command.\nScala override def onSubmit(controlCommand: ControlCommand): SubmitResponse = {\n  controlCommand.commandName match {\n    case `longRunning` ⇒\n      ctx.scheduleOnce(5.seconds,\n                       commandResponseManager.commandResponseManagerActor,\n                       AddOrUpdateCommand(Completed(controlCommand.runId)))\n      Started(controlCommand.runId) Java private CommandResponse.SubmitResponse crmAddOrUpdate(Setup setup) {\n    // This simulates some worker task doing something that finishes after onSubmit returns\n    Runnable task = new Runnable() {\n        @Override\n        public void run() {\n            commandResponseManager.addOrUpdateCommand(new CommandResponse.Completed(setup.runId()));\n        }\n    };\n\n    // Wait a bit and then set CRM to Completed\n    ExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n    ((ScheduledExecutorService) executor).schedule(task, 1, TimeUnit.SECONDS);\n\n    // Return Started from onSubmit\n    return new CommandResponse.Started(setup.runId());\n}","title":"addOrUpdateCommand"},{"location":"/framework/managing-command-state.html#using-the-crm-with-subcommands","text":"If while processing a received command, the component needs to create and send commands to other components (e.g, an Assembly sending commands to one or more HCDs) it can use the CRM to help manage responses from the sub-commands.\nA received command that requires one or more sub-commands must first associate the sub-commands with the received command using the addSubCommand CRM method. When the sub-commands complete, updateSubCommand is used to update the status of sub-commands.\nThe status of original command can then be derived from the status of the sub-commands and when all the sub-commands have completed either successfully or not, the original command will complete and a response returned to the original command sender.","title":"Using the CRM with Subcommands"},{"location":"/framework/managing-command-state.html#addsubcommand","text":"Use addSubCommand to associate sub-commands with a received command.\nScala // When receiving the command, onSubmit adds three subCommands\nshortSetup = Setup(prefix, shortRunning, controlCommand.maybeObsId)\ncommandResponseManager.addSubCommand(runId, shortSetup.runId)\n\nmediumSetup = Setup(prefix, mediumRunning, controlCommand.maybeObsId)\ncommandResponseManager.addSubCommand(runId, mediumSetup.runId)\n\nlongSetup = Setup(prefix, longRunning, controlCommand.maybeObsId)\ncommandResponseManager.addSubCommand(runId, longSetup.runId) Java Prefix prefix1 = new Prefix(\"wfos.red.detector\");\nSetup subCommand1 = new Setup(prefix1, new CommandName(\"sub-command-1\"), sc.jMaybeObsId());\ncommandResponseManager.addSubCommand(sc.runId(), subCommand1.runId());\n\nPrefix prefix2 = new Prefix(\"wfos.blue.detector\");\nSetup subCommand2 = new Setup(prefix2, new CommandName(\"sub-command-2\"), sc.jMaybeObsId());\ncommandResponseManager.addSubCommand(sc.runId(), subCommand2.runId());","title":"addSubCommand"},{"location":"/framework/managing-command-state.html#updatesubcommand","text":"Use updateSubCommand to update the CRM with the SubmitResponse of the sub-commands. This can trigger the delivery of the status of the original/parent command when status of all the sub-commands have been updated. A SubmitResponse indicating failure such as Cancelled or Error in any one of the sub-commands results in the error status of the parent command. Status of any other sub-commands wil not be considered in this case.\nScala // An original command is split into sub-commands and sent to a component.\n// The current state publishing is not relevant to the updateSubCommand usage.\ncase _: Completed ⇒\n  controlCommand.runId match {\n    case id if id == shortSetup.runId ⇒\n      currentStatePublisher\n        .publish(CurrentState(shortSetup.source, StateName(\"testStateName\"), Set(choiceKey.set(shortCmdCompleted))))\n      // As the commands get completed, the results are updated in the commandResponseManager\n      commandResponseManager.updateSubCommand(Completed(id))\n    case id if id == mediumSetup.runId ⇒\n      currentStatePublisher\n        .publish(CurrentState(mediumSetup.source, StateName(\"testStateName\"), Set(choiceKey.set(mediumCmdCompleted))))\n      commandResponseManager.updateSubCommand(Completed(id))\n    case id if id == longSetup.runId ⇒\n      currentStatePublisher\n        .publish(CurrentState(longSetup.source, StateName(\"testStateName\"), Set(choiceKey.set(longCmdCompleted))))\n      commandResponseManager.updateSubCommand(Completed(id))\n  } Java // An original command is split into sub-commands and sent to a component.\n// The result from submitting the sub-commands is used to update the CRM\nICommandService componentCommandService = runningHcds.get(componentInfo.getConnections().get(0)).get();\ncomponentCommandService.submit(subCommand2, Timeout.durationToTimeout(FiniteDuration.apply(5, TimeUnit.SECONDS)))\n        .thenAccept(commandResponse -> {\n            if (commandResponse instanceof CommandResponse.Completed) {\n                // As the commands get completed, the results are updated in the commandResponseManager\n                commandResponseManager.updateSubCommand(commandResponse);\n            } else {\n                // do something\n            }\n        });\nNote It may be the case that the component wants to avoid automatic inference of a command based on the result of the sub-commands. It should refrain from updating the status of the sub-commands in this case and update the status of the parent command directly as required.","title":"updateSubCommand"},{"location":"/framework/tracking-connections.html","text":"","title":"Tracking Connections"},{"location":"/framework/tracking-connections.html#tracking-connections","text":"The component framework tracks the set of connections specified for a component in ComponentInfo if the locationServiceUsage property is set to RegisterAndTrackServices. The framework also provides a helper trackConnection method to track any connection other than those present in ComponentInfo.","title":"Tracking Connections"},{"location":"/framework/tracking-connections.html#onlocationtrackingevent","text":"The onLocationTrackingEvent handler can be used to take action on the TrackingEvent for a particular connection. This event could be for the connections in ComponentInfo tracked automatically or for the connections tracked explicitly using trackConnection method.\nAssembly/Scala override def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = trackingEvent match {\n  case LocationUpdated(location)   ⇒ // do something for the tracked location when it is updated\n  case LocationRemoved(connection) ⇒ // do something for the tracked location when it is no longer available\n} Assembly/Java @Override\npublic void onLocationTrackingEvent(TrackingEvent trackingEvent) {\n    if (trackingEvent instanceof LocationUpdated) {\n        // do something for the tracked location when it is updated\n    } else if (trackingEvent instanceof LocationRemoved) {\n        // do something for the tracked location when it is no longer available\n    }\n} Hcd/Scala override def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = trackingEvent match {\n  case LocationUpdated(location)   ⇒ // do something for the tracked location when it is updated\n  case LocationRemoved(connection) ⇒ // do something for the tracked location when it is no longer available\n} Hcd/Java @Override\npublic void onLocationTrackingEvent(TrackingEvent trackingEvent) {\n    if (trackingEvent instanceof LocationUpdated) {\n        // do something for the tracked location when it is updated\n    } else if (trackingEvent instanceof LocationRemoved) {\n        // do something for the tracked location when it is no longer available\n    }\n}","title":"onLocationTrackingEvent"},{"location":"/framework/publishing-state.html","text":"","title":"Publishing State"},{"location":"/framework/publishing-state.html#publishing-state","text":"A component has access to a currentStatePublisher Actor, which can be used to publish its CurrentState. Any subscriber of this component will receive the published state.\nNote This feature is provided for optimized communication between an Assembly and an HCD only. See Matching state for command completion.\nCurrentState can be used in a number of ways. Two use cases are:\nAn HCD can have detailed information that it publishes for its Assemblies periodically. The Assemblies use the CurrentState information to create events that describe the state of the Assembly and HCD. ‘CurrentState’ information published by the HCD can be used by an Assembly to complete commands that have been submitted to the Assembly.\nThe CommandService shows examples of the use of CurrentState for use case 2. See Matching state for command completion.\nA subscriber can subscribe to all CurrentState published by an HCD or to specific CurrentState specified by its StateName. The publisher does not need to do anything special to support this features.\nScala // Publish the CurrentState using parameter set created using a sample Choice parameter\ncurrentStatePublisher.publish(CurrentState(prefix, StateName(\"testStateName\"), Set(choiceKey.set(initChoice)))) Java CurrentState initState = currentState.add(SampleComponentState.choiceKey().set(SampleComponentState.initChoice()));\ncurrentStatePublisher.publish(initState);","title":"Publishing State"},{"location":"/framework/handling-exceptions.html","text":"","title":"Handling Exceptions"},{"location":"/framework/handling-exceptions.html#handling-exceptions","text":"A component should create exceptions belonging to following two types:\nFailureRestart : As a part of any handler, if an exception can be handled by restarting the component, an exception of type FailureRestart should be thrown to let the framework restart the component. The component’s state will be cleared/reinitialized. The onInitialize handler will be invoked again. Scala case class HcdNotFoundException() extends FailureRestart(\"Could not resolve hcd location. Initialization failure.\")\n\nprivate def resolveHcd(): Future[Option[AkkaLocation]] = {\n  val maybeConnection = componentInfo.connections.find(connection ⇒ connection.componentId.componentType == ComponentType.HCD)\n  maybeConnection match {\n    case Some(hcd) ⇒\n      cswCtx.locationService.resolve(hcd.of[AkkaLocation], 5.seconds).map {\n        case loc @ Some(akkaLocation) ⇒ loc\n        case None                     ⇒\n          // Hcd connection could not be resolved for this Assembly. One option to handle this could be to automatic restart which can give enough time\n          // for the Hcd to be available\n          throw HcdNotFoundException()\n      }\n    case _ ⇒ Future.successful(None)\n  }\n} Java class HcdNotFoundException extends FailureRestart {\n    HcdNotFoundException() {\n        super(\"Could not resolve hcd location. Initialization failure.\");\n    }\n}\n\nprivate CompletableFuture<Optional<AkkaLocation>> resolveHcd() {\n    // find a Hcd connection from the connections provided in componentInfo\n    Optional<Connection> mayBeConnection = componentInfo.getConnections().stream()\n            .filter(connection -> connection.componentId().componentType() == JComponentType.HCD)\n            .findFirst();\n\n    // If an Hcd is found as a connection, resolve its location from location service and create other\n    // required worker actors required by this assembly\n    if (mayBeConnection.isPresent()) {\n        CompletableFuture<Optional<AkkaLocation>> resolve = locationService.resolve(mayBeConnection.get().<AkkaLocation>of(), Duration.ofSeconds(5));\n        return resolve.thenCompose((Optional<AkkaLocation> resolvedHcd) -> {\n            if (resolvedHcd.isPresent())\n                return CompletableFuture.completedFuture(resolvedHcd);\n            else\n                throw new ConfigNotAvailableException();\n        });\n    } else\n        return CompletableFuture.completedFuture(Optional.empty());\n} FailureStop : As a part of any handler, an exception can be thrown of type FailureStop which will result in terminating the component. The onShutdown handler will be invoked to facilitate graceful shutdown. Scala case class ConfigNotAvailableException() extends FailureStop(\"Configuration not available. Initialization failure.\")\n\nprivate def getAssemblyConfig: Future[ConfigData] = {\n\n  configClientService.getActive(Paths.get(\"tromboneAssemblyContext.conf\")).flatMap {\n    case Some(config) ⇒ Future.successful(config) // do work\n    case None         ⇒\n      // required configuration could not be found in the configuration service. Component can choose to stop until the configuration is made available in the\n      // configuration service and started again\n      throw ConfigNotAvailableException()\n  }\n} Java class ConfigNotAvailableException extends FailureStop {\n    ConfigNotAvailableException() {\n        super(\"Configuration not available. Initialization failure.\");\n    }\n}\n\nprivate CompletableFuture<ConfigData> getAssemblyConfig() throws ConfigNotAvailableException {\n    // required configuration could not be found in the configuration service. Component can choose to stop until the configuration is made available in the\n    // configuration service and started again\n    return configClient.getActive(Paths.get(\"tromboneAssemblyContext.conf\"))\n            .thenApply((Optional<ConfigData> maybeConfigData) -> {\n                return maybeConfigData.<ConfigNotAvailableException>orElseThrow(() -> new ConfigNotAvailableException());\n            });\n}","title":"Handling Exceptions"},{"location":"/framework/deploying-components.html","text":"","title":"Deploying Components"},{"location":"/framework/deploying-components.html#deploying-components","text":"","title":"Deploying Components"},{"location":"/framework/deploying-components.html#containercmd","text":"ContainerCmd is a helper utility provided as a part of framework. This helps component writers to start their components inside container.\nA main application needs to be created which uses framework provided utility csw.framework.deploy.containercmd.ContainerCmd to start a container or standalone component. The utility supports following parameters which can be provided as arguments to the application :\nfully qualified path of the configuration file local if the above path is a path to a file available on local disk. If this argument is not provided the file will be looked up in the configuration service using the same path. standalone if the configuration file describes a component to be run in standalone mode. If this argument is not provided the application expects a configuration file describing a container component and will use it to start a container with all the components as described in the file.\nScala object ContainerCmdApp extends App {\n\n  ContainerCmd.start(\"Container-Cmd-App\", args)\n\n} Java public class JContainerCmdApp {\n\n    public static void main(String args[]) {\n        JContainerCmd.start(\"JContainer-Cmd-App\", args, Optional.empty());\n    }\n\n}\nNote It is not necessary to have name of the application as ContainerCmdApp/JContainerCmdApp, user can choose any name.\nStarting a standalone component from a local configuration file\n`./container-cmd-app --standalone --local /assembly/config/assembly.conf`\nStarting a container component from a configuration file available in configuration service\n`./container-cmd-app /assembly/config/assembly.conf`","title":"ContainerCmd"},{"location":"/framework/deploying-components.html#container-for-deployment","text":"A container is a component which starts one or more Components and keeps track of the components within a single JVM process. When started, the container also registers itself with the Location Service. The components to be hosted by the container is defined using a ContainerInfo model which has a set of ComponentInfo objects. It is usually described as a configuration file but can also be created programmatically.\nSampleContainerInfo name = \"Sample_Container\"\ncomponents: [\n  {\n    name = \"SampleAssembly\"\n    componentType = assembly\n    behaviorFactoryClassName = package.component.SampleAssembly\n    prefix = abc.sample.prefix\n    locationServiceUsage = RegisterAndTrackServices\n    connections = [\n      {\n        name: Sample_Hcd_1\n        componentType: hcd\n        connectionType: akka\n      },\n      {\n        name: Sample_Hcd_2\n        componentType: hcd\n        connectionType: akka\n      },\n      {\n        name: Sample_Hcd_3\n        componentType: hcd\n        connectionType: akka\n      }\n    ]\n  },\n  {\n    name = \"Sample_Hcd_1\"\n    componentType = hcd\n    behaviorFactoryClassName = package.component.SampleHcd\n    prefix = abc.sample.prefix\n    locationServiceUsage = RegisterOnly\n  },\n  {\n    name = \"Sample_Hcd_2\"\n    componentType: hcd\n    behaviorFactoryClassName: package.component.SampleHcd\n    prefix: abc.sample.prefix\n    locationServiceUsage = RegisterOnly\n  }\n]","title":"Container for deployment"},{"location":"/framework/deploying-components.html#standalone-components","text":"A component can be run alone in a Standalone mode without sharing its jvm space with any other component.\nSample Info for an assembly name = \"Monitor_Assembly\"\ncomponentType = assembly\nbehaviorFactoryClassName = csw.common.components.command.ComponentBehaviorFactoryForCommand\nprefix = tcs.mobie.blue.monitor\nlocationServiceUsage = RegisterOnly","title":"Standalone components"},{"location":"/commons/command.html","text":"","title":"Communication using Commands"},{"location":"/commons/command.html#communication-using-commands","text":"csw-command library provides support for command based communication between components.\nThis section describes how to communicate with any other component using commands. To check how to manage commands received, please visit Managing Command State","title":"Communication using Commands"},{"location":"/commons/command.html#dependencies","text":"sbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-command\" % \"0.1-SNAPSHOT\"","title":"Dependencies"},{"location":"/commons/command.html#command-based-communication-between-components","text":"A component can send Commands to other components. The commands can be sent as following with three types of messages:\nsubmit - A command is sent as Submit when the result of completion is desired. oneway - A command is sent as Oneway when the result of completion is not desired. validate - A command is sent, but it is only validated with no actions started.\nA submit is the typical way of sending a command from one component to another. When received, a submit command is validated and if accepted, the actions associated with the command are executed or started. submit has a different responses that allow for different scenarios. When the actions started are long-running, the caller can wait for the actions to complete if needed.\nA oneway is primarily meant to be used between an Assembly and an HCD when no completion information is desired. It is also useful when tracking completion using a Matcher and current state values (see below) or events.\nA validate message is used to ask a destination component to validate a command and determine if the command can be executed. But it does not execute the command and returns the result of validation. In some scenarios, it may be useful to test to see if a command can be executed prior to trying to execute the command.\nSignificant Update to Command Service Thanks to an issue brought up by a user of Release 0.4, the Command Service API and command-related component handlers have been modified in this release. The result is a much improved, simplified API that is easier to understand, and refines the responsibilities of the handlers. Code that has been written for 0.5 or 0.4 will need to be updated.","title":"Command-based Communication Between Components"},{"location":"/commons/command.html#command-validation","text":"The first step in processing a command–either submit or oneway–is validation. If not locked, the component’s supervisor calls the validateCommand handler of the Top Level Actor. The developer code evaluates and returns a ValidateCommandResponse as shown in the following table.\nValidateCommandResponse Description Accepted The command is valid and can be executed by the component. Invalid The command is not valid and cannot be executed. The response includes a reason in the form of a CommandIssue Locked The component is locked by some other command sender. The validation could not occur.\nNote that the developer code does not need to return Locked. If the component has been Locked, the component’s Supervisor returns the Locked response to the caller and the validateCommand handler is not called.","title":"Command Validation"},{"location":"/commons/command.html#the-submit-message","text":"A submit message is sent with its command to a component destination. A SubmitResponse is returned to the caller when the submit message is used. If the validateCommand handler returns Accepted, the framework calls the onSubmit handler of the Top Level Actor. The onSubmit handler always returns a SubmitResponse.","title":"The Submit Message"},{"location":"/commons/command.html#immediate-completion-scenario","text":"If the actions of the submit command take a very short time to complete they may be completed by the onSubmit handler. This is called immediate completion. The time for the actions to complete should be less than 1 second. (Note: The framework will timeout if the onSubmit handler does not return a response within 1 second.) In this scenario with onSubmit, the values of SubmitResponse can be Completed, CompletedWithResult, or Error. Error is returned when the actions could not be accomplished. This is different than Invalid, which indicates that the command could not be validated.\nThe immediate completion behavior is similar to a remote procedure call although the execution is entirely asynchronous. If the actions do not produce a value for the client, the Completed SubmitResponse is returned. If there is a result, the CompletedWithResult SubmitResult is returned with a parameter set of Result type.","title":"Immediate Completion Scenario"},{"location":"/commons/command.html#long-running-actions-scenario","text":"When actions take longer than 1 second, onSubmit should start the actions and return the Started SubmitResponse. The Started response indicates to the framework that long running actions have been started. In this case, the Started is returned to the sender of the command. Note, however, that the response returned to the sender by submit in the Command Service API is the final SubmitResponse returned when the actions are finished, not Started.\nOnce the long running actions have started, the client code must notify the framework when the actions are completed. This is done be updating the Command Response Manager.\nIn addition to the values returned for immediate completion, long running actions can return Cancelled. If the component supports a special command to cancel actions, the cancelled command should return Cancelled when successfully cancelled and the command that cancels a command should return Completed.\nThe following table summarizes all the possible values for SubmitResponse.\nSubmitResponse Description Invalid The command is not valid and cannot be executed. The response includes a reason in the form of a CommandIssue. onSubmit is not executed. Completed This response is returned when the actions associated with a command are complete. CompletedWithResult This response is returned when the actions associated with a command are complete and a result is returned. Started Returned when long running actions have been started. Error Error is returned the the actions started by a command do not complete properly. A message is returned explaining the error. Cancelled The actions associated with a long running command have been cancelled. Locked The component is locked by some other command sender. The validation could not occur.","title":"Long Running Actions Scenario"},{"location":"/commons/command.html#the-oneway-message","text":"The other option for sending a command to a component destination is the oneway message. The central difference between submit and oneway is that oneway does not track or allow reporting of completion information. It supports a fire and forget type of communication approach.\nA OnewayResponse is returned to the caller when the oneway message is used. Oneway does validate the command. If the component is not locked, the validateCommand handler is called. If the validateCommand handler returns Accepted, the framework calls the onOneway handler of the Top Level Actor. However, the onOneway handler does not return a value. The sender of the oneway message receives the result of the validation or the Locked indication.\nThe following table summarizes all the possible values for OnewayResponse.\nOnewayResponse Description Invalid The command is not valid and cannot be executed. The response includes a reason in the form of a CommandIssue. onSubmit is not executed. Accepted Returned when validation succeeds and the command was passed to the onOneway handler. Locked The component is locked by some other command sender. The validation could not occur.\nOneway is available as a higher performance option when an Assembly needs to send commands to an HCD but doesn’t really care about completion such as the case when demands are being sent to a motor. Validation is still present to ensure the HCD supports the standalone operation requirement and can check that it is not getting out of range values.\nOneway is can be used with a matcher. The matcher can use CurrentState or even events from Event Service to determine completion. This is more complicated than submit but may be useful in some scenarios.","title":"The Oneway Message"},{"location":"/commons/command.html#the-validate-message","text":"The validate message is available when the sender wants to validate a command but does not want to execute any associated actions. Validate returns a ValidateResponse. If the component is not locked, the validateCommand handler of the Top Level Actor is called and the developer code evaluates the command and returns a ValidateResponse as shown in the following table.\nValidateResponse Description Accepted The command is valid and can be executed by the component. Invalid The command is not valid and cannot be executed. The response includes a reason in the form of a CommandIssue Locked The component is locked by some other command sender. The validation could not occur.\nValidate could be used by an Assembly when it needs to send multiple commands to different HCDs and it wants to first check that all the HCDs can execute their commands before sending a command to any of the HCDs.","title":"The Validate Message"},{"location":"/commons/command.html#commandservice","text":"A helper/wrapper is provided called CommandService that provides a convenient way to use the Command Service with a component from the Location Service.\nA CommandService instance is created using an AkkaLocation discovered from the Location Service. This CommandService instance will has methods for communicating with the component. A new CommandService is created for each component for which commands are to be sent.\nThe API can be exercised as follows for different scenarios of command-based communication:","title":"CommandService"},{"location":"/commons/command.html#submit","text":"Sending a submit message with a command returns a SubmitResponse as a Future. The Future returned by submit will always be the final response, which may be a positive completion (Completed or CompletedWithResult) or a negative completion (Invalid, Error, Cancelled, Locked). The Started response is never seen by the programmer when using the submit of CommandService.\nThis example shows an immediate completion command using submit that returns Completed.\nScala/submit w/immediate-response val immediateSetup = Setup(prefix, immediateCmd, obsId)\nval immediateCommandF = async {\n  await(assemblyCmdService.submit(immediateSetup)) match {\n    case response: Completed ⇒\n      //do something with completed result\n      response\n    case otherResponse ⇒\n      // do something with other response which is not expected\n      otherResponse\n  }\n} Java/submit w/immediate-response CompletableFuture<CommandResponse.SubmitResponse> immediateCommandF =\n        hcdCmdService\n                .submit(immediateCmd, timeout)\n                .thenApply(\n                        response -> {\n                            if (response instanceof CommandResponse.Completed) {\n                                //do something with completed result\n                            } else {\n                                // do something with unexpected response\n                            }\n                            return response;\n                        }\n                );\nNote that the Scala examples are using async/await which simplifies handling the Futures, but is not necessary. The async/await library is not available in Java. If using submit and the validation fails in the destination component, the Invalid response is returned.\nScala/submit w/invalid response val invalidSetup    = Setup(prefix, invalidCmd, obsId)\nval invalidCommandF = assemblyCmdService.submit(invalidSetup)\nasync {\n  await(invalidCommandF) match {\n    case Completed(runId) =>\n    // Do Completed thing\n    case Invalid(runId, issue) =>\n      issue shouldBe a[Invalid]\n    case other =>\n      // Unexpected result\n      log.error(s\"Some other response: $other\")\n  }\n} Java/submit w/invalid response Setup invalidSetup = new Setup(prefix(), invalidCmd(), Optional.empty()).add(intParameter2);\nCompletableFuture<CommandResponse.SubmitResponse> invalidCommandF =\n        hcdCmdService.submit(invalidSetup, timeout).thenApply(\n                response -> {\n                    if (response instanceof CommandResponse.Completed) {\n                        //do something with completed result\n                    } else if (response instanceof CommandResponse.Invalid) {\n                        // Cast the response to get the issue\n                        CommandResponse.Invalid invalid = (CommandResponse.Invalid) response;\n                        assert (invalid.issue().reason().contains(\"failure\"));\n                    }\n                    return response;\n                }\n        );\nThe handling of long-running and immediate completion commands look the same from the command sender’s perspective. The following example shows a long-running command that returns a value when the command action completes with a result.\nScala/submit long running val longRunningSetup1 = Setup(prefix, longRunningCmd, obsId)\n\nval longRunningResultF = async {\n  await(assemblyCmdService.submit(longRunningSetup1)) match {\n    case CompletedWithResult(_, result) =>\n      Some(result(encoder).head)\n\n    case otherResponse =>\n      // log a message?\n      None\n  }\n} Java/submit long running Setup longRunningSetup1 = new Setup(prefix(), longRunningCmd(), Optional.empty()).add(intParameter1);\nKey<Integer> encoder = JKeyType.IntKey().make(\"encoder\");\nCompletableFuture<Optional<Integer>> longRunningResultF =\n        hcdCmdService.submit(longRunningSetup1, timeout)\n                .thenCompose(response -> {\n                    if (response instanceof CommandResponse.CompletedWithResult) {\n                        // This extracts and returns the the first value of parameter encoder\n                        Result result = ((CommandResponse.CompletedWithResult) response).result();\n                        Optional<Integer> rvalue = Optional.of(result.jGet(encoder).get().head());\n                        return CompletableFuture.completedFuture(rvalue);\n                    } else {\n                        // For some other response, return empty\n                        return CompletableFuture.completedFuture(Optional.empty());\n                    }\n\n                });\nIf a command is long-running and the sender needs to determine that the actions have started properly, the query method of CommandService can be used as shown in the following example without using the Future returned by submit, which provides the final completion notification.\nScala/submit long running/query val longRunningSetup2 = longRunningSetup1.cloneCommand\nval longRunningQueryResultF = async {\n  // The following val is set so we can do query and work and complete later\n  val longRunningF = assemblyCmdService.submit(longRunningSetup2)\n\n  await(assemblyCmdService.query(longRunningSetup2.runId)) match {\n    case Started(runId) =>\n    // happy case - no action needed\n    // Do some other work\n    case a =>\n    // log.error. This indicates that the command probably failed to start.\n  }\n\n  // Now wait for completion and result\n  await(longRunningF) match {\n    case CompletedWithResult(_, result) =>\n      Some(result(encoder).head)\n\n    case otherResponse =>\n      // log a message?\n      None\n  }\n}\nAwait.result(longRunningQueryResultF, timeout.duration) shouldBe Some(20) Java/submit long running/query Setup longRunningSetup2 = longRunningSetup1.cloneCommand();\nCompletableFuture<CommandResponse.SubmitResponse> longRunningQueryResultF =\n        hcdCmdService.submit(longRunningSetup2, timeout);\n\n// do some work before querying for the result of above command as needed\nCompletableFuture<CommandResponse.QueryResponse> queryResponseF = hcdCmdService.query(longRunningSetup2.runId(), timeout);\nqueryResponseF.thenAccept(r -> {\n    if (r instanceof CommandResponse.Started) {\n        // happy case - no action needed\n        // Do some other work\n    } else {\n        // log.error. This indicates that the command probably failed to start.\n    }\n});\n\nCompletableFuture<Optional<Integer>> intF =\n        longRunningQueryResultF.thenCompose(response -> {\n    if (response instanceof CommandResponse.CompletedWithResult) {\n        // This extracts and returns the the first value of parameter encoder\n        Result result = ((CommandResponse.CompletedWithResult) response).result();\n        Optional<Integer> rvalue = Optional.of(result.jGet(encoder).get().head());\n        return CompletableFuture.completedFuture(rvalue);\n    } else {\n        // For some other response, return empty\n        return CompletableFuture.completedFuture(Optional.empty());\n    }\n});\nAssert.assertEquals(Optional.of(20), intF.get());\nIt’s also possible to use the runId of the Setup with queryFinal to determine when the actions are completed. This is equivalent to using the Future returned by submit, but in this case, the original Future from submit is not available.\nScala/submit long running/queryFinal val longRunningSetup3 = longRunningSetup1.cloneCommand\nval queryFinalF = async {\n  // The following submit is made without saving the Future!\n  assemblyCmdService.submit(longRunningSetup3)\n\n  // Use queryFinal and runId to wait for completion and result\n  await(assemblyCmdService.queryFinal(longRunningSetup3.runId)) match {\n    case CompletedWithResult(_, result) =>\n      Some(result(encoder).head)\n\n    case otherResponse =>\n      // log a message?\n      None\n  }\n}\nAwait.result(queryFinalF, timeout.duration) shouldBe Some(20) Java/submit long running/queryFinal Setup longRunningSetup3 = longRunningSetup1.cloneCommand();\nhcdCmdService.submit(longRunningSetup3, timeout);\n\nCompletableFuture<Optional<Integer>> int3F =\n        hcdCmdService.queryFinal(longRunningSetup3.runId(), timeout).thenCompose(response -> {\n            if (response instanceof CommandResponse.CompletedWithResult) {\n                // This extracts and returns the the first value of parameter encoder\n                Result result = ((CommandResponse.CompletedWithResult) response).result();\n                Optional<Integer> rvalue = Optional.of(result.jGet(encoder).get().head());\n                return CompletableFuture.completedFuture(rvalue);\n            } else {\n                // For some other response, return empty\n                return CompletableFuture.completedFuture(Optional.empty());\n            }\n        });\nAssert.assertEquals(Optional.of(20), int3F.get());","title":"submit"},{"location":"/commons/command.html#oneway","text":"Oneway does not provide completion information but does return the result of validateCommand handler in the Top-Level-Actor (Accepted, Invalid, or Locked). When sending a command as a oneway message, a OnewayResponse is returned as a Future that can be used to check that it was validated.\nScala // `onewayCmd` is a sample to demonstrate oneway without any actions\nval onewaySetup = Setup(prefix, onewayCmd, obsId)\n// Don't care about the futures from async\nval oneWayF = async {\n  await(assemblyCmdService.oneway(onewaySetup)) match {\n    case invalid: Invalid ⇒\n    // Log an error here\n    case _ ⇒\n    // Ignore anything other than invalid\n  }\n}\nAwait.ready(oneWayF, timeout.duration) Java Setup onewaySetup = new Setup(prefix(), onewayCmd(), Optional.empty()).add(intParameter1);\nCompletableFuture onewayF = hcdCmdService\n        .oneway(onewaySetup, timeout)\n        .thenAccept(onewayResponse -> {\n            if (onewayResponse instanceof CommandResponse.Invalid) {\n                // log an error here\n            } else {\n                // Ignore anything other than invalid\n            }\n        });","title":"oneway"},{"location":"/commons/command.html#validate","text":"Sometimes it may be useful to test whether or not a component can execute a command without committing to executing its actions. The validate message can be used for this purpose. Validate returns a ValidateResponse of Accepted, Invalid, or Locked.\nScala val validateCommandF = async {\n  await(assemblyCmdService.validate(immediateSetup)) match {\n    case response: Accepted ⇒ true\n    case Invalid(_, issue)  ⇒\n      // do something with other response which is not expected\n      log.error(s\"Command failed to validate with issue: $issue\")\n      false\n    case l: Locked => false\n  }\n}\nAwait.result(validateCommandF, timeout.duration) shouldBe true Java Setup onewaySetup = new Setup(prefix(), onewayCmd(), Optional.empty()).add(intParameter1);\nCompletableFuture onewayF = hcdCmdService\n        .oneway(onewaySetup, timeout)\n        .thenAccept(onewayResponse -> {\n            if (onewayResponse instanceof CommandResponse.Invalid) {\n                // log an error here\n            } else {\n                // Ignore anything other than invalid\n            }\n        });","title":"validate"},{"location":"/commons/command.html#query","text":"At any time, the query call of CommandService can be used to check the current status of a command that has been sent via the submit message using the command’s runId. This is most useful with a long-running command but all commands that use submit are available.\nThe query message returns a QueryResponse, which includes all of the values of SubmitResponse plus the CommandNotAvailable response. This response occurs when the framework has no knowledge of the command associated with the runId passed with the query. The previous long-running example above showed the use of query to check that the actions associated with a command that had started. Another usage is to check the final value of a command that is already completed using its runId.\nScala/query usage // Check on a command that was completed in the past\nval queryValue = Await.result(assemblyCmdService.query(longRunningSetup2.runId), timeout.duration)\nqueryValue shouldBe a[CompletedWithResult] Java/query usage CompletableFuture<CommandResponse.QueryResponse> queryResponseF2 = hcdCmdService.query(longRunningSetup2.runId(), timeout);\nAssert.assertTrue(queryResponseF2.get() instanceof CommandResponse.CompletedWithResult);","title":"query"},{"location":"/commons/command.html#submitall","text":"SubmitAll can be used to send multiple commands sequentially to the same component. This could be used to send initialization commands to an HCD, for instance. The argument for submitAll is a list of commands. SubmitAll returns a list of SubmitResponses–one for each command in the list. While submit returns a SubmitResponse as a Future, submitAll returns a list of SubmitResponses as a future, which completes when all the commands in the list have completed.\nScala/query usage val submitAllF = async {\n  await(assemblyCmdService.submitAll(List(submitAllSetup1, submitAllSetup2, submitAllinvalidSetup)))\n}\nval submitAllResponse = Await.result(submitAllF, timeout.duration)\nsubmitAllResponse.length shouldBe 3\nsubmitAllResponse(0) shouldBe a[Completed]\nsubmitAllResponse(1) shouldBe a[CompletedWithResult]\nsubmitAllResponse(2) shouldBe a[Invalid] Java/query usage Setup submitAllSetup1 = new Setup(prefix(), immediateCmd(), Optional.empty()).add(encoderParam);\nSetup submitAllSetup2 = new Setup(prefix(), longRunningCmd(), Optional.empty()).add(encoderParam);\nSetup submitAllSetup3 = new Setup(prefix(), invalidCmd(), Optional.empty()).add(encoderParam);\n\nCompletableFuture<List<CommandResponse.SubmitResponse>> submitAllF = hcdCmdService\n        .submitAll(\n                Arrays.asList(submitAllSetup1, submitAllSetup2, submitAllSetup3),\n                timeout\n        );\n\nList<CommandResponse.SubmitResponse> submitAllResponse = submitAllF.get();\nAssert.assertEquals(submitAllResponse.size(), 3);\nAssert.assertTrue(submitAllResponse.get(0) instanceof CommandResponse.Completed);\nAssert.assertTrue(submitAllResponse.get(1) instanceof CommandResponse.CompletedWithResult);\nAssert.assertTrue(submitAllResponse.get(2) instanceof CommandResponse.Invalid);\nIn the first example, three commands are sent and the result is a list with three SubmitResponses. The last one returned invalid and was not executed.\nThe commands in submitAll will execute sequentially, but each one must complete successfully for the subsequent commands to be executed. If any one of the commands fails, submitAll stops and the list is returned with the commands that are completed up to and including the command that failed. This is shown in the following example by making the invalidCmd second in the list.\nScala/query usage val submitAllF2 = async {\n  await(assemblyCmdService.submitAll(List(submitAllSetup1, submitAllinvalidSetup, submitAllSetup2)))\n}\nval submitAllResponse2 = Await.result(submitAllF2, timeout.duration)\nsubmitAllResponse2.length shouldBe 2\nsubmitAllResponse2(0) shouldBe a[Completed]\nsubmitAllResponse2(1) shouldBe a[Invalid] Java/query usage CompletableFuture<List<CommandResponse.SubmitResponse>> submitAllF2 = hcdCmdService\n        .submitAll(\n                Arrays.asList(submitAllSetup1, submitAllSetup3, submitAllSetup2),\n                timeout\n        );\n\nList<CommandResponse.SubmitResponse> submitAllResponse2 = submitAllF2.get();\nAssert.assertEquals(submitAllResponse2.size(), 2);\nAssert.assertTrue(submitAllResponse2.get(0) instanceof CommandResponse.Completed);\nAssert.assertTrue(submitAllResponse2.get(1) instanceof CommandResponse.Invalid);\nIn this case, the returned list is of length 2 rather than 3.","title":"submitAll"},{"location":"/commons/command.html#subscribecurrentstate","text":"This method provided by CommandService can be used to subscribe to the CurrentState of a component by providing a callback that is called with the arrival of every CurrentState item. SubscribeCurrentState returns a handle of CurrentStateSubscription which should be used to unsubscribe the subscription.\nThe following example code shows an Assembly that subscribes to all CurrentState of an HCD. The example sends a Setup with an encoder parameter value to the HCD as a oneway message.\nScala // Subscriber code\nval expectedEncoderValue = 234\nval currStateSetup       = Setup(prefix, hcdCurrentStateCmd, obsId).add(encoder.set(expectedEncoderValue))\n// Setup a callback response to CurrentState\nvar cstate: CurrentState = CurrentState(prefix, StateName(\"no cstate\"), Set.empty)\nval subscription         = hcdCmdService.subscribeCurrentState(cs => cstate = cs)\n// Send a oneway to the HCD that will cause it to publish a CurrentState with the encoder value\n// in the command parameter \"encoder\". Callback will store value into cstate.\nhcdCmdService.oneway(currStateSetup)\n\n// Wait for a bit for callback\nThread.sleep(100)\n// Test to see if value was received\ncstate(encoder).head shouldBe expectedEncoderValue\n\n// Unsubscribe to CurrentState\nsubscription.unsubscribe() Java // Subscriber code\nint expectedEncoderValue = 234;\nSetup currStateSetup = new Setup(prefix(), hcdCurrentStateCmd(), Optional.empty()).add(encoder.set(expectedEncoderValue));\n// Setup a callback response to CurrentState - use AtomicInteger to capture final value\nfinal AtomicInteger cstate = new AtomicInteger((1));\nCurrentStateSubscription subscription = hcdCmdService.subscribeCurrentState(cs -> {\n    // Example sets variable outside scope of closure\n    cstate.set(cs.jGet(encoder).get().head());\n});\n// Send a oneway to the HCD that will cause a publish of a CurrentState with the encoder value\n// in the command parameter \"encoder\"\nhcdCmdService.oneway(currStateSetup, timeout);\n\n// Wait for a bit for the callback\nThread.sleep(200);\n// Check to see if CurrentState has the value we sent\nAssert.assertEquals(expectedEncoderValue, cstate.get());\n\n// Unsubscribe from CurrentState\nsubscription.unsubscribe();\n// subscribe to the current state of an assembly component and use a callback which forwards each received\n// element to a test probe actor\nCurrentStateSubscription subscription = hcdCmdService.subscribeCurrentState(currentState -> probe.ref().tell(currentState));\nThe second part of the example shows the code in the HCD. When the HCD receives the oneway message, it extracts the encoder value and publishes a CurrentState item with the encoder parameter.\nScala val currentState = CurrentState(prefix, StateName(\"HCDState\"), controlCommand.paramSet)\ncswCtx.currentStatePublisher.publish(currentState) Java Key<Integer> encoder = JKeyType.IntKey().make(\"encoder\");\nint expectedEncoderValue = setup.jGet(encoder).get().head();\n\nCurrentState currentState = new CurrentState(prefix(), new StateName(\"HCDState\")).add(encoder().set(expectedEncoderValue));\ncurrentStatePublisher.publish(currentState);\nThere are two subscribeCurrentState methods in CommandService. The method shown in the above examples subscribes the caller to all CurrentState published. Each CurrentState item has a StateName. A second signature for subscribeCurrentState can include a Set of StateName when the caller only needs some of the CurrentState published by a component.","title":"subscribeCurrentState"},{"location":"/commons/command.html#matching-state-for-command-completion","text":"The matcher is provided to allow a component sending a command to use CurrentState published by a component to determine when actions are complete. The expected case is an Assembly using the CurrentState published by an HCD. When using a submit completion is determined in the destination. In some scenarios, the Assembly may want to determine when actions are complete. This is what the matcher allows.\nTo use this feature, the oneway message is used rather than submit. A oneway command is validated but the framework does not provide completion. Doing a query with the runId of a oneway will always return CommandNotAvailable, but oneway is perfect for use with a matcher.\nThe matcher is created with the ActorRef of the component that is the source of CurrentState and an instance of StateMatcher, which defines the state and criteria for matching.\nSeveral types of StateMatcher are provided as part of CSW for common use. These are DemandMatcherAll for matching the entire DemandState against the current state, DemandMatcher for matching state with or without units against the current state, and PresenceMatcher which checks if a matching state is found with a provided prefix.\nThe developer is not limited to these StateMatchers. Any class the implements the StateMatcher interface can be provided to a Matcher.\nScala val param: Parameter[Int] = encoder.set(100)\nval setupWithMatcher      = Setup(prefix, matcherCmd, obsId)\n\n// create a StateMatcher which specifies the desired algorithm and state to be matched.\nval demandMatcher: StateMatcher =\n  DemandMatcher(DemandState(prefix, StateName(\"testStateName\")).add(param), withUnits = false, timeout)\n\n// create matcher instance\nval matcher = new Matcher(assemblyLocation.componentRef, demandMatcher)\n\n// start the matcher so that it is ready to receive state published by the source\nval matcherResponseF: Future[MatcherResponse] = matcher.start\n\n// Submit command as a oneway and if the command is successfully validated,\n// check for matching of demand state against current state\nval matchResponseF: Future[MatchingResponse] = async {\n  val onewayResponse: OnewayResponse = await(assemblyCmdService.oneway(setupWithMatcher))\n  onewayResponse match {\n    case Accepted(runId) ⇒\n      val matcherResponse = await(matcherResponseF)\n      // create appropriate response if demand state was matched from among the published state or otherwise\n      // this would allow the response to be used to complete a command received by the Assembly\n      matcherResponse match {\n        case MatchCompleted =>\n          Completed(setupWithMatcher.runId)\n        case mf: MatchFailed =>\n          Error(setupWithMatcher.runId, mf.throwable.getMessage)\n      }\n    case invalid: Invalid ⇒\n      matcher.stop()\n      invalid\n    case locked: Locked =>\n      matcher.stop()\n      locked\n  }\n}\n\nval commandResponse = Await.result(matchResponseF, timeout.duration)\ncommandResponse shouldBe Completed(setupWithMatcher.runId) Java Parameter<Integer> param = JKeyType.IntKey().make(\"encoder\").set(100);\nSetup setupWithMatcher = new Setup(prefix(), matcherCmd(), Optional.empty()).add(param);\n\n// create a StateMatcher which specifies the desired algorithm and state to be matched.\nDemandMatcher demandMatcher = new DemandMatcher(new DemandState(prefix(), new StateName(\"testStateName\")).add(param), false, timeout);\n\n// create the matcher instance\nMatcher matcher = new Matcher(AkkaLocationExt.RichAkkaLocation(hcdLocation).componentRef().narrow(), demandMatcher, ec, mat);\n\n// start the matcher so that it is ready to receive state published by the source\nCompletableFuture<MatcherResponse> matcherResponseFuture = matcher.jStart();\n\n// Submit command as a oneway and if the command is successfully validated,\n// check for matching of demand state against current state\nCompletableFuture<CommandResponse.MatchingResponse> matchResponseF = hcdCmdService\n        .oneway(setupWithMatcher, timeout)\n        .thenCompose(initialCommandResponse -> {\n            if (initialCommandResponse instanceof CommandResponse.Accepted) {\n                return matcherResponseFuture.thenApply(matcherResponse -> {\n                    if (matcherResponse.getClass().isAssignableFrom(MatcherResponses.jMatchCompleted().getClass()))\n                        return new CommandResponse.Completed(initialCommandResponse.runId());\n                    else\n                        return new CommandResponse.Error(initialCommandResponse.runId(), \"Match not completed\");\n                });\n\n            } else {\n                matcher.stop();\n                return CompletableFuture.completedFuture(new CommandResponse.Error(initialCommandResponse.runId(), \"Matcher failed\"));\n            }\n        });\n\nCommandResponse.MatchingResponse actualResponse = matchResponseF.get();\nCommandResponse.Completed expectedResponse = new CommandResponse.Completed(setupWithMatcher.runId());\nAssert.assertEquals(expectedResponse, actualResponse);\nOne important point is that the matcher is created and must be shutdown when you are finished with it using the stop method of the matcher as shown in the example.","title":"Matching state for command completion"},{"location":"/commons/command.html#onewayandmatch","text":"CommandService provides a short-cut called onewayAndMatch that combines a oneway and a matcher and implements much of the boilerplate of the previous example. This can be often be used saving code.\nScala val onewayMatchF = async {\n  await(assemblyCmdService.onewayAndMatch(setupWithMatcher, demandMatcher)) match {\n    case i: Invalid =>\n      // Command was not accepted\n      log.error(s\"Oneway match was not accepted: ${i.issue}\")\n      i\n    case c: Completed =>\n      // Do some completed work\n      c\n    case e: Error =>\n      // Match failed and timedout generating an error - log a message\n      println(\"Error\")\n      log.error(s\"Oeway match produced an error: ${e.message}\")\n      e\n    case l: Locked =>\n      // Destination component was locked, log a message\n      log.error(s\"Destination component was locked\")\n      l\n  }\n}\nAwait.result(onewayMatchF, timeout.duration) shouldBe Completed(setupWithMatcher.runId) Java  // create a DemandMatcher which specifies the desired state to be matched.\n StateMatcher stateMatcher = new DemandMatcher(new DemandState(prefix(), new StateName(\"testStateName\")).add(param), false, timeout);\n\n // create matcher instance\n //Matcher matcher1 = new Matcher(AkkaLocationExt.RichAkkaLocation(hcdLocation).componentRef().narrow(), demandMatcher, ec, mat);\n\n // start the matcher so that it is ready to receive state published by the source\n// CompletableFuture<MatcherResponse> matcherResponse = matcher1.jStart();\n\n CompletableFuture<CommandResponse.MatchingResponse> matchedCommandResponse =\n         hcdCmdService.onewayAndMatch(setupWithMatcher, stateMatcher, timeout);","title":"onewayAndMatch"},{"location":"/commons/services.html","text":"","title":"Services"},{"location":"/commons/services.html#services","text":"Location Service Configuration Service Logging Service Event Service Alarm Service Time Service Database Service Authentication and Authorization Service (AAS)","title":"Services"},{"location":"/services/location.html","text":"","title":"Location Service"},{"location":"/services/location.html#location-service","text":"The Location Service handles component (i.e., Applications, Sequencers, Assemblies, HCDs, and Services) registration and discovery in the distributed TMT software system.\nCSW Location Service cluster must be running, and appropriate environment variables set to run apps. See CSW Location Server.\nA component’s location information can be used by other components and services to connect to it and use it. An example of location information is:\nhost address/port pairs URL/URIs paths connection protocols log-admin actor reference\nasync handling in scala and java examples. Scala: async marks a block of asynchronous code and allows to await the computation till the Future is complete. For more info, please refer to: https://github.com/scala/async Java non-blocking example: The code snippets use CompletableFuture and its thenAsync, thenApply methods. This style allows to compose multiple Futures and not block the calling thread till Futures are complete. Java blocking example: The code snippets use CompletableFuture using get blocking call. This style blocks the calling thread till the Future is complete.","title":"Location Service"},{"location":"/services/location.html#dependencies","text":"To use the Location Service without using the framework, add this to your build.sbt file:\nsbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-location-server\" % \"0.1-SNAPSHOT\"","title":"Dependencies"},{"location":"/services/location.html#create-location-service","text":"Note that before using this API, the csw-location-server application should be running at a known location in the network (or at multiple locations) and the necessary configuration, environment variables or system properties should be defined to point to the correct host and port number(s).\nLocationServiceFactory provides a make method to create an instance of the LocationService API. This call will look for configuration or environment variable settings as described here: ClusterSettings.\nScala private val locationService = HttpLocationServiceFactory.makeLocalClient(actorSystem, mat) Java private ActorSystem system = context().system();\nprivate ActorMaterializer mat = ActorMaterializer.create(system);\nprivate ILocationService locationService = JHttpLocationServiceFactory.makeLocalClient(system, mat);","title":"Create Location Service"},{"location":"/services/location.html#creating-components-connections-and-registrations","text":"An Application, Sequencer, Assembly, HCD, or Service component may need to be used by another component as part of normal observatory operations. It must register its location information with Location Service so that other components can find it. A location information comprises of:\nComponentId : A component id comprises of ComponentName : a name depicting the component. ComponentType : such as Container, Sequencer, HCD, Assembly, Service. ConnectionType : the means to reach components. These are categorized as Akka, HTTP, or Tcp type connections.\nThe location information is stored in Location Service as Registrations.\nSome of the examples of string representation of a connection are:\nTromboneAssembly-assembly-akka TromboneHcd-hcd-akka ConfigServer-service-http EventService-service-tcp\nThe register API takes a Registration parameter and returns a future registration result. If registration fails for some reason, the returned future will fail with an exception. (Registration will fail if the csw-location-server application is not running or could not be found or if the given component name was already registered.)\nThe following example shows registration of both UnTyped ActorRef and Typed ActorRef:\nScala // add some dummy registrations for illustrative purposes\n\n// dummy http connection\nval httpPort                          = 8080\nval httpConnection                    = HttpConnection(ComponentId(\"configuration\", ComponentType.Service))\nval httpRegistration                  = HttpRegistration(httpConnection, httpPort, \"path123\")\nval httpRegResult: RegistrationResult = Await.result(locationService.register(httpRegistration), 2.seconds)\n\n// ************************************************************************************************************\n\n// import scaladsl adapter to implicitly convert UnTyped ActorRefs to Typed ActorRef[Nothing]\nimport akka.actor.typed.scaladsl.adapter._\n\n// dummy HCD connection\nval hcdConnection = AkkaConnection(ComponentId(\"hcd1\", ComponentType.HCD))\nval hcdRegistration: AkkaRegistration = AkkaRegistration(\n  hcdConnection,\n  Prefix(\"nfiraos.ncc.tromboneHcd\"),\n  context.actorOf(Props(new akka.actor.Actor {\n    override def receive: Receive = {\n      case \"print\" => log.info(\"hello world\")\n    }\n  }), name = \"my-actor-1\")\n)\n\n// Register UnTyped ActorRef with Location service. Import scaladsl adapter to implicitly convert\n// UnTyped ActorRefs to Typed ActorRef[Nothing]\nval hcdRegResult: RegistrationResult = Await.result(locationService.register(hcdRegistration), 2.seconds)\n\n// ************************************************************************************************************\n\ndef behavior(): Behavior[String] = Behaviors.setup { ctx =>\n  Behaviors.receiveMessage { msg =>\n    Behaviors.same\n  }\n}\nval typedActorRef: ActorRef[String] = context.system.spawn(behavior(), \"typed-actor-ref\")\n\nval assemblyConnection = AkkaConnection(ComponentId(\"assembly1\", ComponentType.Assembly))\n\n// Register Typed ActorRef[String] with Location Service\nval assemblyRegistration: AkkaRegistration =\n  AkkaRegistration(assemblyConnection, Prefix(\"nfiraos.ncc.tromboneAssembly\"), typedActorRef)\n\nval assemblyRegResult: RegistrationResult = Await.result(locationService.register(assemblyRegistration), 2.seconds) Java // dummy http connection\nHttpConnection httpConnection = new HttpConnection(new ComponentId(\"configuration\", JComponentType.Service));\nHttpRegistration httpRegistration = new HttpRegistration(httpConnection, 8080, \"path123\");\nhttpRegResult = locationService.register(httpRegistration).get();\n\n// ************************************************************************************************************\n\n// dummy HCD connection\nAkkaConnection hcdConnection = new AkkaConnection(new ComponentId(\"hcd1\", JComponentType.HCD));\nActorRef actorRef = getContext().actorOf(Props.create(AbstractActor.class, () -> new AbstractActor() {\n            @Override\n            public Receive createReceive() {\n                return ReceiveBuilder.create().build();\n            }\n        }),\n        \"my-actor-1\"\n);\n\n// Register UnTyped ActorRef with Location service. Use javadsl Adapter to convert UnTyped ActorRefs\n// to Typed ActorRef[Nothing]\nAkkaRegistration hcdRegistration = AkkaRegistration.apply(hcdConnection, new Prefix(\"nfiraos.ncc.tromboneHcd\"), Adapter.toTyped(actorRef));\nhcdRegResult = locationService.register(hcdRegistration).get();\n\n// ************************************************************************************************************\n\nBehavior<String> behavior = Behaviors.setup(ctx -> {\n    return Behaviors.same();\n});\nakka.actor.typed.ActorRef<String> typedActorRef = Adapter.spawn(context(), behavior, \"typed-actor-ref\");\n\nAkkaConnection assemblyConnection = new AkkaConnection(new ComponentId(\"assembly1\", JComponentType.Assembly));\n\n// Register Typed ActorRef[String] with Location Service\nAkkaRegistration assemblyRegistration = new RegistrationFactory().akkaTyped(assemblyConnection, new Prefix(\"nfiraos.ncc.tromboneAssembly\"), typedActorRef);\n\n\nassemblyRegResult = locationService.register(assemblyRegistration).get();\nNote The AkkaRegistration api takes only Typed ActorRefs. Hence, to register an UnTyped ActorRef for an akka connection, it needs to be adapted to Typed ActorRef[Nothing]. This can be achieved using adapter provided for scaladsl and javadsl. The usage of adapter is shown in above snippet for scala and java both. Also, note that for components, the registration will be taken care of via csw-framework. Hence, component developers won’t register any connections during their development. So, above demonstration of registering connections is for explanatory and testing purpose only.","title":"Creating Components, Connections and Registrations"},{"location":"/services/location.html#creating-actorref-for-registration","text":"Make sure the ActorSystem used to start actors using the location service is created using ActorSystemFactory as follows:\nScala implicit val actorSystem: ActorSystem = ActorSystemFactory.remote(\"csw-examples-locationServiceClient\") Java ActorSystem actorSystem = ActorSystemFactory.remote(\"csw-examples-locationServiceClient\");\nThis is required to start a remote ActorSystem on the same network interface where the csw-cluster is running. All the ActorRefs created using this ActorSystem will be available for communication from other components that are part of csw-cluster.","title":"Creating ActorRef for Registration"},{"location":"/services/location.html#resolving-connections","text":"The list API returns a list of the currently registered connections from the Location Service.\nA connection of interest can be looked up using the resolve or find methods:\nresolve gets the location for a connection from the local cache. If not found in the cache, it waits for the event to arrive within the specified time limit and returns None on failure.\nfind returns the location for a connection from the local cache and returns None if not found there.\nScala // find connection to LocationServiceExampleComponent in location service\n// [do this before starting LocationServiceExampleComponent.  this should return Future[None]]\nval exampleConnection: AkkaConnection = LocationServiceExampleComponent.connection\n\nlog.info(s\"Attempting to find $exampleConnection\",\n         Map(Keys.OBS_ID → \"foo_obs_id\", \"exampleConnection\" → exampleConnection.name))\nval findResult: Option[AkkaLocation] = Await.result(locationService.find(exampleConnection), timeout)\n\nlog.info(s\"Result of the find call: $findResult\") Java // find connection to LocationServiceExampleComponent in location service\n// [do this before starting LocationServiceExampleComponent.  this should return Future[None]]\n\nlog.info(\"Attempting to find \" + exampleConnection,\n        new HashMap<String, Object>() {{\n            put(JKeys.OBS_ID, \"foo_obs_id\");\n            put(\"exampleConnection\", exampleConnection.name());\n        }});\n\nOptional<AkkaLocation> findResult = locationService.find(exampleConnection).get();\nif (findResult.isPresent()) {\n    log.info(\"Find result: \" + connectionInfo(findResult.get().connection()));\n} else {\n    log.info(() -> \"Result of the find call : None\");\n}\nThe logging output from the above example when the given component is not registered should include:\n[INFO] Attempting to find connection AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))\n[INFO] Result of the find call: None\nAn example of the resolve command is shown in the following:\nScala // resolve connection to LocationServiceExampleComponent\n// [start LocationServiceExampleComponent after this command but before timeout]\nlog.info(s\"Attempting to resolve $exampleConnection with a wait of $waitForResolveLimit ...\")\n\nval resolveResultF: Future[Option[AkkaLocation]] = locationService.resolve(exampleConnection, waitForResolveLimit)\nval resolveResult: Option[AkkaLocation]          = Await.result(resolveResultF, waitForResolveLimit + timeout)\nresolveResult match {\n  case Some(result) ⇒\n    log.info(s\"Resolve result: ${locationInfoToString(result)}\")\n  case None ⇒\n    log.info(s\"Timeout waiting for location $exampleConnection to resolve.\")\n} Java // resolve connection to LocationServiceExampleComponent\n// [start LocationServiceExampleComponent after this command but before timeout]\nDuration waitForResolveLimit = Duration.ofSeconds(30);\n\nlog.info(() -> \"Attempting to resolve \" + exampleConnection + \" with a wait of \" + waitForResolveLimit + \"...\", () -> {\n    Map<String, Object> map = new HashMap<>();\n    map.put(JKeys.OBS_ID, \"foo_obs_id\");\n    map.put(\"exampleConnection\", exampleConnection.name());\n    return map;\n});\n\nOptional<AkkaLocation> resolveResult = locationService.resolve(exampleConnection, waitForResolveLimit).get();\nif (resolveResult.isPresent()) {\n    log.info(() -> \"Resolve result: \" + connectionInfo(resolveResult.get().connection()));\n} else {\n    log.info(() -> \"Timeout waiting for location \" + exampleConnection + \" to resolve.\");\n}\nThe logging output from the above example should include:\n[INFO] Attempting to resolve AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly)) with a wait of 30 seconds ...\nIf you then start the LocationServiceExampleComponentApp, the following message will be logged:\n[INFO] Resolve result: LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\nIf not, eventually the operation will timeout and the output should read:\n[INFO] Timeout waiting for location AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly)) to resolve.\nNote The resolve and find api returns the concrete Location type i.e. Akkalocation, HttpLocation or TcpLocation as demonstrated in this section. Once the akka location is found or resolved, we need to retain the type to the actorRef, since the explicit type annotation is removed from the program, before it is executed at run-time (refer type erasure). Use following AkkaLocation api to get the correct Typed ActorRef: Scala // If the component type is HCD or Assembly, use this to get the correct ActorRef\nval typedComponentRef: ActorRef[ComponentMessage] = akkaLocation.componentRef\n\n// If the component type is Container, use this to get the correct ActorRef\nval typedContainerRef: ActorRef[ContainerMessage] = akkaLocation.containerRef Java // If the component type is HCD or Assembly, use this to get the correct ActorRef\nakka.actor.typed.ActorRef<ComponentMessage> typedComponentRef = AkkaLocationExt.RichAkkaLocation(akkaLocation).componentRef();\n\n// If the component type is Container, use this to get the correct ActorRef\nakka.actor.typed.ActorRef<ContainerMessage> typedContainerRef = AkkaLocationExt.RichAkkaLocation(akkaLocation).containerRef();","title":"Resolving Connections"},{"location":"/services/location.html#filtering","text":"The list API and its variants offer means to inquire about available connections with the Location Service. The parameter-less list returns all available connections\nScala // list connections in location service\nval connectionList: List[Location] = Await.result(locationService.list, timeout)\nlog.info(\"All Registered Connections:\")\nconnectionList.foreach(c => log.info(s\"--- ${locationInfoToString(c)}\")) Java // list connections in location service\nList<Location> connectionList = locationService.list().get();\nlog.info(\"All Registered Connections:\");\nfor (Location loc : connectionList) {\n    log.info(\"--- \" + connectionInfo(loc.connection()));\n}\nThe log output from the above should contain:\n[INFO] All Registered Connections:\n[INFO] --- configuration-service-http, component type=Service, connection type=HttpType\n[INFO] --- hcd1-hcd-akka, component type=HCD, connection type=AkkaType\n[INFO] --- LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\n[INFO] --- redis-service-tcp, component type=Service, connection type=TcpType\n[INFO] --- assembly1-assembly-akka, component type=Assembly, connection type=AkkaType\nOther variants are filters using ConnectionType, ComponentType, and hostname.\nFiltering by component type is shown below:\nScala // filter connections based on component type\nval componentList: List[Location] = Await.result(locationService.list(ComponentType.Assembly), timeout)\nlog.info(\"Registered Assemblies:\")\ncomponentList.foreach(c => log.info(s\"--- ${locationInfoToString(c)}\")) Java // filter connections based on component type\nList<Location> componentList = locationService.list(JComponentType.Assembly).get();\nlog.info(\"Registered Assemblies:\");\nfor (Location loc : componentList) {\n    log.info(\"--- \" + connectionInfo(loc.connection()));\n}\nThe log output from the above code should contain:\n[INFO] Registered Assemblies:\n[INFO] --- LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\n[INFO] --- assembly1-assembly-akka, component type=Assembly, connection type=AkkaType\nFiltering by connection type is shown below:\nScala // filter connections based on connection type\nval akkaList: List[Location] = Await.result(locationService.list(ConnectionType.AkkaType), timeout)\nlog.info(\"Registered Akka connections:\")\nakkaList.foreach(c => log.info(s\"--- ${locationInfoToString(c)}\")) Java // filter connections based on connection type\nList<Location> akkaList = locationService.list(JConnectionType.AkkaType).get();\nlog.info(\"Registered Akka connections:\");\nfor (Location loc : akkaList) {\n    log.info(\"--- \" + connectionInfo(loc.connection()));\n}\nThe log output should contain:\n[INFO] Registered Akka connections:\n[INFO] --- hcd1-hcd-akka, component type=HCD, connection type=AkkaType\n[INFO] --- LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\n[INFO] --- assembly1-assembly-akka, component type=Assembly, connection type=AkkaType\nFiltering akka connections by prefix is shown below:\nScala // filter akka locations based on prefix\nval akkaLocations: List[AkkaLocation] = Await.result(locationService.listByPrefix(\"nfiraos.ncc\"), timeout)\nlog.info(\"Registered akka locations for nfiraos.ncc\")\nakkaLocations.foreach(c ⇒ log.info(s\"--- ${locationInfoToString(c)}\")) Java List<AkkaLocation> akkaLocations = locationService.listByPrefix(\"nfiraos.ncc\").get();\nlog.info(\"Registered akka locations for nfiraos.ncc\");\nfor (Location loc : akkaLocations) {\n    log.info(\"--- \" + connectionInfo(loc.connection()));\n}\nThe log output should contain:\n[INFO] Registered akka locations for nfiraos.ncc\n[INFO] --- hcd1-hcd-akka, component type=HCD, connection type=AkkaType\n[INFO] --- assembly1-assembly-akka, component type=Assembly, connection type=AkkaType","title":"Filtering"},{"location":"/services/location.html#tracking-and-subscribing","text":"The lifecycle of a connection of interest can be followed using either the track API or the subscribe API.\nThese methods take a Connection instance as a parameter. A Connection need not already be registered with Location Service. It’s alright to track connections that will be registered in future.\nA track API returns two values: * A source that will emit a stream of TrackingEvents for the connection. * A Killswitch to turn off the stream when no longer needed.\nThe Akka stream API provides many building blocks to process this stream, such as Flow and Sink. In the example below, Sink.actorRef is used to forward any location messages received to the current actor (self).\nA consumer can shut down the stream using the Killswitch.\nThe subscribe API allows the caller to track a connection and receive the TrackingEvent notifications via a callback.\nThe API expects following parameters : * An existing connection or a connection to be registered in the future. * A callback that implements Consumer, receives the TrackEvent as a parameter.\nIn return it gives a Killswitch that can be used to turn off the event notifications and release the supplied callback, if required.\nScala // the following two methods are examples of two ways to track a connection.\n// both are implemented but only one is really needed.\n\n// Method1: track connection to LocationServiceExampleComponent\n// Calls track method for example connection and forwards location messages to this actor\n//\nlog.info(s\"Starting to track $exampleConnection\")\nlocationService\n  .track(exampleConnection)\n  .to(Sink.actorRef(self, AllDone))\n  .run()\n//track returns a Killswitch, that can be used to turn off notifications arbitarily\n//in this case track a connection for 5 seconds, after that schedule switching off the stream\nval killswitch = locationService\n  .track(httpConnection)\n  .toMat(Sink.foreach(println))(Keep.left)\n  .run()\ncontext.system.scheduler.scheduleOnce(5.seconds) {\n  killswitch.shutdown()\n}\n\n// Method2: subscribe to LocationServiceExampleComponent events\nlog.info(s\"Starting a subscription to $exampleConnection\")\nlocationService.subscribe(\n  exampleConnection,\n  trackingEvent => {\n    // the following println is to distinguish subscription events from tracking events\n    log.info(\"subscription event\")\n    self ! trackingEvent\n  }\n) Java // the following two methods are examples of two ways to track a connection.\n// both are implemented but only one is really needed.\n\n// track connection to LocationServiceExampleComponent\n// Calls track method for example connection and forwards location messages to this actor\nMaterializer mat = ActorMaterializer.create(getContext());\nlog.info(\"Starting to track \" + exampleConnection);\nlocationService.track(exampleConnection).toMat(Sink.actorRef(getSelf(), AllDone.class), Keep.both()).run(mat);\n\n//track returns a Killswitch, that can be used to turn off notifications arbitarily\n//in this case track a connection for 5 seconds, after that schedule switching off the stream\nPair pair = locationService.track(exampleConnection).toMat(Sink.ignore(), Keep.both()).run(mat);\ncontext().system().scheduler().scheduleOnce(\n        Duration.ofSeconds(5),\n        () -> ((KillSwitch) pair.first()).shutdown(),\n        context().system().dispatcher());\n\n// subscribe to LocationServiceExampleComponent events\nlog.info(\"Starting a subscription to \" + exampleConnection);\nlocationService.subscribe(exampleConnection, trackingEvent -> {\n    log.info(\"subscription event\");\n    getSelf().tell(trackingEvent, ActorRef.noSender());\n});\nThe log output should contain the following:\n[INFO] Starting to track AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly)) LocationUpdated(HttpLocation(HttpConnection(ComponentId(configuration,Service)),http://131.215.210.170:8080/path123))\n[INFO] Starting a subscription to AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))\n[INFO] Subscribing to connection LocationServiceExampleComponent-assembly-akka\n[INFO] Location updated LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\n[INFO] subscription event\n[INFO] Location updated LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\nIf you now stop the LocationServiceExampleComponentApp, it would log:\n[INFO] subscription event\n[INFO] Location removed AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))\n[INFO] Location removed AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))\nIf you start the LocationServiceExampleComponentApp again, the log output should be:\n[INFO] subscription event\n[INFO] Location updated LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\n[INFO] Location updated LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\nNote: the line after the words “subscription event” in our example is generated by the subscription, and the other line is from tracking. These two events could come in any order.","title":"Tracking and Subscribing"},{"location":"/services/location.html#unregistering","text":"One of the ways to unregister a service is by calling unregister on registration result received from register API.\nScala val unregisterF = async {\n  httpRegResult.unregister()\n  hcdRegResult.unregister()\n  assemblyRegResult.unregister()\n}\nAwait.result(unregisterF, 5.seconds) Java httpRegResult.unregister();\nhcdRegResult.unregister();\nassemblyRegResult.unregister();","title":"Unregistering"},{"location":"/services/location.html#source-code-for-examples","text":"Scala Example JavaBlocking Example","title":"Source code for examples"},{"location":"/services/config.html","text":"","title":"Configuration Service"},{"location":"/services/config.html#configuration-service","text":"The Configuration Service provides a centralized persistent store for any configuration file used in the TMT Software System. All versions of configuration files are retained, providing a historical record of each configuration file.\nNote that in order to use the APIs described here, the Location Service (csw-location-server) and Configuration Service Server needs to be running somewhere in the local network and the necessary configuration, environment variables or system properties should be defined to point to the correct host and port number(s) for the Location Service nodes.\nThis service will be part of the observatory cluster and exposes Rest endpoints that can be accessed over HTTP. Component developers can use the csw-config-client library in their code. The library wraps the low level communication with Configuration Service Server and exposes simple to use methods to access and manage configuration files.","title":"Configuration Service"},{"location":"/services/config.html#dependencies","text":"To use the Configuration Service without using the framework, add this to your build.sbt file:\nsbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-config-client\" % \"0.1-SNAPSHOT\"","title":"Dependencies"},{"location":"/services/config.html#rules-and-checks","text":"The config file path must not contain !#<>$%&'@^``~+,;= or any whitespace character If the input file is > 10MB or has lot of non ASCII characters, then for optimization, server will archive it in annex store. Large and binary files can be forced to go to ‘annex’ store by using a annex=true flag in create operation. API functions accept date-time values in UTC timezone. (e.g. 2017-05-17T08:00:24.246Z)","title":"Rules and Checks"},{"location":"/services/config.html#model-classes","text":"ConfigData : Represents the contents of the files being managed. It wraps stream of ByteString. ConfigFileInfo : Represents information about a config file stored in the config service. ConfigFileRevision : Represents information about a specific version of a config file. ConfigId : Represents identifier associated with a revision of configuration file, often generated by create or update methods. ConfigMetadata : Represents metadata information about ConfigServer. FileType : Represents the type of storage for a configuration file. Currently two types are supported Normal(small, text files) and Annex(Large, Binary files).","title":"Model Classes"},{"location":"/services/config.html#api-flavors","text":"The Configuration Service is used to provide the runtime settings for components. When a component is started, it will use a limited “clientAPI” to obtain the “active” configuration from the Configuration Service, and use those settings for its execution.\nTo change the active configuration, an administrative tool with access to the full “admin API” must be used. These tools would have the ability to create, delete, and update configurations, as well as retrieve past configurations and their history. Any time a new configuration is to be used by a component, the user must use one of these tools (via CLI, perhaps) to set the active configuration for a component. Since a history of active configurations is maintained by the service, the settings of each component each time it is run can be retrieved, and the system configuration at any moment can be recreated.\nclientAPI : Must be used in Assembly and HCD components. Available functions are: {exists | getActive} adminAPI : Full functionality exposed by Configuration Service Server is available with this API. Expected to be used administrators. Available functions are: {create | update | getById | getLatest | getByTime | delete | list | history | historyActive | setActiveVersion | resetActiveVersion | getActiveVersion | getActiveByTime | getMetadata | exists | getActive}\nComponent developers must use clientAPI.","title":"API Flavors"},{"location":"/services/config.html#accessing-clientapi-and-adminapi","text":"ConfigClientFactory exposes functions to get clientAPI and adminAPI. Both the functions require Location Service instance which is used to resolve ConfigServer.\nNote Components should only use the client API. The Admin API may be used from an engineering user interface. The CSW Config Client CLI application is provided with this functionality.\nScala //config client API\nval clientApi: ConfigClientService = ConfigClientFactory.clientApi(actorSystem, locationService)\n//config admin API\nval adminApi: ConfigService = ConfigClientFactory.adminApi(actorSystem, locationService, factory) Java //config client API\nIConfigClientService clientApi = JConfigClientFactory.clientApi(actorSystem, clientLocationService);\n//config admin API\nIConfigService adminApi = JConfigClientFactory.adminApi(actorSystem, clientLocationService, mocks.factory());\nNote Creating adminAPI requires instance of TokenFactory. TokenFactory has getToken method which returns raw access token string which is used by config client to insert it into auth header of http request before sending to config server. For more details, refer bottom section on Admin Protected Routes","title":"Accessing clientAPI and adminAPI"},{"location":"/services/config.html#exists","text":"Function checks if the file exists at specified path in the repository. If it exists it returns Future of Boolean\nScala //construct the path\nval filePath = Paths.get(\"/tmt/trmobone/assembly/hcd.conf\")\n\nval doneF = async {\n  // create file using admin API\n  await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"First commit\"))\n\n  //check if file exists with config service\n  val exists: Boolean = await(clientApi.exists(filePath))\n  exists shouldBe true\n}\nAwait.result(doneF, 5.seconds) Java Path filePath = Paths.get(\"/tmt/trmobone/assembly/hcd.conf\");\n\n// create file using admin API\nadminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"commit config file\").get();\n\nBoolean exists = clientApi.exists(filePath).get();\nAssert.assertTrue(exists);","title":"exists"},{"location":"/services/config.html#getactive","text":"Function retrieves currently active file for a given path from config service. It returns a Future of Option of ConfigData.\nScala val defaultStrConf: String = \"foo { bar { baz : 1234 } }\"\nval doneF = async {\n  // construct the path\n  val filePath = Paths.get(\"/tmt/trmobone/assembly/hcd.conf\")\n\n  await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"First commit\"))\n\n  val activeFile: Option[ConfigData] = await(clientApi.getActive(filePath))\n  await(activeFile.get.toStringF(mat)) shouldBe defaultStrConf\n}\nAwait.result(doneF, 5.seconds) Java String defaultStrConf = \"foo { bar { baz : 1234 } }\";\n// construct the path\nPath filePath = Paths.get(\"/tmt/trmobone/assembly/hcd.conf\");\n\nadminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"First commit\").get();\n\nConfigData activeFile = clientApi.getActive(filePath).get().get();\nAssert.assertEquals(activeFile.toJConfigObject(mat).get().getString(\"foo.bar.baz\"), \"1234\");","title":"getActive"},{"location":"/services/config.html#create","text":"Takes input ConfigData and creates the configuration in the repository at a specified path\nScala   async {\n    //construct ConfigData from String containing ASCII text\n    val configString: String =\n      \"\"\"\n    // Name: ComponentType ConnectionType\n    {\n      name: lgsTromboneHCD\n      type: Hcd\n      connectionType: [akka]\n    }\n    \"\"\".stripMargin\n    val config1: ConfigData = ConfigData.fromString(configString)\n\n    //construct ConfigData from a local file containing binary data\n    val srcFilePath         = getClass.getClassLoader.getResource(\"smallBinary.bin\").toURI\n    val config2: ConfigData = ConfigData.fromPath(Paths.get(srcFilePath))\n\n    //construct ConfigData from Array[Byte] by reading a local file\n    val stream: InputStream    = getClass.getClassLoader.getResourceAsStream(\"smallBinary.bin\")\n    def byteArray: Array[Byte] = Stream.continually(stream.read).takeWhile(_ != -1).map(_.toByte).toArray\n    val config3                = ConfigData.fromBytes(byteArray)\n\n    //store the config, at a specified path as normal text file\n    val id1: ConfigId =\n      await(adminApi.create(Paths.get(\"/hcd/trombone/overnight.conf\"), config1, annex = false, \"review done\"))\n\n    //store the config, at a specified path as a binary file in annex store\n    val id2: ConfigId =\n      await(adminApi.create(Paths.get(\"/hcd/trombone/firmware.bin\"), config2, annex = true, \"smoke test done\"))\n\n    //store the config, at a specified path as a binary file in annex store\n    val id3: ConfigId =\n      await(adminApi.create(Paths.get(\"/hcd/trombone/debug.bin\"), config3, annex = true, \"new file from vendor\"))\n\n    //CAUTION: for demo example setup these IDs are returned. Don't assume them in production setup.\n    id1 shouldEqual ConfigId(1)\n    id2 shouldEqual ConfigId(3)\n    id3 shouldEqual ConfigId(5)\n  }\nAwait.result(futC, 2.seconds) Java //construct ConfigData from String containing ASCII text\nString configString = \"axisName11111 = tromboneAxis\\naxisName22222 = tromboneAxis2\\naxisName3 = tromboneAxis3333\";\nConfigData config1 = ConfigData.fromString(configString);\n\n//construct ConfigData from a local file containing binary data\nURI srcFilePath = getClass().getClassLoader().getResource(\"smallBinary.bin\").toURI();\nConfigData config2 = ConfigData.fromPath(Paths.get(srcFilePath));\n\nConfigId id1 = adminApi.create(Paths.get(\"/hcd/trombone/overnight.conf\"), config1, false, \"review done\").get();\nConfigId id2 = adminApi.create(Paths.get(\"/hcd/trombone/firmware.bin\"), config2, true, \"smoke test done\").get();\n\n//CAUTION: for demo example setup these IDs are returned. Don't assume them in production setup.\nAssert.assertEquals(id1, new ConfigId(\"1\"));\nAssert.assertEquals(id2, new ConfigId(\"3\"));","title":"create"},{"location":"/services/config.html#update","text":"Takes input ConfigData and overwrites the configuration specified in the repository\nScala val futU = async {\n  val destPath = Paths.get(\"/hcd/trombone/debug.bin\")\n  val newId = await(\n    adminApi\n      .update(destPath, ConfigData.fromString(defaultStrConf), comment = \"debug statements\")\n  )\n\n  //validate the returned id\n  newId shouldEqual ConfigId(7)\n}\nAwait.result(futU, 2.seconds) Java Path destPath = Paths.get(\"/hcd/trombone/overnight.conf\");\nConfigId newId = adminApi.update(destPath, ConfigData.fromString(defaultStrConf), \"added debug statements\").get();\n\n//validate the returned id\nAssert.assertEquals(newId, new ConfigId(\"5\"));","title":"update"},{"location":"/services/config.html#delete","text":"Deletes a file located at specified path in the repository\nScala val futD = async {\n  val unwantedFilePath = Paths.get(\"/hcd/trombone/debug.bin\")\n  await(adminApi.delete(unwantedFilePath, \"no longer needed\"))\n  //validates the file is deleted\n  await(adminApi.getLatest(unwantedFilePath)) shouldBe None\n}\nAwait.result(futD, 2.seconds) Java Path unwantedFilePath = Paths.get(\"/hcd/trombone/overnight.conf\");\nadminApi.delete(unwantedFilePath, \"no longer needed\").get();\nAssert.assertEquals(adminApi.getLatest(unwantedFilePath).get(), Optional.empty());","title":"delete"},{"location":"/services/config.html#getbyid","text":"Returns file at a given path and matching revision Id\nScala val doneF = async {\n  // create a file using API first\n  val filePath = Paths.get(\"/tmt/trmobone/assembly/hcd.conf\")\n  val id: ConfigId =\n    await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"First commit\"))\n\n  //validate\n  val actualData = await(adminApi.getById(filePath, id)).get\n  await(actualData.toStringF(mat)) shouldBe defaultStrConf\n}\nAwait.result(doneF, 2.seconds) Java Path filePath = Paths.get(\"/tmt/trmobone/assembly/hcd.conf\");\nConfigId id = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"First commit\").get();\n\n//validate\nConfigData actualData = adminApi.getById(filePath, id).get().get();\nAssert.assertEquals(defaultStrConf, actualData.toJStringF(mat).get());","title":"getById"},{"location":"/services/config.html#getlatest","text":"Returns the latest versio of file stored at the given path.\nScala val assertionF: Future[Assertion] = async {\n  //create a file\n  val filePath = Paths.get(\"/test.conf\")\n  await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"initial configuration\"))\n\n  //override the contents\n  val newContent = \"I changed the contents!!!\"\n  await(adminApi.update(filePath, ConfigData.fromString(newContent), \"changed!!\"))\n\n  //get the latest file\n  val newConfigData = await(adminApi.getLatest(filePath)).get\n  //validate\n  await(newConfigData.toStringF(mat)) shouldBe newContent\n}\nAwait.result(assertionF, 2.seconds) Java //create a file\nPath filePath = Paths.get(\"/test.conf\");\nConfigId id = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"initial configuration\").get();\n\n//override the contents\nString newContent = \"I changed the contents!!!\";\nadminApi.update(filePath, ConfigData.fromString(newContent), \"changed!!\").get();\n\n//get the latest file\nConfigData newConfigData = adminApi.getLatest(filePath).get().get();\n//validate\nAssert.assertEquals(newConfigData.toJStringF(mat).get(), newContent);","title":"getLatest"},{"location":"/services/config.html#getbytime","text":"Gets the file at the given path as it existed at a given time-instance. Note:\nIf time-instance is before the file was created, the initial version is returned. If time-instance is after the last change, the most recent version is returned.\nScala val assertionF = async {\n  val tInitial = Instant.MIN\n  //create a file\n  val filePath = Paths.get(\"/a/b/c/test.conf\")\n  await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"initial configuration\"))\n\n  //override the contents\n  val newContent = \"I changed the contents!!!\"\n  await(adminApi.update(filePath, ConfigData.fromString(newContent), \"changed!!\"))\n\n  val initialData: ConfigData = await(adminApi.getByTime(filePath, tInitial)).get\n  await(initialData.toStringF(mat)) shouldBe defaultStrConf\n\n  val latestData = await(adminApi.getByTime(filePath, Instant.now())).get\n  await(latestData.toStringF(mat)) shouldBe newContent\n}\nAwait.result(assertionF, 2.seconds) Java Instant tInitial = Instant.now();\n\n//create a file\nPath filePath = Paths.get(\"/test.conf\");\nConfigId id = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"initial configuration\").get();\n\n//override the contents\nString newContent = \"I changed the contents!!!\";\nadminApi.update(filePath, ConfigData.fromString(newContent), \"changed!!\").get();\n\nConfigData initialData = adminApi.getByTime(filePath, tInitial).get().get();\nAssert.assertEquals(defaultStrConf, initialData.toJStringF(mat).get());\n\nConfigData latestData = adminApi.getByTime(filePath, Instant.now()).get().get();\nAssert.assertEquals(newContent, latestData.toJStringF(mat).get());","title":"getByTime"},{"location":"/services/config.html#list","text":"For a given FileType(Annex or Normal) and an optional pattern string, it will list all files whose path matches the given pattern. Some pattern examples are: “/path/hcd/*.*”, “a/b/c/d.*”, “.*.conf”, “.*hcd.*”\nScala //Here's a list of tuples containing FilePath and FileTyepe(Annex / Normal)\nval paths: List[(Path, FileType)] = List[(Path, FileType)](\n  (Paths.get(\"a/c/trombone.conf\"), Annex),\n  (Paths.get(\"a/b/c/hcd/hcd.conf\"), Normal),\n  (Paths.get(\"a/b/assembly/assembly1.fits\"), Annex),\n  (Paths.get(\"a/b/c/assembly/assembly2.fits\"), Normal),\n  (Paths.get(\"testing/test.conf\"), Normal)\n)\n\n//create config files at those paths\npaths map {\n  case (path, fileType) ⇒\n    val createF = async {\n      await(\n        adminApi.create(path, ConfigData.fromString(defaultStrConf), Annex == fileType, \"initial commit\")\n      )\n    }\n    Await.result(createF, 2.seconds)\n}\n\nval assertionF = async {\n  //retrieve list of all files; for demonstration purpose show validate return values\n  await(adminApi.list()).map(info ⇒ info.path).toSet shouldBe paths.map {\n    case (path, fileType) ⇒ path\n  }.toSet\n\n  //retrieve list of files based on type; for demonstration purpose validate return values\n  await(adminApi.list(Some(Annex))).map(info ⇒ info.path).toSet shouldBe paths.collect {\n    case (path, fileType) if fileType == Annex ⇒ path\n  }.toSet\n  await(adminApi.list(Some(FileType.Normal))).map(info ⇒ info.path).toSet shouldBe paths.collect {\n    case (path, fileType) if fileType == FileType.Normal ⇒ path\n  }.toSet\n\n  //retrieve list using pattern; for demonstration purpose validate return values\n  await(adminApi.list(None, Some(\".*.conf\"))).map(info ⇒ info.path.toString).toSet shouldBe Set(\n    \"a/b/c/hcd/hcd.conf\",\n    \"a/c/trombone.conf\",\n    \"testing/test.conf\"\n  )\n  //retrieve list using pattern and file type; for demonstration purpose validate return values\n  await(adminApi.list(Some(FileType.Normal), Some(\".*.conf\"))).map(info ⇒ info.path.toString).toSet shouldBe\n  Set(\"a/b/c/hcd/hcd.conf\", \"testing/test.conf\")\n  await(adminApi.list(Some(Annex), Some(\"a/c.*\"))).map(info ⇒ info.path.toString).toSet shouldBe\n  Set(\"a/c/trombone.conf\")\n  await(adminApi.list(Some(FileType.Normal), Some(\"test.*\"))).map(info ⇒ info.path.toString).toSet shouldBe\n  Set(\"testing/test.conf\")\n}\nAwait.result(assertionF, 2.seconds) Java Path trombonePath = Paths.get(\"a/c/trombone.conf\");\nPath hcdPath = Paths.get(\"a/b/c/hcd/hcd.conf\");\nPath fits1Path = Paths.get(\"a/b/assembly/assembly1.fits\");\nPath fits2Path = Paths.get(\"a/b/c/assembly/assembly2.fits\");\nPath testConfPath = Paths.get(\"testing/test.conf\");\n\nString comment = \"initial commit\";\n\n//create files\nConfigId tromboneId = adminApi.create(trombonePath, ConfigData.fromString(defaultStrConf), true, comment).get();\nConfigId hcdId = adminApi.create(hcdPath, ConfigData.fromString(defaultStrConf), false, comment).get();\nConfigId fits1Id = adminApi.create(fits1Path, ConfigData.fromString(defaultStrConf), true, comment).get();\nConfigId fits2Id = adminApi.create(fits2Path, ConfigData.fromString(defaultStrConf), false, comment).get();\nConfigId testId = adminApi.create(testConfPath, ConfigData.fromString(defaultStrConf), true, comment).get();\n\n//retrieve full list; for demonstration purpose validate return values\nAssert.assertEquals(new HashSet<ConfigId>(Arrays.asList(tromboneId, hcdId, fits1Id, fits2Id, testId)),\n    adminApi.list().get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));\n\n//retrieve list of files based on type; for demonstration purpose validate return values\nAssert.assertEquals(new HashSet<>(Arrays.asList(tromboneId, fits1Id, testId)),\n    adminApi.list(JFileType.Annex).get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));\nAssert.assertEquals(new HashSet<>(Arrays.asList(hcdId, fits2Id)),\n    adminApi.list(JFileType.Normal).get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));\n\n//retrieve list using pattern; for demonstration purpose validate return values\nAssert.assertEquals(new HashSet<>(Arrays.asList(tromboneId, hcdId, testId)),\n    adminApi.list(\".*.conf\").get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));\n//retrieve list using pattern and file type; for demonstration purpose validate return values\nAssert.assertEquals(new HashSet<>(Arrays.asList(tromboneId, testId)),\n    adminApi.list(JFileType.Annex, \".*.conf\").get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));\nAssert.assertEquals(new HashSet<>(Arrays.asList(tromboneId)),\n    adminApi.list(JFileType.Annex, \"a/c.*\").get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));\nAssert.assertEquals(new HashSet<>(Arrays.asList(testId)),\n    adminApi.list(JFileType.Annex, \"test.*\").get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));","title":"list"},{"location":"/services/config.html#history","text":"Returns the history of revisions of the file at the given path for a range of period specified by from and to. The size of the list can be restricted using maxResults. Returns the history of active revisions of the file at the given path for a range of period specified by from and to. The size of the list can be restricted using maxResults.\nScala val assertionF = async {\n  val filePath = Paths.get(\"/a/test.conf\")\n  val id0      = await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"first commit\"))\n\n  //override the contents twice\n  val tBeginUpdate = Instant.now()\n  val id1          = await(adminApi.update(filePath, ConfigData.fromString(\"changing contents\"), \"second commit\"))\n  val id2          = await(adminApi.update(filePath, ConfigData.fromString(\"changing contents again\"), \"third commit\"))\n  val tEndUpdate   = Instant.now()\n\n  //full file history\n  val fullHistory = await(adminApi.history(filePath))\n  fullHistory.map(_.id) shouldBe List(id2, id1, id0)\n  fullHistory.map(_.comment) shouldBe List(\"third commit\", \"second commit\", \"first commit\")\n\n  //drop initial revision and take only update revisions\n  await(adminApi.history(filePath, tBeginUpdate, tEndUpdate)).map(_.id) shouldBe List(id2, id1)\n\n  //take last two revisions\n  await(adminApi.history(filePath, maxResults = 2)).map(_.id) shouldBe List(id2, id1)\n}\nAwait.result(assertionF, 3.seconds) Java Path filePath = Paths.get(\"/a/test.conf\");\nConfigId id0 = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"first commit\").get();\n\n//override the contents twice\nInstant tBeginUpdate = Instant.now();\nConfigId id1 = adminApi.update(filePath, ConfigData.fromString(\"changing contents\"), \"second commit\").get();\nConfigId id2 = adminApi.update(filePath, ConfigData.fromString(\"changing contents again\"), \"third commit\").get();\nInstant tEndUpdate = Instant.now();\n\n//full file history\nList<ConfigFileRevision> fullHistory = adminApi.history(filePath).get();\nAssert.assertEquals(new ArrayList<>(Arrays.asList(id2, id1, id0)),\n    fullHistory.stream().map(ConfigFileRevision::id).collect(Collectors.toList()));\nAssert.assertEquals(new ArrayList<>(Arrays.asList(\"third commit\", \"second commit\", \"first commit\")),\n    fullHistory.stream().map(ConfigFileRevision::comment).collect(Collectors.toList()));\n\n//drop initial revision and take only update revisions\nAssert.assertEquals(new ArrayList<>(Arrays.asList(id2, id1)),\n    adminApi.history(filePath, tBeginUpdate, tEndUpdate).get().stream().map(ConfigFileRevision::id).collect(Collectors.toList()));\n//take last two revisions\nAssert.assertEquals(new ArrayList<>(Arrays.asList(id2, id1)),\n    adminApi.history(filePath, 2).get().stream().map(ConfigFileRevision::id).collect(Collectors.toList()));","title":"history"},{"location":"/services/config.html#managing-active-versions","text":"Following API functions are available to manage the active version of a config file. In its lifetime a config file undergoes many revisions. An active version is a specific revision from a file’s history and it is set by administrators.\nhistoryActive : Returns the history of active revisions of the file at the given path for a range of period specified by from and to. The size of the list can be restricted using maxResults. setActiveVersion : Sets the “active version” to be the version provided for the file at the given path. If this method is never called in a config’s lifetime, the active version will always be the version returned by create function. resetActiveVersion : Resets the “active version” of the file at the given path to the latest version. getActiveVersion : Returns the revision Id which represents the “active version” of the file at the given path. getActiveByTime : Returns the content of active version of the file existed at given instant\nScala val assertionF = async {\n  val tBegin   = Instant.now()\n  val filePath = Paths.get(\"/a/test.conf\")\n  //create will make the 1st revision active with a default comment\n  val id1 = await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"first\"))\n  await(adminApi.historyActive(filePath)).map(_.id) shouldBe List(id1)\n  //ensure active version is set\n  await(adminApi.getActiveVersion(filePath)).get shouldBe id1\n\n  //override the contents four times\n  await(adminApi.update(filePath, ConfigData.fromString(\"changing contents\"), \"second\"))\n  val id3 = await(adminApi.update(filePath, ConfigData.fromString(\"changing contents again\"), \"third\"))\n  val id4 = await(adminApi.update(filePath, ConfigData.fromString(\"final contents\"), \"fourth\"))\n  val id5 = await(adminApi.update(filePath, ConfigData.fromString(\"final final contents\"), \"fifth\"))\n\n  //update doesn't change the active revision\n  await(adminApi.historyActive(filePath)).map(_.id) shouldBe List(id1)\n\n  //play with active version\n  await(adminApi.setActiveVersion(filePath, id3, s\"$id3 active\"))\n  await(adminApi.setActiveVersion(filePath, id4, s\"$id4 active\"))\n  await(adminApi.getActiveVersion(filePath)).get shouldBe id4\n  val tEnd = Instant.now()\n  //reset active version to latest\n  await(adminApi.resetActiveVersion(filePath, \"latest active\"))\n  await(adminApi.getActiveVersion(filePath)).get shouldBe id5\n  //finally set initial version as active\n  await(adminApi.setActiveVersion(filePath, id1, s\"$id1 active\"))\n  await(adminApi.getActiveVersion(filePath)).get shouldBe id1\n\n  //validate full history\n  val fullHistory = await(adminApi.historyActive(filePath))\n  fullHistory.map(_.id) shouldBe List(id1, id5, id4, id3, id1)\n  fullHistory.map(_.comment) shouldBe List(s\"$id1 active\",\n                                           \"latest active\",\n                                           s\"$id4 active\",\n                                           s\"$id3 active\",\n                                           \"initializing active file with the first version\")\n\n  //drop initial revision and take only update revisions\n  val fragmentedHistory = await(adminApi.historyActive(filePath, tBegin, tEnd))\n  fragmentedHistory.size shouldBe 3\n\n  //take last three revisions\n  await(adminApi.historyActive(filePath, maxResults = 3)).map(_.id) shouldBe List(id1, id5, id4)\n\n  //get contents of active version at a specified instance\n  val initialContents = await(adminApi.getActiveByTime(filePath, tBegin)).get\n  await(initialContents.toStringF(mat)) shouldBe defaultStrConf\n}\nAwait.result(assertionF, 5.seconds) Java Instant tBegin = Instant.now();\nPath filePath = Paths.get(\"/a/test.conf\");\n\n//create will make the 1st revision active with a default comment\nConfigId id1 = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"first commit\").get();\nAssert.assertEquals(new ArrayList<>(Arrays.asList(id1)),\n    adminApi.historyActive(filePath).get().stream().map(ConfigFileRevision::id).collect(Collectors.toList()));\n//ensure active version is set\nAssert.assertEquals(id1, adminApi.getActiveVersion(filePath).get().get());\n\n//override the contents four times\nadminApi.update(filePath, ConfigData.fromString(\"changing contents\"), \"second\").get();\nConfigId id3 = adminApi.update(filePath, ConfigData.fromString(\"changing contents again\"), \"third\").get();\nConfigId id4 = adminApi.update(filePath, ConfigData.fromString(\"final contents\"), \"fourth\").get();\nConfigId id5 = adminApi.update(filePath, ConfigData.fromString(\"final final contents\"), \"fifth\").get();\n\n//update doesn't change the active revision\nAssert.assertEquals(id1, adminApi.getActiveVersion(filePath).get().get());\n\n//play with active version\nadminApi.setActiveVersion(filePath, id3, \"id3 active\").get();\nadminApi.setActiveVersion(filePath, id4, \"id4 active\").get();\nAssert.assertEquals(id4, adminApi.getActiveVersion(filePath).get().get());\nInstant tEnd = Instant.now();\n\n//reset active version to latest\nadminApi.resetActiveVersion(filePath, \"latest active\").get();\nAssert.assertEquals(id5, adminApi.getActiveVersion(filePath).get().get());\n//finally set initial version as active\nadminApi.setActiveVersion(filePath, id1, \"id1 active\").get();\nAssert.assertEquals(id1, adminApi.getActiveVersion(filePath).get().get());\n\n//validate full history\nList<ConfigFileRevision> fullHistory = adminApi.historyActive(filePath).get();\nAssert.assertEquals(new ArrayList<>(Arrays.asList(id1, id5, id4, id3, id1)),\n        fullHistory.stream().map(ConfigFileRevision::id).collect(Collectors.toList()));\nAssert.assertEquals(new ArrayList<>(Arrays.asList(\"id1 active\", \"latest active\", \"id4 active\", \"id3 active\",\n        \"initializing active file with the first version\")),\n        fullHistory.stream().map(ConfigFileRevision::comment).collect(Collectors.toList()));\n\n//drop initial revision and take only update revisions\nList<ConfigFileRevision> fragmentedHistory = adminApi.historyActive(filePath, tBegin, tEnd).get();\nAssert.assertEquals(3, fragmentedHistory.size());\n\n//take last three revisions\nAssert.assertEquals(new ArrayList<>(Arrays.asList(id1, id5, id4)),\n        adminApi.historyActive(filePath, 3).get().stream().map(ConfigFileRevision::id).collect(Collectors.toList()));\n\n//get contents of active version at a specified instance\nString initialContents = adminApi.getActiveByTime(filePath, tBegin).get().get().toJStringF(mat).get();\nAssert.assertEquals(defaultStrConf, initialContents);","title":"Managing active versions"},{"location":"/services/config.html#getmetadata","text":"Used to get metadata information about config service. It includes:\nrepository directory annex directory min annex file size max config file size\nScala val assertF = async {\n  val metaData: ConfigMetadata = await(adminApi.getMetadata)\n  //repository path must not be empty\n  metaData.repoPath should not be empty\n}\nAwait.result(assertF, 2.seconds) Java ConfigMetadata metadata = adminApi.getMetadata().get();\n//repository path must not be empty\nAssert.assertNotEquals(metadata.repoPath(), \"\");","title":"getMetaData"},{"location":"/services/config.html#admin-protected-routes","text":"Following config server routes are Admin Protected. To use these routes, you need to get yourself authenticated and authorized.\ncreate update delete setActiveVersion resetActiveVersion\ncsw-config-client provides factory to create admin config service which allows you to access these protected routes. This requires you to implement TokenFactory interface. Currently csw-config-cli is the only user of config service admin api. You can refer CliTokenFactory which implements TokenFactory interface.\nNote Refer csw-aas docs to know more about how you can authenticate and authorize with auth server and get access token.","title":"Admin Protected Routes"},{"location":"/services/config.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source code for examples"},{"location":"/services/logging.html","text":"","title":"Logging Service"},{"location":"/services/logging.html#logging-service","text":"The Logging Service library provides an advanced logging facility for csw components and services.\nNote With this release of CSW, only the local logging is provided. A future release will provide the centralized logging facility.","title":"Logging Service"},{"location":"/services/logging.html#dependencies","text":"To use the Logging Service without using the framework, add this to your build.sbt file:\nsbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-logging-client\" % \"0.1-SNAPSHOT\"","title":"Dependencies"},{"location":"/services/logging.html#configuration","text":"These are the relevant default configuration values for logging\nlogging.conf csw-logging {\n\n    # Default appender and is recommended only for dev setup.\n    # To use multiple appenders give comma separated list of appenders.\n    appenders = [\"csw.logging.client.appenders.StdOutAppender$\"]\n\n    # Recommended for production setup - Uncomment below line and comment above to enable FileAppender\n    #appenders = [\"csw.logging.client.appenders.FileAppender$\"]\n\n    component-log-levels {\n      # By default each compoent will use log level specified by `csw-logging.logLevel`. If required, this block allows\n      # overriding log level configuration for one/more components.\n      # -- Example --\n      # TromboneHcd = debug\n      # TromboneAssembly = error\n    }\n\n    appender-config {\n      file {\n        # Include standard headers\n        fullHeaders = true\n        # Sort the fields in Json objects\n        sorted = true\n        # Directory to hold log files.\n        logPath = \"/tmp/\"\n        # Common log messages below this level are removed, none removed when set to trace\n        logLevelLimit = trace\n        # Flag to turn file rotation ON or OFF. Currently log file is rotated daily at 12:00 pm UTC time. By turning this flag off\n        # file rotation will not happen.\n        rotate = true\n      }\n      stdout {\n        # Include standard headers\n        fullHeaders = false\n        # Use colors for log levels\n        color = true\n        # The maximum number of character that should be on a line\n        # This is only a goal; in practice some may contain more characters.\n        width = 80\n        # Print summary counts when logger is closed\n        summary = true\n        # pretty output - multiple line json\n        pretty = false\n        # Messages below this level are removed, none removed when set to trace\n        logLevelLimit = trace\n        # false Json output; true simple one line text output\n        oneLine = false\n      }\n    }\n    # If component does not specify their log level in component-log-levels block,\n    # Then this will be considered as default log level for that component.\n    logLevel = info\n    # Log level for slf4j messages\n    slf4jLogLevel = info\n    # Log level for Akka messages\n    akkaLogLevel = warn\n    # Enable timing logging\n    time = false\n    # Enable garbage collection logging\n    gc = false\n}\nIMPORTANT !!! It is required to include logging.conf that is shipped with this library in application.conf as follows: include \"logging.conf\"\n Default configuration values can be then overridden in application.conf.\nAlso logLevel for each component can be set in application.conf as follows:\ncomponent-log-levels {\n    tromboneHcd = debug\n    tromboneAssembly = error\n  }\nNote Here tromboneHcd and tromboneAssembly is the name of component that will be registered with LocationService, which is the name field in the ComponentInfo file (see DeployingComponents). By default, all components will log at level specified by csw-logging.logLevel.\nThe library provides StdOutAppender as default logging appender. To use FileAppender or some custom appender along-with StdOutAppender, override appenders property to include multiple appender in csv format as follows:\nappenders = [\"csw.logging.client.appenders.FileAppender$\", \"csw.logging.client.appenders.StdOutAppender$\"]\nNote Make sure to provide full path of the appender since it will be spawned using java reflection. In csw code base, a working example of custom appender can be found at: Custom Appender\nFor StdOutAppender specify the format of log statements in csw-logging.stdout via csw-logging.stdout.pretty and csw-logging.stdout.oneLine.\nTurning pretty on or off will produce log statements in following format:\npretty=true {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"LocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"@version\":\"0.1\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53618/user/$a\",\n \"class\":\"csw.location.LocationServiceExampleClient\",\n \"file\":\"LocationServiceExampleClientApp.scala\",\n \"line\":149,\n \"message\":\"Result of the find call: None\",\n \"timestamp\":\"2017-11-30T10:58:03.102Z\"\n }\n pretty=false {\"@componentName\":\"my-component-name\",\"@host\":\"INsaloni.local\",\"@name\":\"LocationServiceExampleClient\",\"@severity\":\"INFO\",\"@version\":\"0.1\",\"actor\":\"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53618/user/$a\",\"class\":\"csw.location.LocationServiceExampleClient\",\"file\":\"LocationServiceExampleClientApp.scala\",\"line\":149,\"message\":\"Result of the find call: None\",\"timestamp\":\"2017-11-24T04:16:42.108Z\"}\nSimilarly, turning oneLine on will produce log statements in following format:\noneLine=true [INFO] Attempting to find connection (LocationServiceExampleClientApp.scala 131)\nNote If oneLine is set to true then value of pretty will be ignored","title":"Configuration"},{"location":"/services/logging.html#log-levels","text":"Following Log levels are supported by csw-logging library\nFATAL ERROR WARN INFO DEBUG TRACE\nThe library allows separate log levels for the logging API(logLevel), Akka logging(akkaLogLevel), and Slf4J(slf4jLogLevel). The initial values of these are set in the configuration file as seen above. These can be overriden in the application.conf file.\nThese values can also be changed dynamically by calling methods on LoggingSystem class.","title":"Log Levels"},{"location":"/services/logging.html#log-structure","text":"All messages are logged by default as Json. Logs can contain following fields:\n@componentName: The name of the component if present @host: The local host name @name: The name of the application being run @version: The version of the application being run @severity: The message level: trace, debug, info, warn, error or fatal actor: The path for an actor when using ActorLogging class: The class for ClassLogging or ActorLogging file: The file containing the log call kind: Either slf4j or akka. Not present for logger API line: The line where the message was logged message: The log message timestamp: The UTC time when the message was logged trace: Information for any exception specified in the logging call\nNote @host, @name and @version will appear in log statements only if fullHeaders is set as true in the configuration file and line will appear only in log statements from Scala classes/actors. This is typical for Java logging tools, and is due to the lack of macro support in Java.","title":"Log Structure"},{"location":"/services/logging.html#enable-component-logging","text":"Component developers will have an instance of LoggerFactory available from csw-framework. This instance will already have a componentName set by csw-framework which will appear in log statements against @componentName tag. Next, to get the Logger from LoggerFactory use one of the following ways:\nScala Class class SampleClass(loggerFactory: LoggerFactory) {\n\n  val log: Logger = loggerFactory.getLogger\n} Java Class public class JSampleClass {\n\n    public JSampleClass(JLoggerFactory loggerFactory) {\n        ILogger log = loggerFactory.getLogger(getClass());\n    }\n}\nScala Actor class SampleActor(loggerFactory: LoggerFactory) extends akka.actor.Actor {\n\n  //context is available from akka.actor.Actor\n  val log: Logger = loggerFactory.getLogger(context)\n\n  override def receive = ???\n} Java Actor class JSampleActor extends akka.actor.AbstractActor {\n\n    public JSampleActor(JLoggerFactory loggerFactory) {\n\n        //context() is available from akka.actor.AbstractActor\n        ILogger log = loggerFactory.getLogger(context(), getClass());\n    }\n\n    @Override\n    public Receive createReceive() {\n        return null;\n    }\n}\nScala Typed Actor class SampleTypedActor(loggerFactory: LoggerFactory, ctx: ActorContext[ComponentMessage]) {\n\n  val log: Logger = loggerFactory.getLogger(ctx)\n} Java Typed Actor class JSampleTypedActor {\n\n    public JSampleTypedActor(JLoggerFactory loggerFactory, ActorContext<ComponentMessage> ctx) {\n        ILogger log = loggerFactory.getLogger(ctx, getClass());\n    }\n}\nNote The LoggerFactory can be changed to JLoggerFactory by using asJava method and JLoggerFactory can be changed to LoggerFactory by using asScala method","title":"Enable Component Logging"},{"location":"/services/logging.html#enable-generic-logging","text":"In case there is a need to log statements without @componentName tag, which can be due to unavailability of componentName in some utility code, then use the GenericLoggerFactory as follows:\nScala Class class GenericClass {\n\n  val log: Logger = GenericLoggerFactory.getLogger\n} Java Class public class JGenericClass {\n\n    ILogger log = JGenericLoggerFactory.getLogger(getClass());\n}\nScala Actor class GenericActor extends akka.actor.AbstractActor {\n\n  //context is available from akka.actor.Actor\n  val log: Logger = GenericLoggerFactory.getLogger(context)\n\n  override def createReceive() = ???\n} Java Actor class JGenericActor extends akka.actor.AbstractActor {\n\n    //context() is available from akka.actor.AbstractActor\n    ILogger log = JGenericLoggerFactory.getLogger(context(), getClass());\n\n    @Override\n    public Receive createReceive() {\n        return null;\n    }\n}\nScala Typed Actor class GenericTypedActor(ctx: ActorContext[ComponentMessage]) {\n\n  val log: Logger = GenericLoggerFactory.getLogger(ctx)\n} Java Typed Actor class JGenericTypedActor {\n\n    public JGenericTypedActor(ActorContext<ComponentMessage> ctx) {\n        ILogger log = JGenericLoggerFactory.getLogger(ctx, getClass());\n    }\n}\nlog variable is now available in scala and java classes to write log statements as explained in next segment.","title":"Enable Generic Logging"},{"location":"/services/logging.html#log-statements","text":"Logging statements are used very much like existing logging services such as log4j. For Java, there is an additional way of writing log messages using Supplier methods (lambdas). The use of lambdas is more efficient since the computations in a message (e.g. string concatenation) are not performed unless the message is actually being logged. Therefore, these supplier methods should be used in cases where high performance is required (see performance results below).\nA basic info statement can be written as follows:\nScala log.info(s\"Result of the find call: $findResult\") Java log.info(\"Find result: \" + connectionInfo(findResult.get().connection())); Java (Supplier) log.info(() -> \"Resolve result: \" + connectionInfo(resolveResult.get().connection()));\nThe output of log statement will be:\nScala {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"LocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"@version\":\"0.1\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53618/user/$a\",\n \"class\":\"csw.location.LocationServiceExampleClient\",\n \"file\":\"LocationServiceExampleClientApp.scala\",\n \"line\":149,\n \"message\":\"Result of the find call: None\",\n \"timestamp\":\"2017-11-30T10:58:03.102Z\"\n }\n Java {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"JLocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"@version\":\"0.1\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53625/user/LocationServiceExampleClient\",\n \"class\":\"csw.location.JLocationServiceExampleClient\",\n \"message\":\"Result of the find call : None\",\n \"timestamp\":\"2017-11-30T11:02:54.691Z\"\n}\n Java (Supplier) {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"JLocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53625/user/LocationServiceExampleClient\",\n \"class\":\"csw.location.JLocationServiceExampleClient\",\n \"message\":\n   \"Resolve result: LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\",\n \"timestamp\":\"2017-07-26T19:44:58.636Z\"\n}\nThe library allows usage of Map in message as follows:\nScala log.info(s\"Attempting to find $exampleConnection\",\n         Map(Keys.OBS_ID → \"foo_obs_id\", \"exampleConnection\" → exampleConnection.name)) Java log.info(\"Attempting to find \" + exampleConnection,\n        new HashMap<String, Object>() {{\n            put(JKeys.OBS_ID, \"foo_obs_id\");\n            put(\"exampleConnection\", exampleConnection.name());\n        }}); Java (Supplier) log.info(() -> \"Attempting to resolve \" + exampleConnection + \" with a wait of \" + waitForResolveLimit + \"...\", () -> {\n    Map<String, Object> map = new HashMap<>();\n    map.put(JKeys.OBS_ID, \"foo_obs_id\");\n    map.put(\"exampleConnection\", exampleConnection.name());\n    return map;\n});\nThe output of log statement will be:\nScala {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"LocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"@version\":\"0.1\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53618/user/$a\",\n \"class\":\"csw.location.LocationServiceExampleClient\",\n \"exampleConnection\":\"LocationServiceExampleComponent-assembly-akka\",\n \"file\":\"LocationServiceExampleClientApp.scala\",\n \"line\":143,\n \"message\":\n   \"Attempting to find AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))\",\n \"obsId\":\"foo_obs_id\",\n \"timestamp\":\"2017-11-30T10:58:03.097Z\"\n}\n Java {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"JLocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"@version\":\"0.1\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53625/user/LocationServiceExampleClient\",\n \"class\":\"csw.location.JLocationServiceExampleClient\",\n \"exampleConnection\":\"LocationServiceExampleComponent-assembly-akka\",\n \"message\":\n   \"Attempting to find AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))\",\n \"obsId\":\"foo_obs_id\",\n \"timestamp\":\"2017-11-30T11:02:54.686Z\"\n}\n Java (Supplier) {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"JLocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"@version\":\"0.1\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53625/user/LocationServiceExampleClient\",\n \"class\":\"csw.location.JLocationServiceExampleClient\",\n \"exampleConnection\":\"LocationServiceExampleComponent-assembly-akka\",\n \"message\":\n   \"Attempting to resolve AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly)) with a wait of 30 seconds...\",\n \"obsId\":\"foo_obs_id\",\n \"timestamp\":\"2017-11-24T04:22:02.589Z\"\n}\nThe library allows you to log an error with its full stacktrace as follows:\nScala val runtimeException = new RuntimeException(s\"Received unexpected message $x\")\nlog.error(runtimeException.getMessage, ex = runtimeException) Java } catch (InterruptedException | ExecutionException ex) {\n    log.info(ex.getMessage(), ex);\n    throw ex;\n} Java (Supplier) RuntimeException runtimeException = new RuntimeException(\"Received unexpected message \" + x);\nlog.info(() -> runtimeException.getMessage(), runtimeException);","title":"Log Statements"},{"location":"/services/logging.html#create-loggerfactory","text":"Note This functionality is included in the framework code and users should not have to implement it themselves. Documentation is included for testing or further understanding.\nIn order to create a LoggerFactory with a custom componentName refer the following code:\nScala val loggerFactory: LoggerFactory = new LoggerFactory(\"my-component-name\")\n\n// convert a scala LoggerFactory to java JLoggerFactory\nval jLoggerFactory: JLoggerFactory = loggerFactory.asJava Java JLoggerFactory jLoggerFactory = new JLoggerFactory(\"my-component-name\");\n\n// convert a java JLoggerFactory to scala LoggerFactory\nLoggerFactory loggerFactory = jLoggerFactory.asScala();","title":"Create LoggerFactory"},{"location":"/services/logging.html#create-loggingsystem","text":"Note This functionality is included in the framework code and users should not have to implement it themselves. Documentation is included for testing or further understanding.\nFor logging statements to appear in the program, start LoggingSystem at an earliest location in an application. Also note, LoggingSystem should be started only once in an application. The name used while creating LoggingSystem will be used to create the folder and dump all logging files.\nScala private val host = InetAddress.getLocalHost.getHostName\n// Only call this once per application\nval loggingSystem: LoggingSystem = LoggingSystemFactory.start(\"LocationServiceExampleClient\", \"0.1\", host, actorSystem) Java String host = InetAddress.getLocalHost().getHostName();\nloggingSystem = JLoggingSystemFactory.start(\"JLocationServiceExampleClient\", \"0.1\", host, actorSystem);\nNote The hostname that is provided while creating LoggingSystem will appear in log statements against @host tag","title":"Create LoggingSystem"},{"location":"/services/logging.html#stop-loggingsystem","text":"Note This functionality is included in the framework code and users should not have to implement it themselves. Documentation is included for testing or further understanding.\nPlease ensure to stop LoggingSystem before application exits.\nScala // Only call this once per application\nAwait.result(loggingSystem.stop, 30.seconds) Java // Only call this once per application\nloggingSystem.javaStop().get();","title":"Stop LoggingSystem"},{"location":"/services/logging.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source code for examples"},{"location":"/services/logging.html#performance","text":"Performance results documented on this page is measured in terms of Throughput and obtained with the JMH Java benchmark harness. Sourcecode for all the JMH benchmarks can be found here at CSW Benchmarks\nWikipedia definition of Throughput is the maximum rate of production or the maximum rate at which something can be processed. In our case, throughput is defined as how many messages can be logged in a certain period of time.","title":"Performance"},{"location":"/services/logging.html#test-machine-configuration-","text":"MacBook Pro (Retina, 15-inch, Mid 2015) Processor Name: Intel Core i7 Processor Speed: 2.8 GHz No. of Processors: 1 No. of Cores: 4 L2 Cache (per Core): 256 KB L3 Cache: 6 MB Memory: 16 GB 1600 MHz DDR3 JDK: 1.8.0_121","title":"Test Machine Configuration :"},{"location":"/services/logging.html#scala-logging-appenders-throughput","text":"Above graph includes the throughput results for File and StdOut appender’s using scala’s logging API. Java’s logging API throughput results are included further down this page. As shown in the above graph, experiment was carried out for 1, 2, 4, 8 and 16 threads. That means, multiple threads are logging messages concurrently.\nNote Numbers indicated in the graph does not mean that those number of messages are actually written to file or console. These are the number of logging messages sent to LogActor asynchronously for the period of one second. It is the responsibility of LogActor to write these messages to file or console. LogActor uses BoundedMailbox with a mailbox-capacity = 262144, messages are dropped if mailbox gets full.","title":"Scala Logging : Appender’s Throughput"},{"location":"/services/logging.html#scala-and-java-logging-throughput-comparision-log-level-enabled-vs-disabled-","text":"Below graph depicts the throughput of Java’s logging API (String and Supplier) and scala’s logging API when log level was enabled and disabled.\nNote Log Level Enabled : Results are obtained for log.info when default log level was set to info, that means the logging messages were sent to LogActor for writing it to file. Log Level Disabled : Results are obtained for log.trace when default log level was set to info, that means the logging messages were not written to file.\nThis graph is produced based on the result generated by JE2ELoggingBenchmark and E2ELoggingBenchmark\nNote As you can see in the above graph, Supplier version of Java log API and by name of scala API is very efficient and throughput is much higher than String version. It is recommended to use Supplier API by java developers.","title":"Scala And Java Logging : Throughput Comparision (Log Level Enabled vs Disabled)"},{"location":"/services/logging.html#acknowledgement","text":"The codebase in csw-logging module is based on persist-logging library. We appreciate efforts put in by authors of the persist-logging library which made our development fast and easy.","title":"Acknowledgement"},{"location":"/services/event.html","text":"","title":"Event Service"},{"location":"/services/event.html#event-service","text":"The Event Service implements the publish/subscribe messaging paradigm where one component publishes an event and all components that have subscribed receive the event. In CSW, the events published are described under the messages documentation here. One advantage of this type of message system and Event Service also is that publishers and subscribers are decoupled. This decoupling of publishers and subscribers can allow for greater scalability and a more dynamic network topology. Publishers can publish regardless of whether there are subscribers, and subscribers can subscribe even if there are no publishers. The relationship between publishers and subscribers can be one-to-one, one-to-many, many to one, or even many-to-many.\nEvent Service is optimized for the high performance requirements of events as demands with varying rates, for ex. 100 Hz, 50 Hz etc., but can also be used with events that are published infrequently or when values change. In the TMT control system, events may be created as the output of a calculation by one component for the input to a calculation in one or more other components. Demand events often consist of events that are published at a specific rate.\nThe Event Service provides an API that allows events to be published and also allows clients to subscribe and unsubscribe to specific events and call developer code when events are received.\nEvent Service also stores the most recent published event for every unique event by prefix and name. This is useful for publishing components when an event contains state information that changes. Other components needing to check the state can do so without the overhead of subscribing.","title":"Event Service"},{"location":"/services/event.html#dependencies","text":"If you already have a dependency on csw-framework in your build.sbt, then you can skip this as csw-framework depends on csw-event-client Otherwise add below dependency in your build.sbt\nsbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-event-client\" % \"0.1-SNAPSHOT\"","title":"Dependencies"},{"location":"/services/event.html#accessing-event-service","text":"When you create component handlers using csw-framework as explained here, you get a handle to EventService which is created by csw-framework\nUsing EventService you can start publishing or subscribing to events. EventService is injected in component handlers via csw-framwework and provides the following features:\nAccess to defaultPublisher: Using defaultPublisher in EventService, you can publish a single event or a stream of demand events to Event Service. In most cases, you should use defaultPublisher, because you can then pass the instance of EventService in worker actors or different places in your code and call eventService.defaultPublisher to access publisher. Each EventPublisher has its own TCP connection to the Event Service. When you reuse the defaultPublisher instance of EventPublisher, all events published go through same TCP connection.\nAccess to defaultSubscriber: Using defaultSubscriber, you can subscribe to specific event keys. You can share defaultSubscriber in the same way as defaultPublisher by passing an instance of EventService to different parts of your code. Unlike defaultPublisher, each subscription with defaultSubscriber.subscribe creates a new TCP connection for just that subscription. This behavior is the same whether you use defaultSubscriber or makeNewSubscriber call on EventService.\nEach EventSubscriber also has one TCP connection that is used to provide the latest event from the event server when subscribing and also for the explicit get calls. That means, with defaultSubscriber, you are sharing same connection for getting latest events and creating a new connection for each subscribe call. The underlying event server can handle many connections, but it is good to understand how connections are used and reused.\nCreating a new Publisher or Subscriber: The makeNewPublisher API of Event Service can be used to create a new publisher which would internally create a new TCP connection to the Event Store. One of the use cases of this API could be to publish high frequency event streams in order to dedicate a separate connection to demanding streams without affecting the performance of all other low frequency (for ex. 1Hz, 20Hz etc.) event streams.\nHowever, makeNewSubscriber API does not really have any specific use cases. Both defaultSubscriber and makeNewSubscriber APIs behave almost similar since the subscribe API of EventService itself creates a new connection for every subscription. Prefer using defaultSubscriber over makeNewSubscriber.","title":"Accessing Event Service"},{"location":"/services/event.html#usage-of-eventpublisher","text":"Below examples demonstrate the usage of multiple variations of publish API.","title":"Usage of EventPublisher"},{"location":"/services/event.html#for-single-event","text":"This is the simplest API to publish a single event. It returns a Future which will complete successfully if the event is published or fail immediately with a PublishFailure exception if the component cannot publish the event.\nScala {\n  val publisher = eventService.defaultPublisher\n  val event     = SystemEvent(componentInfo.prefix, EventName(\"filter_wheel\"))\n  publisher.publish(event)\n} Java Event event = new SystemEvent(componentInfo.prefix(), new EventName(\"filter_wheel\"));\neventService.defaultPublisher().publish(event);","title":"For Single Event"},{"location":"/services/event.html#with-generator","text":"A generator is useful when component code needs to publish events with a specific frequency. The following example demonstrates the usage of publish API with event generator which will publish one event at each interval. eventGenerator is a function responsible for generating events. It can hold domain specific logic of generating new events based on certain conditions.\nScala {\n  val publisher        = eventService.defaultPublisher\n  val baseEvent: Event = SystemEvent(componentInfo.prefix, EventName(\"filter_wheel\"))\n  val interval         = 100.millis\n\n  // this holds the logic for event generation, could be based on some computation or current state of HCD\n  def eventGenerator(): Event = baseEvent match {\n    case e: SystemEvent  ⇒ e.copy(eventId = Id(), eventTime = UTCTime.now())\n    case e: ObserveEvent ⇒ e.copy(eventId = Id(), eventTime = UTCTime.now())\n  }\n\n  publisher.publish(eventGenerator(), interval)\n} Java private Cancellable startPublishingEvents(ComponentInfo componentInfo) {\n    Event baseEvent = new SystemEvent(componentInfo.prefix(), new EventName(\"filter_wheel\"));\n    return eventService.defaultPublisher().publish(() -> eventGenerator(baseEvent), Duration.ofMillis(100));\n}\n\n// this holds the logic for event generation, could be based on some computation or current state of HCD\nprivate Event eventGenerator(Event baseEvent) {\n    // add logic here to create a new event and return the same\n    return baseEvent;\n}","title":"With Generator"},{"location":"/services/event.html#with-event-stream","text":"In order to publish a continuous stream of events, this stream-based API can also be used. If an infinite stream is provided, shutdown of the stream needs to be taken care by the users. (Note that streams discussed here are an Akka feature that is supported in event publisher and subscriber APIs. See Akka stream documentation.)\nScala def onError(publishFailure: PublishFailure): Unit =\n  log.error(s\"Publish failed for event: [${publishFailure.event}]\", ex = publishFailure.cause)\n\nval publisher = eventService.defaultPublisher\nval eventStream: Source[Event, Future[Done]] = Source(1 to n)\n  .map(id ⇒ makeEvent(id, componentInfo.prefix, EventName(\"filter_wheel\")))\n  .watchTermination()(Keep.right)\n\npublisher.publish(eventStream, failure ⇒ onError(failure)) Java Source<Event, CompletionStage<Done>> eventStream = Source\n        .range(1, n)\n        .map(id -> makeEvent(id, componentInfo.prefix(), new EventName(\"filter_wheel\")))\n        .watchTermination(Keep.right());\n\nreturn eventService.defaultPublisher().<CompletionStage<Done>>publish(eventStream, failure -> { /*do something*/ });\nThis API also demonstrates the usage of onError callback which can be used to be alerted to and handle events that failed while being published. The eventGenerator API showed just above also demonstrates the use of the onError callback.\nYou can find complete list of APIs supported by EventPublisher and IEventPublisher with detailed description of each API here:\nEventPublisher IEventPublisher","title":"With Event Stream"},{"location":"/services/event.html#usage-of-eventsubscriber","text":"The EventSubscriber API has several options available that are useful in different situations. Examples below demonstrate the usage of multiple variations available in the subscribe API.","title":"Usage of EventSubscriber"},{"location":"/services/event.html#with-callback","text":"The example shown below takes a set of event keys to subscribe to and a callback function which will be called on each event received by the event stream. This is the simplest and most commonly used API. The example below uses an inline function, but that is not necessary.\nScala {\n  val subscriber = eventService.defaultSubscriber\n\n  subscriber.subscribeCallback(\n    Set(EventKey(hcd.prefix, EventName(\"filter_wheel\"))),\n    event ⇒ { /*do something*/ }\n  )\n} Java IEventSubscriber subscriber = eventService.defaultSubscriber();\n\nEventKey filterWheelEventKey = new EventKey(hcdLocation.prefix(), new EventName(\"filter_wheel\"));\nreturn subscriber.subscribeCallback(Collections.singleton(filterWheelEventKey), event -> { /*do something*/ });","title":"With Callback"},{"location":"/services/event.html#with-asynchronous-callback","text":"The above example will run into concurrency issues if the callback has an shared state or asynchronous behavior. To avoid that use the following API which will give the guarantee of ordered execution of these asynchronous callbacks. In this case, no further processing occurs until the Future completes.\nScala def subscribe(): EventSubscription = {\n  val subscriber = eventService.defaultSubscriber\n  subscriber.subscribeAsync(Set(EventKey(hcd.prefix, EventName(\"filter_wheel\"))), callback)\n}\n\nprivate def callback(event: Event): Future[String] = {\n  /* do something */\n  Future.successful(\"some value\")\n} Java public IEventSubscription subscribe() {\n    IEventSubscriber subscriber = eventService.defaultSubscriber();\n\n    EventKey filterWheelEventKey = new EventKey(hcdLocation.prefix(), new EventName(\"filter_wheel\"));\n    return subscriber.subscribeAsync(Collections.singleton(filterWheelEventKey), this::callback);\n}\n\nprivate CompletableFuture<String> callback(Event event) {\n    /* do something */\n    return CompletableFuture.completedFuture(\"some value\");\n}","title":"With Asynchronous Callback"},{"location":"/services/event.html#with-actorref","text":"If there is a need to mutate state on receiving each event, then it is recommended to use this API and send a message to an actor. To use this API, you have to create an actor which takes event and then you can safely keep mutable state inside this actor. In the example shown below, eventHandler is the actorRef which accepts events.\nScala def subscribe(ctx: ActorContext[TopLevelActorMessage]): EventSubscription = {\n  val subscriber                    = eventService.defaultSubscriber\n  val eventHandler: ActorRef[Event] = ctx.spawnAnonymous(EventHandler.make())\n\n  subscriber.subscribeActorRef(Set(EventKey(hcd.prefix, EventName(\"filter_wheel\"))), eventHandler)\n}\n\nobject EventHandler {\n  def make(): Behavior[Event] = Behaviors.setup(ctx ⇒ new EventHandler(ctx))\n}\n\nclass EventHandler(ctx: ActorContext[Event]) extends AbstractBehavior[Event] {\n  override def onMessage(msg: Event): Behavior[Event] = {\n    // handle messages\n    Behaviors.same\n  }\n} Java public IEventSubscription subscribe(ActorContext<TopLevelActorMessage> ctx) {\n\n    IEventSubscriber subscriber = eventService.defaultSubscriber();\n    ActorRef<Event> eventHandler = ctx.spawnAnonymous(new JEventHandlerFactory().make());\n\n    EventKey filterWheelEventKey = new EventKey(hcdLocation.prefix(), new EventName(\"filter_wheel\"));\n    return subscriber.subscribeActorRef(Collections.singleton(filterWheelEventKey), eventHandler);\n}\n\npublic class JEventHandlerFactory {\n    public Behavior<Event> make() {\n        return Behaviors.setup(JEventHandler::new);\n    }\n}\n\npublic class JEventHandler extends AbstractBehavior<Event> {\n    private ActorContext<Event> ctx;\n\n    JEventHandler(ActorContext<Event> context) {\n        ctx = context;\n    }\n\n    @Override\n    public Receive<Event> createReceive() {\n        // handle messages\n        return null;\n    }\n}","title":"With ActorRef"},{"location":"/services/event.html#receive-event-stream","text":"This API takes a set of Event keys to subscribe to and returns a Source of events (see Akka stream documentation). This API gives more control to the user to customize behavior of an event stream.\nScala {\n  val subscriber = eventService.defaultSubscriber\n\n  subscriber\n    .subscribe(Set(EventKey(hcd.prefix, EventName(\"filter_wheel\"))))\n    .to(Sink.foreach { event => /*do something*/\n    })\n    .run()\n} Java IEventSubscriber subscriber = eventService.defaultSubscriber();\n\nEventKey filterWheelEventKey = new EventKey(hcdLocation.prefix(), new EventName(\"filter_wheel\"));\nreturn subscriber.subscribe(Collections.singleton(filterWheelEventKey)).to(Sink.foreach(event -> { /*do something*/ })).run(mat);","title":"Receive Event Stream"},{"location":"/services/event.html#controlling-subscription-rate","text":"In all the examples shown above, events are received by the subscriber as soon as they are published. There will be scenarios where you would like to control the rate of events received by your code. For instance, slow subscribers can receive events at their own specified speed rather than being overloaded with events to catch up with the publisher’s speed.\nAll the APIs in EventSubscriber can be provided with interval and SubscriptionMode to control the subscription rate. Following example demonstrates this with the subscribeCallback API.\nScala {\n  val subscriber = eventService.defaultSubscriber\n\n  subscriber.subscribeCallback(\n    Set(EventKey(hcd.prefix, EventName(\"filter_wheel\"))),\n    event ⇒ { /*do something*/ },\n    1.seconds,\n    SubscriptionModes.RateAdapterMode\n  )\n} Java IEventSubscriber subscriber = eventService.defaultSubscriber();\n\nEventKey filterWheelEventKey = new EventKey(hcdLocation.prefix(), new EventName(\"filter_wheel\"));\nreturn subscriber.subscribeCallback(Collections.singleton(filterWheelEventKey), event -> { /* do something*/ }, Duration.ofMillis(1000), SubscriptionModes.jRateAdapterMode());\nThere are two types of Subscription modes:\nRateAdapterMode which ensures that an event is received exactly at each tick of the specified interval. RateLimiterMode which ensures that events are received as they are published along with the guarantee that no more than one event is delivered within a given interval.\nRead more about Subscription Mode here","title":"Controlling Subscription Rate"},{"location":"/services/event.html#pattern-subscription","text":"The following example demonstrates the usage of pattern subscribe API with callback. Events with keys that match the specified pattern and belong to the given subsystem are received by the subscriber. The callback function provided is called on each event received.\nScala {\n  val subscriber = eventService.defaultSubscriber\n  subscriber.pSubscribeCallback(subsystem, \"*\", event ⇒ { /*do something*/ })\n} Java IEventSubscriber subscriber = eventService.defaultSubscriber();\nsubscriber.pSubscribeCallback(subsystem, \"*\", event -> { /* do something*/ });\nWarning DO NOT include subsystem in the provided pattern. Final pattern generated will be provided pattern prepended with subsystem. For Ex. pSubscribe(Subsytem.WFOS, *) will subscribe to event keys matching pattern : wfos.*\nWarning The pattern-based subscribe API is provided because it is useful in testing, but should not be used in production code. The use of certain patterns and many pattern-based subscriptions can impact the overall-performance of the Event Service.","title":"Pattern Subscription"},{"location":"/services/event.html#event-subscription","text":"On subscription to event keys, you receive an EventSubscription which provides following APIs:\nunsubscribe: On un-subscribing, the event stream is destroyed and the connection created to event server while subscription is released. ready: check if event subscription is successful or not.\nYou can find complete list of API’s supported by EventSubscriber and IEventSubscriber with detailed description of each API here:\nEventSubscriber IEventSubscriber","title":"Event Subscription"},{"location":"/services/event.html#create-event-service","text":"If you are not using csw-framework, you can create EventService using EventServiceFactory.\nScala // create event service using location service\nval eventService1: EventService = new EventServiceFactory().make(locationService)\n\n// create event service using host and port of event server.\nval eventService2: EventService = new EventServiceFactory().make(\"localhost\", 26379) Java // create event service using host and port of event server.\nIEventService eventService1 = new EventServiceFactory().jMake(locationService, actorSystem);\n\n// create event service using host and port of event server.\nIEventService eventService2 = new EventServiceFactory().jMake(\"localhost\", 26379, actorSystem);\nThe provided implementation of Event Service is backed up by Redis. The above example demonstrates creation of Event Service with default Redis client options. You can optionally supply a RedisClient to the EventStore from outside which allows you to customize the behaviour of RedisClient used by Event Service, which in most often be required in test scope only.\nRedisClient is an expensive resource. Reuse this instance as much as possible.\nNote that it is the responsibility of consumer of this API to shutdown Redis Client when it is no longer in use.\nScala val clientOptions = ClientOptions.builder().disconnectedBehavior(DisconnectedBehavior.REJECT_COMMANDS).build\nval redisClient   = RedisClient.create()\nredisClient.setOptions(clientOptions)\n\n// create event service using location service\nval eventService1: EventService = new EventServiceFactory(RedisStore(redisClient)).make(locationService)\n\n// create event service using host and port of event server.\nval eventService2: EventService = new EventServiceFactory(RedisStore(redisClient)).make(\"localhost\", 26379) Java ClientOptions clientOptions = ClientOptions.builder().disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build();\nRedisClient redisClient   = RedisClient.create();\nredisClient.setOptions(clientOptions);\n\nEventStores.RedisStore redisStore = new EventStores.RedisStore(redisClient);\n// create event service using location service\nIEventService eventService1 = new EventServiceFactory(redisStore).jMake(locationService, actorSystem);\n\n// create event service using host and port of event server.\nIEventService eventService2 = new EventServiceFactory(redisStore).jMake(\"localhost\", 26379, actorSystem);","title":"Create Event Service"},{"location":"/services/event.html#source-code-for-examples-of-creation","text":"Scala Example Java Example","title":"Source code for examples of creation"},{"location":"/services/event.html#source-code-for-examples-of-publishing","text":"Scala Example Java Example","title":"Source code for examples of publishing"},{"location":"/services/event.html#source-code-for-examples-of-subscribing","text":"Scala Example Java Example","title":"Source code for examples of subscribing"},{"location":"/services/alarm.html","text":"","title":"Alarm Service"},{"location":"/services/alarm.html#alarm-service","text":"The Alarm Service provides API to manage alarms in the TMT software system. The service uses Redis to store Alarm data, including the alarm status and associated metadata. Alarm “keys” are used to access information about an alarm.","title":"Alarm Service"},{"location":"/services/alarm.html#dependencies","text":"The Alarm Service comes bundled with the Framework, no additional dependency needs to be added to your build.sbt file if using it. To use the Alarm service without using the framework, add this to your build.sbt file:\nsbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-alarm-client\" % \"0.1-SNAPSHOT\"","title":"Dependencies"},{"location":"/services/alarm.html#api-flavors","text":"There are two APIs provided in the Alarm Service: a client API, and an administrative (admin) API. The client API is the API used by component developers to set the severity of an alarm. This is the only functionality needed by component developers. As per TMT policy, the severity of an alarm must be set periodically (within some time limit) in order to maintain the integrity of the alarm status. If an alarm severity is not refreshed within the time limit, currently set at 9 seconds, the severity is set to Disconnected by the Alarm Service, which indicates to the operator that there is some problem with the component’s ability to evaluate the alarm status.\nThe admin API provides all of the functions needed manage the alarm store, as well as providing access to monitor alarms for use by an operator or instrument specialist. The admin API provides the ability to load alarm data into alarm store, set severity of an alarm, acknowledge alarms, shelve or unshelve alarms, reset a latched alarm, get the metadata/status/severity of an alarm, and get or subscribe to aggregations of severity and health of the alarm, a component’s alarms, a subsystem’s alarms, or the alarms of the whole TMT System.\nA command line tool is provided as part of the Alarm Service that implements this API can provides low level control over the Alarm Service. More details about alarm CLI can be found here: CSW Alarm Client CLI application\nEventually, operators will use Graphical User Interfaces that access the admin API through a UI gateway. This will be delivered as part of the ESW HCMS package.\nNote Since the admin API will primarily be used with the CLI and HCMS applications, it is only supported in Scala, and not Java.\nTo summarize, the APIs are as follows: * client API (AlarmService) : Must be used by component. Available method is : {setSeverity} * admin API (AlarmAdminService) : Expected to be used by administrator. Available methods are: {initAlarm | setSeverity | acknowledge | shelve | unshelve | reset | getMetaData | getStatus | getCurrentSeverity | getAggregatedSeverity | getAggregatedHealth | subscribeAggregatedSeverityCallback | subscribeAggregatedSeverityActorRef | subscribeAggregatedHealthCallback | subscribeAggregatedHealthActorRef }","title":"API Flavors"},{"location":"/services/alarm.html#creating-clientapi-and-adminapi","text":"For component developers, the client API is provided as an AlarmService object in the CswContext object injected into the ComponentHandlers class provided by the framework.\nIf you are not using csw-framework, you can create AlarmService using AlarmServiceFactory.\nScala // create alarm client using host and port of alarm server\nprivate val clientAPI1 = new AlarmServiceFactory().makeClientApi(\"localhost\", 5225)\n\n// create alarm client using location service\nprivate val clientAPI2 = new AlarmServiceFactory().makeClientApi(locationService)\n\n// create alarm admin using host and port of alarm server\nprivate val adminAPI1 = new AlarmServiceFactory().makeAdminApi(\"localhost\", 5226)\n\n// create alarm admin using location service\nprivate val adminAPI2 = new AlarmServiceFactory().makeAdminApi(locationService) Java // create alarm client using host and port of alarm server\n IAlarmService jclientAPI1 = new AlarmServiceFactory().jMakeClientApi(\"localhost\", 5227, actorSystem);\n\n// create alarm client using location service\n IAlarmService jclientAPI2 = new AlarmServiceFactory().jMakeClientApi(jLocationService, actorSystem);","title":"Creating clientAPI and adminAPI"},{"location":"/services/alarm.html#rules-and-checks","text":"When representing a unique alarm, the alarm name or component name must not have * [ ] ^ - or any whitespace characters","title":"Rules and checks"},{"location":"/services/alarm.html#model-classes","text":"AlarmKey : Represents the unique alarm in the TMT system. It is composed of subsystem, component and alarm name. ComponentKey : Represents all alarms of a component. Used for getting severity or health of an entire component. SubsystemKey : Represents all alarms of a subsystem Used for getting severity or health of an entire subsystem. GlobalKey : Represents all alarms present in the TMT system. Used for getting severity or health of an entire observatory. AlarmMetadata : Represents static metadata of an alarm, which will not change in its entire lifespan. AlarmStatus : Represents dynamically changing data of the an alarm, which will be changing depending on the severity change or manually changed by an operator AlarmSeverity : Represents severity levels that can be set by the component developer e.g. Okay, Indeterminate, Warning, Major and Critical FullAlarmSeverity : Represents all possible severity levels of the alarm i.e. Disconnected (cannot be set by the developer) plus other severity levels that can be set by the developer AlarmHealth : Represents possible health of an alarm or component or subsystem or whole TMT system","title":"Model Classes"},{"location":"/services/alarm.html#client-api","text":"","title":"Client API"},{"location":"/services/alarm.html#setseverity","text":"Sets the severity of the given alarm. The severity must be refreshed by setting it at a regular interval or it will automatically be changed to Disconnected after a specific time.\nScala val alarmKey              = AlarmKey(NFIRAOS, \"trombone\", \"tromboneAxisLowLimitAlarm\")\nval resultF: Future[Done] = clientAPI.setSeverity(alarmKey, Okay) Java private AlarmKey alarmKey = new AlarmKey(NFIRAOS, \"trombone\", \"tromboneAxisLowLimitAlarm\");\nFuture<Done> doneF = jclientAPI1.setSeverity(alarmKey, Okay);\nNote If the alarm is not refreshed within 9 seconds, it will be inferred as Disconnected If the alarm is auto-acknowledgable and the severity is set to Okay then, the alarm will be auto-acknowledged and will not require any explicit admin action in terms of acknowledging","title":"setSeverity"},{"location":"/services/alarm.html#admin-api","text":"","title":"Admin API"},{"location":"/services/alarm.html#initalarms","text":"Loads the given alarm data in alarm store, passing in the alarm configuration file.\nScala val resource               = \"test-alarms/valid-alarms.conf\"\nval alarmsConfig: Config   = ConfigFactory.parseResources(resource)\nval result2F: Future[Done] = adminAPI.initAlarms(alarmsConfig)\nAlarm configuration files are written in the HOCON format using the following fields:\nsubsystem: subsystem name the alarm belongs to component: name of component for the alarm, matching the name in the componentInfo file (see Describing Components) name: name of the alarm description: a description of what the alarm represents location: physical location within observatory or instrument in which the alarm condition is occuring alarmType: the general category for the alarm. supportedSeverities: list of non-Okay severities the alarm may become (Warning, Major, Critical). All alarms are assumed to support Okay, Disconnected, and Indeterminate. probableCause: a description of the likely cause of the alarm reaching each severity level operatorResponse: instructions or information to help the operator respond to the alarm. isAutoAcknowledgable: true/false flag for whether the alarm automatically acknowledges alarm when alarm severity returns to Okay. isLatchable: true/false flag whether alarm latches at highest severity until reset. activationStatus: true/false flag for whether alarm is currently active (and considered in aggregated severity and health calculations)\nalarms.conf alarms: [\n  {\n    subsystem = NFIRAOS\n    component = trombone\n    name = tromboneAxisLowLimitAlarm\n    description = \"Warns when trombone axis has reached the low limit\"\n    location = \"south side\"\n    alarmType = Absolute\n    supportedSeverities = [Warning, Major, Critical]\n    probableCause = \"the trombone software has failed or the stage was driven into the low limit\"\n    operatorResponse = \"go to the NFIRAOS engineering user interface and select the datum axis command\"\n    isAutoAcknowledgeable = false\n    isLatchable = true\n    activationStatus = Active\n  },\n  {\n    subsystem = NFIRAOS\n    component = trombone\n    name = tromboneAxisHighLimitAlarm\n    description = \"Warns when trombone axis has reached the high limit\"\n    location = \"south side\"\n    alarmType = Absolute\n    supportedSeverities = [Warning, Major]\n    probableCause = \"the trombone software has failed or the stage was driven into the high limit\"\n    operatorResponse = \"go to the NFIRAOS engineering user interface and select the datum axis command\"\n    isAutoAcknowledgeable = true\n    isLatchable = true\n    activationStatus = Active\n  },\n  {\n    subsystem = TCS\n    component = tcsPk\n    name = cpuExceededAlarm\n    description = \"This alarm is activated when the tcsPk Assembly can no longer calculate all of its pointing values in the time allocated. The CPU may lock power, or there may be pointing loops running that are not needed. Response: Check to see if pointing loops are executing that are not needed or see about a more powerful CPU.\"\n    location = \"in computer...\"\n    alarmType = Absolute\n    supportedSeverities = [Warning, Major, Critical]\n    probableCause = \"too fast...\"\n    operatorResponse = \"slow it down...\"\n    isAutoAcknowledgeable = true\n    isLatchable = false\n    activationStatus = Active\n  },\n  {\n    subsystem = LGSF\n    component = tcsPkInactive\n    name = cpuIdleAlarm\n    description = \"This alarm is activated CPU is idle\"\n    location = \"in computer...\"\n    alarmType = Absolute\n    supportedSeverities = [Warning, Major, Critical]\n    probableCause = \"too fast...\"\n    operatorResponse = \"slow it down...\"\n    isAutoAcknowledgeable = true\n    isLatchable = false\n    activationStatus = Inactive\n  }\n]","title":"initAlarms"},{"location":"/services/alarm.html#acknowledge","text":"Acknowledges the given alarm which is raised to a higher severity\nScala val result3F: Future[Done] = adminAPI.acknowledge(alarmKey)","title":"acknowledge"},{"location":"/services/alarm.html#shelve","text":"Shelves the given alarm. Alarms will be un-shelved automatically at a specific time(i.e. 8 AM local time by default) if it is not un-shelved manually before that. The time to automatically un-shelve can be configured in application.conf for e.g csw-alarm.shelve-timeout = h:m:s a .\nScala val result4F: Future[Done] = adminAPI.shelve(alarmKey)\nNote Shelved alarms are also considered in aggregation severity or health calculation of alarms.","title":"shelve"},{"location":"/services/alarm.html#unshelve","text":"Unshelves the given alarm\nScala val result5F: Future[Done] = adminAPI.unshelve(alarmKey)","title":"unshelve"},{"location":"/services/alarm.html#reset","text":"Resets the status of the given latched alarm by updating the latched severity same as current severity and acknowledgement status to acknowledged without changing any other properties of the alarm.\nScala val result6F: Future[Done] = adminAPI.reset(alarmKey)","title":"reset"},{"location":"/services/alarm.html#getmetadata","text":"Gets the metadata of an alarm, component, subsystem, or whole TMT system. The following information is returned for each alarm:\nsubsystem component name description location alarmType supported severities probable cause operator response is autoAcknowledgeable is latchable activation status\nScala val metadataF: Future[AlarmMetadata] = adminAPI.getMetadata(alarmKey)\nmetadataF.onComplete {\n  case Success(metadata)  => println(s\"${metadata.name}: ${metadata.description}\")\n  case Failure(exception) => println(s\"Error getting metadata: ${exception.getMessage}\")\n}\nNote Inactive alarms will not be taking part in aggregation of severity or health. Alarms are set active or inactive in the alarm configuration file, and not through either API.","title":"getMetadata"},{"location":"/services/alarm.html#getstatus","text":"Gets the status of the alarm which contains fields like:\nlatched severity acknowledgement status shelve status alarm time\nScala val statusF: Future[AlarmStatus] = adminAPI.getStatus(alarmKey)\nstatusF.onComplete {\n  case Success(status)    => println(s\"${status.alarmTime}: ${status.latchedSeverity}\")\n  case Failure(exception) => println(s\"Error getting status: ${exception.getMessage}\")\n}","title":"getStatus"},{"location":"/services/alarm.html#getcurrentseverity","text":"Gets the severity of the alarm.\nScala val severityF: Future[FullAlarmSeverity] = adminAPI.getCurrentSeverity(alarmKey)\nseverityF.onComplete {\n  case Success(severity)  => println(s\"${severity.name}: ${severity.level}\")\n  case Failure(exception) => println(s\"Error getting severity: ${exception.getMessage}\")\n}","title":"getCurrentSeverity"},{"location":"/services/alarm.html#getaggregatedseverity","text":"Gets the aggregated severity for the given alarm/component/subsystem/whole TMT system. Aggregation of the severity represents the most severe alarm amongst multiple alarms.\nScala val componentKey                                   = ComponentKey(NFIRAOS, \"tromboneAssembly\")\nval aggregatedSeverityF: Future[FullAlarmSeverity] = adminAPI.getAggregatedSeverity(componentKey)\naggregatedSeverityF.onComplete {\n  case Success(severity)  => println(s\"aggregate severity: ${severity.name}: ${severity.level}\")\n  case Failure(exception) => println(s\"Error getting aggregate severity: ${exception.getMessage}\")\n}","title":"getAggregatedSeverity"},{"location":"/services/alarm.html#getaggregatedhealth","text":"Gets the aggregated health for the given alarm/component/subsystem/whole TMT system. Aggregation of health is either Good, ill or Bad based on the most severe alarm amongst multiple alarms.\nScala val subsystemKey                 = SubsystemKey(IRIS)\nval healthF: Future[AlarmHealth] = adminAPI.getAggregatedHealth(subsystemKey)\nhealthF.onComplete {\n  case Success(health)    => println(s\"${subsystemKey.subsystem.name} health = ${health.entryName}\")\n  case Failure(exception) => println(s\"Error getting health: ${exception.getMessage}\")\n}","title":"getAggregatedHealth"},{"location":"/services/alarm.html#subscribeaggregatedseveritycallback","text":"Subscribes to the changes of aggregated severity for given alarm/component/subsystem/whole TMT system by providing a callback which gets executed for every change.\nScala val alarmSubscription: AlarmSubscription = adminAPI.subscribeAggregatedSeverityCallback(\n  ComponentKey(NFIRAOS, \"tromboneAssembly\"),\n  aggregatedSeverity ⇒ { /* do something*/ }\n)\n// to unsubscribe:\nval unsubscribe1F: Future[Done] = alarmSubscription.unsubscribe()","title":"subscribeAggregatedSeverityCallback"},{"location":"/services/alarm.html#subscribeaggregatedseverityactorref","text":"Subscribes to the changes of aggregated severity for given alarm/component/subsystem/whole TMT system by providing an actor which will receive a message of aggregated severity on every change.\nScala val severityActorRef = typed.ActorSystem(behaviour[FullAlarmSeverity], \"fullSeverityActor\")\nval alarmSubscription2: AlarmSubscription =\n  adminAPI.subscribeAggregatedSeverityActorRef(SubsystemKey(NFIRAOS), severityActorRef)\n\n// to unsubscribe:\nval unsubscribe2F: Future[Done] = alarmSubscription2.unsubscribe()","title":"subscribeAggregatedSeverityActorRef"},{"location":"/services/alarm.html#subscribeaggregatedhealthcallback","text":"Subscribe to the changes of aggregated health for given alarm/component/subsystem/whole TMT system by providing a callback which gets executed for every change.\nScala val alarmSubscription3: AlarmSubscription = adminAPI.subscribeAggregatedHealthCallback(\n  ComponentKey(IRIS, \"ImagerDetectorAssembly\"),\n  aggregatedHealth ⇒ { /* do something*/ }\n)\n\n// to unsubscribe\nval unsubscribe3F: Future[Done] = alarmSubscription3.unsubscribe()","title":"subscribeAggregatedHealthCallback"},{"location":"/services/alarm.html#subscribeaggregatedhealthactorref","text":"Subscribes to the changes of aggregated health for given alarm/component/subsystem/whole TMT system by providing an actor which will receive a message of aggregated severity on every change.\nScala val healthActorRef                        = typed.ActorSystem(behaviour[AlarmHealth], \"healthActor\")\nval alarmSubscription4: AlarmSubscription = adminAPI.subscribeAggregatedHealthActorRef(SubsystemKey(IRIS), healthActorRef)\n\n// to unsubscribe\nval unsubscribe4F: Future[Done] = alarmSubscription4.unsubscribe()","title":"subscribeAggregatedHealthActorRef"},{"location":"/services/alarm.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source code for examples"},{"location":"/services/time.html","text":"","title":"Time Service"},{"location":"/services/time.html#time-service","text":"The Time Service provides APIs to access time in Coordinated Universal Time (UTC) and International Atomic Time (TAI) time scales with up to nano second precision when available. It also provides APIs for scheduling periodic and non-periodic tasks in the future, which are optimised for scheduling at up to 1KHz frequency.\nTMT has standardised on the use of Precision Time Protocol (PTP) as the basis of time to achieve sub-microsecond accuracy and precision between computers. The Time Service provides each participating computer with access to time synchronized by PTP.\nAt the telescope site, the Global Positioning System (GPS) provides an absolute time base, and a PTP grand master clock (a hardware device) synchronized to the GPS broadcasts the PTP protocol. Each computer system participating in the PTP system is synchronized with GPS and each other using the PTP protocol. For higher accuracy in time measurements hardware time stamping is required, and those computers should be fitted with PTP capable Network Interface Cards (NIC).\nIn order to read the time with high precision, the Time Service relies on making native calls to the Linux kernel libraries, since Java 8 supports only millisecond precision. Java Native Access (JNA) is used internally in Time Service to make native calls that return the required precision. The implementation of Time Service Scheduler is based on the Akka Scheduler, which is designed for high-throughput tasks rather than long-term, cron-like scheduling of tasks.","title":"Time Service"},{"location":"/services/time.html#dependencies","text":"The Time Service comes bundled with the Framework, no additional dependency needs to be added to your build.sbt file if using it. To use the Time Service without using the framework, add this to your build.sbt file:\nsbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-time-client\" % \"0.1-SNAPSHOT\"","title":"Dependencies"},{"location":"/services/time.html#time-service-api-flavors","text":"There are total three APIs provided by the Time Service:\nTMTTime API: This API provides a way to get current UTC or TAI time. TMTTimeHelper API: This API provides additional time zone related functionality on top of TMTTime. Scheduler API: This API provides various methods to schedule future or periodic tasks.","title":"Time Service API Flavors"},{"location":"/services/time.html#tmttime-api","text":"TMTTime represents an instantaneous point in time with nanosecond precision. It’s a wrapper around Instant and provides additional information about the timescale of the instant.\nTMTTime supports two timescales:\nCoordinated Universal Time ( UTCTime ) International Atomic Time ( TAITime )","title":"TMTTime API"},{"location":"/services/time.html#get-current-time","text":"Gets the current UTC/TAI time with nanosecond precision.\nScala // get current UTC time\nval utcTime: UTCTime = UTCTime.now()\n\n// get current TAI time\nval taiTime: TAITime = TAITime.now() Java // get current UTC time\nprivate UTCTime utcTime = UTCTime.now();\n\n// get current TAI time\nprivate TAITime taiTime = TAITime.now();\nNote that time is returned a UTCTime or TAITime object so that it is possible to determine the time scale of the time value by inspection.","title":"Get Current Time"},{"location":"/services/time.html#converting-from-utc-to-tai-time-and-vice-versa","text":"Each time object provides a way to convert to the other.\nScala // UTC to TAI\nval taiTime: TAITime = utcTime.toTAI\n\n// TAI to UTC\nval utcTime0: UTCTime = taiTime.toUTC Java // UTC to TAI\nTAITime taiTime = utcTime.toTAI();\n\n// TAI to UTC\nUTCTime utcTime = taiTime.toUTC();","title":"Converting from UTC to TAI Time and Vice-versa"},{"location":"/services/time.html#tmttimehelper-api","text":"This API provides additional time zone related functionality on top of TMTTime. It allows users to get a Java ZonedDateTime representation of a TMTTime.","title":"TMTTimeHelper API"},{"location":"/services/time.html#at-local-time-zone","text":"Gets the given TMTTime at Local time zone. The local time zone is fetched from the calling system’s default time zone.\nScala // Get UTCTime at local timezone\nval utcLocalTime: ZonedDateTime = TMTTimeHelper.atLocal(utcTime)\n\n// Get TAITime at local timezone\nval taiLocalTime: ZonedDateTime = TMTTimeHelper.atLocal(taiTime) Java // Get UTCTime at local timezone\nZonedDateTime utcLocalTime = TMTTimeHelper.atLocal(utcTime);\n\n// Get TAITime at local timezone\nZonedDateTime taiLocalTime = TMTTimeHelper.atLocal(taiTime);","title":"At Local Time Zone"},{"location":"/services/time.html#at-hawaii-hst-timezone","text":"Gets the given TMTTime at Hawaii time zone.\nScala // Get UTCTime at Hawaii (HST) timezone\nval utcHawaiiTime: ZonedDateTime = TMTTimeHelper.atHawaii(utcTime)\n\n// Get TAITime at Hawaii (HST) timezone\nval taiHawaiiTime: ZonedDateTime = TMTTimeHelper.atHawaii(taiTime) Java // Get UTCTime at Hawaii (HST) timezone\nZonedDateTime utcHawaiiTime = TMTTimeHelper.atHawaii(utcTime);\n\n// Get TAITime at Hawaii (HST) timezone\nZonedDateTime taiHawaiiTime = TMTTimeHelper.atHawaii(taiTime);","title":"At Hawaii (HST) Timezone"},{"location":"/services/time.html#at-custom-timezone","text":"Gets the given TMTTime at the specified time zone.\nScala // Get UTCTime at specified timezone\nval utcKolkataTime: ZonedDateTime = TMTTimeHelper.atZone(utcTime, ZoneId.of(\"Asia/Kolkata\"))\n\n// Get TAITime at specified timezone\nval taiKolkataTime: ZonedDateTime = TMTTimeHelper.atZone(taiTime, ZoneId.of(\"Asia/Kolkata\")) Java // Get UTCTime at specified timezone\nZonedDateTime utcKolkataTime = TMTTimeHelper.atZone(utcTime, ZoneId.of(\"Asia/Kolkata\"));\n\n// Get TAITime at specified timezone\nZonedDateTime taiKolkataTime = TMTTimeHelper.atZone(taiTime, ZoneId.of(\"Asia/Kolkata\"));","title":"At Custom Timezone"},{"location":"/services/time.html#scheduler-api","text":"This API provides various methods to schedule periodic or non-periodic, one-shot tasks in the future.\nFor component developers, the scheduler API is provided as a TimeServiceScheduler object in the CswContext object injected into the ComponentHandlers class provided by the framework.\nIf you are not using csw-framework, you can create TimeServiceScheduler using TimeServiceSchedulerFactory as follows.\nScala // create time service scheduler using the factory method\nprivate val scheduler: TimeServiceScheduler = TimeServiceSchedulerFactory.make()(actorSystem) Java // create time service scheduler using the factory method\nTimeServiceScheduler scheduler = TimeServiceSchedulerFactory.make(actorSystem);\nFor all scheduler calls, an instance of Cancellable is returned which can be used to cancel the execution of the future tasks.","title":"Scheduler API"},{"location":"/services/time.html#schedule-once","text":"Schedules a task to execute once at the given start time. The startTime is a TMTTime and can be either a UTCTime or TAITime.\nScala scheduler.scheduleOnce(utcTime) {\n  // do something\n} Java Runnable task = () -> {/* do something*/};\nscheduler.scheduleOnce(utcTime, task);\nWarning Note that callbacks are asynchronous and can be potentially executed in an unknown thread. Therefore, if there is a need to mutate state when the time expires, it is recommended to send a message to an Actor, and keep any mutable state within the actor where it can be managed safely. This is true for any CSW API with a callback. The schedule once with ActorRef can often be used in this scenario.","title":"Schedule Once"},{"location":"/services/time.html#schedule-once-with-actorref","text":"Schedules sending of the message to the provided actorRef at the given start time. The startTime can be either UTCTime or TAITime.\nScala class SchedulingHandler(ctx: ActorContext[UTCTime]) extends AbstractBehavior[UTCTime] {\n  override def onMessage(msg: UTCTime): Behavior[UTCTime] = {\n    // handle the message to execute the task on scheduled time\n    Behaviors.same\n  }\n}\n\nprivate val behavior: Behavior[UTCTime] = Behaviors.setup(ctx ⇒ new SchedulingHandler(ctx))\nprivate val actorRef: ActorRef          = ctx.spawnAnonymous(behavior).toUntyped\n\nscheduler.scheduleOnce(utcTime, actorRef, UTCTime.now())\n Java class SchedulingHandler extends AbstractBehavior<UTCTime> {\n    @Override\n    public Receive<UTCTime> createReceive() {\n        // handle the message to execute the task on scheduled time\n        return null;\n    }\n}\n\nCancellable schedule() {\n    Behavior<UTCTime> behavior = Behaviors.setup(ctx -> new SchedulingHandler());\n    ActorRef actorRef = Adapter.toUntyped(ctx.asJava().spawnAnonymous(behavior));\n\n    return scheduler.scheduleOnce(utcTime, actorRef, UTCTime.now());\n}","title":"Schedule Once With ActorRef"},{"location":"/services/time.html#schedule-periodically","text":"Schedules a task to execute periodically at the given interval. The first task is executed once immediately without any initial delay followed by periodic executions. In case you do not want to start scheduling immediately, you can use the overloaded method for schedulePeriodically() with startTime as shown in the next example.\nScala scheduler.schedulePeriodically(Duration.ofMillis(50)) { /* do something*/ } Java Runnable task = () -> {/* do something*/};\nscheduler.schedulePeriodically(Duration.ofMillis(50), task);","title":"Schedule Periodically"},{"location":"/services/time.html#schedule-periodically-with-start-time","text":"Schedules a task to execute periodically at the given interval. The task is executed once at the given start time followed by execution of task at each interval. The startTime can be either UTCTime or TAITime.\nScala scheduler.schedulePeriodically(utcTime, Duration.ofMillis(50)) { /* do something*/ } Java Runnable task = () -> {/* do something*/};\nscheduler.schedulePeriodically(utcTime, Duration.ofMillis(50), task);\nAs with the schedule once API, there is also a periodic schedule API that takes a message and ActorRef.","title":"Schedule Periodically with Start Time"},{"location":"/services/time.html#source-code-for-tmttime-examples","text":"Scala Example Java Example","title":"Source code for TMTTime examples"},{"location":"/services/time.html#source-code-for-scheduler-examples","text":"Scala Example Java Example","title":"Source code for Scheduler examples"},{"location":"/services/database.html","text":"","title":"Database Service"},{"location":"/services/database.html#database-service","text":"The Database Service is included in TMT Common Software for use by components that need the features of a relational database. CSW Database Service provides a TMT-standard relational database and connection library. Databases created by Database Service will be stored reliably at the site during operations.\nThe Database Service provides an API to manage database connections and access data in the TMT Software System. The service provides PostgreSQL as the underlying database server. It uses the Jooq library underneath to manage database access, connection pooling, etc.\nNote Jooq is a Java library that provides a higher level API for accessing data i.e. DDL support, DML support, fetch, batch execution, prepared statements, safety against sql injection, connection pooling, etc. To know more about Jooq and its features, please refer to this link.\nDatabase Service requires PostgreSQL server to be running on a machine. To start the PostgreSQL server for development and testing purposes, refer to Starting Apps for Development.\nOnce the PostgreSQL is up and running, Database Service can be used to connect and access data. It is assumed that there will be more than one user types registered with PostgreSQL i.e. for read access, for write access, for admin access, etc.","title":"Database Service"},{"location":"/services/database.html#dependencies","text":"To include the Database Service in a component, add this to your build.sbt file:\nsbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-database\" % \"0.1-SNAPSHOT\"","title":"Dependencies"},{"location":"/services/database.html#accessing-database-service","text":"Database Service is accessed differently than other CSW services in that it is not passed to a component through CswContext/JCswContext in the component’s ComponentHandlers. To access Database Service, developers create a DatabaseServiceFactory. DatabaseServiceFactory can be created anywhere in the code using an ActorSystem and its creation is explained in next section.\nNote Creating a new DatabaseServiceFactory does not mean a new connection to PostgreSQL server will be created. Database connections are managed in a pool by the underlying Database Service implementation. Hence, creating multiple DatabaseServiceFactory per component can be considered pretty cheap and harmless. But it is also possible to save what is returned by DatabaseServiceFactory and pass it around your component.","title":"Accessing Database Service"},{"location":"/services/database.html#connect-with-read-access","text":"Our access approach is that all components can read any Database Service database and clients that only need read access use the following factory method. But a writer will need a special username/password with write access as shown below.\nBy default while connecting to PostgreSQL, Database Service will provide read access for data. To achieve that, create an instance of DatabaseServiceFactory and use it as shown below:\nScala val dbFactory = new DatabaseServiceFactory(ctx.system)\n\ndbFactory\n  .makeDsl(locationService, \"postgres\") // postgres is dbName\n  .foreach((dsl: DSLContext) ⇒ this.dsl = dsl) // save returned dsl to a local variable Java dbFactory = new DatabaseServiceFactory(ctx.getSystem());\n\ndbFactory\n        .jMakeDsl(cswCtx.locationService(), \"postgres\") // postgres is dbName\n        .thenAccept((DSLContext dsl) -> this.dsl = dsl);        // save the returned dsl to a local variable\nThe underlying database server is registered with the Location Service. makeDsl/jMakeDsl takes locationService to locate the PostgreSQL server running and connect to it. It connects to the database by the provided dbName. It picks the database username and password for read access profile from TMT-standard environment variables called dbReadUsername for username and dbReadPassword for password, hence it is expected that developers will set these environment variables prior to using DatabaseServiceFactory. PostgreSQL should also be initialized with a read-only user and password that agrees with the values in the environment variables. This approach is used to keep from putting database login information in the source code.\nNote See the PostgreSQL docs or this site for help with creating users, passwords, and roles in PostgreSQL. The psql interactive CLI client is provided with PostgreSQL. It can be used to connect to PostgreSQL and create users (as well as many other maintenance commands). If Database Service is started with csw-services.sh, the database server is started on port 5432. Eventually, all TMT user logins will all have these environment variables set with the agreed upon read-only user and password.\nmakeDsl/jMakeDsl returns a Jooq type DSLContext. DSLContext provides the mechanism to access the data stored in PostgreSQL using the selected JDBC driver underneath. The usage of DSLContext in component development will be explained in later sections.\nHint Any exception encountered while connecting to PostgreSQL server will be wrapped in DatabaseException.","title":"Connect with Read Access"},{"location":"/services/database.html#connect-with-write-access","text":"In order to connect to PostgreSQL for write access (or any other access other than read), use the DatabaseServiceFactory as shown below with different environment variables:\nScala dbFactory\n  .makeDsl(locationService, \"postgres\", \"dbWriteUsername\", \"dbWritePassword\")\n  .foreach((dsl: DSLContext) ⇒ this.dsl = dsl) // save returned dsl to a local variable Java dbFactory\n        .jMakeDsl(cswCtx.locationService(), \"postgres\", \"dbWriteUsername\", \"dbWritePassword\")\n        .thenAccept((DSLContext dsl) -> this.dsl = dsl);        // save the returned dsl to a local variable\nHere the username is picked from dbWriteUsername and password is picked from dbWritePassword environment variables. Hence, it is expected from developers to set environment variables prior to using this method with the user name and password to use for write access.","title":"Connect with Write Access"},{"location":"/services/database.html#connect-for-development-or-testing","text":"For development and testing purposes, all database connection properties can be provided from application.conf including username and password. This will not require setting any environment variables for credentials as described in previous sections. In order to do so, use the DatabaseServiceFactory as shown below:\nScala dbFactory\n  .makeDsl()\n  .foreach((dsl: DSLContext) ⇒ this.dsl = dsl) // save returned dsl to a local variable Java dbFactory\n        .jMakeDsl()\n        .thenAccept((DSLContext dsl) -> this.dsl = dsl);        // save the returned dsl to a local variable\nThe reference for providing database properties is shown below:\nreference.conf csw-database = {\n  databaseDialect = POSTGRES_10\n  hikari-datasource {\n    dataSourceClassName = org.postgresql.ds.PGSimpleDataSource\n//    dataSource {\n      //  serverName = <server_name>\n      //  portNumber = <port_number>\n      //  databaseName = <database_name>\n      //  user = <username>\n      //  password = <password>\n//    }\n\n    // Below are the default properties of HikariCP\n    //autoCommit = true\n    //connectionTimeout = 30000 (30 seconds)\n    //idleTimeout = 600000 (10 minutes)\n    //maxLifetime = 600000 (10 minutes)\n    //maximumPoolSize = 10\n    //minimumIdle = 10 (same as max pool size)\n  }\n}\nIn order to override any property shown above, it needs to be defined in application.conf for e.g. a sample application.conf can look as follows:\ncsw-database.hikari-datasource.dataSource {\n  serverName = localhost\n  portNumber = 5432\n  databaseName = postgres\n  user = postgres\n  password = postgres\n}\nNote By default CSW configures HikariCP connection pool for managing connections with PostgreSQL server. To know more about HikariCP please refer this link.","title":"Connect for Development or Testing"},{"location":"/services/database.html#using-dslcontext","text":"Once the DSLContext is returned from makeDsl/jMakeDsl, it can be used to provide plain SQL to Database Service and get it executed on the PostgreSQL server.\nThe following sections show examples of most typical SQL use cases.","title":"Using DSLContext"},{"location":"/services/database.html#create","text":"To create a table, use the DSLContext as follows:\nScala val createQuery: Query = dsl.query(\"CREATE TABLE films (id SERIAL PRIMARY KEY, Name VARCHAR (10) NOT NULL)\")\n\nimport csw.database.scaladsl.JooqExtentions.RichQuery\nval createResultF: Future[Integer] = createQuery.executeAsyncScala()\ncreateResultF.foreach(result ⇒ println(s\"Films table created with $result\")) Java Query createQuery = dsl.query(\"CREATE TABLE films (id SERIAL PRIMARY KEY, Name VARCHAR (10) NOT NULL)\");\nCompletionStage<Integer> createResultF = createQuery.executeAsync();\ncreateResultF.thenAccept(result -> System.out.println(\"Films table created with \" + result));","title":"Create"},{"location":"/services/database.html#insert","text":"To insert data in batch, use the DSLContext as follows:\nScala val movie_2 = \"movie_2\"\n\nval queries = dsl.queries(\n  dsl.query(\"INSERT INTO films(name) VALUES (?)\", \"movie_1\"),\n  dsl.query(\"INSERT INTO films(id, name) VALUES (?, ?)\", \"2\", movie_2)\n)\n\nimport csw.database.scaladsl.JooqExtentions.RichQueries\nval batchResultF: Future[List[Int]] = queries.executeBatchAsync()\nbatchResultF.foreach(results ⇒ println(s\"executed queries [$queries] with results [$results]\")) Java String movie_2 = \"movie_2\";\n\nQueries queries = dsl.queries(\n        dsl.query(\"INSERT INTO films(name) VALUES (?)\", \"movie_1\"),\n        dsl.query(\"INSERT INTO films(id, name) VALUES (?, ?)\", 2, movie_2)\n);\n\nCompletableFuture<int[]> batchResultF = JooqHelper.executeBatch(queries);\nbatchResultF.thenAccept(results ->\n        System.out.println(\"executed queries [\" + queries + \"] with results [\" + Arrays.toString(results) + \"]\"));\nNote The insert statements above gets mapped to prepared statements underneath at JDBC layer and values like movie_1, movie_2 and 2 from the example are bound to the dynamic parameters of these generated prepared statements. As prepared statements provide safety against SQL injection, it is recommended to use prepared statements instead of static SQL statements whenever there is a need to dynamically bind values. In the above example, two insert statements are batched together and sent to PostgreSQL server in a single call. executeBatchAsync/executeBatch maps to batch statements underneath at JDBC layer.","title":"Insert"},{"location":"/services/database.html#select","text":"To select data from table, use the DSLContext as follows:\nScala // domain model\ncase class Films(id: Int, name: String) // variable name and type should be same as column's name and type in database\n\n// fetch data from table and map it to Films class\nval selectQuery = dsl.resultQuery(\"SELECT id, name FROM films WHERE id = ?\", \"1\")\n\nimport csw.database.scaladsl.JooqExtentions.RichResultQuery\nval selectResultF: Future[List[Films]] = selectQuery.fetchAsyncScala[Films]\nselectResultF.foreach(names ⇒ s\"Fetched names of films $names\") Java // domain model\nclass Films {\n    private Integer id;  // variable name (id) and type (Integer) should be same as column's name and type in database\n    private String name; // variable name (name) and type (String) should be same as column's name and type in database\n};\n\n// fetch data from table and map it to Films class\nResultQuery<Record> selectQuery = dsl.resultQuery(\"SELECT id, name FROM films WHERE id = ?\", 1);\nCompletableFuture<List<Films>> selectResultF = JooqHelper.fetchAsync(selectQuery, Films.class);\nselectResultF.thenAccept(names -> System.out.println(\"Fetched names of films \" + names));\nNote Make sure that variable name and type of Films class is same as column’s name and type in database. This is necessary for successful mapping of table fields to domain model class.","title":"Select"},{"location":"/services/database.html#stored-function","text":"To create a stored function, use the DSLContext as follows:\nScala val functionQuery = dsl\n  .query(\n    \"\"\"\n    |CREATE FUNCTION inc(val integer) RETURNS integer AS $$\n    |BEGIN\n    |RETURN val + 1;\n    |END; $$\n    |LANGUAGE PLPGSQL;\n    \"\"\".stripMargin\n  )\n\nval functionResultF: Future[Integer] = functionQuery.executeAsyncScala()\nfunctionResultF.foreach(result ⇒ println(s\"Function inc created with $result\")) Java Query functionQuery = dsl.query(\"CREATE FUNCTION inc(val integer) RETURNS integer AS $$\\n\" +\n        \"BEGIN\\n\" +\n        \"RETURN val + 1;\\n\" +\n        \"END; $$\\n\" +\n        \"LANGUAGE PLPGSQL;\");\n\nCompletionStage<Integer> functionResultF = functionQuery.executeAsync();\nfunctionResultF.thenAccept(result -> System.out.println(\"Function inc created with  \" + result));\nSimilarly, any SQL queries can be written with the help of DSLContext including stored procedures.\nNote If there is a syntax error in SQL queries the Future/CompletableFuture returned will fail with CompletionException and CompletionStage will fail with ExecutionException. But both CompletionException and ExecutionException will have Jooq’s DataAccessException underneath as cause.\nThese examples are just a start. Any SQL statement can be created and executed using the DSLContext.","title":"Stored Function"},{"location":"/services/database.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source code for examples"},{"location":"/services/aas.html","text":"","title":"Authentication and Authorization Service (AAS)"},{"location":"/services/aas.html#authentication-and-authorization-service-aas-","text":"Authentication and Authorization Service (AAS) is a suite of libraries (aka adapters) provided CSW to help build ecosystem of client & server side applications that enforce authentication & authorization policies.\nThe backbone of AAS is keycloak. It is where all the client and server applications need to registered and configured. keycloak comes bundled with csw-services.sh so you don’t have to download & install it manually.\nCore concepts and terms Akka HTTP Adapter (csw-aas-http) Javascript Adapter (csw-aas-js) Installed Auth Adapter (csw-aas-installed)","title":"Authentication and Authorization Service (AAS)"},{"location":"/services/aas/core-concepts-and-terms.html","text":"","title":"Core concepts and terms"},{"location":"/services/aas/core-concepts-and-terms.html#core-concepts-and-terms","text":"These are some commons terms used in AAS. More information is available on keycloak documentation","title":"Core concepts and terms"},{"location":"/services/aas/core-concepts-and-terms.html#users","text":"Users are entities that are able to log into your system. They can have attributes associated with themselves like email, username, address, phone number, and birth day. They can be assigned group membership and have specific roles assigned to them.","title":"Users"},{"location":"/services/aas/core-concepts-and-terms.html#roles","text":"Roles identify a type or category of user. Admin, user, manager, and employee are all typical roles that may exist in an organization. Applications often assign access and permissions to specific roles rather than individual users as dealing with users can be too fine grained and hard to manage.","title":"Roles"},{"location":"/services/aas/core-concepts-and-terms.html#realms","text":"A realm manages a set of users, credentials, roles, and groups. A user belongs to and logs into a realm. Realms are isolated from one another and can only manage and authenticate the users that they control.","title":"Realms"},{"location":"/services/aas/core-concepts-and-terms.html#clients","text":"Clients are entities that can request Keycloak to authenticate a user. Most often, clients are applications and services that want to use Keycloak to secure themselves and provide a single sign-on solution. Clients can also be entities that just want to request identity information or an access token so that they can securely invoke other services on the network that are secured by Keycloak.","title":"Clients"},{"location":"/services/aas/core-concepts-and-terms.html#client-roles","text":"Clients can define roles that are specific to them. This is basically a role namespace dedicated to the client.","title":"Client Roles"},{"location":"/services/aas/csw-aas-http.html","text":"","title":"Akka HTTP Adapter (csw-aas-http)"},{"location":"/services/aas/csw-aas-http.html#akka-http-adapter-csw-aas-http-","text":"This library is a security adapter for akka-http server applications. csw-aas uses OpenId Connect for authentication and authorization. The authentication server used by aas is keycloak. we recommend that you get familiar with keycloak’s documentation and configurations to fully leverage this adapters features.\nThis adapter provides authentication via security directives such as sGet, sPost, sPut, etc. For authorization, these secure directives accept a wide range of policy expressions.","title":"Akka HTTP Adapter (csw-aas-http)"},{"location":"/services/aas/csw-aas-http.html#dependencies","text":"To use the Akka HTTP Adapter (csw-aas-http), add this to your build.sbt file:\nsbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-aas-http\" % \"0.1-SNAPSHOT\"","title":"Dependencies"},{"location":"/services/aas/csw-aas-http.html#prerequisites","text":"To run an akka-http server app, which uses this adapter, we need\nlocation service running Keycloak instance running and registered with location service\nLocation service and keycloak can be running on different machines. To start location service & keycloak server on a local machine, you make make use of csw-services.sh script.","title":"Prerequisites"},{"location":"/services/aas/csw-aas-http.html#application-configurations","text":"All auth related configurations go inside auth-config block. There are tree configurations applicable for a akka-http server application i.e. realm, client-id & enable-permissions.\nrealm has a default value of TMT if not specified. Ideally all apps in TMT should not have to override this, however it might be useful to override this while testing your app.\nenable-permissions is optional config with a default value of false. If your akka-http server application uses permission based authorization policies, this config needs to set to true.\nclient-id is a mandatory configuration which specifies the client id of the app as per registration in keycloak.\nauth-config {\n  realm = TMT # DEFAULT\n  enable-permissions = false # DEFAULT\n  client-id = demo-cli # REQUIRED\n}","title":"Application Configurations"},{"location":"/services/aas/csw-aas-http.html#building-a-secure-akka-http-server-application","text":"The core of this adapter is the SecurityDirectives class. The recommended way to instantiate SecurityDirectives is as shown below.\nScala object SampleHttpApp extends HttpApp with App {\n\n  implicit val actorSystem: ActorSystem = ActorSystem()\n  implicit val ec: ExecutionContext     = ExecutionContext.global\n  implicit val mat: ActorMaterializer   = ActorMaterializer()\n\n  val locationService = HttpLocationServiceFactory.makeLocalClient\n  val directives      = SecurityDirectives(locationService)\n  import directives._\n\n  override protected def routes: Route = pathPrefix(\"api\") {\n    get {\n      complete(\"SUCCESS\")\n    } ~\n    sPost(RealmRolePolicy(\"admin\")) {\n      complete(\"SUCCESS\")\n    }\n  }\n\n  private val host = \"0.0.0.0\"\n  private val port = 9003\n\n  startServer(host, port)\n}\nImporting everything from security directives is recommended as it imports some implicit methods along with all security directives.\nIn the above example, GET http://localhost:9003/api does not use any security directive and hence is accessible to all. POST http://localhost:9003/api uses sPost which is secure directive. This directive takes care of authentication (access token signature & expiration validation). For authorization it needs an authorization policy. Authorizing policy specifies one or more conditions for request validation.\nIn this instance, sPost directive has been given RealmRolePolicy policy with parameter value admin.\nThis results into following sequence of actions when a request arrives for a secure directive route\nSecure directive will check request header to look for an access token Validate token signature and expiry Check the token for roles and validate that it has admin realm role After all the above checks/validations pass, execute the route logic\nIf any of the validations fails, an appropriate http status code is returned to the requester. For authentication failure 401 is sent and for authorization failure 403 is sent.\nNote To know more about realm roles, check out keycloak documentation","title":"Building a Secure Akka-HTTP server application"},{"location":"/services/aas/csw-aas-http.html#authorization-policies","text":"An authorization policy is a way to provide filter incoming HTTP requests based on standard rules. Following policies can be applied to protect routes.\nReamRolePolicy ClientRolePolicy PermissionPolicy CustomPolicy CustomPolicyAsync EmptyPolicy","title":"Authorization Policies"},{"location":"/services/aas/csw-aas-http.html#realmrolepolicy","text":"This policy filters requests based on Realm Role. A Realm Role is global and is applicable for all clients within realm.\nIn the following example policy will authorize request if user has assigned admin\nScala val routeWithRealmRolePolicy: Route = sGet(RealmRolePolicy(\"admin\")) {\n  complete(\"OK\")\n}","title":"RealmRolePolicy"},{"location":"/services/aas/csw-aas-http.html#clientrolepolicy","text":"Client roles are basically a namespace dedicated to a client. Each client gets its own namespace.\nThis policy filters requests based on Client Role. In the following example policy will authorize request if user has assigned accounts-admin for clientId specified in configurations\nScala val routeWithClientRolePolicy: Route = sGet(ClientRolePolicy(\"accounts-admin\")) {\n  complete(\"OK\")\n}","title":"ClientRolePolicy"},{"location":"/services/aas/csw-aas-http.html#permissionpolicy","text":"This policy filters requests based on permissions. It expects name of scope and name of resource on which permission is created in keycloak. Scope and Resource forms a “Permission”. For example, “scope: Sell; resource: Vehicle” combined specifies that the user with this scope and resource combination can “sell vehicles”.\nIn the following example policy will authorize request if user has appropriate permission associated in keycloak which specifies delete scope for account resource.\nScala val routeWithPermissions = sDelete(PermissionPolicy(\"delete\", \"account\")) {\n  complete(\"OK\")\n}","title":"PermissionPolicy"},{"location":"/services/aas/csw-aas-http.html#custompolicy","text":"This policy allows custom request filtering based on access token properties. It expects predicate function which accepts an access token and returns a boolean. If the predicate returns true, it indicates user is authorized.\nIn the following example policy will authorize request if user’s given name contains test-user\nScala val routeWithCustomPolicy: Route = sPost(CustomPolicy(token ⇒ token.given_name.contains(\"test-user\"))) {\n  complete(\"OK\")\n}","title":"CustomPolicy"},{"location":"/services/aas/csw-aas-http.html#custompolicyasync","text":"This policy is similar to CustomPolicy with only difference that it expects a predicate which returns a Future of Boolean instead of a Boolean. This could be very useful for custom validations which need to make an IO call. For example,\nScala //GET http://[host]:[port]/files?fileId=[fileId]\nval route: Route =\n  path(\"files\" / LongNumber) { fileId =>\n    sGet(CustomPolicyAsync(token => Database.doesUserOwnFile(token.preferred_username, fileId))) {\n      complete(Database.getFileContents(fileId))\n    }\n  }\nThis forms a an http route for a secure GET request for path /files/[fileId] and expects a path parameter of type Long. The async custom policy makes an async database call to check whether the file being requested belongs to the user who made http request.","title":"CustomPolicyAsync"},{"location":"/services/aas/csw-aas-http.html#emptypolicy","text":"This policy is used this when only authentication is needed but not authorization. EmptyPolicy is an object and not a class like other policies and it does not need any parameters.\nScala val authenticationOnlyRoute: Route = // GET http://[host]:[post]/api\n  path(\"api\") {\n    sGet(EmptyPolicy) {\n      complete(\"OK\")\n    }\n  }","title":"EmptyPolicy"},{"location":"/services/aas/csw-aas-http.html#security-directives","text":"csw-aas-http adapter supports following secure HTTP verbs:\nName Description sGet Rejects all un-authorized and non-GET requests sPost Rejects all un-authorized and non-POST requests sPut Rejects all un-authorized and non-PUT requests sDelete Rejects all un-authorized and non-DELETE requests sHead Rejects all un-authorized and non-HEAD requests sConnect Rejects all un-authorized and non-CONNECT requests","title":"Security Directives"},{"location":"/services/aas/csw-aas-http.html#using-access-token","text":"A handle of access token is given to to all secure routes. It is optional to define parameter for it.\nFor example:\nScala val routeExampleWithToken: Route = sDelete(EmptyPolicy) { token =>\n  parameter(\"entityId\".as[Long]) { entityId =>\n    ThirdPartyService.deleteEntity(entityId, token.preferred_username)\n    complete(s\"user ${token.given_name} ${token.family_name} deleted entity $entityId\")\n  }\n}\n\nval routeExampleWithoutToken: Route = sDelete(EmptyPolicy) {\n  parameter(\"entityId\".as[Long]) { entityId =>\n    ThirdPartyService.deleteEntity(entityId)\n    complete(s\"entity $entityId deleted\")\n  }\n}\nBoth of the above approaches compile and are valid. Access token holds basic information about the user or the client who has made request.\nPlease go through api documentation to know more about Access Token.","title":"Using Access Token"},{"location":"/services/aas/csw-aas-http.html#policy-expressions","text":"So far, we have seen that security directives can accept an authorization policy. It can however accept an expression of multiple authorization policies too. This could be useful to express complex authorization logic. For example:\nScala val routes: Route =\nsGet(RealmRolePolicy(\"admin\") | CustomPolicy(_.email.contains(\"super-admin@tmt.org\"))) {\n  complete(\"OK\")\n} ~\nsPost(ClientRolePolicy(\"finance_user\") & PermissionPolicy(\"edit\")) {\n  complete(\"OK\")\n}\nNote the | , & operators which helps compose an expression. A Policy expression could be more complex than this and can contain braces to group more expressions. For example:\nval policy = policy1 | (policy2 & (policy3 | policy4)) | policy5","title":"Policy Expressions"},{"location":"/services/aas/csw-aas-http.html#directive-composition","text":"Since security directives extend from akka.http.scaladsl.server.Directive they give you all the benefits of a usual directive. These benefits include being able to label & compose higher level directives.\nWith the help of directive labeling you could write a route like below:\nScala sGet(RealmRolePolicy(\"admin\")) & sGet(ClientRolePolicy(\"sales_admin\"))\nThe same can be achieved via Policy Expressions as shown below\nScala sGet(RealmRolePolicy(\"admin\") & ClientRolePolicy(\"sales_admin\"))\nIf you want to combine two directives and both of them are csw security directives, we strongly recommend that you use Policy Expressions. The reason for this is that, when you combine two csw security directives authentication check happens twice (or multiple times based on how many csw security directives are combined) which was meant to happen only once thus causing performance slowdown. You can however combine csw security directives with other directives freely without worrying about performance.","title":"Directive Composition"},{"location":"/services/aas/csw-aas-http.html#source-code-for-above-examples","text":"Example http server","title":"Source code for above examples"},{"location":"/services/aas/csw-aas-js.html","text":"","title":"Javascript Adapter (csw-aas-js)"},{"location":"/services/aas/csw-aas-js.html#javascript-adapter-csw-aas-js-","text":"csw-aas-js is a npm package which provides react components. UI applications can use these react components which will enable UI application to show or hide components based on authentication and authorization policy.","title":"Javascript Adapter (csw-aas-js)"},{"location":"/services/aas/csw-aas-js.html#dependencies","text":"To use the csw-aas-js adapter, run this command from root folder of your application where package.json exists:\nnpm     npm i --save csw-aas-js@0.1-SNAPSHOT\n yarn     yarn add csw-aas-js@0.1-SNAPSHOT","title":"Dependencies"},{"location":"/services/aas/csw-aas-js.html#components","text":"csw-aas-js exposes react components.\nJavascript export {\n  Logout,\n  Login,\n  CheckLogin,\n  RealmRole,\n  ClientRole,\n  AuthContextProvider,\n  Consumer,\n  AuthContext\n}\nImporting and usage of those components is explained below:","title":"Components"},{"location":"/services/aas/csw-aas-js.html#importing-components","text":"Components can be imported as shown in code snippet below\nJavascript import { Consumer, Logout, Login } from 'csw-aas-js'\ncsw-aas-js exposes following react components:\nAuthContextProvider Consumer Login Logout CheckLogin RealmRole ClientRole","title":"Importing components"},{"location":"/services/aas/csw-aas-js.html#authcontextprovider","text":"AuthContextProvider is wrapper over provider from react context API. It expects config json to be passed. This config json is UI application specific AAS server configuration e.g. clientId, realm. When user loges in AAS Server is instantiated by merging UI application specific config and predefined configuration. UI application can choose to override predefined json configuration. Once AAS sever is instantiated, auth object is updated with needed attributes and apis. This auth is available to all react components. Auth Context is designed to share data that can be considered “global” for a tree of React components and is available via Consumer. All consumers that are descendants of a Provider will re-render whenever the AuthContextProvider’s state changes i.e auth. Recommended way is use AuthContextProvider to wrap entire application so that data can be shared anywhere in application via Consumer.\nJavascript <AuthContextProvider config={config}>\n  <BrowserRouter>\n    <div>\n      <NavComponent />\n      <Route\n        exact\n        path='/secured'\n        render={_ => (\n          <CheckLogin error={<ExampleError />}>\n            <Write />\n          </CheckLogin>\n        )}\n      />\n      <Route exact path='/public' component={Read} />\n    </div>\n  </BrowserRouter>\n\n  {\n    <RealmRole realmRole='example-admin-role' error={<ExampleError />}>\n      <div>Example admin role specific functionality</div>\n    </RealmRole>\n  }\n  {\n    <ClientRole\n      clientRole='person-role'\n      client='example-server'\n      error={<ExampleError />}>\n      <div>Person role specific functionality</div>\n    </ClientRole>\n  }\n\n</AuthContextProvider>","title":"AuthContextProvider"},{"location":"/services/aas/csw-aas-js.html#source-code-for-realmrole-component","text":"AuthContextProvider Component","title":"Source code for RealmRole component"},{"location":"/services/aas/csw-aas-js.html#consumer","text":"Consumer is similar to consumer from react context api. auth can be accessed using Consumer component\nJavascript <Consumer>\n  { ({auth}) => {\n    return <div className='nav-wrapper'>\n      { (auth && auth.isAuthenticated()) ? <div>\n          Hello, you are logged in\n        <div>Open functionality</div>\n      </div>\n        : <div>\n          Hello, you are not logged in\n          <div>Open functionality</div>\n        </div>\n      }\n    </div>\n  }\n  }\n</Consumer>","title":"Consumer"},{"location":"/services/aas/csw-aas-js.html#source-code-for-realmrole-component","text":"Consumer Component","title":"Source code for RealmRole component"},{"location":"/services/aas/csw-aas-js.html#login","text":"Login component instantiate AAS server with configurations provided. It redirects to AAS server login page for user to login. After login auth in context is updated with appropriate values e.g. token, realm & client roles etc.\nJavascript <Login />","title":"Login"},{"location":"/services/aas/csw-aas-js.html#source-code-for-login-component","text":"Login Component","title":"Source code for Login component"},{"location":"/services/aas/csw-aas-js.html#logout","text":"Logout component logs out user from AAS server. It clears auth stored in context.\nJavascript <Logout />","title":"Logout"},{"location":"/services/aas/csw-aas-js.html#source-code-for-logout-component","text":"Logout Component","title":"Source code for Logout component"},{"location":"/services/aas/csw-aas-js.html#checklogin","text":"CheckLogin components provides ability to show something only if user is logged in. In the following code snippet Write is a react component is shown only if user is logged in. Behaviour is user is not logged in can be defined by html element or react component and that can be passed to error prop e.g - ExampleError Component in following snippet\nJavascript <CheckLogin error={<ExampleError />}>\n  <Write />\n</CheckLogin>","title":"CheckLogin"},{"location":"/services/aas/csw-aas-js.html#source-code-for-checklogin-component","text":"CheckLogin Component","title":"Source code for CheckLogin component"},{"location":"/services/aas/csw-aas-js.html#realmrole","text":"RealmRole components provides ability to show something only if user is logged in and has specified realm role. In the following code snippet div is shown only if user is logged in and has realm role specified in realmRole prop Behaviour is user is not logged in can be optionally defined by html element or react component and that can be passed to error prop e.g - ExampleError Component in following snippet.\nJavascript <RealmRole realmRole='example-admin-role' error={<ExampleError />}>\n  <div>Example admin role specific functionality</div>\n</RealmRole>","title":"RealmRole"},{"location":"/services/aas/csw-aas-js.html#source-code-for-realmrole-component","text":"RealmRole Component","title":"Source code for RealmRole component"},{"location":"/services/aas/csw-aas-js.html#clientrole","text":"ClientRole components provides ability to show something only if user is logged in and has specified client role for specified client. In the following code snippet div is shown only if user is logged in and has client role specified in clientRole prop for client specified in client prop. Behaviour is user is not logged in can be optionally defined by html element or react component and that can be passed to error prop e.g - ExampleError Component in following snippet.\nJavascript <ClientRole\n  clientRole='person-role'\n  client='example-server'\n  error={<ExampleError />}>\n  <div>Person role specific functionality</div>\n</ClientRole>","title":"ClientRole"},{"location":"/services/aas/csw-aas-js.html#source-code-for-clientrole-component","text":"ClientRole Component","title":"Source code for ClientRole component"},{"location":"/services/aas/csw-aas-installed.html","text":"","title":"Installed Auth Adapter (csw-aas-installed)"},{"location":"/services/aas/csw-aas-installed.html#installed-auth-adapter-csw-aas-installed-","text":"csw-aas-installed is the adapter you will use if you want to build an that executes on user’s machine & talks to auth-protected web service application. Examples of such applications could be a CLI app that is installed on end users machine.","title":"Installed Auth Adapter (csw-aas-installed)"},{"location":"/services/aas/csw-aas-installed.html#dependencies","text":"To use the Akka HTTP Adapter (csw-aas-installed), add this to your build.sbt file:\nsbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-aas-installed\" % \"0.1-SNAPSHOT\"","title":"Dependencies"},{"location":"/services/aas/csw-aas-installed.html#prerequisites","text":"To run a client app that is installed on user’s machine, which needs to talk to a protected http server, we need\nlocation service running Keycloak instance running and registered with location service protected http server running\nAll of these can be running on different machines. To start location service & keycloak server on a local machine, you make make use of csw-services.sh script.","title":"Prerequisites"},{"location":"/services/aas/csw-aas-installed.html#application-configurations","text":"All auth related configurations go inside auth-config block. There are two configurations applicable for a public cli client application i.e. realm & client-id.\nrealm has a default value of TMT if not specified. Ideally all apps in TMT should not have to override this, however it might be useful to override this while testing your app.\nclient-id is a mandatory configuration which specifies the client id of the app as per registration in keycloak.\nauth-config {\n  realm = TMT # DEFAULT\n  client-id = demo-cli # REQUIRED\n}","title":"Application Configurations"},{"location":"/services/aas/csw-aas-installed.html#building-a-cli-application","text":"Let’s say that we have an existing akka-http application which has some open and some protected routes and we want to build a CLI client which accesses these routes.\nThis is what the routes look like:\nScala var data: Set[String] = Set.empty\n\nval routes: Route =\n  pathPrefix(\"data\") {\n    get { // un-protected route for reading data\n      pathEndOrSingleSlash { // e.g HTTP GET http://localhost:7000/data\n        complete(data)\n      }\n    } ~ sPost(RealmRolePolicy(\"admin\")) { // only users with 'admin' role is allowed for this route\n      parameter(\"value\") { value => // e.g POST GET localhost:7000/data?value=abc\n        data = data + value\n        complete(StatusCodes.OK)\n      }\n    }\n  }\nNote To know more about how to create secure web apis, please go through Akka HTTP Adapter - csw-aas-http\nWe will create a CLI application that has following commands:\ncommand description login performs user authentication logout logs user out read reads data from server write {content} writes data to server\nLet’s begin with Main.scala\nScala object Main extends App {\n\n  LocationServerStatus.requireUpLocally()\n\n  implicit val actorSystem: ActorSystem = ActorSystem()\n\n  val adapter: InstalledAppAuthAdapter = AdapterFactory.makeAdapter\n\n  val command: Option[AppCommand] = CommandFactory.makeCommand(adapter, args)\n\n  try {\n    command.foreach(_.run())\n  } finally {\n    actorSystem.terminate()\n  }\n}\nThe statement LocationServerStatus.requireUpLocally() ensures that location service is up and running before proceeding further. If location service is not running, it will throw an exception and exit the application.\nNote In a real application, you would ideally want to use LocationServerStatus.requireUp which takes locationHost: String parameter instead of looking for location service on localhost.\nNext, we will instantiate InstalledAppAuthAdapter. There is a factory already available to create the required instance. We will create a small factory on top this factory to keep our Main.scala clean.\nScala object AdapterFactory {\n  def makeAdapter(implicit actorSystem: ActorSystem): InstalledAppAuthAdapter = {\n    implicit val ec: ExecutionContextExecutor = actorSystem.dispatcher\n    implicit val mat: Materializer            = ActorMaterializer()\n    val locationService: LocationService      = HttpLocationServiceFactory.makeLocalClient(actorSystem, mat)\n    val authStore                             = new FileAuthStore(Paths.get(\"/tmp/demo-cli/auth\"))\n    InstalledAppAuthAdapterFactory.make(locationService, authStore)\n  }\n}\nNote the the internal factory overload we have used, requires two parameters, i.e. location service & authStore. It needs location service to resolve keycloak server. FileAuthStore is just a storage for tokens for it to save access tokens & refresh tokens in file system.\nWarning In this case we have configured it to store all tokens in “/tmp/demo-cli/auth” directory but ideally you want this location to be somewhere in user’s home directory. This will ensure that different users don’t have access to each other’s tokens.\nComing back to Main.scala, now we need to find out which command user wants to execute. To parse user input arguments, we will create a small utility.\nScala object CommandFactory {\n  def makeCommand(adapter: InstalledAppAuthAdapter,\n                  args: Array[String])(implicit actorSystem: ActorSystem): Option[AppCommand] = {\n    args match {\n      case Array(\"login\")          => Some(new LoginCommand(adapter))\n      case Array(\"logout\")         => Some(new LogoutCommand(adapter))\n      case Array(\"read\")           => Some(new ReadCommand)\n      case Array(\"write\", content) => Some(new WriteCommand(adapter, content))\n      case _ =>\n        println(\"invalid or no command\\nvalid commands are: login, logout, read & write\")\n        None\n    }\n  }\n}\nAll of these commands extend from a simple trait - AppCommand\nScala trait AppCommand {\n  def run(): Unit\n}\nNote We could have used a command line parser library here to parse the command names and options/arguments, but since our requirements are simple and this is a demonstration, we will keep things simple. However, we strongly recommend that you use one of the existing libraries. CSW makes extensive use of scopt. There are other libraries which are equally good and easy to use\nLet’s go through each command one by one","title":"Building a CLI Application"},{"location":"/services/aas/csw-aas-installed.html#login","text":"Scala class LoginCommand(val installedAppAuthAdapter: InstalledAppAuthAdapter) extends AppCommand {\n  override def run(): Unit = {\n    installedAppAuthAdapter.login()\n    println(\"SUCCESS : Logged in successfully\")\n  }\n}\nHere the constructor takes InstalledAppAuthAdapter as a parameter and in the run method, it calls installedAppAuthAdapter.login(). This method, opens a browser and redirects user to TMT login screen (served by keycloak). In the background, it starts an http server on a random port. Once the user submits correct credentials on the login screen, keycloak redirects user to http://localhost:[RandomPort] with the access and refresh tokens in query string. The InstalledAppAuthAdapter will then save these token in file system using FileAuthStore. After this, InstalledAppAuthAdapter will shut down the local server since it’s purpose is served. Now, user can close the browser.\nIf you want to develop an CLI app that is not dependent on browser, you can call loginCommandLine() method instead of login(). This will prompt credentials in CLI instead of opening a browser.\nNote It may be tempting to use the loginCommandLine() method, however a browser is generally more user-friendly since it can store cookies & remember passwords.","title":"Login"},{"location":"/services/aas/csw-aas-installed.html#logout","text":"Scala class LogoutCommand(val installedAppAuthAdapter: InstalledAppAuthAdapter) extends AppCommand {\n  override def run(): Unit = {\n    installedAppAuthAdapter.logout()\n    println(\"SUCCESS : Logged out successfully\")\n  }\n}\nThe structure here is very similar to login command. installedAppAuthAdapter.logout() clears all the tokens from file system via FileAuthStore.","title":"Logout"},{"location":"/services/aas/csw-aas-installed.html#read","text":"Scala class ReadCommand(implicit val actorSystem: ActorSystem) extends AppCommand {\n  override def run(): Unit = {\n    val url      = \"http://localhost:7000/data\"\n    val response = Await.result(Http().singleRequest(HttpRequest(uri = Uri(url))), 2.seconds)\n    println(convertToString(response.entity))\n  }\n}\nSince in the akka-http routes, the get route is not protected by any authentication or authorization, read command simply sends a get request and prints the response.","title":"Read"},{"location":"/services/aas/csw-aas-installed.html#write","text":"Scala class WriteCommand(val installedAppAuthAdapter: InstalledAppAuthAdapter, value: String)(implicit val actorSystem: ActorSystem)\n    extends AppCommand {\n  override def run(): Unit = {\n\n    installedAppAuthAdapter.getAccessTokenString() match {\n      case Some(token) =>\n        val bearerToken = headers.OAuth2BearerToken(token)\n        val url         = s\"http://localhost:7000/data?value=$value\"\n        val response =\n          Await.result(\n            Http().singleRequest(\n              HttpRequest(\n                method = HttpMethods.POST,\n                uri = Uri(url),\n                headers = List(headers.Authorization(bearerToken))\n              )\n            ),\n            2.seconds\n          )\n\n        response.status match {\n          case StatusCodes.OK           => println(\"Success\")\n          case StatusCodes.Unauthorized => println(\"Authentication failed\")\n          case StatusCodes.Forbidden    => println(\"Permission denied\")\n          case code                     => println(s\"Unrecognised error: http status code = ${code.value}\")\n        }\n\n      case None =>\n        println(\"you need to login before executing this command\")\n        System.exit(1)\n    }\n  }\n}\nWrite command constructor takes InstalledAppAuthAdapter & a string value. This string value is expected from the CLI input. Since in the akka-http routes, the post route is protected by a realm role policy, we need to pass bearer token in the request header.\ninstalledAppAuthAdapter.getAccessTokenString() returns Option[String] if it is None, it means that user has not logged in and so we display an error message stating the same. If it returns a token string, we pass it in the header.\nIf the response status code is 200, it means authentication and authorization were successful. In this case authorization required that the user had admin role.\nIf the response is 401, it indicates that there was something wrong with the token. It could indicate that token is expired or does not have valid signature. InstalledAppAuthAdapter ensures that you don’t send a request with an expired token. If the access token is expired, it refreshes the access token with the help of a refresh token. If the refresh token is also expired, it returns None which means that user has to log in again.\nIf the response is 403, it indicates that token was valid but the token is not authorized to perform certain action. In this case if the token belonged to a user who does not have admin role, server will return 403.","title":"Write"},{"location":"/services/aas/csw-aas-installed.html#source-code-for-above-examples","text":"Example","title":"Source code for above examples"},{"location":"/commons/apps.html","text":"","title":"Applications"},{"location":"/commons/apps.html#applications","text":"Starting Apps for Development csw-location-server csw-admin-server csw-location-agent csw-config-server csw-config-cli csw-event-cli csw-alarm-cli csw-host-config","title":"Applications"},{"location":"/commons/apps.html#starting-apps-for-development","text":"In order to run a component it is required to run csw-location-server. Moreover, even to start event service or configuration service, csw-location-server should be running.\nBut for developers to start csw-location-server first and then configuration service and then event service is a tedious job. So, for development purpose, it is recommended to use a shell script which will start csw-location-server and/or configuration service and/or event service and/or alarm service.\nAssuming that developer has downloaded csw-apps-<some-version>.zip from csw releases and unzipped it.\nThere are three folders, as follows, in csw-apps-<some-version> * bin * lib * and conf.\nAll the shell scripts provided by csw reside in bin folder. The shell script referred in this segment is named as csw-services.sh. Go to the bin folder and hit ./csw-services.sh --help. This will list all possible options applicable for the script.\nNote This shell script will start csw-location-server as the first step regardless of any options provided.\nThe execution of the script is such that it starts csw-location-server, then checks whether to start configuration service from provided options.\nPossible options to start services are explained below:\n--auth if provided, starts authentication service. --config if provided, starts configuration service. --event if provided, starts event service. --alarm if provided, starts alarm service. --database if provided, starts database service. It is important to set PGDATA env var to start the postgres server. See --help for more details\nNote While starting database service, make sure that PGDATA environment variable is set to postgres data directory where postgres is installed e.g. for mac: “/usr/local/var/postgres” and there is a password set for the valid Postgres user. If not, go to postgres shell via psql and run ALTER USER <username> WITH PASSWORD '<mypassword>';. If there is any problem entering postgres shell, go to conf folder -> database_service -> pg_hba.conf and change password to trust. Try entering postgres shell again and set the password. Once set successfully, revert trust to password in pg_hba.conf and run database service via csw-services.sh.\nWith this, the component code is now ready to connect to provided services via csw-services.sh.","title":"Starting Apps for Development"},{"location":"/apps/cswlocationserver.html","text":"","title":"csw-location-server"},{"location":"/apps/cswlocationserver.html#csw-location-server","text":"Note: Normally you will not need to start this application manually. The csw-services.sh script does this for you.\nThis application will start a HTTP CSW location server on port 7654 which is required for all Location service consumers who uses HTTP Location client. All the components (HCD’s, Assemblies, Services etc.) uses local HTTP location client which expects location server running at localhost:7654. In a production environment, it is required that all machines running components should have HTTP location server running locally.","title":"csw-location-server"},{"location":"/apps/cswlocationserver.html#prerequisite","text":"The CSW location server application can be installed as binaries or constructed from source. To download the application, go to the CSW Release page and follow instructions.\nTo install from source, the command sbt csw-location-server/universal:publishLocal will publish necessary artifacts to run csw-location-server application. The target of above command is a zip file titled “csw-location-server.zip” and its path will be printed on console.\nNote: An alternative method is to run sbt publishLocal stage, which installs all the dependencies locally and also installs all the csw applications in target/universal/stage/bin.\nUnzip either the downloaded or constructed zip file and switch current working directory to the extracted folder. Choose appropriate instructions from below based on requirement ie single machine or multiple machines.","title":"Prerequisite"},{"location":"/apps/cswlocationserver.html#starting-location-server-on-a-single-machine","text":"The steps below describe how to run location server on a single machine. This can be a requirement for testing or demo purpose.\nPreparation: Find out the IP address and dedicated port for running the location server. Assume that IP is 192.168.1.21 and port is 3552.\nProvisioning: Make sure you have the environment variable clusterSeeds set to the IP address and port as in 192.168.1.21:3552\nRunning: Switch to application directory and run this command - ./bin/csw-location-server --clusterPort=3552","title":"Starting Location Server on a single machine"},{"location":"/apps/cswlocationserver.html#starting-location-server-on-two-machines","text":"The steps below describe how to run location server on multiple machines, which is the recommended set-up for production usage.\nPreparation: Identify machines which are running location server and whose IP and port are known. Let’s assume they are two for now, and the IP address for machine1 is 192.168.1.21 and for machine2 is 192.168.1.22. Also, they will both have dedicated port 3552 to run the location server.\nProvisioning: Make sure you have the environment variable clusterSeeds set to 192.168.1.21:3552,192.168.1.22:3552 on machine1 and machine2.\nSwitch to application directory and run this command on machine1 and machine2 - ./bin/csw-location-server --clusterPort=3552\nNote In some cases it may be necessary to also specify the network interface to use, for example, if the host has multiple network interfaces and the correct one is not used automatically. In this case, you can set the environment variable interfaceName to the name of the network interface to use or pass the --interfaceName=... command line option. Use ifconfig -a to see a list of the available network interfaces.","title":"Starting Location Server on two machines"},{"location":"/apps/cswlocationserver.html#help","text":"Use the following command to get help on the options available with this app.\n./bin/csw-location-server --help","title":"Help"},{"location":"/apps/cswlocationserver.html#version","text":"Use the following command to get version information for this app.\n./bin/csw-location-server --version","title":"Version"},{"location":"/apps/cswadminserver.html","text":"","title":"csw-admin-server"},{"location":"/apps/cswadminserver.html#csw-admin-server","text":"A HTTP server application that supports changing/getting log level of component.","title":"csw-admin-server"},{"location":"/apps/cswadminserver.html#prerequisites","text":"A required check before starting csw-admin-server app is to ensure the csw-cluster is setup and location sever is available so that using HTTP location client, it can resolve components for which log level needs to be fetched/changed.. Kindly refer to CSW Location Server for more information about location server setup.","title":"Prerequisites"},{"location":"/apps/cswadminserver.html#command-line-parameter-options","text":"--port is an optional parameter. When specified the HTTP server will start on this port. Default is 7878. --locationHost is an optional parameter. Indicates the host address of machine where location server is running. Default is localhost. --help prints the help message. --version prints the version of the application.","title":"Command line parameter options"},{"location":"/apps/cswadminserver.html#examples","text":"csw-admin-server\nStart HTTP server on default port 7878.\nNote This requires that location server is running locally\ncsw-admin-server --locationHost 172.1.1.2\nStart HTTP server on default port 7878.\nNote This indicates, location server is running on remote machine having ip address=172.1.1.2\ncsw-admin-server --port 8080\nStart HTTP server on port 8080. csw-admin-server --help\n Prints help message csw-admin-server --version\n Prints application version\n## Accessing csw-admin-server routes via HTTP (curl)\nGet LogMetadata : Returns current log level of component along with default, akka and slf4j log levels.\nRequest: curl -X GET 'http://10.131.21.184:7878/admin/logging/trombone-hcd-akka/level' Response: { \"defaultLevel\": \"DEBUG\", \"akkaLevel\": \"ERROR\", \"slf4jLevel\": \"INFO\", \"componentLevel\": \"DEBUG\" }\nSet Log Level : Sets the log level of component and returns with status code 200 OK\nRequest: curl -X POST 'http://10.131.21.184:7878/admin/logging/trombone-hcd-akka/level?value=DEBUG'\nNote Assuming csw-admin-server is running on IP 10.131.21.184 on port 7878.","title":"Examples"},{"location":"/apps/cswlocationagent.html","text":"","title":"csw-location-agent"},{"location":"/apps/cswlocationagent.html#csw-location-agent","text":"A utility application that starts a given external program, registers a comma separated list of services with the Location Service and unregisters them when the program exits.","title":"csw-location-agent"},{"location":"/apps/cswlocationagent.html#command-line-parameter-options","text":"--names is a required parameter. It needs to be a list of comma separated service names without a space after comma. --command is an optional parameter. The command that starts the target application. Use use %port to specify the port number. If parameter is not provided value $name.command from config file will be picked up. If value in config file is not found, the service names provided will be registered with Location Service. --port the optional port number the application listens on (default: use value of $name.port from config file, or use a random, free port.) an optional config file in HOCON format. Will be automatically picked based on –names parameter (Options specified as: $name.command, $name.port, etc.) --delay the number of milliseconds to wait for the app to start before registering it with the Location Service (default: 1000) --http is an optional parameter. To register services as Http with provided path. (default: none, i.e Services will be registered as Tcp) --no-exit For testing: prevents application from exiting after running command --help Prints the help message. --version Prints the version of the application.","title":"Command line parameter options"},{"location":"/apps/cswlocationagent.html#examples","text":"csw-location-agent --name \"redis\" --command \"redis-server /usr/local/etc/redis.conf\" --port 6379\nApplication will start redis server on port 6379(default redis port) and will register a TcpConnection for the same with Location Service csw-location-agent --name \"foo\" --command \"sleep 30\"\n Application will sleep for 30 seconds. Then, will register a service named foo on a random port with Location Service. Once sleep is over after 30 seconds, will unregister foo service. csw-location-agent --name \"myHttpServiceAsTcp\" --command \"python -m SimpleHTTPServer 8080\" --port 8080\n Application will start a simple HTTP service on port 8080. Then, will register myHttpServiceAsTcp as a TCP service with Location Service. csw-location-agent --name \"myHttpServiceAsHttp\" --command \"python -m SimpleHTTPServer 8080\" --port 8080 --http \"path\"\n Application will start a simple HTTP service on port 8080. Then, will register myHttpServiceAsHttp as a Http service with provided path with Location Service. csw-location-agent --help\n Prints help message csw-location-agent --version\n Prints application version\nNote Before running csw-location-agent, make sure that csw-location-server is running on local machine at localhost:7654. As location agent uses local HTTP location client which expect location server running locally.","title":"Examples"},{"location":"/apps/cswonfigserverapp.html","text":"","title":"csw-config-server"},{"location":"/apps/cswonfigserverapp.html#csw-config-server","text":"A HTTP server application that hosts Configuration Service.","title":"csw-config-server"},{"location":"/apps/cswonfigserverapp.html#prerequisites","text":"The HTTP server hosting Configuration Service needs to be part of csw-cluster so that it can be consumed by other components. A required check before starting configuration service is to ensure the csw-cluster is setup and location server are available. Kindly refer to CSW Location Server for more information about location server setup.","title":"Prerequisites"},{"location":"/apps/cswonfigserverapp.html#command-line-parameter-options","text":"--initRepo is an optional parameter. When supplied, server will try to initialize a repository if it does not exist. --port is an optional parameter. When specified the HTTP server will start on this port. Default will be 4000. --help prints the help message. --version prints the version of the application.","title":"Command line parameter options"},{"location":"/apps/cswonfigserverapp.html#examples","text":"csw-config-server --initRepo\nStart HTTP server on default port 4000. Initialize repository if it does not exist and register it with Location Service csw-config-server --initRepo --port 4001\n Start HTTP server on port 4001. Initialize repository if it does not exist and register it with Location Service csw-config-server --help\n Prints help message csw-config-server --version\n Prints application version\nNote Before running csw-config-server, make sure that csw-location-server is running on local machine at localhost:7654. As config server uses local HTTP location client which expect location server running locally.","title":"Examples"},{"location":"/apps/cswconfigcli.html","text":"","title":"csw-config-cli"},{"location":"/apps/cswconfigcli.html#csw-config-cli","text":"A command line application that facilitates interaction with Configuration Service. It accepts various commands to store, retrieve, list and manage configuration files.","title":"csw-config-cli"},{"location":"/apps/cswconfigcli.html#supported-commands","text":"login logout create update get delete list history setActiveVersion resetActiveVersion getActiveVersion getActiveByTime getMetadata exists getActive","title":"Supported Commands"},{"location":"/apps/cswconfigcli.html#login","text":"create, update, delete, setActiveVersion & resetActiveVersion commands are admin protected. In order to use those, you need to login first. You need to have valid user name and password to login which has admin role assigned to it.","title":"login"},{"location":"/apps/cswconfigcli.html#examples","text":"csw-config-cli login\"\nThis opens up default browser on your machine and asks to provide username and password. Once you provide valid credentials, auth server will respond with access token, refresh token etc. which gets stored in local filesystem. So next time when you use any of the above admin protected commands, this access token gets retrieved from local filesystem and implicitly passed in a request sent to config server. csw-config-cli login --consoleLogin\"\n Instead of opening default browser on your machine, this will prompt for username and password on the console. (You do not need to leave console in this case.)","title":"Examples"},{"location":"/apps/cswconfigcli.html#logout","text":"Use this command to logout if you are already logged in or you want to re-login with different credentials.","title":"logout"},{"location":"/apps/cswconfigcli.html#example","text":"csw-config-cli logout\"\nThis command will delete all the tokens stored in local filesystem.","title":"Example"},{"location":"/apps/cswconfigcli.html#admin-api","text":"The commands listed below will be used by administrators and maintainers of Configuration Service.","title":"Admin API"},{"location":"/apps/cswconfigcli.html#create","text":"Takes an input source file and creates the configuration in the repository at a specified path.\n‘relativeRepoPath’ is path in the repository -i, --in is input file path --annex is optional parameter. Add this option to specify if the input file must be save to annex store. It usually is the case if file is binary/large(>10 MiB) -c, --comment optional create comment","title":"create"},{"location":"/apps/cswconfigcli.html#examples","text":"csw-config-cli create /path/hcd/trombone.conf -i /Users/admin/configs/trombone.conf -c \"Initial version\"\nCreates a config file at path /path/hcd/trombone.conf, using local file at /Users/admin/configs/trombone.conf, with Initial version as a comment. csw-config-cli create /path/hcd/trombone.conf -i /Users/admin/large-configs/bigBinary.conf --annex\n Creates a config file at path /path/hcd/trombone.conf, using local file at /Users/admin/large-configs/bigBinary.conf, file will be stored in annex store.","title":"Examples"},{"location":"/apps/cswconfigcli.html#update","text":"Overwrites the file specified in the repository by the input file.\n‘path’ is path in the repository -i, --in is input file path -c, --comment optional create comment","title":"update"},{"location":"/apps/cswconfigcli.html#example","text":"csw-config-cli update /path/hcd/trombone.conf -i /Users/foo/new_trombone.conf -c \"new conf for next observation\"\nUpdates repository file /path/hcd/trombone.conf, with a local file at /Users/foo/new_trombone.conf, using a specified comment.","title":"Example"},{"location":"/apps/cswconfigcli.html#get","text":"Retrieves a file for a given path and saves it to the output file. The latest file is fetched if neither date nor id is specified.\n‘relativeRepoPath’ is path in the repository. -o, --out is output file path --id optional. if specified this id will be matched --date optional. if specified will get the file matching this date. Format: 2017-04-16T16:15:23.503Z","title":"get"},{"location":"/apps/cswconfigcli.html#examples","text":"1.\ncsw-config-cli get /path/hcd/trombone.conf -o /Users/bar/temp/latest_trombone.conf\nGets repository file /path/hcd/trombone.conf, stores at local disk location /Users/bar/temp/latest_trombone.conf\n2.\ncsw-config-cli get /path/hcd/trombone.conf -o /Users/bar/temp/old_trombone.conf --id 10\nGets version revision 10 of repository file /path/hcd/trombone.conf, stores at local disk location /Users/bar/temp/old_trombone.conf","title":"Examples"},{"location":"/apps/cswconfigcli.html#delete","text":"Deletes the file at the specified path in the repository.\n‘relativeRepoPath’ is path in the repository -c, --comment optional delete comment","title":"delete"},{"location":"/apps/cswconfigcli.html#example","text":"csw-config-cli delete /path/hcd/outdated_trombone.conf -c monthly maintainance activity\nDeletes repository file /path/hcd/outdated_trombone.conf if it exists using a comment","title":"Example"},{"location":"/apps/cswconfigcli.html#list","text":"Lists the files in the repository. Can’t use ‘–annex’ and ‘–normal’ together.\n--annex optional parameter. List all files that are of annex type. --normal optional parameter. List all files that are of normal type. --pattern optional parameter. List all files whose path matches the given pattern. e.g. “/path/hcd/*.*”, “a/b/c/d.*”, “.*.conf”, “.*hcd.*”","title":"list"},{"location":"/apps/cswconfigcli.html#history","text":"Shows the version history of the file in the repository.\n‘relativeRepoPath’ is path in the repository --max optional parameter. maximum no of files to be retrieved","title":"history"},{"location":"/apps/cswconfigcli.html#example","text":"csw-config-cli history /path/hcd/trombone.conf --max 25\nPrints history of repository file /path/hcd/trombone.conf, with only 25 entries.","title":"Example"},{"location":"/apps/cswconfigcli.html#setactiveversion","text":"Sets the active version of the file in the repository.\n‘relativeRepoPath’ is path in the repository --id optional parameter. version id of the repository file to set as active. -c, --comment optional delete comment","title":"setActiveVersion"},{"location":"/apps/cswconfigcli.html#example","text":"csw-config-cli setActiveVersion /path/hcd/trombone.conf --id 4 -c restoring last successful version.\nSets revision 4 to be active for repository file /path/hcd/trombone.conf, using a comment.","title":"Example"},{"location":"/apps/cswconfigcli.html#resetactiveversion","text":"Resets the active version to the latest version for the specified file path.\n‘relativeRepoPath’ is path in the repository -c, --comment optional reset comment","title":"resetActiveVersion"},{"location":"/apps/cswconfigcli.html#example","text":"csw-config-cli resetActiveVersion /path/hcd/trombone.conf -c testing most recent config\nSets latest revision to be active for repository file /path/hcd/trombone.conf, using a comment.","title":"Example"},{"location":"/apps/cswconfigcli.html#getactiveversion","text":"Gets the id of the active version of the file in the repository.\n‘relativeRepoPath’ is path in the repository","title":"getActiveVersion"},{"location":"/apps/cswconfigcli.html#example","text":"csw-config-cli getActiveVersion /path/hcd/trombone.conf\nGets active version ID for repository file /path/hcd/trombone.conf.","title":"Example"},{"location":"/apps/cswconfigcli.html#getactivebytime","text":"Gets the file that was active at a specified time.\n‘relativeRepoPath’ is path in the repository -o, --out is output file path --date optional. if specified will get the active file matching this date. Format: 2017-04-16T16:15:23.503Z","title":"getActiveByTime"},{"location":"/apps/cswconfigcli.html#example","text":"csw-config-cli getActiveByTime /path/hcd/trombone.conf -o /usr/tmp/last_week_trombone.conf --date 2017-05-09T07:29:53.242Z\nGets version of repository file /path/hcd/trombone.conf, that was active on 2017-05-09T07:29:53.242Z and saves it on local disk.","title":"Example"},{"location":"/apps/cswconfigcli.html#getmetadata","text":"Gets the metadata of Configuration Service server e.g. repository directory, annex directory, min annex file size, max config file size.","title":"getMetadata"},{"location":"/apps/cswconfigcli.html#example","text":"csw-config-cli getMetadata\nPrints the metadata on screen.","title":"Example"},{"location":"/apps/cswconfigcli.html#client-api","text":"The following commands are available for component developers.","title":"Client API"},{"location":"/apps/cswconfigcli.html#exists","text":"Checks if the file exists at specified path in the repository.\n‘relativeRepoPath’ is path in the repository","title":"exists"},{"location":"/apps/cswconfigcli.html#example","text":"csw-config-cli exists /path/hcd/trombone.conf\nTrue if repository file /path/hcd/trombone.conf exists, false otherwise","title":"Example"},{"location":"/apps/cswconfigcli.html#getactive","text":"Retrieves active file for a given path from Configuration Service and writes it to the output file. * ‘relativeRepoPath’ is path in the repository * -o, --out is output file path","title":"getActive"},{"location":"/apps/cswconfigcli.html#example","text":"csw-config-cli getActive /path/hcd/trombone.conf -o /Users/bar/temp/scheduled_trombone.conf\nGets currently active version of repository file /path/hcd/trombone.conf, stores at local disk location /Users/bar/temp/scheduled_trombone.conf","title":"Example"},{"location":"/apps/cswconfigcli.html#about-this-application","text":"","title":"About this application"},{"location":"/apps/cswconfigcli.html#help","text":"Prints the help message.","title":"–help"},{"location":"/apps/cswconfigcli.html#version","text":"Prints the version of the application.\nNote All the above examples require that csw-location-server is running on local machine at localhost:7654. If csw-location-server is running on remote machine having Ip address 172.1.1.2, then you need to pass additional --locationHost 172.1.1.2 command line argument. Example: csw-config-cli getMetadata --locationHost 172.1.1.2","title":"–version"},{"location":"/apps/csweventcli.html","text":"","title":"csw-event-cli"},{"location":"/apps/csweventcli.html#csw-event-cli","text":"A command line application that facilitates interaction with Event Service. It accepts various commands to publish and subscribe to events.","title":"csw-event-cli"},{"location":"/apps/csweventcli.html#supported-commands","text":"inspect get publish subscribe","title":"Supported Commands"},{"location":"/apps/csweventcli.html#inspect","text":"Takes a comma separated list of events and displays event’s parameter information which includes key name, key type and unit along with metadata (event key, timestamp & id).\n-e, --events : comma separated list of events to inspect","title":"inspect"},{"location":"/apps/csweventcli.html#examples-","text":"csw-event-cli inspect -e wfos.prog.cloudcover,wfos.prog.filter\nNote inspect command does not display parameter values. To view values, use get command instead.","title":"Examples:"},{"location":"/apps/csweventcli.html#get","text":"Takes a comma separated list of events with nested key paths and displays event information including values either in oneline or json format.\n-e, --events comma separated list of events in the form of <event1:key1>,<event2:key2:key3>, use : to separate multiple keys for same event. Ex. -e a.b.c:struct1/ra,x.y.z:struct2/dec:epoch -o, --out output format, default is oneline -t, --timestamp display timestamp --id display event id -u, --units display units","title":"get"},{"location":"/apps/csweventcli.html#examples-","text":"csw-event-cli get -e wfos.prog.cloudcover\nDisplays all keys information in oneline form for event wfos.prog.cloudcover csw-event-cli get -e wfos.prog.cloudcover:struct1/ra:epoch -t --id -u\n Displays information of only struct1/ra and epoch keys as well as timestamp, event id and units of provided keys in oneline form for event wfos.prog.cloudcover csw-event-cli get -e wfos.prog.cloudcover:epoch,wfos.prog.filter:ra\n Displays information of epoch of event wfos.prog.cloudcover and ra key of event wfos.prog.filter:ra csw-event-cli get -e wfos.prog.cloudcover:epoch -o json\n Displays event wfos.prog.cloudcover with only epcoh key in JSON format.\nNote -t, --id & --u options are not applicable when -o json option is provided. Event displayed in json format will always have timestamp, event id and units irrespective of whether those options are provided or not via CLI.","title":"Examples:"},{"location":"/apps/csweventcli.html#publish","text":"Publishes an event to event server from provided input data file or CLI params.\n-e, --event event key to publish --data absolute file path which contains event in JSON format --params pipe ‘|’ separated list of params enclosed in double quotes in the form of \"keyName:keyType:unit=values| ...\". unit is optional here. Supported key types are: [i = IntKey | s = StringKey | f = FloatKey | d = DoubleKey | l = LongKey | b = BooleanKey]. You can optionally choose to enclose param values in [, ] brackets. Values of string key should be provided in single quotes and use backslash to escape string. Ex. \"addressKey:s=['Kevin O\\'Brien','Chicago, USA']|timestampKey:s=['2016-08-05T16:23:19.002']\" -i, --interval interval in <ms> to publish event, single event will be published if not provided -p, --period publish events for this duration <seconds> on provided interval. Default is 2147483 seconds.\nNote If --data & --params are provided together, then event is generated from both --data file & --params option. --params takes a precedence and overrides params from event data file if it is already present in the file. Option -p should be used with -i, otherwise -p is ignored.","title":"publish"},{"location":"/apps/csweventcli.html#examples-","text":"csw-event-cli publish -e wfos.prog.cloudcover --data /path/to/event.json\nCreates event from provided JSON file and publishes same with key wfos.prog.cloudcover to event server. csw-event-cli publish -e wfos.prog.cloudcover --data /path/to/event.json -i 500 -p 60\n Creates event from provided JSON file and publishes same event at every 500ms for duration of 60s. csw-event-cli publish -e wfos.prog.cloudcover --params \"k1:s=['Kevin O\\'Brien','Chicago, USA']|k2:s=['2016-08-05T16:23:19.002']\"\n First fetches already published event for key wfos.prog.cloudcover from event server and then updates that event with provided --params If provided keys are already present in existing event, then those will be updated else new param entries will be added to event. If no event is published in past for provided key, then new event gets created with provided params and event key.","title":"Examples:"},{"location":"/apps/csweventcli.html#subscribe","text":"Takes a comma separated list of events with nested key paths and displays continuous stream of event information as soon as it receives event.\n-e, --events comma separated list of events in the form of <event1:key1>,<event2:key2:key3>, use : to separate multiple keys for same event. Ex. -e a.b.c:struct1/ra,x.y.z:struct2/dec:epoch -i, --interval interval in <ms>, receive an event exactly at each interval -o, --out output format, default is oneline -t, --timestamp display timestamp --id display event id -u, --units display units","title":"subscribe"},{"location":"/apps/csweventcli.html#examples-","text":"csw-event-cli subscribe -e wfos.prog.cloudcover\nSubscribes to event key wfos.prog.cloudcover and displays all keys information as soon as there is an event published for key wfos.prog.cloudcover in the form of oneline. csw-event-cli subscribe -e wfos.prog.cloudcover:struct1/ra:epoch -t --id -u\n Subscribes to event key wfos.prog.cloudcover and displays information of only struct1/ra and epoch keys along with timestamp, event id and units of provided keys in oneline form as soon as there is an event published for key wfos.prog.cloudcover. csw-event-cli subscribe -e wfos.prog.cloudcover -i 500\n Subscribes to event key wfos.prog.cloudcover and displays all keys information at provided interval <500ms>. Irrespective of whether there are multiple events published for key wfos.prog.cloudcover within 500ms interval or not, at every tick (i.e. 500ms), latest event information will be displayed on the console. csw-event-cli subscribe -e wfos.prog.cloudcover:epoch -o json\n Subscribes to event key wfos.prog.cloudcover and displays only epoch key information as soon as there is an event published for key wfos.prog.cloudcover in the form of JSON.\nNote -t, --id & --u options are not applicable when -o json option is provided. Event displayed in json format will always have timestamp, event id and units irrespective of whether those options are provided or not via CLI.","title":"Examples:"},{"location":"/apps/csweventcli.html#about-this-application","text":"","title":"About this application"},{"location":"/apps/csweventcli.html#help","text":"Prints the help message.","title":"--help"},{"location":"/apps/csweventcli.html#version","text":"Prints the version of the application.\nNote All the above examples require that csw-location-server is running on local machine at localhost:7654. If csw-location-server is running on remote machine having Ip address 172.1.1.2, then you need to pass additional --locationHost 172.1.1.2 command line argument. Example: csw-event-cli get -e wfos.prog.cloudcover --locationHost 172.1.1.2","title":"--version"},{"location":"/apps/csweventcli.html#testing-development","text":"While testing or development, in order to use this CLI application, below prerequisites must be satisfied:\ncsw-location-server application is running. csw-location-agent application is running, which has started event server and registered it to location service.\nPlease refer Starting Apps for Development section for more details on how to start these applications using csw-services.sh script.","title":"Testing/Development"},{"location":"/apps/csweventcli.html#monitor-statistics","text":"Event Service uses redis as a event store. Using redis-cli, you can monitor continuous stats about Event service.\n$ redis-cli --stat\n------- data ------ --------------------- load -------------------- - child -\nkeys       mem      clients blocked requests            connections\n305        20.70M   605     0       1771418 (+0)        615\n305        20.71M   605     0       1825363 (+53945)    615\n305        20.70M   605     0       1877638 (+52275)    615\n305        20.71M   605     0       1910198 (+32560)    615\n305        20.71M   605     0       1960837 (+50639)    615\n305        20.74M   605     0       2001565 (+40728)    615\nIn above example, new line is printed every second with useful information and also the difference between the current and old data point.\nkeys: Represents all the keys present in the Redis database which in case of event service are EventKeys clients: Represents total number of clients currently connected to Redis server requests: Represents total number of Redis commands processed along with delta between every interval, in this case 1 second connections: Represents total number of socket connections opened to Redis server\nThe -i <interval> option in this case works as a modifier in order to change the frequency at which new lines are emitted. The default is one second.\nYou can explicitly pass hostname and port of Redis server while running redis-cli\n$ redis-cli -h redis.tmt.org -p 6379\nDetailed list of operations you can perform with redis-cli can be found here","title":"Monitor statistics"},{"location":"/apps/cswalarmcli.html","text":"","title":"csw-alarm-cli"},{"location":"/apps/cswalarmcli.html#csw-alarm-cli","text":"A command line application that facilitates interaction with Alarm Service. It accepts various commands to load and retrieve alarm data, to subscribe to severity and health activities of alarm, and to change current of the state of alarms.","title":"csw-alarm-cli"},{"location":"/apps/cswalarmcli.html#supported-commands","text":"init list acknowledge unacknowledge activate deactivate shelve unshelve reset severity health","title":"Supported Commands"},{"location":"/apps/cswalarmcli.html#admin-api","text":"The commands listed below will be used by administrators of the alarm service.","title":"Admin API"},{"location":"/apps/cswalarmcli.html#init","text":"Loads the alarm data in the alarm store\nfile path - is a required parameter. Can be of local disk or config server (by default it will be picked from the config service. --local - this specifies that config file must be picked up from local disk --reset - this is an optional parameter to clear previous data before loading the new one. By default it will be false.","title":"init"},{"location":"/apps/cswalarmcli.html#examples","text":"csw-alarm-cli init /path/allAlarms.conf --local --reset\nClears the alarm store and loads alarm data to alarm store from /path/allAlarms.conf which is a path of a local file.","title":"Examples"},{"location":"/apps/cswalarmcli.html#list","text":"Gets the data of alarms from alarm store. If none of the optional parameters are given then by default, data of all alarms will be displayed.\n--subsystem - is an optional parameter to get the data of a specific subsystem’s alarms --component - is an optional parameter to get the data of a specific component’s alarms. --subsystem must be specified with this parameter. --name - is an optional parameter to get the data of a specific alarm. --subsystem and --component must be specified with this parameter. --metadata - is an optional parameter to get only the metadata of alarms --status - is an optional parameter to get only the status of the alarms","title":"list"},{"location":"/apps/cswalarmcli.html#examples","text":"1.\ncsw-alarm-cli list --subsystem nfiraos --component trombone --name tromboneAxisLowLimitAlarm\nDisplays metadata, status and severity of alarm with name tromboneAxisLowLimitAlarm of component trombone and subsystem nfiraos.\n2.\ncsw-alarm-cli list --subsystem nfiraos --metadata --status\nDisplays metadata and status of all alarms which belong to nfiraos subsystem.","title":"Examples"},{"location":"/apps/cswalarmcli.html#operations-specific-to-an-alarm","text":"Commands given below are specific to an alarm. All of commands must be provided with --subsystem,--component and --name as parameters.\n--subsystem - is a parameter to specify the subsystem of alarm --component - is a parameter to specify the component of alarm --name - is a parameter to specify the name of the alarm","title":"Operations specific to an alarm"},{"location":"/apps/cswalarmcli.html#acknowledge","text":"Sets the acknowledgement status of the alarm to Acknowledged","title":"acknowledge"},{"location":"/apps/cswalarmcli.html#examples","text":"csw-alarm-cli acknowledge --subsystem nfiraos --component trombone --name tromboneAxisLowLimitAlarm\nAcknowledge the alarm with name tromboneAxisLowLimitAlarm of component trombone and subsystem nfiraos.","title":"Examples"},{"location":"/apps/cswalarmcli.html#unacknowledge","text":"Sets the acknowledgement status of the alarm to Unacknowledged","title":"unacknowledge"},{"location":"/apps/cswalarmcli.html#examples","text":"csw-alarm-cli unacknowledge --subsystem nfiraos --component trombone --name tromboneAxisLowLimitAlarm\nUnacknowledge the alarm with name tromboneAxisLowLimitAlarm of component trombone and subsystem nfiraos.","title":"Examples"},{"location":"/apps/cswalarmcli.html#activate","text":"Sets the activation status of the alarm to Active","title":"activate"},{"location":"/apps/cswalarmcli.html#examples","text":"csw-alarm-cli activate --subsystem nfiraos --component trombone --name tromboneAxisLowLimitAlarm\nSets activation status to Active of the alarm with name tromboneAxisLowLimitAlarm of component trombone and subsystem nfiraos.","title":"Examples"},{"location":"/apps/cswalarmcli.html#deactivate","text":"Sets the activation status of the alarm to Inactive","title":"deactivate"},{"location":"/apps/cswalarmcli.html#examples","text":"csw-alarm-cli inactivate --subsystem nfiraos --component trombone --name tromboneAxisLowLimitAlarm\nSets activation status to Inactive of the alarm with name tromboneAxisLowLimitAlarm of component trombone and subsystem nfiraos.","title":"Examples"},{"location":"/apps/cswalarmcli.html#shelve","text":"Sets the shelve status of the alarm to Shelved","title":"shelve"},{"location":"/apps/cswalarmcli.html#examples","text":"csw-alarm-cli shelve --subsystem nfiraos --component trombone --name tromboneAxisLowLimitAlarm\nShelves the alarm with name tromboneAxisLowLimitAlarm of component trombone and subsystem nfiraos.","title":"Examples"},{"location":"/apps/cswalarmcli.html#unshelve","text":"Sets the shelve status of the alarm to Unshelved","title":"unshelve"},{"location":"/apps/cswalarmcli.html#examples","text":"csw-alarm-cli unshelve --subsystem nfiraos --component trombone --name tromboneAxisLowLimitAlarm\nUnshelves the alarm with name tromboneAxisLowLimitAlarm of component trombone and subsystem nfiraos.","title":"Examples"},{"location":"/apps/cswalarmcli.html#reset","text":"Resets the alarm status. This will set the acknowledgement Status to Acknowledged and the latched severity to the current severity of the alarm.","title":"reset"},{"location":"/apps/cswalarmcli.html#examples","text":"csw-alarm-cli reset --subsystem nfiraos --component trombone --name tromboneAxisLowLimitAlarm\nResets the alarm with name tromboneAxisLowLimitAlarm of component trombone and subsystem nfiraos.","title":"Examples"},{"location":"/apps/cswalarmcli.html#severity","text":"Severity command contains 3 sub-commands.","title":"severity"},{"location":"/apps/cswalarmcli.html#get","text":"Used to get the severity of the subsystem, component or alarm. If none of the optional parameters are given then severity of whole TMT system will be displayed.\nNote For a single alarm, current severity will be displayed. For a system, subsystem or component, aggregated severity will be displayed.\n--subsystem - is an optional parameter to get the severity of a specific subsystem’s alarms --component - is an optional parameter to get the severity of a specific component’s alarms. --subsystem must be specified with this parameter. --name - is an optional parameter to get the severity of a specific alarm. --subsystem and --component must be specified with this parameter.","title":"get"},{"location":"/apps/cswalarmcli.html#examples","text":"1.\ncsw-alarm-cli severity get --subsystem nfiraos --component trombone --name tromboneAxisLowLimitAlarm\nDisplays severity of alarm with name tromboneAxisLowLimitAlarm of component trombone and subsystem nfiraos.\n2.\ncsw-alarm-cli severity get --subsystem nfiraos --component trombone\nDisplays aggregated severity of component with name trombone of subsystem nfiraos.","title":"Examples"},{"location":"/apps/cswalarmcli.html#set","text":"Sets the given severity for the alarms\nseverity to which given alarm needs to be set --subsystem - is a parameter to specify the subsystem of alarm --component - is a parameter to specify the component of alarm --name - is a parameter to specify the name alarm --refresh - is an optional parameter to refresh severity after every 3 seconds","title":"set"},{"location":"/apps/cswalarmcli.html#examples","text":"1.\ncsw-alarm-cli severity set major --subsystem nfiraos --component trombone --name tromboneAxisLowLimitAlarm\nSets Major as the severity of alarm with name tromboneAxisLowLimitAlarm of component trombone and subsystem nfiraos.\n2.\ncsw-alarm-cli severity set major --subsystem nfiraos --component trombone --name tromboneAxisLowLimitAlarm --refresh\nRefresh Major as the severity of alarm with name tromboneAxisLowLimitAlarm of component trombone and subsystem nfiraos after every 3 seconds.","title":"Examples"},{"location":"/apps/cswalarmcli.html#subscribe","text":"Subscribes to the severity changes of the whole TMT system, subsystem, component or an alarm. If none of the optional parameters are given then the severity of the whole TMT system will be displayed.\nNote For a single alarm, current severity will be displayed. For system, subsystem or component, aggregated severity will be displayed.\n--subsystem - is an optional parameter to get the severity of a specific subsystem’s alarms --component - is an optional parameter to get the severity of a specific component’s alarms. --subsystem must be specified with this parameter. --name - is an optional parameter to get the severity of a specific alarm. --subsystem and --component must be specified with this parameter.","title":"subscribe"},{"location":"/apps/cswalarmcli.html#examples","text":"1.\ncsw-alarm-cli severity subscribe --subsystem nfiraos --component trombone\nSubscribes to the aggregated severity of a component with name trombone and subsystem nfiraos.","title":"Examples"},{"location":"/apps/cswalarmcli.html#health","text":"Health command contains two sub-commands.","title":"health"},{"location":"/apps/cswalarmcli.html#get","text":"Gets the health of the whole TMT system, subsystem, component or alarm. If none of the optional parameters are given then the health of the whole TMT system will be displayed.\nNote For a single alarm, current health will be displayed. For system, subsystem or component, aggregated health will be displayed.\n--subsystem - is an optional parameter to get the health of a specific subsystem’s alarms --component - is an optional parameter to get the health of a specific component’s alarms. --subsystem must be specified with this parameter. --name - is an optional parameter to get the health of a specific alarm. --subsystem and --component must be specified with this parameter.","title":"get"},{"location":"/apps/cswalarmcli.html#examples","text":"1.\ncsw-alarm-cli health get --subsystem nfiraos --component trombone --name tromboneAxisLowLimitAlarm\nDisplays health of alarm with name tromboneAxisLowLimitAlarm of component trombone and subsystem nfiraos.\n2.\ncsw-alarm-cli health get --subsystem nfiraos\nDisplays aggregated health of subsystem with name nfiraos.","title":"Examples"},{"location":"/apps/cswalarmcli.html#subscribe","text":"Subscribes to the health changes of the whole TMT system, subsystem, component or an alarm. If none of the optional parameters are given then the health of the whole TMT system will be displayed.\nNote For a single alarm, current health will be displayed. For system, subsystem or component, aggregated health will be displayed.\n--subsystem - is an optional parameter to get the health of a specific subsystem’s alarms --component - is an optional parameter to get the health of a specific component’s alarms. --subsystem must be specified with this parameter. --name - is an optional parameter to get the health of a specific alarm. --subsystem and --component must be specified with this parameter.","title":"subscribe"},{"location":"/apps/cswalarmcli.html#examples","text":"1.\ncsw-alarm-cli health subscribe --subsystem nfiraos --component trombone\nSubscribes to the aggregated health of subsystem with name nfiraos.","title":"Examples"},{"location":"/apps/cswalarmcli.html#about-this-application","text":"","title":"About this application"},{"location":"/apps/cswalarmcli.html#help","text":"Prints the help message.","title":"–help"},{"location":"/apps/cswalarmcli.html#version","text":"Prints the version of the application.\nNote All the above examples require that csw-location-server is running on local machine at localhost:7654. If csw-location-server is running on remote machine having Ip address 172.1.1.2, then you need to pass additional --locationHost 172.1.1.2 command line argument. Example: csw-alarm-cli list --locationHost 172.1.1.2","title":"–version"},{"location":"/apps/hostconfig.html","text":"","title":"csw-host-config"},{"location":"/apps/hostconfig.html#csw-host-config","text":"This is just a helper to create a host configuration application. A component/subsystem is can create their own host configuration application using this helper, to be more precise every github repository should have one host configuration application. The reason for having one app per repo is, when you run universal:publish task, it will generate zip which will be self contained (will have all the required dependencies) and can be deployed independently on any machine.\nThis application will start multiple containers on a given host machine and each container will have single/multiple components.","title":"csw-host-config"},{"location":"/apps/hostconfig.html#how-to-create","text":"Scala object HostConfigApp extends App {\n\n  HostConfig.start(\"Host-Config-App\", args)\n\n} Java public class JHostConfigApp {\n\n    public static void main(String args[]) {\n        JHostConfig.start(\"JHost-Config-App\", args);\n    }\n\n}\nNote It is not necessary to have a name of the application as HostConfigApp/JHostConfigApp, user can choose this name.","title":"How to create"},{"location":"/apps/hostconfig.html#command-line-parameter-options","text":"--local is an optional parameter. When supplied, get the host configuration file from local machine located at hostConfigPath, else fetch it from config service <file> is a mandatory parameter. It specifies Host configuration file path -s, --container-script <script-path> specifies the path of generated shell script of container command app from task universal:packageBin (sbt-native-packager task) --help prints the help of the application. --version prints the version of the application.","title":"Command line parameter options"},{"location":"/apps/hostconfig.html#examples","text":"","title":"Examples"},{"location":"/apps/hostconfig.html#pre-requisites","text":"Run sbt project/universal:packageBin command. Here project contains HostConfigApp and ContainerCmdApp and it depends on required components. Ex. Hcd’s, Assembly’s etc. Navigate to project/target/universal directory Unzip file created with projects name Navigate to bin directory from unzipped content\nSbt task: sbt project/universal:packageBin creates following four scripts in bin directory:\ntrombone-host-config-app : Responsible for starting multiple containers. It takes hostconfig.conf file as an argument which contains list of container specifications. trombone-container-cmd-app : Responsible for starting single container or component in standalone mode. It takes containerConfig.conf file as an argument which contains single container specifications. trombone-host-config-app.bat : For windows machine. trombone-container-cmd-app.bat : For windows machine.\nExamples:\n./trombone-host-config-app hostconfig.conf -s ./trombone-container-cmd-app\nFetch hostconfig.conf from configuration service which contains multiple container configuration, then invoke trombone-container-cmd-app script per container configuration which spawns container ./trombone-host-config-app --local hostconfig.conf -s ./trombone-container-cmd-app\n Fetch and parse hostconfig.conf from current directory which contains multiple container configuration, then invoke trombone-container-cmd-app script per container configuration which spawns container\nNote In above examples, we are passing argument: -s ./trombone-container-cmd-app to ./trombone-host-config-app. here -s stands for script and following to that is script name, in our case its trombone-container-cmd-app. and if you notice, trombone-container-cmd-app does not take container configuration file. hostconfig.conf passed to trombone-host-config-app contains location of container configuration files. Host config app internally parses hostconfig.conf and passes container configuration file location to trombone-container-cmd-app. Find more details of ContainerCmd application here.","title":"Pre-requisites"},{"location":"/apps/hostconfig.html#where-does-it-fit-in-overall-deployment-strategy-may-change-","text":"","title":"Where does it fit in overall deployment strategy (may change)"},{"location":"/apps/hostconfig.html#custom-host-configuration","text":"hostconfig.conf # This is a host configuration file which contains list of containers to be spawned by host configuration app\ncontainers: [\n  {\n    # mode can be one of Container or Standalone\n    mode: \"Container\"\n    # path of individual container configuration file\n    configFilePath: \"/Users/salonivithalani/Desktop/tw_tmt/csw/examples/src/main/resources/assemblyContainer.conf\"\n    # provide 'Remote' if file needs to fetched from config service else\n    # provide 'Local' to fetch file from local machine\n    configFileLocation: \"Local\"\n  },\n  {\n    mode: \"Standalone\"\n    configFilePath: \"/Users/salonivithalani/Desktop/tw_tmt/csw/examples/src/main/resources/hcdStandalone.conf\"\n    configFileLocation: \"Local\"\n  }\n]","title":"Custom Host Configuration"},{"location":"/apps/hostconfig.html#help","text":"Use the following command to get help on the options available with this app\n./bin/trombone-host-config-app --help","title":"Help"},{"location":"/apps/hostconfig.html#version","text":"Use the following command to get version information for this app\n./bin/trombone-host-config-app --version\nNote Before running host-config app, make sure that csw-location-server is running on local machine at localhost:7654. As host config application internally executes container-cmd application which uses local HTTP location client which expect location server running locally.","title":"Version"},{"location":"/apps/hostconfig.html#systemd-configuration","text":"Using systemd, you can configure host configuration application to spawn containers on a machine to be run automatically on system startup.\nFor detailed information on systemd configuration, please refer to readme.md","title":"Systemd configuration"},{"location":"/commons/testing.html","text":"","title":"Testing"},{"location":"/commons/testing.html#testing","text":"","title":"Testing"},{"location":"/commons/testing.html#dependencies","text":"To use Csw Testkit, you must add the following dependency in your project:\nsbt libraryDependencies += \"com.github.tmtsoftware.csw\" %% \"csw-testkit\" % \"0.1-SNAPSHOT\"","title":"Dependencies"},{"location":"/commons/testing.html#introduction","text":"CSW comes with a dedicated csw-testkit module for supporting tests. This module includes following multiple individual testkits:\nLocationTestKit : starts and stops location server ConfigTestKit : starts and stops config server EventTestKit : starts and stops event service (Note : This uses embedded-redis to start redis sentinel and master) AlarmTestKit : starts and stops alarm service (Note : This uses embedded-redis to start redis sentinel and master) FrameworkTestKit : in most of the cases, you will end up using this testkit. FrameworkTestKit is created by composing all the above mentioned testkits. Hence it supports starting and stopping all provided csw services.\nNote All the testkits requires location server to be up and running. Hence first thing all testkits does is to start location server. You do not need to start it explicitly.","title":"Introduction"},{"location":"/commons/testing.html#testkits","text":"When you really want a granular level access to testkits then only you would want to use LocationTestKit|ConfigTestKit|EventTestKit|AlarmTestKit|FrameworkTestKit directly. You can create instance of FrameworkTestKit as shown below:\nScala // create instance of framework testkit\nprivate val frameworkTestKit = FrameworkTestKit()\n\n// starts Config Server and Event Service\noverride protected def beforeAll(): Unit = frameworkTestKit.start(ConfigServer, EventServer)\n\n// stops all services started by this testkit\noverride protected def afterAll(): Unit = frameworkTestKit.shutdown() Java private static FrameworkTestKit frameworkTestKit = FrameworkTestKit.create();\n\n@BeforeClass\npublic static void beforeAll() {\n    frameworkTestKit.start(JCSWService.ConfigServer, JCSWService.EventServer);\n}\n\n@AfterClass\npublic static void afterAll() {\n    frameworkTestKit.shutdown();\n}\nNote Similarly you can use other testkits. Please refer API docs for more details.","title":"TestKits"},{"location":"/commons/testing.html#spawning-components","text":"FrameworkTestKit provides easy way to spawn components in Container or Standalone mode. Use spawnContainer method provided by FrameworkTestKit to start components in container mode andspawnStandalone method to start component in standalone mode.\nBelow example show how to spawn container or component in standalone mode using framework testkit.\nScala // starting container from container config using testkit\nframeworkTestKit.spawnContainer(ConfigFactory.load(\"SampleContainer.conf\"))\n\n// starting standalone component from config using testkit\n// val componentRef: ActorRef[ComponentMessage] =\n//   frameworkTestKit.spawnStandaloneComponent(ConfigFactory.load(\"SampleHcdStandalone.conf\"))\n Java // starting container from container config using testkit\nframeworkTestKit.spawnContainer(ConfigFactory.load(\"JSampleContainer.conf\"));\n\n// starting standalone component from config using testkit\n// ActorRef<ComponentMessage> componentRef =\n//      frameworkTestKit.spawnStandaloneComponent(ConfigFactory.load(\"SampleHcdStandalone.conf\"));\nFull source at GitHub\nScala Java","title":"Spawning components"},{"location":"/commons/testing.html#test-framework-integration","text":"","title":"Test framework integration"},{"location":"/commons/testing.html#scalatest","text":"If you are using ScalaTest then you can extend csw.testkit.scaladsl.ScalaTestFrameworkTestKit to have framework test kit automatically start provided services before running tests and shutdown it when the test is complete. This is done in beforeAll and afterAll from the BeforeAndAfterAll trait. If you override that method you should call super.beforeAll to start services and super.afterAll to shutdown the test kit.","title":"ScalaTest"},{"location":"/commons/testing.html#junit","text":"If you are using JUnit then you can use csw.testkit.javadsl.FrameworkTestKitJunitResource to have the framework test kit automatically start provided services before running tests and shutdown it when the test is complete.","title":"JUnit"},{"location":"/commons/testing.html#supported-csw-services-by-frameworktestkit","text":"ScalaTestFrameworkTestKit and FrameworkTestKitJunitResource both support starting one or more of the following services.\nCSWService.LocationServer | JCSWService.LocationServer CSWService.ConfigServer | JCSWService.ConfigServer CSWService.EventServer | JCSWService.EventServer CSWService.AlarmServer | JCSWService.AlarmServer\nBelow example show’s the usage of ScalaTestFrameworkTestKit and FrameworkTestKitJunitResource and how you can start above mentioned services as per your need.\nScala import com.typesafe.config.ConfigFactory\nimport csw.testkit.scaladsl.CSWService.{AlarmServer, EventServer}\nimport csw.testkit.scaladsl.ScalaTestFrameworkTestKit\nimport org.scalatest.FunSuiteLike\n\nclass ScalaTestIntegrationExampleTest extends ScalaTestFrameworkTestKit(AlarmServer, EventServer) with FunSuiteLike {\n\n  test(\"test spawning component in standalone mode\") {\n    spawnStandalone(ConfigFactory.load(\"SampleHcdStandalone.conf\"))\n\n    // .. assertions etc.\n\n  }\n\n} Java import com.typesafe.config.ConfigFactory;\nimport csw.testkit.javadsl.FrameworkTestKitJunitResource;\nimport csw.testkit.javadsl.JCSWService;\nimport org.junit.ClassRule;\nimport org.junit.Test;\nimport org.scalatest.junit.JUnitSuite;\n\nimport java.util.Arrays;\n\npublic class JUnitIntegrationExampleTest extends JUnitSuite {\n\n    @ClassRule\n    public static final FrameworkTestKitJunitResource testKit =\n            new FrameworkTestKitJunitResource(Arrays.asList(JCSWService.AlarmServer, JCSWService.EventServer));\n\n    @Test\n    public void testSpawningComponentInStandaloneMode() {\n        testKit.spawnStandalone(ConfigFactory.load(\"JSampleHcdStandalone.conf\"));\n\n         // ... assertions etc.\n    }\n}\nNote You do not need to externally start any services like event, config, location etc. via csw-services.sh script. Testkits will start required services as a part of initialization. For event and alarm service, it uses embedded-redis.","title":"Supported CSW Services by FrameworkTestKit"},{"location":"/commons/testing.html#unit-tests","text":"The goal of unit testing is to break your application into the smallest testable units, and test them individually, isolating a specific piece of functionality and ensuring it is working correctly. It is always a good idea to write more unit test cases and relatively fewer component and integration tests. If you want to get an idea of how many tests you should have in different types of testing phases (Unit/Component/Integration), refer this blog\nUnit testing simple scala/java classes or objects is straight forward. You can mock external dependencies using Mockito. Refer to the Mockito section for more details.\nThe following links provide guides for testing applications using different modules of Akka:\nAkka Untyped Actors Akka Typed Actors Akka Streams","title":"Unit Tests"},{"location":"/commons/testing.html#multi-jvm-tests","text":"Testing asynchronous distributed systems requires special tooling/framework support. Sbt has a plugin called sbt-multi-jvm which helps to test systems across multiple JVMs or machines. This is especially useful for integration testing where multiple systems communicate with each other.\nYou can find more details on multi-JVM tests here.\nYou can also refer csw for writing your own multi-JVM tests. For example: CommandServiceTest.scala\nIn case you want to run your multi-JVM tests across machines, refer this multi-node testing guide here.","title":"Multi-JVM Tests"},{"location":"/commons/testing.html#mockito","text":"Mocks are used so that unit tests can be written independent of dependencies. csw uses Mockito for writing unit tests. ScalaTest comes with MockitoSugar trait which provides some basic syntax sugar for Mockito.\nFor example: ContainerBehaviorTest.scala","title":"Mockito"},{"location":"/commons/testing.html#acceptance-tests","text":"This section explains how and where csw maintains and executes acceptance tests. If you are a component writer and want to maintain acceptance tests, you can create a repo similar to csw-acceptance and update dependencies, projects as per your need.\nAs required by TMT Systems Engineering, the acceptance pipeline runs all the existing Java and Scala tests from csw repo on published bintray binaries rather than directly on source code.\nMore information can be found here.\nBelow are the two separate Jenkins pipelines to run csw acceptance tests:\nAcceptance Dev Pipeline Automatically triggered every night to get fast feedback and intended for developer’s visibility. Acceptance Release Pipeline Automatically triggered on completion of csw-prod-release pipeline. csw-prod-release pipeline published CSW artifacts to bintray, and must be manually triggered by an administrator.\nNote csw-prod-release pipeline is responsible for following tasks: build and run csw tests publish binaries to bintray publish paradox documentation publish apps and release notes to github releases trigger acceptance-release pipeline\nAcceptance pipelines can also be triggered manually via an HTTP end point, for STIL acceptance tesing, for example. Using the security token obtained from the Jenkins pipeline settings (available upon request), run the curl cmd as shown below:\nFor triggering acceptance-dev pipeline, run below\ncurl -G 'http://ec2-35-154-215-191.ap-south-1.compute.amazonaws.com:8080/job/acceptance-dev/buildWithParameters'  \\\n    --data-urlencode token=$DEV_TOKEN \\\n    --data-urlencode DEV_VERSION=0.1-SNAPSHOT \\\n    --data-urlencode BUILD_ENV=DEV\nFor triggering acceptance-release pipeline, run below: (Modify parameters as applicable)\ncurl -G '$REMOTE_JENKINS_URL/job/$JOB_NAME/buildWithParameters' \\\n    --data-urlencode token=$RELEASE_TOKEN \\\n    --data-urlencode RELEASE_VERSION=$RELEASE_VERSION \\\n    --data-urlencode BUILD_ENV=PROD","title":"Acceptance Tests"},{"location":"/commons/sbt-tasks.html","text":"","title":"sbt Tasks"},{"location":"/commons/sbt-tasks.html#sbt-tasks","text":"csw uses multiple plugins in the sbt ecosystem to help accomplish a variety of tasks.\nplugin task Description default in sbt test compile and run all tests including scala tests, java tests, multi-jvm/multi-node tests default in sbt test:test compile and run all tests excluding multi-jvm/multi-node tests default in sbt publishLocal install your libraries in local Ivy repository so they can be added as dependencies to other projects sbt-multi-jvm multi-jvm:test provides support for running applications (objects with main methods) and ScalaTest tests in multiple JVMs at the same time. sbt-site makeSite generates project’s webpage in the target/site directory sbt-ghpages ghpagesPushSite publish project website to GitHub Pages sbt-github-release githubRelease creates Github releases with proper release notes and optional artifact uploading. Releases in Github are first-class objects with changelogs and binary assets that present a full project history beyond Git artifacts. They’re accessible from a repository’s homepage. sbt-bintray publish upload and release artifacts into bintray (command requires proper bintray credentials. Intended for TMT staff.) sbt-native-packager stage locally install your app in target/universal/stage/bin/ so you can run it locally without having the app packaged. sbt-native-packager universal:packageBin Generates a universal zip file","title":"sbt Tasks"},{"location":"/commons/manuals.html","text":"","title":"Manuals"},{"location":"/commons/manuals.html#manuals","text":"Complete user guide on how to use common software platform, Scaladoc and Javadoc API’s can be found below:","title":"Manuals"},{"location":"/commons/manuals.html#","text":"","title":"Javadoc"},{"location":"/commons/manuals.html#","text":"","title":"Scaladoc"}]}