<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="docs">
<meta name="generator" content="Paradox, paradox-material-theme=0.7.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="docs">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Communication using Commands Â· TMT Common Software (CSW)</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="TMT Common Software (CSW)" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
TMT Common Software (CSW)
</span>
<span class="md-header-nav__topic">
Communication using Commands
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="TMT Common Software (CSW)" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="TMT Common Software (CSW)">
TMT Common Software (CSW)
</a>
</label>
<ul>
  <li><a href="../commons/getting-started.html" class="page">Getting Started</a></li>
  <li><a href="../commons/create-component.html" class="page">Creating a Component</a></li>
  <li><a href="../commons/multiple-components.html" class="page">Multiple Components</a></li>
  <li><a href="../commons/using-alarms.html" class="page">Using Alarms</a></li>
  <li><a href="../commons/unit-tests.html" class="page">Adding Unit Tests</a></li>
  <li><a href="../commons/params.html" class="page">Params</a>
  <ul>
    <li><a href="../params/keys-parameters.html" class="page">Keys and Parameters</a></li>
    <li><a href="../params/units.html" class="page">Units</a></li>
    <li><a href="../params/subsystem.html" class="page">Subsystem</a></li>
    <li><a href="../params/commands.html" class="page">Commands</a></li>
    <li><a href="../params/events.html" class="page">Events</a></li>
    <li><a href="../params/states.html" class="page">State Variables</a></li>
    <li><a href="../params/result.html" class="page">Result</a></li>
  </ul></li>
  <li><a href="../commons/framework.html" class="page">Framework for creating components (HCD, Assembly, Container)</a>
  <ul>
    <li><a href="../framework/describing-components.html" class="page">ComponentInfo</a></li>
    <li><a href="../framework/creating-components.html" class="page">Creating an Assembly or Hcd Component</a></li>
    <li><a href="../framework/handling-lifecycle.html" class="page">Component Handlers</a></li>
    <li><a href="../framework/managing-command-state.html" class="page">Managing Command State</a></li>
    <li><a href="../framework/tracking-connections.html" class="page">Tracking Connections</a></li>
    <li><a href="../framework/publishing-state.html" class="page">Publishing State</a></li>
    <li><a href="../framework/handling-exceptions.html" class="page">Handling Exceptions</a></li>
    <li><a href="../framework/deploying-components.html" class="page">Deploying Components</a></li>
  </ul></li>
  <li><a href="../commons/command.html" class="active page">Communication using Commands</a></li>
  <li><a href="../commons/logging_aggregator.html" class="page">Logging Aggregator</a></li>
  <li><a href="../commons/services.html" class="page">Services</a>
  <ul>
    <li><a href="../services/location.html" class="page">Location Service</a></li>
    <li><a href="../services/config.html" class="page">Configuration Service</a></li>
    <li><a href="../services/logging.html" class="page">Logging Service</a></li>
    <li><a href="../services/event.html" class="page">Event Service</a></li>
    <li><a href="../services/alarm.html" class="page">Alarm Service</a></li>
    <li><a href="../services/time.html" class="page">Time Service</a></li>
    <li><a href="../services/database.html" class="page">Database Service</a></li>
    <li><a href="../services/aas.html" class="page">Authentication and Authorization Service (AAS)</a></li>
    <li><a href="../services/sequencer-command-service.html" class="page">Sequencer Command Service</a></li>
  </ul></li>
  <li><a href="../commons/apps.html" class="page">Applications</a>
  <ul>
    <li><a href="../apps/csinstallation.html" class="page">Coursier Installation</a></li>
    <li><a href="../apps/cswservices.html" class="page">csw-services</a></li>
    <li><a href="../apps/cswlocationserver.html" class="page">csw-location-server</a></li>
    <li><a href="../apps/cswlocationagent.html" class="page">csw-location-agent</a></li>
    <li><a href="../apps/cswonfigserverapp.html" class="page">csw-config-server</a></li>
    <li><a href="../apps/cswconfigcli.html" class="page">csw-config-cli</a></li>
    <li><a href="../apps/csweventcli.html" class="page">csw-event-cli</a></li>
    <li><a href="../apps/cswalarmcli.html" class="page">csw-alarm-cli</a></li>
    <li><a href="../apps/hostconfig.html" class="page">csw-host-config</a></li>
  </ul></li>
  <li><a href="../commons/deployment.html" class="page">Deployment</a>
  <ul>
    <li><a href="../deployment/env-vars.html" class="page">Environment variables</a></li>
    <li><a href="../deployment/network-topology.html" class="page">Network Topology</a></li>
  </ul></li>
  <li><a href="../commons/testing.html" class="page">Testing</a></li>
  <li><a href="../commons/sbt-tasks.html" class="page">sbt Tasks</a></li>
  <li><a href="../commons/manuals.html" class="page">Manuals</a></li>
  <li><a href="../migration_guide/migration-guides.html" class="page">Migration Guides</a>
  <ul>
    <li><a href="../migration_guide/migration_guide_1.0.0_to_2.0.0/migration-guide-1.0.0-to-2.0.0.html" class="page">Migration Guide from 1.0.0 to 2.0.0</a></li>
    <li><a href="../migration_guide/migration_guide_2.0_to_3.0/migration-guide-2.0-to-3.0.html" class="page">Migration Guide from 2.0 to 3.0</a></li>
    <li><a href="../migration_guide/migration_guide_3.0.0_to_4.0.0/migration-guide-3.0.0-to-4.0.0.html" class="page">Migration Guide from 3.0.0 to 4.0.0</a></li>
    <li><a href="../migration_guide/migration_guide_4.0.0_to_5.0.0/migration-guide-4.0.0-to-5.0.0.html" class="page">Migration Guide from 4.0.0 to 5.0.0</a></li>
    <li><a href="../migration_guide/migration_guide_5.0.0_to_6.0.0/migration-guide-5.0.0-to-6.0.0.html" class="page">Migration Guide from 5.0.0 to 6.0.0</a></li>
  </ul></li>
  <li><a href="../commons/contract.html" class="page">CSW Service contract</a></li>
  <li><a href="../technical/technical.html" class="page">Technical Design Documents</a>
  <ul>
    <li><a href="../technical/framework/framework.html" class="page">Framework</a></li>
    <li><a href="../technical/command/command.html" class="page">Command</a></li>
    <li><a href="../technical/params/params.html" class="page">Params</a></li>
    <li><a href="../technical/units/adding-unit.html" class="page">Adding a new unit</a></li>
    <li><a href="../technical/location/location.html" class="page">Location Service</a></li>
    <li><a href="../technical/configuration/configuration.html" class="page">Configuration Service</a></li>
    <li><a href="../technical/logging/logging.html" class="page">Logging Service</a></li>
    <li><a href="../technical/event/event.html" class="page">Event Service</a></li>
    <li><a href="../technical/alarm/alarm.html" class="page">Alarm Service</a></li>
    <li><a href="../technical/time/time.html" class="page">Time Service</a></li>
    <li><a href="../technical/database/database.html" class="page">Database Service</a></li>
    <li><a href="../technical/aas/aas.html" class="page">Authentication and Authorization Service</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../commons/command.html#communication-using-commands" class="header">Communication using Commands</a>
  <ul>
    <li><a href="../commons/command.html#dependencies" class="header">Dependencies</a></li>
    <li><a href="../commons/command.html#command-based-communication-between-components" class="header">Command-based Communication Between Components</a></li>
    <li><a href="../commons/command.html#commandservice" class="header">CommandService</a></li>
    <li><a href="../commons/command.html#matching-state-for-command-completion" class="header">Matching State for Command Completion</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 6.0.0-M4
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../commons/command.html#communication-using-commands" class="header">Communication using Commands</a>
  <ul>
    <li><a href="../commons/command.html#dependencies" class="header">Dependencies</a></li>
    <li><a href="../commons/command.html#command-based-communication-between-components" class="header">Command-based Communication Between Components</a></li>
    <li><a href="../commons/command.html#commandservice" class="header">CommandService</a></li>
    <li><a href="../commons/command.html#matching-state-for-command-completion" class="header">Matching State for Command Completion</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#communication-using-commands" name="communication-using-commands" class="anchor"><span class="anchor-link"></span></a>Communication using Commands</h1>
<p>The <strong>csw-command</strong> library provides support for command based communication between components.</p>
<p>This section describes how to communicate with any other component using commands. To check how to manage commands received, please visit <a href="../framework/handling-lifecycle.html">Component Handlers</a> and <a href="../framework/managing-command-state.html">Managing Command State</a>.</p>
<h2><a href="#dependencies" name="dependencies" class="anchor"><span class="anchor-link"></span></a>Dependencies</h2>
<dl>
  <dt>sbt</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;com.github.tmtsoftware.csw&quot; %% &quot;csw-command&quot; % &quot;6.0.0-M4&quot;
</code></pre></dd>
</dl>
<h2><a href="#command-based-communication-between-components" name="command-based-communication-between-components" class="anchor"><span class="anchor-link"></span></a>Command-based Communication Between Components</h2>
<p>A component can send <a href="../params/commands.html">Commands</a> to other components. The commands can be sent as one of the following three types of messages:</p>
<ul>
  <li><strong>submit</strong> - A command is sent using a <code>submit</code> when the result of completion is desired.</li>
  <li><strong>oneway</strong> - A command is sent as <code>oneway</code> when the result of completion is not desired.</li>
  <li><strong>validate</strong> - A command is sent, but it is only validated with no actions started.</li>
</ul>
<p>Submit comes in two versions: <code>submit</code> and <code>submitAndWait</code>. The only difference is in how long-running commands are treated. If a command starts long-running actions, <code>submit</code> returns a <code>Started</code> response immediately while <code>submitAndWait</code> will wait for the long-running actions to complete before returning a final response. The <code>submitAndWait</code> is a composite of <code>submit</code> and <code>queryFinal</code>.</p>
<p>A <code>submitAndWait</code> is the most convenient way of sending a command from one component to another. When received, a <code>submitAndWait</code> command is validated and if accepted, the actions associated with the command are executed or started. When the <code>submit</code> response that is part of the <code>submitAndWait</code> is received, <code>submitAndWait</code> immediately does a <code>queryFinal</code>. For simple scenarios, this is the right command and will be the most commonly used.</p>
<p>A <code>submit</code> can be used when the sender of a command needs to do additional work before long-running actions are completed. For instance, send another command to execute in parallel. If commands are short, <code>submit</code> and <code>submitAndWait</code> behave the same way. When the actions started by <code>submit</code> are long-running, the caller can wait for the actions to complete if needed using the <code>queryFinal</code> call.</p>
<p>A <code>oneway</code> is primarily meant to be used between an Assembly and an HCD when no completion information is desired. It is also useful when tracking completion using a Matcher and current state values (see below) or events.</p>
<p>A <code>validate</code> message is used to ask a destination component to validate a command and determine if the command can be executed. It does not execute the command and only returns the result of validation. In some scenarios, it may be useful to test to see if a command can be executed prior to trying to execute the command.</p>
<h3><a href="#component-locking" name="component-locking" class="anchor"><span class="anchor-link"></span></a>Component Locking</h3>
<p>If a component is locked, any Command Service command will have a response of <code>Locked</code>. The corresponding handler will not be called until the component is unlocked. See <a href="create-component.html">Creating a Component</a> for more information on locking. </p>
<p>Note that the code in the receiving component&rsquo;s handler does not need to return <code>Locked</code>. If the component has been Locked, the component&rsquo;s Supervisor returns the <code>Locked</code> response to the caller and the handler is not called.</p>
<h3><a href="#command-validation" name="command-validation" class="anchor"><span class="anchor-link"></span></a>Command Validation</h3>
<p>Command validations occur in two scenarios. One is using the <code>validate</code> message as described above. For example, <code>validate</code> could be used by an Assembly when it needs to send multiple commands to different HCDs and it wants to first check that all the HCDs can execute their commands before sending a command to any of the HCDs.<br/>The second scenario is that it is always the first step in processing a command with <code>submit</code>, <code>submitAndWait</code>, or <code>oneway</code>.</p>
<p>If the receiving component is not locked, the component&rsquo;s supervisor calls the <code>validateCommand</code> handler of the Top Level Actor. The developer code evaluates and returns a <code>ValidateCommandResponse</code> as shown in the following table. </p>
<table>
  <thead>
    <tr>
      <th align="center">ValidateCommandResponse </th>
      <th>Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="center">Accepted </td>
      <td>The command is valid and can be executed by the component. </td>
    </tr>
    <tr>
      <td align="center">Invalid </td>
      <td>The command is not valid and cannot be executed. The response includes a reason in the form of a <code>CommandIssue</code> </td>
    </tr>
    <tr>
      <td align="center">Locked </td>
      <td>The component is locked by some other command sender. The validation could not occur.</td>
    </tr>
  </tbody>
</table>
<h3><a href="#the-submit-message" name="the-submit-message" class="anchor"><span class="anchor-link"></span></a>The Submit Message</h3>
<p>A <code>submit</code> message is sent with its <a href="../params/commands.html">command</a> to a component destination. A <code>SubmitResponse</code> is returned to the caller when the <code>submit</code> message is used. If the <code>validateCommand</code> handler returns <code>Accepted</code>, the framework calls the <code>onSubmit</code> handler of the Top Level Actor. The <code>onSubmit</code> handler always returns a <code>SubmitResponse</code>.</p>
<h4><a href="#immediate-completion-scenario-submit-" name="immediate-completion-scenario-submit-" class="anchor"><span class="anchor-link"></span></a>Immediate Completion Scenario (submit)</h4>
<p>If the actions of the <code>submit</code> command take a very short time to complete, they may be completed by the <code>onSubmit</code> handler. This is called <em>immediate completion</em>. The time for the actions to complete should be less than 1 second. (Note: The framework will timeout if the destination does not return a response within 1 second.) In this scenario with <code>onSubmit</code>, the values of <code>SubmitResponse</code> can be <code>Completed</code> or <code>Error</code>. <code>Error</code> is returned when the actions could not be accomplished. This is different than <code>Invalid</code>, which indicates that the command could not be validated.</p>
<p>The immediate completion behavior is similar to a remote procedure call although the execution is entirely asynchronous. If the actions are successful, the <code>Completed</code> <code>SubmitResponse</code> is returned. If there is a result, the <code>Completed</code> is returned with a parameter set of <code>Result</code> type that can be inspected by the sender.</p>
<h4><a href="#long-running-actions-scenario-submit-" name="long-running-actions-scenario-submit-" class="anchor"><span class="anchor-link"></span></a>Long Running Actions Scenario (submit)</h4>
<p>When actions take longer than 1 second, <code>onSubmit</code> should start the actions and return the <code>Started</code> <code>SubmitResponse</code>. The <code>Started</code> response indicates to the framework that long-running actions have been started.</p>
<p>Once the long-running actions have started, the receiving component code must notify the framework when the actions are completed. This is done be updating through the <a href="../framework/managing-command-state.html">Command Response Manager</a>.</p>
<p>In addition to the values returned for immediate completion, long running actions can return <code>Cancelled</code>. If the component supports a separate command to stop a long-running command, the stopped command should return <code>Cancelled</code> when successfully cancelled. The command that cancels the long running command should return <code>Completed</code>.</p>
<h3><a href="#the-submitandwait-message" name="the-submitandwait-message" class="anchor"><span class="anchor-link"></span></a>The SubmitAndWait Message</h3>
<p>A <code>submitAndWait</code> message is sent with its <a href="../params/commands.html">command</a> to a component destination. A <code>SubmitResponse</code> is returned to the caller when the <code>submitAndWait</code> message is used. If the <code>validateCommand</code> handler returns <code>Accepted</code>, the framework calls the <code>onSubmit</code> handler of the Top Level Actor. The <code>onSubmit</code> handler always returns a <code>SubmitResponse</code>.</p>
<h4><a href="#immediate-completion-scenario-submitandwait-" name="immediate-completion-scenario-submitandwait-" class="anchor"><span class="anchor-link"></span></a>Immediate Completion Scenario (submitAndWait)</h4>
<p>If the actions of the <code>submitAndWait</code> command take a very short time to complete, <code>submitAndWait</code> behaves exactly like <code>submit</code> as described above.</p>
<p>The immediate completion behavior is similar to a remote procedure call although the execution is entirely asynchronous. If the actions are successful, the <code>Completed</code> <code>SubmitResponse</code> is returned. If there is a result, the <code>Completed</code> is returned with a parameter set of <code>Result</code> type that can be inspected by the sender.</p>
<h4><a href="#long-running-actions-scenario-submitandwait-" name="long-running-actions-scenario-submitandwait-" class="anchor"><span class="anchor-link"></span></a>Long Running Actions Scenario (submitAndWait)</h4>
<p>When actions take longer than 1 second, <code>onSubmit</code> should start the actions and return the <code>Started</code> <code>SubmitResponse</code>. The <code>Started</code> response indicates to the framework that long-running actions have been started. In this case, <code>submitAndWait</code> immediately executes a <code>queryFinal</code> command in order to wait for the final response.</p>
<p>As with the <code>submit</code> description, the receiving component code must notify the framework when the actions are completed. This is done be updating the <a href="../framework/managing-command-state.html">Command Response Manager</a>.</p>
<h4><a href="#submitresponse-summary" name="submitresponse-summary" class="anchor"><span class="anchor-link"></span></a>SubmitResponse Summary</h4>
<p>The following table summarizes all the possible values for <code>SubmitResponse</code>.</p>
<table>
  <thead>
    <tr>
      <th align="center">SubmitResponse </th>
      <th>Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="center">Invalid </td>
      <td>The command is not valid and cannot be executed. The response includes a reason in the form of a <code>CommandIssue</code>. <code>onSubmit</code> is not executed. </td>
    </tr>
    <tr>
      <td align="center">Completed(Result) </td>
      <td>This response is returned when the actions associated with a command are completed. A result may or may not be returned. </td>
    </tr>
    <tr>
      <td align="center">Started </td>
      <td>Returned by <code>onSubmit</code> when long-running actions have been started. </td>
    </tr>
    <tr>
      <td align="center">Error </td>
      <td>Error is returned the the actions started by a command do not complete properly. A message is returned explaining the error. </td>
    </tr>
    <tr>
      <td align="center">Cancelled </td>
      <td>The actions associated with a long-running command have been cancelled. </td>
    </tr>
    <tr>
      <td align="center">Locked </td>
      <td>The component is locked by some other command sender. The validation could not occur. </td>
    </tr>
  </tbody>
</table>
<h3><a href="#the-oneway-message" name="the-oneway-message" class="anchor"><span class="anchor-link"></span></a>The Oneway Message</h3>
<p>The other option for sending a <a href="../params/commands.html">command</a> to a component destination is the <code>oneway</code> message. The central difference between <code>submit</code> and <code>oneway</code> is that <code>oneway</code> does not track or allow reporting of completion information. It supports a <em>fire and forget</em> type of communication approach.</p>
<p>A <code>OnewayResponse</code> is returned to the caller when the <code>oneway</code> message is used. <code>Oneway</code> does validate the command. If the component is not locked, the <code>validateCommand</code> handler is called.<br/>If the <code>validateCommand</code> handler returns <code>Accepted</code>, the framework calls the <code>onOneway</code> handler of the Top Level Actor. However, the <code>onOneway</code> handler does not return a value. The sender of the <code>oneway</code> message receives the result of the validation or the Locked indication. </p>
<p>The following table summarizes all the possible values for <code>OnewayResponse</code>.</p>
<table>
  <thead>
    <tr>
      <th align="center">OnewayResponse </th>
      <th>Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="center">Invalid </td>
      <td>The command is not valid and cannot be executed. The response includes a reason in the form of a <code>CommandIssue</code>. <code>onOneway</code> is not executed. </td>
    </tr>
    <tr>
      <td align="center">Accepted </td>
      <td>Returned when validation succeeds and the command was passed to the <code>onOneway</code> handler. </td>
    </tr>
    <tr>
      <td align="center">Locked </td>
      <td>The component is locked by some other command sender. The validation could not occur. </td>
    </tr>
  </tbody>
</table>
<p><code>Oneway</code> is available as a higher performance option when an Assembly needs to send commands to an HCD but doesn&rsquo;t really care about completion such as the case when demands are being sent to a motor. Validation is still present to ensure the HCD supports the standalone operation requirement that allows the HCD to check that its input values are not invalid and it is not getting out of range values.</p>
<p><code>Oneway</code> can be used with a <em>matcher</em>. The matcher can use CurrentState or even events from the Event Service to determine completion. This can be more complicated than <code>submit</code>, but may be useful in some scenarios.</p>
<h2><a href="#commandservice" name="commandservice" class="anchor"><span class="anchor-link"></span></a>CommandService</h2>
<p>A helper/wrapper is provided called <code>CommandService</code> that provides a convenient way to use the Command Service with a component from the Location Service.</p>
<p>A <code>CommandService</code> instance is created using an <code>PekkoLocation</code> of the receiving component, discovered from the Location Service. This <code>CommandService</code> instance has methods for communicating with the component. A new <code>CommandService</code> is created for each component for which commands are to be sent.</p><div class="callout note "><div class="callout-title">Scala async library!</div>
<p>Note that the Scala examples are using async/await which simplifies handling the Futures, but is not necessary. The async/await library is not available in Java.</p></div>
<p>This example shows creating a <code>Command Service</code> using <code>Pekko Location</code> of the receiving component, discovered from the Location Service. Actor System is created here using Actor System Context <code>ctx</code> and is passed as implicit parameter to <code>make</code> method of <code>CommandServiceFactory</code>. In Java though the actor is passed explicitly as shown in the example.</p>
<dl>
  <dt>Scala/resolve hcd/create command service</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/example/tutorial/basic/sampleassembly/SampleAssemblyHandlers.scala#L43-L84" target="_blank" title="Go to snippet source">source</a><code class="language-scala">class SampleAssemblyHandlers(ctx: ActorContext[TopLevelActorMessage], cswCtx: CswContext) extends ComponentHandlers(ctx, cswCtx) {
  private implicit val system: ActorSystem[Nothing] = ctx.system
  override def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = {
    log.debug(s&quot;onLocationTrackingEvent called: $trackingEvent&quot;)
    trackingEvent match {
      case LocationUpdated(location) =&gt;
        hcdLocation = location.asInstanceOf[PekkoLocation]
        hcdCS = Some(CommandServiceFactory.make(location))
        onSetup(Id(), Setup(prefix, shortCommand, None))
      case LocationRemoved(connection) =&gt;
        if (connection == hcdConnection) {
          hcdCS = None
        }
    }
  }</code></pre></dd>
  <dt>Java/resolve hcd/create command service</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/example/tutorial/basic/sampleassembly/JSampleAssemblyHandlers.java#L56-L113" target="_blank" title="Go to snippet source">source</a><code class="language-java">private final ActorSystem&lt;Void&gt; system;
JSampleAssemblyHandlers(ActorContext&lt;TopLevelActorMessage&gt; ctx, JCswContext cswCtx) {
  super(ctx, cswCtx);
  this.cswCtx = cswCtx;
  system = ctx.getSystem();
@Override
public void onLocationTrackingEvent(TrackingEvent trackingEvent) {
  log.debug(() -&gt; &quot;onLocationTrackingEvent called: &quot; + trackingEvent.toString());
  if (trackingEvent instanceof LocationUpdated) {
    Location location = ((LocationUpdated) trackingEvent).location();
    hcdLocation = (PekkoLocation) location;
    cswCtx.eventService().defaultPublisher().publish(new SystemEvent(prefix, new EventName(&quot;receivedHcdLocation&quot;)));
    hcdCS = Optional.of(CommandServiceFactory.jMake(location, system));
    onSetup(Id.apply(), new Setup(prefix, shortCommand, Optional.empty()));
  } else if (trackingEvent instanceof LocationRemoved) {
    Connection connection = trackingEvent.connection();
    if (connection == hcdConnection) {
      hcdCS = Optional.empty();
    }
  }
}</code></pre></dd>
</dl>
<p>The API can be exercised as follows for different scenarios of command-based communication:</p>
<h3><a href="#submit" name="submit" class="anchor"><span class="anchor-link"></span></a>submit</h3>
<p>Sending a <code>submit</code> message with a command returns a <code>SubmitResponse</code> as a Future. The Future returned by <code>submit</code> will be the final response in case of short-running command and may be a positive completion (<code>Completed</code>) or a negative completion (<code>Invalid</code>, <code>Error</code>, <code>Cancelled</code>, <code>Locked</code>). The response may also be the <code>Started</code> response in the case of long-running actions. In the case of a long-running command the <code>Started</code> response can be used with either <code>query</code> or <code>queryFinal</code> to obtain the final response.</p>
<p>This example shows a command using <code>submit</code> that returns <code>Started</code> followed by a <code>queryFinal</code> to get the final response.</p>
<dl>
  <dt>Scala/submit w/queryFinal</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/example/tutorial/basic/sampleassembly/SampleAssemblyHandlers.scala#L214-L229" target="_blank" title="Go to snippet source">source</a><code class="language-scala">private def sleepHCD(runId: Id, setup: Setup, sleepTime: Long): Unit =
  hcdCS match {
    case Some(cs) =&gt;
      val s = Setup(prefix, hcdSleep, None).add(setSleepTime(sleepTime))
      cs.submit(s).foreach {
        case started: Started =&gt;
          // Can insert extra code during execution here
          cs.queryFinal(started.runId).foreach(sr =&gt; commandResponseManager.updateCommand(sr.withRunId(runId)))
        case other =&gt;
          commandResponseManager.updateCommand(other.withRunId(runId))
      }
    case None =&gt;
      commandResponseManager.updateCommand(
        Error(runId, s&quot;A needed HCD is not available: ${hcdConnection.componentId} for $prefix&quot;)
      )
  }</code></pre></dd>
  <dt>Java/submit w/queryFinal</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/example/tutorial/basic/sampleassembly/JSampleAssemblyHandlers.java#L249-L267" target="_blank" title="Go to snippet source">source</a><code class="language-java">private void sleepHCD(Id runId, Setup setup, Long sleepTime) {
  if (hcdCS.isPresent()) {
    ICommandService cs = hcdCS.get();
    Setup s = new Setup(prefix, hcdSleep, Optional.empty()).add(setSleepTime(sleepTime));
    cs.submit(s).thenAccept(submitResponse -&gt; {
      if (submitResponse instanceof Started) {
        Started started = (Started) submitResponse;
        // Can insert extra code during execution here
        cs.queryFinal(started.runId(), timeout).thenAccept(sr -&gt; cswCtx.commandResponseManager().updateCommand(sr.withRunId(runId)));
      } else {
        cswCtx.commandResponseManager().updateCommand(submitResponse.withRunId(runId));
      }
    });
  } else {
    cswCtx.commandResponseManager().updateCommand(
        new CommandResponse.Error(runId, &quot;A needed HCD is not available: &quot; + hcdConnection.componentId() + &quot; for &quot; + prefix)
    );
  }
}</code></pre></dd>
</dl>
<p>If using <code>submit</code> and the validation fails in the destination component, the <code>Invalid</code> response is returned. Sometimes it is possible to handle an <code>Invalid</code> response locally, but in most cases it must simply be returned to the caller. The following example shows how to process individual responses from a <code>submit</code>:</p>
<dl>
  <dt>Scala/submit w/invalid response</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/scala/example/command/CommandServiceExample.scala#L89-L101" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val invalidSetup    = Setup(prefix, invalidCmd, obsId)
val invalidCommandF = assemblyCmdService.submitAndWait(invalidSetup)
val resultF: Future[Unit] = async {
  await(invalidCommandF) match {
    case Completed(_, _) =&gt;
    // Do Completed thing
    case Invalid(_, _) =&gt;
    // issue shouldBe a[Invalid]
    case other =&gt;
      // Unexpected result
      log.error(s&quot;Some other response: $other&quot;)
  }
}</code></pre></dd>
  <dt>Java/submit w/invalid response</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/java/example/command/JCommandServiceExample.java#L158-L169" target="_blank" title="Go to snippet source">source</a><code class="language-java">CompletableFuture&lt;SubmitResponse&gt; invalidSubmitCommandF =
        hcdCmdService.submit(invalidSetup).thenApply(
                response -&gt; {
                    if (response instanceof Started) {
                        //do something with completed result
                    } else if (response instanceof Invalid invalid) {
                        // Cast the response to get the issue
                        assert (invalid.issue().reason().contains(&quot;failure&quot;));
                    }
                    return response;
                }
        );</code></pre></dd>
</dl>
<p>The handling an immediate completion command looks the same from the command sender&rsquo;s perspective, but can be challenging on the side of the component handling the command. Because <code>submit</code> returns a <code>Future[SubmitResponse]</code> and <code>onSetup</code> returns <code>SubmitResponse</code>, an immediate completion command must be handled in the component that receives the request. For instance, an Assembly can return a <code>Completed</code> without returning <code>Started</code>, but if an Assembly needs to contact an HCD to get a response, the Assembly must first return <code>Started</code> and then contact the HCD. The following snippet shows a portion of an <code>onSetup</code> handler that returns some local state as an immediate completion.</p>
<dl>
  <dt>Scala/submit immediate command</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/example/tutorial/basic/sampleassembly/SampleAssemblyHandlers.scala#L158-L163" target="_blank" title="Go to snippet source">source</a><code class="language-scala">private def onSetup(runId: Id, setup: Setup): SubmitResponse =
  setup.commandName match {
    case `immediateCommand` =&gt;
      val localValue = 1000L
      // Assembly preforms a calculation or reads state information storing in a result
      Completed(runId, Result().add(resultKey.set(localValue)))</code></pre></dd>
  <dt>Java/submit immediate command</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/example/tutorial/basic/sampleassembly/JSampleAssemblyHandlers.java#L190-L195" target="_blank" title="Go to snippet source">source</a><code class="language-java">private SubmitResponse onSetup(Id runId, Setup setup) {
  CommandName cmd = setup.commandName();
  if (cmd.equals(immediateCommand)) {
    // Assembly preforms a calculation or reads state information storing in a result
    return new Completed(runId, new Result().add(resultKey.set(1000L)));
  }</code></pre></dd>
</dl>
<h3><a href="#submitandwait" name="submitandwait" class="anchor"><span class="anchor-link"></span></a>submitAndWait</h3>
<p><code>submitAndWait</code> is a convenience method which sends a <code>submit</code> message and then, if the command is long-running, it waits for final completion. Sending a <code>submit</code> message with a command returns a <code>SubmitResponse</code> as a Future. The Future returned by <code>submitAndWait</code> will always be the final response, whether the actions are long-running or not. The final result may be a positive completion (<code>Completed</code>) or a negative completion (<code>Invalid</code>, <code>Error</code>, <code>Cancelled</code>, <code>Locked</code>). The <code>Started</code> response is never seen by the programmer when using <code>submitAndWait</code> of <code>CommandService</code>. The handling of long-running and immediate completion commands look the same from the command sender&rsquo;s perspective when using <code>submitAndWait</code>.</p>
<p>This example shows an immediate completion command using <code>submitAndWait</code>.</p>
<dl>
  <dt>Scala/submitAndWait w/immediate-response
  </dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/scala/example/command/CommandServiceExample.scala#L110-L120" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val immediateSetup = Setup(prefix, immediateCmd, obsId)
val immediateCommandF: Future[SubmitResponse] = async {
  await(assemblyCmdService.submitAndWait(immediateSetup)) match {
    case response: Completed =&gt;
      // do something with completed result
      response
    case otherResponse =&gt;
      // do something with other response which is not expected
      otherResponse
  }
}</code></pre></dd>
  <dt>Java/submitAndWait w/immediate-response
  </dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/java/example/command/JCommandServiceExample.java#L110-L120" target="_blank" title="Go to snippet source">source</a><code class="language-java">CompletableFuture&lt;SubmitResponse&gt; immediateCommandF =
        hcdCmdService.submitAndWait(immediateCmd, timeout).thenApply(
                response -&gt; {
                    if (response instanceof Completed) {
                        //do something with completed result
                    } else {
                        // do something with unexpected response
                    }
                    return response;
                }
        );</code></pre></dd>
</dl>
<p>Several examples have been shown of sending a command that is long-running. The following examples show an Assembly that issues a command to an HCD with <code>submitAndWait</code> and returns <code>Started</code>. When <code>submitAndWait</code> returns with a final response, the parent is updated with the final response through the <code>CommandResponseManager</code>.</p>
<dl>
  <dt>Scala/submitAndWait w/immediate-response
  </dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/csw/sample/CurrentStateExampleComponentHandlers.scala#L124-L131" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case `longRunningCmd` =&gt;
  // A local assembly command that takes some time returning Started
  timeServiceScheduler.scheduleOnce(UTCTime(UTCTime.now().value.plusSeconds(2))) {
    // After time expires, send final update
    commandResponseManager.updateCommand(Completed(runId, Result(encoder.set(20))))
  }
  // Starts long-runing and returns started
  Started(runId)</code></pre></dd>
  <dt>Java/submitAndWait w/immediate-response
  </dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/java/example/command/JCommandServiceExample.java#L177-L190" target="_blank" title="Go to snippet source">source</a><code class="language-java">Setup longRunningSetup = new Setup(prefix(), longRunningCmd(), Optional.empty()).add(encoderValue);
CompletableFuture&lt;Optional&lt;Integer&gt;&gt; longRunningResultF =
        hcdCmdService.submitAndWait(longRunningSetup, timeout)
                .thenCompose(response -&gt; {
                    if (response instanceof Completed) {
                        // This extracts and returns the the first value of parameter encoder
                        Result result = ((Completed) response).result();
                        Optional&lt;Integer&gt; rvalue = Optional.of(result.jGet(encoder).orElseThrow().head());
                        return CompletableFuture.completedFuture(rvalue);
                    } else {
                        // For some other response, return empty
                        return CompletableFuture.completedFuture(Optional.empty());
                    }
                });</code></pre></dd>
</dl>
<h3><a href="#oneway" name="oneway" class="anchor"><span class="anchor-link"></span></a>oneway</h3>
<p><code>Oneway</code> does not provide completion information but does return the result of <code>validateCommand</code> handler in the Top-Level-Actor (<code>Accepted</code>, <code>Invalid</code>, or <code>Locked</code>). When sending a command as a <code>oneway</code> message, a <code>OnewayResponse</code> is returned as a Future that can be used to check that it was validated if necessary.</p>
<p>Oneway is useful for communication between an Assembly when it needs to send commands to an HCD as quickly as possible. The command is validated on the destination and the validation response is returned, but no other responses are provided.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/scala/example/command/CommandServiceExample.scala#L212-L225" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// `onewayCmd` is a sample to demonstrate oneway without any actions
val onewaySetup = Setup(prefix, onewayCmd, obsId)
// Don&#39;t care about the futures from async
val oneWayF: Future[Unit] = async {
  await(assemblyCmdService.oneway(onewaySetup)) match {
    case invalid: Invalid =&gt;
    // Log an error here
    case _ =&gt;
    // Ignore anything other than invalid
  }
}
oneWayF.map(_ =&gt; {
  // do something
})</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/java/example/command/JCommandServiceExample.java#L286-L295" target="_blank" title="Go to snippet source">source</a><code class="language-java">Setup onewaySetup = new Setup(prefix(), onewayCmd(), Optional.empty()).add(encoderValue);
CompletableFuture&lt;Void&gt; onewayF = hcdCmdService
        .oneway(onewaySetup)
        .thenAccept(onewayResponse -&gt; {
            if (onewayResponse instanceof Invalid) {
                // log an error here
            } else {
                // Ignore anything other than invalid
            }
        });</code></pre></dd>
</dl>
<h3><a href="#validate" name="validate" class="anchor"><span class="anchor-link"></span></a>validate</h3>
<p>Sometimes it may be useful to test whether or not a component can execute a command without committing to executing its actions. The <code>validate</code> message can be used for this purpose. <code>Validate</code> returns a <code>ValidateResponse</code> of <code>Accepted</code>, <code>Invalid</code>, or <code>Locked</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/scala/example/command/CommandServiceExample.scala#L229-L238" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val validateCommandF: Future[Boolean] = async {
  await(assemblyCmdService.validate(immediateSetup)) match {
    case _: Accepted       =&gt; true
    case Invalid(_, issue) =&gt;
      // do something with other response which is not expected
      log.error(s&quot;Command failed to validate with issue: $issue&quot;)
      false
    case _: Locked =&gt; false
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/java/example/command/JCommandServiceExample.java#L301-L317" target="_blank" title="Go to snippet source">source</a><code class="language-java">CompletableFuture&lt;Boolean&gt; validateCommandF =
        hcdCmdService.validate(immediateCmd)
                .thenApply(
                        response -&gt; {
                            if (response instanceof Accepted) {
                                //do something with completed result
                                return true;
                            } else if (response instanceof Invalid) {
                                // do something with unexpected response
                                return false;
                            } else {
                                // Locked
                                return false;
                            }
                        }
                );
Assert.assertTrue(validateCommandF.get());</code></pre></dd>
</dl>
<h3><a href="#query" name="query" class="anchor"><span class="anchor-link"></span></a>query</h3>
<p>If a command returns a <code>Started</code> response indicating it has long-running actions, and the sender needs to determine that the actions have started properly, or wishes to poll the destination component for the final response, the <code>query</code> method of <code>CommandService</code> can be used as shown in the following example without using the Future returned by <code>submitAndWait</code>, which provides the final completion notification.</p>
<dl>
  <dt>Scala/submit w/query</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/scala/example/command/CommandServiceExample.scala#L146-L170" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val longRunningQueryResultF: Future[Option[Int]] = async {
  // The following val is set so we can do query and work and complete later
  val longRunningF = assemblyCmdService.submit(longRunningSetup)
  // This is used in a later test
  longRunningRunId = await(longRunningF).runId

  await(assemblyCmdService.query(longRunningRunId)) match {
    case Started(runId) =&gt;
      runId shouldEqual longRunningRunId
    // happy case - no action needed
    // Do some other work
    case a =&gt;
    // log.error. This indicates that the command probably failed to start.
  }

  // Now wait for completion and result
  await(assemblyCmdService.queryFinal(longRunningRunId)) match {
    case Completed(_, result) =&gt;
      Some(result(encoder).head)

    case otherResponse =&gt;
      // log a message?
      None
  }
}</code></pre></dd>
  <dt>Java/submit w/query</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/java/example/command/JCommandServiceExample.java#L197-L224" target="_blank" title="Go to snippet source">source</a><code class="language-java">CompletableFuture&lt;SubmitResponse&gt; longRunningCommandResultF =
        hcdCmdService.submitAndWait(longRunningSetup, timeout);

// do some work before querying for the result of above command as needed
SubmitResponse sresponse = longRunningCommandResultF.get();
CompletableFuture&lt;SubmitResponse&gt; queryResponseF = hcdCmdService.query(sresponse.runId());
queryResponseF.thenAccept(r -&gt; {
    if (r instanceof Started) {
        // happy case - no action needed
        // Do some other work
    } else {
        // log.error. This indicates that the command probably failed to start.
    }
});

CompletableFuture&lt;Optional&lt;Integer&gt;&gt; intF =
        longRunningCommandResultF.thenCompose(response -&gt; {
            if (response instanceof Completed) {
                // This extracts and returns the the first value of parameter encoder
                Result result = ((Completed) response).result();
                Optional&lt;Integer&gt; rvalue = Optional.of(result.jGet(encoder).orElseThrow().head());
                return CompletableFuture.completedFuture(rvalue);
            } else {
                // For some other response, return empty
                return CompletableFuture.completedFuture(Optional.empty());
            }
        });
Assert.assertEquals(Optional.of(20), intF.get());</code></pre></dd>
</dl>
<h3><a href="#queryfinal" name="queryfinal" class="anchor"><span class="anchor-link"></span></a>queryFinal</h3>
<p>When using <code>submit</code> and the <code>submit</code> returns a <code>Started</code> response, the final completion reponse can be obtained using <code>queryFinal</code>. Like <code>query</code>, <code>queryFinal</code> uses the <code>Id</code> returned by <code>Started</code>. But in this case, rather than returning immediately like <code>query</code>, it waits and only returns when the final <code>SubmitResponse</code> is sent. <code>queryFinal</code> is used exclusively with <code>submit</code> in the case where some other activity must be done before the actions started by the <code>submit</code> complete. <code>submitAndWait</code> is just a <code>submit</code> + <code>queryFinal</code>. It is also possible to just start actions with <code>submitAndWait</code> and use the returned Future when you are ready. The following examples show you can use the runId returned by <code>submitAndWait</code> with <code>queryFinal</code>.</p>
<dl>
  <dt>Scala/submitAndWait long running/queryFinal</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/scala/example/command/CommandServiceExample.scala#L194-L207" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val encoderValue: Future[Option[Int]] = async {
  // The following submit is made without saving the Future!
  val runId = await(assemblyCmdService.submitAndWait(longRunningSetup)).runId

  // Use queryFinal and runId to wait for completion and result
  await(assemblyCmdService.queryFinal(runId)) match {
    case Completed(_, result) =&gt;
      Some(result(encoder).head)

    case otherResponse =&gt;
      // log a message?
      None
  }
}</code></pre></dd>
  <dt>Java/submitAndWait long running/queryFinal</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/java/example/command/JCommandServiceExample.java#L261-L277" target="_blank" title="Go to snippet source">source</a><code class="language-java">longRunningCommandResultF = hcdCmdService.submitAndWait(longRunningSetup, timeout);
sresponse = longRunningCommandResultF.get();

// longRunningSetup3 has already been submitted
CompletableFuture&lt;Optional&lt;Integer&gt;&gt; int3F =
        hcdCmdService.queryFinal(sresponse.runId(), timeout).thenCompose(response -&gt; {
            if (response instanceof Completed) {
                // This extracts and returns the the first value of parameter encoder
                Result result = ((Completed) response).result();
                Optional&lt;Integer&gt; rvalue = Optional.of(result.jGet(encoder).orElseThrow().head());
                return CompletableFuture.completedFuture(rvalue);
            } else {
                // For some other response, return empty
                return CompletableFuture.completedFuture(Optional.empty());
            }
        });
Assert.assertEquals(Optional.of(20), int3F.get());</code></pre></dd>
</dl>
<h3><a href="#submitallandwait" name="submitallandwait" class="anchor"><span class="anchor-link"></span></a>submitAllAndWait</h3>
<p><code>submitAllAndWait</code> can be used to send multiple commands sequentially to the same component. This could be used to send initialization commands to an HCD, for instance. The argument for <code>submitAllAndWait</code> is a list of commands. <code>submitAllAndWait</code> returns a list of <code>SubmitResponse</code>s &ndash; one for each command in the list. While <code>submitAndWait</code> returns a <code>SubmitResponse</code> as a Future, <code>submitAllAndWait</code> returns a list of <code>SubmitResponse</code>s as a future, which completes when all the commands in the list have completed.</p>
<dl>
  <dt>Scala/query usage</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/scala/example/command/CommandServiceExample.scala#L262-L271" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val submitAllF: Future[List[SubmitResponse]] = async {
  await(assemblyCmdService.submitAllAndWait(List(submitAllSetup1, submitAllSetup2, submitAllinvalidSetup)))
}
submitAllF.map(submitAllResponse =&gt; {
  // do something with submitAllResponse
  submitAllResponse.length // 3
  submitAllResponse.head   // [Completed]
  submitAllResponse(1)     // [Completed]
  submitAllResponse(2)     // [Invalid]
})</code></pre></dd>
  <dt>Java/query usage</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/java/example/command/JCommandServiceExample.java#L321-L332" target="_blank" title="Go to snippet source">source</a><code class="language-java">Setup submitAllSetup1 = new Setup(prefix(), immediateCmd(), Optional.empty()).add(encoderValue);
Setup submitAllSetup2 = new Setup(prefix(), longRunningCmd(), Optional.empty()).add(encoderValue);
Setup submitAllSetup3 = new Setup(prefix(), invalidCmd(), Optional.empty()).add(encoderValue);

CompletableFuture&lt;List&lt;SubmitResponse&gt;&gt; submitAllF = hcdCmdService
        .submitAllAndWait(List.of(submitAllSetup1, submitAllSetup2, submitAllSetup3), timeout);

List&lt;SubmitResponse&gt; submitAllResponse = submitAllF.get();
Assert.assertEquals(submitAllResponse.size(), 3);
Assert.assertTrue(submitAllResponse.get(0) instanceof Completed);
Assert.assertTrue(submitAllResponse.get(1) instanceof Completed);
Assert.assertTrue(submitAllResponse.get(2) instanceof Invalid);</code></pre></dd>
</dl>
<p>In the first example, three commands are sent and the result is a list with three <code>SubmitResponse</code>s. The last one returned invalid and was not executed.</p>
<p>The commands in <code>submitAllAndWait</code> will execute sequentially, but each one must complete successfully for the subsequent commands to be executed. If any one of the commands fails, <code>submitAllAndWait</code> stops and the list is returned with the commands that are completed up to and including the command that failed.</p>
<h3><a href="#subscribecurrentstate" name="subscribecurrentstate" class="anchor"><span class="anchor-link"></span></a>subscribeCurrentState</h3>
<p>This method provided by <code>CommandService</code> can be used to subscribe to the <a href="../params/states.html">CurrentState</a> of a component by providing a callback that is called with the arrival of every <code>CurrentState</code> item. <code>SubscribeCurrentState</code> returns a handle of the <code>CurrentStateSubscription</code> which should be used to unsubscribe the subscription.</p><div class="callout note "><div class="callout-title">Note</div>
<p>Callbacks are not thread-safe on the JVM. If you are doing side effects/mutations inside the callback, you should ensure that it is done in a thread-safe way inside an actor. Here is an <a href="https://github.com/tmtsoftware/csw/blob/v6.0.0-M4/examples/src/main/scala/example/event/ConcurrencyInCallbacksExample.scala">example</a> of how it can be done.</p></div>
<p><code>CurrentState</code> can be an efficient way to keep the Aseembly up to date with the current internal state of the HCD.</p>
<p>The following example code shows an Assembly that subscribes to all <code>CurrentState</code> items of an HCD. The example sends a <code>Setup</code> with an encoder parameter value to the HCD as a <code>oneway</code> message. In this example, sending this command causes the HCD to publish <code>CurrentState</code> with the value that was sent to it.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/scala/example/command/CommandServiceExample.scala#L295-L310" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// Subscriber code
val expectedEncoderValue = 234
val currStateSetup       = Setup(prefix, hcdCurrentStateCmd, obsId).add(encoder.set(expectedEncoderValue))
// Setup a callback response to CurrentState
var cstate: CurrentState = CurrentState(prefix, StateName(&quot;no cstate&quot;), Set.empty)
val subscription         = hcdCmdService.subscribeCurrentState(cs =&gt; cstate = cs)
// Send a oneway to the HCD that will cause it to publish a CurrentState with the encoder value
// in the command parameter &quot;encoder&quot;. Callback will store value into cstate.
hcdCmdService.oneway(currStateSetup)

// Eventually current state callback will get invoked when hcd publish its state
// Test to see if value was received
eventually(cstate(encoder).head shouldBe expectedEncoderValue)

// Unsubscribe to CurrentState
subscription.cancel()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/java/example/command/JCommandServiceExample.java#L349-L429" target="_blank" title="Go to snippet source">source</a><code class="language-java">// Subscriber cod
int expectedEncoderValue = 234;
Setup currStateSetup = new Setup(prefix(), hcdCurrentStateCmd(), Optional.empty()).add(encoder.set(expectedEncoderValue));
// Setup a callback response to CurrentState - use AtomicInteger to capture final value
final AtomicInteger cstate = new AtomicInteger((1));
Subscription subscription = hcdCmdService.subscribeCurrentState(cs -&gt; {
    // Example sets variable outside scope of closure
    cstate.set(cs.jGet(encoder).orElseThrow().head());
});

// Send a oneway to the HCD that will cause a publish of a CurrentState with the encoder value
// in the command parameter &quot;encoder&quot;
hcdCmdService.oneway(currStateSetup);

// Wait for a bit for the callback
Thread.sleep(200);
// Check to see if CurrentState has the value we sent
Assert.assertEquals(expectedEncoderValue, cstate.get());

// Unsubscribe from CurrentState
subscription.cancel();
// subscribe to the current state of an assembly component and use a callback which forwards each received
// element to a test probe actor
Subscription subscription = hcdCmdService.subscribeCurrentState(currentState -&gt; probe.ref().tell(currentState));</code></pre></dd>
</dl>
<p>The second part of the example shows the code in the HCD. When the HCD receives the <code>oneway</code> message, it extracts the encoder value and publishes a CurrentState item with the encoder parameter.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/scala/org/tmt/csw/sample/CurrentStateExampleComponentHandlers.scala#L62-L63" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// Publish the CurrentState using parameter set created using a sample Choice parameter
currentStatePublisher.publish(CurrentState(filterAsmPrefix, StateName(&quot;testStateName&quot;), Set(choiceKey.set(initChoice))))</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/main/java/org/tmt/csw/sample/JCurrentStateExampleComponentHandlers.java#L75-L175" target="_blank" title="Go to snippet source">source</a><code class="language-java">CurrentState initState = currentState.add(SampleComponentState.choiceKey().set(SampleComponentState.initChoice()));
currentStatePublisher.publish(initState);
Key&lt;Integer&gt; encoder = JKeyType.IntKey().make(&quot;encoder&quot;, JUnits.encoder);
int expectedEncoderValue = setup.jGet(encoder).orElseThrow().head();

CurrentState currentState = new CurrentState(prefix(), new StateName(&quot;HCDState&quot;)).add(encoder.set(expectedEncoderValue));
currentStatePublisher.publish(currentState);</code></pre></dd>
</dl>
<p>There are two <code>subscribeCurrentState</code> methods in <code>CommandService</code>. The method shown in the above examples subscribes the caller to <em>all</em> CurrentState published. Each <code>CurrentState</code> item has a <code>StateName</code>. A second signature for <code>subscribeCurrentState</code> can include a Set of <code>StateName</code> when the caller only needs some of the CurrentState published by a component.</p>
<h2><a href="#matching-state-for-command-completion" name="matching-state-for-command-completion" class="anchor"><span class="anchor-link"></span></a>Matching State for Command Completion</h2>
<p>The <code>matcher</code> is provided to allow a component sending a command to use <code>CurrentState</code> published by a component to determine when actions are complete. The expected case is an Assembly using the <code>CurrentState</code> published by an HCD. When using a <code>submit</code> or <code>submitAndWait</code>, completion is determined in the destination. In some scenarios, the Assembly may want to determine when actions are complete. This is what the  <code>matcher</code> allows.</p>
<p>To use this feature, the <code>oneway</code> message is used rather than <code>submit</code>. A <code>oneway</code> command is  validated but the framework does not provide completion. Doing a query with the <code>runId</code> of a <code>oneway</code>  will always return <code>CommandNotAvailable</code>, but <code>oneway</code> is perfect for use with a <code>matcher</code>.</p>
<p>The <code>matcher</code> is created with the ActorRef of the component that is the source of <code>CurrentState</code> and an instance of <code>StateMatcher</code>, which defines the state and criteria for matching.</p>
<p>Several types of <code>StateMatcher</code> are provided as part of CSW for common use. These are <code>DemandMatcherAll</code> for matching the entire <code>DemandState</code> against the current state, <code>DemandMatcher</code> for matching state with or without units against the current state, and <code>PresenceMatcher</code> which checks if a matching state is found with a provided prefix.</p>
<p>The developer is not limited to these <code>StateMatcher</code>s. Any class the implements the <code>StateMatcher</code> interface can be provided to a <code>Matcher</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/scala/example/command/CommandServiceExample.scala#L315-L327" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val param: Parameter[Int] = encoder.set(100)
val setupWithMatcher      = Setup(prefix, matcherCmd, obsId)

// create a StateMatcher which specifies the desired algorithm and state to be matched.
val demandMatcher: StateMatcher =
  DemandMatcher(DemandState(prefix, StateName(&quot;testStateName&quot;)).add(param), withUnits = false, timeout)

// Submit command as a oneway and if the command is successfully validated,
// check for matching of demand state against current state
val matchResponseF: Future[MatchingResponse] = assemblyCmdService.onewayAndMatch(setupWithMatcher, demandMatcher)
matchResponseF.map(commandResponse =&gt; {
  commandResponse // [Completed]
})</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/java/example/command/JCommandServiceExample.java#L375-L386" target="_blank" title="Go to snippet source">source</a><code class="language-java">Parameter&lt;Integer&gt; param = JKeyType.IntKey().make(&quot;encoder&quot;, JUnits.encoder).set(100);
Setup setupWithMatcher = new Setup(prefix(), matcherCmd(), Optional.empty()).add(param);

// create a StateMatcher which specifies the desired algorithm and state to be matched.
DemandMatcher demandMatcher = new DemandMatcher(new DemandState(prefix(), new StateName(&quot;testStateName&quot;)).add(param), false, timeout);

// Submit command as a oneway and if the command is successfully validated,
// check for matching of demand state against current state
CompletableFuture&lt;MatchingResponse&gt; matchResponseF = hcdCmdService.onewayAndMatch(setupWithMatcher, demandMatcher);
MatchingResponse actualResponse = matchResponseF.get();
Completed expectedResponse = new Completed(actualResponse.runId());
Assert.assertEquals(expectedResponse, actualResponse);            // Not a great test for now</code></pre></dd>
</dl>
<p>One important point is that the <code>matcher</code> is created and must be shutdown when you are finished with it using the <code>stop</code> method of the matcher as shown in the example.</p>
<h3><a href="#onewayandmatch" name="onewayandmatch" class="anchor"><span class="anchor-link"></span></a>onewayAndMatch</h3>
<p><code>CommandService</code> provides a short-cut called <code>onewayAndMatch</code> that combines a <code>oneway</code> and a <code>matcher</code>  and implements much of the boilerplate of the previous example.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/scala/example/command/CommandServiceExample.scala#L333-L351" target="_blank" title="Go to snippet source">source</a><code class="language-scala">val onewayMatchF: Future[SubmitResponse &amp; MatchingResponse] = async {
  await(assemblyCmdService.onewayAndMatch(setupWithMatcher, demandMatcher)) match {
    case i: Invalid =&gt;
      // Command was not accepted
      log.error(s&quot;Oneway match was not accepted: ${i.issue}&quot;)
      i
    case c: Completed =&gt;
      // Do some completed work
      c
    case e: Error =&gt;
      // Match failed and timedout generating an error - log a message
      log.error(s&quot;Oeway match produced an error: ${e.message}&quot;)
      e
    case l: Locked =&gt;
      // Destination component was locked, log a message
      log.error(s&quot;Destination component was locked&quot;)
      l
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/tmtsoftware/csw/tree/master/examples/src/test/java/example/command/JCommandServiceExample.java#L390-L395" target="_blank" title="Go to snippet source">source</a><code class="language-java">// create a DemandMatcher which specifies the desired state to be matched.
StateMatcher stateMatcher = new DemandMatcher(new DemandState(prefix(), new StateName(&quot;testStateName&quot;)).add(param), false, timeout);

CompletableFuture&lt;MatchingResponse&gt; matchedCommandResponseF =
        hcdCmdService.onewayAndMatch(setupWithMatcher, stateMatcher);
</code></pre></dd>
</dl>
</div>
<div>
<a href="https://github.com/tmtsoftware/csw/tree/master/docs/src/main/commons/command.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
6.0.0-M4
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../framework/deploying-components.html" title="Deploying Components" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Deploying Components
</span>
</div>
</a>
<a href="../commons/logging_aggregator.html" title="Logging Aggregator" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Logging Aggregator
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
