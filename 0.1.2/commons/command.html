<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="docs">
<meta name="generator" content="Paradox, paradox-material-theme=0.4.0, mkdocs-material=2.2.2">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.language" content="">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="docs">
<link rel="shortcut icon" href="../assets/tmt_favicon.ico">
<title>Communication using Commands · TMT Common Software (CSW)</title>
<link rel="stylesheet" href="../assets/stylesheets/application.7a4cdee3.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../lib/modernizr/modernizr.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
<label class="md-overlay" data-md-component="overlay" for="drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="TMT Common Software (CSW)" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
TMT Common Software (CSW)
</span>
<span class="md-header-nav__topic">
Communication using Commands
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="search"></label>
<div class="md-search__inner">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" required placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query">
<label class="md-icon md-search__icon" for="search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/tmtsoftware/csw-prod"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
tmtsoftware/csw-prod
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</span>
<a href="../index.html" title="TMT Common Software (CSW)">
TMT Common Software (CSW)
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/tmtsoftware/csw-prod"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
tmtsoftware/csw-prod
</div>
</a>

</div>
<ul>
  <li><a href="../commons/getting-started.html" class="page">Getting Started</a></li>
  <li><a href="../commons/create-component.html" class="page">Creating a Component</a></li>
  <li><a href="../commons/multiple-components.html" class="page">Multiple Components</a></li>
  <li><a href="../commons/messages.html" class="page">Messages</a>
  <ul>
    <li><a href="../messages/keys-parameters.html" class="page">Keys and Parameters</a></li>
    <li><a href="../messages/units.html" class="page">Units</a></li>
    <li><a href="../messages/subsystem.html" class="page">Subsystem</a></li>
    <li><a href="../messages/commands.html" class="page">Commands</a></li>
    <li><a href="../messages/events.html" class="page">Events</a></li>
    <li><a href="../messages/states.html" class="page">State Variables</a></li>
    <li><a href="../messages/result.html" class="page">Result</a></li>
  </ul></li>
  <li><a href="../commons/framework.html" class="page">Framework for creating components (HCD, Assembly, Container)</a>
  <ul>
    <li><a href="../framework/describing-components.html" class="page">ComponentInfo</a></li>
    <li><a href="../framework/creating-components.html" class="page">Creating an Assembly or Hcd Component</a></li>
    <li><a href="../framework/handling-lifecycle.html" class="page">Lifecycle support</a></li>
    <li><a href="../framework/managing-command-state.html" class="page">Managing Command State</a></li>
    <li><a href="../framework/tracking-connections.html" class="page">Tracking Connections</a></li>
    <li><a href="../framework/publishing-state.html" class="page">Publishing State</a></li>
    <li><a href="../framework/handling-exceptions.html" class="page">Handling Exceptions</a></li>
    <li><a href="../framework/deploying-components.html" class="page">Deploying Components</a></li>
  </ul></li>
  <li><a href="../commons/command.html" class="active page">Communication using Commands</a></li>
  <li><a href="../commons/services.html" class="page">Services</a>
  <ul>
    <li><a href="../services/location.html" class="page">Location Service</a></li>
    <li><a href="../services/config.html" class="page">Configuration Service</a></li>
    <li><a href="../services/logging.html" class="page">Logging Service</a></li>
  </ul></li>
  <li><a href="../commons/apps.html" class="page">Applications</a>
  <ul>
    <li><a href="../apps/cswclusterseed.html" class="page">csw-cluster-seed</a></li>
    <li><a href="../apps/cswlocationagent.html" class="page">csw-location-agent</a></li>
    <li><a href="../apps/cswonfigserverapp.html" class="page">csw-config-server</a></li>
    <li><a href="../apps/cswconfigclientcli.html" class="page">csw-config-client-cli</a></li>
    <li><a href="../apps/hostconfig.html" class="page">csw-host-config</a></li>
  </ul></li>
  <li><a href="../commons/testing.html" class="page">Testing</a></li>
  <li><a href="../commons/sbt-tasks.html" class="page">sbt tasks</a></li>
  <li><a href="../commons/manuals.html" class="page">Manuals</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="toc">Table of contents</label>
<ul>
  <li><a href="../commons/command.html#communication-using-commands" class="header">Communication using Commands</a>
  <ul>
    <li><a href="../commons/command.html#dependencies" class="header">Dependencies</a></li>
    <li><a href="../commons/command.html#command-based-communication-between-components" class="header">Command based communication between components</a></li>
    <li><a href="../commons/command.html#commandservice" class="header">CommandService</a></li>
    <li><a href="../commons/command.html#matching-state-for-command-completion" class="header">Matching state for command completion</a></li>
    <li><a href="../commons/command.html#distributing-commands" class="header">Distributing commands</a></li>
  </ul></li>
</ul>
</nav>

<div class="md-nav__title--site md-version" title="Version">
<i class="md-icon">label_outline</i> 0.1.2
</div>
</nav>

</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="toc">Table of contents</label>
<ul>
  <li><a href="../commons/command.html#communication-using-commands" class="header">Communication using Commands</a>
  <ul>
    <li><a href="../commons/command.html#dependencies" class="header">Dependencies</a></li>
    <li><a href="../commons/command.html#command-based-communication-between-components" class="header">Command based communication between components</a></li>
    <li><a href="../commons/command.html#commandservice" class="header">CommandService</a></li>
    <li><a href="../commons/command.html#matching-state-for-command-completion" class="header">Matching state for command completion</a></li>
    <li><a href="../commons/command.html#distributing-commands" class="header">Distributing commands</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#communication-using-commands" name="communication-using-commands" class="anchor"><span class="anchor-link"></span></a>Communication using Commands</h1>
<p><strong>csw-command</strong> library provides support for command based communication between components. </p>
<p>This section describes how to communicate with any other component using commands. To check how to manage commands received, please visit <a href="../framework/managing-command-state.html">Managing Command State</a></p>
<h2><a href="#dependencies" name="dependencies" class="anchor"><span class="anchor-link"></span></a>Dependencies</h2>
<dl>
  <dt>sbt</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;org.tmt&quot; %% &quot;csw-command&quot; % &quot;0.1.2&quot;
</code></pre></dd>
</dl>
<h2><a href="#command-based-communication-between-components" name="command-based-communication-between-components" class="anchor"><span class="anchor-link"></span></a>Command based communication between components</h2>
<p>A component can send <a href="../messages/commands.html">Commands</a> to other components. The commands can be sent as following two types of messages: </p>
<ul>
  <li><strong>Submit</strong> - A command is sent as Submit when the result of completion is desired.</li>
  <li><strong>Oneway</strong> - A command is sent as Oneway when the result of completion is not desired.</li>
</ul>
<p>A <code>Oneway</code> should only be used between an Assembly and an HCD. It is also used when tracking completion using a Matcher (see below).</p>
<p>The following responses can be received as a <code>CommandResponse</code> after sending a command with <code>Submit</code> or <code>Oneway</code>:</p>
<ul>
  <li><strong>Accepted</strong> : The command is validated and will be executed, this is returned for a long-running action.</li>
  <li><strong>Completed</strong> : The command has been executed successfully.</li>
  <li><strong>CompletedWithResult</strong> : The command is executed successfully and generated some result as a parameter set.</li>
  <li><strong>Invalid</strong> : The command is not valid and will not be executed. A reason is provided.</li>
  <li><strong>NoLongerValid</strong> : The command can no longer be executed (will be deprecated)</li>
  <li><strong>Error</strong> : The command has failed in execution. A reason is provided.</li>
  <li><strong>Cancelled</strong> : The command was cancelled.</li>
  <li><strong>CommandNotAvailable</strong> : A queried command is not available.</li>
  <li><strong>NotAllowed</strong> : The command cannot be executed currently because of the current state of the destination component. Eg. another command is in execution in the presence of which it cannot accept any other command to execute or some other reason.</li>
</ul>
<p>A command sent as <code>Submit</code> or <code>Oneway</code> is validated by the receiving component before actual execution. If the validation is successful, the actual execution can happen in two ways :</p>
<ul>
  <li><strong>Immediate Completion</strong> - The component receiving the command can determine if the command can be executed immediately and thus provide the final execution response directly without sending a response for validation. This should be reserved for actions that do not take long to complete.</li>
</ul>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val eventualResponse: Future[CommandResponse] = async {
  await(assemblyComponent.submit(Setup(prefix, immediateCmd, obsId))) match {
    case response: Completed ⇒
      //do something with completed result
      response
    case otherResponse ⇒
      // do something with other response which is not expected
      otherResponse
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; eventualCommandResponse =
        hcdCmdService
                .submit(imdInvalidCommand, timeout)
                .thenApply(
                        response -&gt; {
                            if (response instanceof Completed) {
                                //do something with completed result
                            }
                            return response;
                        }
                );</code></pre></dd>
</dl>
<ul>
  <li><strong>Long Running Actions</strong> - The component receiving the command may determine that the command cannot be executed immediately. In this case, the component provides a <code>Accepted</code> response as an acknowledgement and maintains the state of the command. The sender can query the state of a particular command at a later time or use the subscribe method to get the final response when the execution is completed.</li>
</ul>
<p>The sender component can use the following with the command id (RunId) of an executing command to get the current status, completion response and/or result of the command</p>
<ul>
  <li><strong>Query</strong> - Query the current state of an executing command</li>
</ul>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val setupForQuery = Setup(prefix, longRunning, Some(obsId))
assemblyCommandService.submit(setupForQuery)

//do some work before querying for the result of above command as needed

val eventualResponse: Future[CommandResponse] = assemblyCommandService.query(setupForQuery.runId)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">hcdCmdService.submit(controlCommand, timeout);

// do some work before querying for the result of above command as needed

CompletableFuture&lt;CommandResponse&gt; queryResponse = hcdCmdService.query(controlCommand.runId(), timeout);</code></pre></dd>
</dl>
<ul>
  <li><strong>Subscribe</strong> - It is also possible to subscribe to asynchronously get command response updates for an executing command. At least one response is always delivered.</li>
</ul>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val eventualCommandResponse = assemblyCommandService.submit(setup).flatMap {
  case _: Accepted ⇒ assemblyCommandService.subscribe(setup.runId)
  case _           ⇒ Future(CommandResponse.Error(setup.runId, &quot;&quot;))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; testCommandResponse =
        hcdCmdService
                .submit(controlCommand, timeout)
                .thenCompose(commandResponse -&gt; {
                    if (commandResponse instanceof CommandResponse.Accepted)
                        return hcdCmdService.subscribe(commandResponse.runId(), timeout);
                    else
                        return CompletableFuture.completedFuture(new CommandResponse.Error(commandResponse.runId(), &quot;test error&quot;));
                });</code></pre></dd>
</dl>
<h2><a href="#commandservice" name="commandservice" class="anchor"><span class="anchor-link"></span></a>CommandService</h2>
<p>A helper/wrapper is provided called <code>CommandService</code> that provides a convenient way to use the Command Service with a component discovered using Location Service. A <code>CommandService</code> instance is created using the value from the Location Service. This <code>CommandService</code> instance will has methods for communicating with the component. </p>
<p>The API can be exercised as follows for different scenarios of command-based communication:</p>
<h3><a href="#submit" name="submit" class="anchor"><span class="anchor-link"></span></a>submit</h3>
<p>Submit a command and get a <code>CommandResponse</code> as a Future. The CommandResponse can be a response from validation (Accepted, Invalid) or a final Response in case of immediate completion.</p>
<dl>
  <dt>Scala/immediate-response
  </dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val eventualResponse: Future[CommandResponse] = async {
  await(assemblyComponent.submit(Setup(prefix, immediateCmd, obsId))) match {
    case response: Completed ⇒
      //do something with completed result
      response
    case otherResponse ⇒
      // do something with other response which is not expected
      otherResponse
  }
}</code></pre></dd>
  <dt>Java/immediate-response
  </dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; eventualCommandResponse =
        hcdCmdService
                .submit(imdInvalidCommand, timeout)
                .thenApply(
                        response -&gt; {
                            if (response instanceof Completed) {
                                //do something with completed result
                            }
                            return response;
                        }
                );</code></pre></dd>
  <dt>Scala/validation-response
  </dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// `setupWithTimeoutMatcher` is a sample setup payload intended to be used when command response is not determined
// using matcher
val submitCommandResponseF: Future[Unit] = async {
  val initialResponse: CommandResponse = await(assemblyComponent.submit(setupWithTimeoutMatcher))
  initialResponse match {
    case accepted: Accepted ⇒
    // do Something
    case invalid: Invalid ⇒
    // do Something
    case x ⇒
    // do Something
  }
}</code></pre></dd>
  <dt>Java/validation-response
  </dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture submitCommandResponseF = hcdCmdService
        .oneway(setup, timeout)
        .thenAccept(initialCommandResponse -&gt; {
            if (initialCommandResponse instanceof CommandResponse.Accepted) {
                //do something
            } else if (initialCommandResponse instanceof CommandResponse.Invalid) {
                //do something
            } else {
                //do something
            }
        });
</code></pre></dd>
</dl>
<h3><a href="#oneway" name="oneway" class="anchor"><span class="anchor-link"></span></a>oneway</h3>
<p>Send a command as a Oneway and get a <code>CommandResponse</code> as a Future. The CommandResponse can be a response of validation (Accepted, Invalid) or a final Response.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// `setupWithTimeoutMatcher` is a sample setup payload intended to be used when command response is not determined
// using matcher
val onewayCommandResponseF: Future[Unit] = async {
  val initialResponse: CommandResponse = await(assemblyComponent.oneway(setupWithTimeoutMatcher))
  initialResponse match {
    case accepted: Accepted ⇒
    // do Something
    case invalid: Invalid ⇒
    // do Something
    case x ⇒
    // do Something
  }
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture onewayCommandResponseF = hcdCmdService
        .oneway(setup, timeout)
        .thenAccept(initialCommandResponse -&gt; {
            if (initialCommandResponse instanceof CommandResponse.Accepted) {
                //do something
            } else if (initialCommandResponse instanceof CommandResponse.Invalid) {
                //do something
            } else {
                //do something
            }
        });
</code></pre></dd>
</dl>
<h3><a href="#subscribe" name="subscribe" class="anchor"><span class="anchor-link"></span></a>subscribe</h3>
<p>Subscribe for the result of a long-running command which was sent as Submit to get a <code>CommandResponse</code> as a Future.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val eventualCommandResponse = assemblyCommandService.submit(setup).flatMap {
  case _: Accepted ⇒ assemblyCommandService.subscribe(setup.runId)
  case _           ⇒ Future(CommandResponse.Error(setup.runId, &quot;&quot;))
}</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; testCommandResponse =
        hcdCmdService
                .submit(controlCommand, timeout)
                .thenCompose(commandResponse -&gt; {
                    if (commandResponse instanceof CommandResponse.Accepted)
                        return hcdCmdService.subscribe(commandResponse.runId(), timeout);
                    else
                        return CompletableFuture.completedFuture(new CommandResponse.Error(commandResponse.runId(), &quot;test error&quot;));
                });</code></pre></dd>
</dl>
<h3><a href="#query" name="query" class="anchor"><span class="anchor-link"></span></a>query</h3>
<p>Query for the result of a long-running command which was sent as Submit to get a <code>CommandResponse</code> as a Future.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val setupForQuery = Setup(prefix, longRunning, Some(obsId))
assemblyCommandService.submit(setupForQuery)

//do some work before querying for the result of above command as needed

val eventualResponse: Future[CommandResponse] = assemblyCommandService.query(setupForQuery.runId)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">hcdCmdService.submit(controlCommand, timeout);

// do some work before querying for the result of above command as needed

CompletableFuture&lt;CommandResponse&gt; queryResponse = hcdCmdService.query(controlCommand.runId(), timeout);</code></pre></dd>
</dl>
<h3><a href="#submitandsubscribe" name="submitandsubscribe" class="anchor"><span class="anchor-link"></span></a>submitAndSubscribe</h3>
<p>Submit a command and Subscribe for the result if it was successfully validated as <code>Accepted</code> to get a final <code>CommandResponse</code> as a Future.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val setupForSubscribe = Setup(prefix, longRunning, Some(obsId))
val response          = assemblyCommandService.submitAndSubscribe(setupForSubscribe)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; finalResponseCompletableFuture = hcdCmdService.submitAndSubscribe(failureResCommand1, timeout);
CommandResponse actualValidationResponse = finalResponseCompletableFuture.get();</code></pre></dd>
</dl>
<h3><a href="#onewayandmatch" name="onewayandmatch" class="anchor"><span class="anchor-link"></span></a>onewayAndMatch</h3>
<p>Send a command and match the published state from the component using a <code>StateMatcher</code>. If the match is successful a <code>Completed</code> response is provided as a future. In case of a failure or unmatched state, <code>Error</code> CommandResponse is provided as a Future.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val eventualResponse1: Future[CommandResponse] = assemblyComponent.onewayAndMatch(setupWithMatcher, demandMatcher)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java"><br/>// create a DemandMatcher which specifies the desired state to be matched.
StateMatcher stateMatcher = new DemandMatcher(new DemandState(prefix().prefix()).add(param), false, timeout);

// create matcher instance
Matcher matcher1 = new Matcher(hcdLocation.componentRef().narrow(), demandMatcher, ec, mat);

// start the matcher so that it is ready to receive state published by the source
CompletableFuture&lt;MatcherResponse&gt; matcherResponse = matcher1.jStart();

CompletableFuture&lt;CommandResponse&gt; matchedCommandResponse =
        hcdCmdService.onewayAndMatch(setup, stateMatcher, timeout);
</code></pre></dd>
</dl>
<h3><a href="#submitallandgetresponse" name="submitallandgetresponse" class="anchor"><span class="anchor-link"></span></a>submitAllAndGetResponse</h3>
<p>Submit multiple commands and get one CommandResponse as a Future of <code>CommandResponse</code> for all commands. If all the commands were successful, a CommandResponse as <code>Completed</code> will be returned. If any one of the command fails, an <code>Error</code> will be returned.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala"><br/>val responseOfMultipleCommands = hcdComponent.submitAllAndGetResponse(Set(setupHcd1, setupHcd2))
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Setup setupHcd1 = new Setup(prefix(), shortRunning(), Optional.empty()).add(encoderParam);
Setup setupHcd2 = new Setup(prefix(), mediumRunning(), Optional.empty()).add(encoderParam);

HashMap&lt;JCommandService, Set&lt;ControlCommand&gt;&gt; componentsToCommands = new HashMap&lt;JCommandService, Set&lt;ControlCommand&gt;&gt;() {
    {
        put(hcdCmdService, new HashSet&lt;ControlCommand&gt;(Arrays.asList(setupHcd1, setupHcd2)));
    }
};

CompletableFuture&lt;CommandResponse&gt; commandResponse = hcdCmdService
        .submitAllAndGetResponse(
                new HashSet&lt;ControlCommand&gt;(Arrays.asList(setupHcd1, setupHcd2)),
                timeout
        );</code></pre></dd>
</dl>
<h3><a href="#submitallandgetfinalresponse" name="submitallandgetfinalresponse" class="anchor"><span class="anchor-link"></span></a>submitAllAndGetFinalResponse</h3>
<p>Submit multiple commands and get final CommandResponse for all as one CommandResponse. If all the commands were successful, a CommandResponse as <code>Completed</code> will be returned. If any one of the command fails, an <code>Error</code> will be returned. For long running commands, it will subscribe for the result of those which were successfully validated as <code>Accepted</code> and get the final CommandResponse.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala"><br/>val finalResponseOfMultipleCommands = hcdComponent.submitAllAndGetFinalResponse(Set(setupHcd1, setupHcd2))
</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Setup setupHcd1 = new Setup(prefix(), shortRunning(), Optional.empty()).add(encoderParam);
Setup setupHcd2 = new Setup(prefix(), mediumRunning(), Optional.empty()).add(encoderParam);

HashMap&lt;JCommandService, Set&lt;ControlCommand&gt;&gt; componentsToCommands = new HashMap&lt;JCommandService, Set&lt;ControlCommand&gt;&gt;() {
    {
        put(hcdCmdService, new HashSet&lt;ControlCommand&gt;(Arrays.asList(setupHcd1, setupHcd2)));
    }
};

CompletableFuture&lt;CommandResponse&gt; finalCommandResponse = hcdCmdService
        .submitAllAndGetFinalResponse(
                new HashSet&lt;ControlCommand&gt;(Arrays.asList(setupHcd1, setupHcd2)),
                timeout
        );</code></pre></dd>
</dl>
<h3><a href="#subscribecurrentstate" name="subscribecurrentstate" class="anchor"><span class="anchor-link"></span></a>subscribeCurrentState</h3>
<p>This method can be used to subscribe to the <a href="../messages/states.html">CurrentState</a> of the component by providing a callback. Subscribing results into a handle of <code>CurrentStateSubscription</code> which can be used to unsubscribe the subscription.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">// subscribe to the current state of an assembly component and use a callback which forwards each received
// element to a test probe actor
assemblyCommandService.subscribeCurrentState(probe.ref ! _)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">// subscribe to the current state of an assembly component and use a callback which forwards each received
// element to a test probe actor
CurrentStateSubscription subscription = hcdCmdService.subscribeCurrentState(currentState -&gt; probe.ref().tell(currentState));</code></pre></dd>
</dl>
<h2><a href="#matching-state-for-command-completion" name="matching-state-for-command-completion" class="anchor"><span class="anchor-link"></span></a>Matching state for command completion</h2>
<p>A <code>Matcher</code> is provided for matching state against a desired state. The matcher is created with a source of state identified by its ActorRef and an instance of <code>StateMatcher</code> which defines the state and criteria for matching. Several instances of <code>StateMatcher</code> are available for common use. These are <code>DemandMatcherAll</code> for matching the entire <code>DemandState</code> against the current state, <code>DemandMatcher</code> for matching state with or without units against the current state and <code>PresenceMatcher</code> which checks if a matching state is found with a provided prefix. </p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala"><br/>// create a DemandMatcher which specifies the desired state to be matched.
val demandMatcher = DemandMatcher(DemandState(prefix, Set(param)), withUnits = false, timeout)

// create matcher instance
val matcher = new Matcher(assemblyLocation.componentRef, demandMatcher)

// start the matcher so that it is ready to receive state published by the source
val matcherResponseF: Future[MatcherResponse] = matcher.start

// submit command and if the command is successfully validated, check for matching of demand state against current state
val eventualCommandResponse: Future[CommandResponse] = async {
  val initialResponse = await(assemblyComponent.oneway(setupWithMatcher))
  initialResponse match {
    case _: Accepted ⇒
      val matcherResponse = await(matcherResponseF)
      // create appropriate response if demand state was matched from among the published state or otherwise
      matcherResponse match {
        case MatchCompleted  ⇒ Completed(setupWithMatcher.runId)
        case MatchFailed(ex) ⇒ Error(setupWithMatcher.runId, ex.getMessage)
      }
    case invalid: Invalid ⇒
      matcher.stop()
      invalid
    case x ⇒ x
  }
}

val commandResponse = Await.result(eventualCommandResponse, timeout.duration)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java"><br/>// create a DemandMatcher which specifies the desired state to be matched.
DemandMatcher demandMatcher = new DemandMatcher(new DemandState(prefix().prefix()).add(param), false, timeout);

// create matcher instance
Matcher matcher = new Matcher(hcdLocation.componentRef().narrow(), demandMatcher, ec, mat);

// start the matcher so that it is ready to receive state published by the source
CompletableFuture&lt;MatcherResponse&gt; matcherResponseFuture = matcher.jStart();

// submit command and if the command is successfully validated, check for matching of demand state against current state
CompletableFuture&lt;CommandResponse&gt; commandResponseToBeMatched = hcdCmdService
        .oneway(setup, timeout)
        .thenCompose(initialCommandResponse -&gt; {
            if (initialCommandResponse instanceof CommandResponse.Accepted) {
                return matcherResponseFuture.thenApply(matcherResponse -&gt; {
                    // create appropriate response if demand state was matched from among the published state or otherwise
                    if (matcherResponse.getClass().isAssignableFrom(MatcherResponses.jMatchCompleted().getClass()))
                        return new Completed(initialCommandResponse.runId());
                    else
                        return new CommandResponse.Error(initialCommandResponse.runId(), &quot;Match not completed&quot;);
                });
            } else {
                matcher.stop();
                return CompletableFuture.completedFuture(initialCommandResponse);
            }
        });

CommandResponse actualResponse = commandResponseToBeMatched.get();
</code></pre></dd>
</dl>
<h2><a href="#distributing-commands" name="distributing-commands" class="anchor"><span class="anchor-link"></span></a>Distributing commands</h2>
<p><code>CommandDistributor</code> is a utility for distributing commands to multiple components and get an aggregated response. </p>
<h3><a href="#aggregated-validation-response" name="aggregated-validation-response" class="anchor"><span class="anchor-link"></span></a>aggregated validation response</h3>
<p>A component can send one or more commands to one or more components using a <code>Map[ComponentRef, Set[ControlCommand]</code>, and get an aggregated response of validation as <code>Accepted</code> if all the commands were successfully validated. An <code>Error</code> response is returned otherwise</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val aggregatedValidationResponse = CommandDistributor(
  Map(assemblyCommandService → Set(setupAssembly1, setupAssembly2), hcdComponent → Set(setupHcd1, setupHcd2))
).aggregatedValidationResponse()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; cmdValidationResponseF =
        new JCommandDistributor(componentsToCommands).
                aggregatedValidationResponse(timeout, ec, mat);</code></pre></dd>
</dl>
<h3><a href="#aggregated-completion-response" name="aggregated-completion-response" class="anchor"><span class="anchor-link"></span></a>aggregated completion response</h3>
<p>A component can send one or more commands to one or more components using a <code>Map[ComponentRef, Set[ControlCommand]</code>. The utility handles subscribing for final completion result for all the commands post successful validation and get an aggregated response of completion as <code>Completed</code> if all the commands were successfully completed. An <code>Error</code> response is returned otherwise.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val aggregatedResponse = CommandDistributor(
  Map(assemblyCommandService → Set(setupAssembly1, setupAssembly2), hcdComponent → Set(setupHcd1, setupHcd2))
).aggregatedCompletionResponse()</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">CompletableFuture&lt;CommandResponse&gt; cmdCompletionResponseF =
        new JCommandDistributor(componentsToCommands).
                aggregatedCompletionResponse(timeout, ec, mat);</code></pre></dd>
</dl>
</div>
<div>
<a href="https://github.com/tmtsoftware/csw-prod/tree/master/docs/src/main/commons/command.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.1.2
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../framework/deploying-components.html" title="Deploying Components" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Deploying Components
</span>
</div>
</a>
<a href="../commons/services.html" title="Services" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Services
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.5165553b.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
