{"docs":[{"location":"/index.html","text":"","title":"TMT Common Software (CSW)"},{"location":"/index.html#tmt-common-software-csw-","text":"Common Software is the package of services and infrastructure software that integrates the TMT software systems.\nVisit TMT website to know more about Thirty Meter Telescope.","title":"TMT Common Software (CSW)"},{"location":"/index.html#common-software-architecture","text":"CSW is designed to support the Observing Mode-Oriented Architecture (OMOA). An observing mode is a well-defined instrument observing task and an associated set of owned resources, procedures, and capabilities that implement the mode. An example observing mode is: IRIS multi-filter integral field spectroscopy using the NFIRAOS adaptive optics unit with AO laser guide star correction. An instrument will generally have several associated observing modes for acquisition, science objects, and calibrations. Examples of observing mode resources could be an instrument’s hardware devices, or the use of a larger system such as the Laser Guide Star Facility.\nOMOA structures the software as the layers in the following figure. Each layer contains components with specific responsibilities described in the following sections. OMOA bypasses the use of standalone “subsystems” (large principal systems) for a flatter system that requires less code and allows the software system for an observing mode to optionally be more flexibly composed at run-time.","title":"Common Software Architecture"},{"location":"/index.html#layer-0-obseratory-hardware","text":"Layer 0 represents the actual hardware being controlled and the hardware controllers that interface the hardware to the computer systems.","title":"Layer 0 - Obseratory Hardware"},{"location":"/index.html#layer-1-hardware-control-layer","text":"The lowest layer in the OMOA software system, the Hardware Control Layer, consists of all the controllable hardware that is available for use by higher levels of software. A sea of similar software components called Hardware Control Daemons (HCD) at layer 1 controls the low-level hardware of the telescope, adaptive optics, and instruments.\nAn HCD is similar to the device driver found in many systems. Each HCD is associated with a networked motion controller, a PLC/PAC, or other low-level hardware controller present in Layer 0. Some hardware controllers will support multiple channels. An HCD may support a highly cohesive, related set of functionality. For instance, one motion controller with 8 axes might handle all the slow moving filters and gratings of an instrument. In other cases, the channels of the controller hardware could be associated with unrelated devices. If the hardware controller has multiple channels, the HCD supports access to all the channels and must multiplex access to the controller and coordinate requests and replies among the clients.","title":"Layer 1 - Hardware Control Layer"},{"location":"/index.html#layer-2-assembly-layer","text":"The Assembly Layer exists just above the Hardware Control Layer at Layer 2. Software at this layer consists of components called Assemblies. In OMOA, an Assembly represents a device as a collection of hardware that makes sense at the user level. Examples of instrument devices are a filter wheel, a deformable mirror, or a detector controller. Assemblies often represent user-oriented devices in the software system, but it is not necessary that an Assembly control HCDs.","title":"Layer 2 - Assembly Layer"},{"location":"/index.html#layer-3-sequencing-layer","text":"The Sequencing Layer is Layer 3 in the figure above. Components at this level are called Sequencers or Sequence Components because they take complex descriptions of tasks and control and synchronize the actions of the Assemblies to accomplish the tasks.\nSequence Components in this layer share a software interface that allows them to be plugged together to form the sequencing hierarchy for a specific observing mode. Individual Sequencers can provide higher-level control of a set of distributed hardware (e.g., init). Individual sequencers can be programmable using scripts. There can be one or many Sequence Components in an observing mode sequencer.","title":"Layer 3 - Sequencing Layer"},{"location":"/index.html#layer-4-monitoring-and-control-layer","text":"The Monitoring/Control Layer is the layer of software that contains the user interface programs that are used to observe with the telescope. At TMT there will be graphical user interfaces for use by observers during observing. These applications use the CSW services to control and monitor the system.","title":"Layer 4 - Monitoring and Control Layer"},{"location":"/index.html#csw-services","text":"CSW or Common Software provides a shared software infrastructure based on a set of services and associated software for integrating individual components in the large observatory software architecture. The components and client applications use a set of loosely coupled services, each autonomous with a well-defined interface that hides the service implementation. It also provides a standardized communication with the services.","title":"CSW Services"},{"location":"/index.html#","text":"The Location Service of TMT Common Software handles application, component, and service registration and discovery in the distributed TMT software system. When a component (i.e. an Sequencer, Assembly, or HCD) is initializing, it registers its name along with other information such as interface type and connection information to the Location Service. The important feature and reason for the Location Service is that details of connection information should not be hardwired, they should be discovered at runtime.\nLocation Service is most obviously needed when one component commands another component. In this case the first component uses the Location Service to get information about the second component, and uses that information to make a connection. Discovered information might include a protocol (e.g., HTTP), interface type (e.g., command), or host and port.","title":"Location Service"},{"location":"/index.html#","text":"The Configuration Service (CS) provides a centralized persistent store for “configuration files” used in the TMT Software System. In this context, a configuration file is a set of values describing state, initialization values, or other information useful to a component or set of components. The TCS provides many examples such as look-up tables of various kinds or a set of pointing model parameters or parameters for setting up a motion controller. Another is the Alarm Service Configuration File. At the applications level, the GUI used by the Observing Assistant could provide a button to save offsets between an instrument science field and its acquisition camera origin. These are the kinds of scenarios that use the Configuration Service.\nThe Configuration Service provides the added feature of storing versions of configuration files. All versions of configuration files are retained providing a historical record of changes for each configuration file. Components can save today’s version without fear that yesterday’s version will be lost. If the configuration of a component is inadvertently lost, it will be possible to easily restore to the most recently saved version or a default version.","title":"Configuration Service"},{"location":"/index.html#","text":"Logging is the ability of a software component to output a message, usually for diagnostic purposes. TMT Common Software will provide a Logging Service. Logging should not be confused with “data logging”, which is usually collection of measured values.\nThis log message includes a time of the log message, a severity (INFO), the source of the log message as a package path in the software, and a formatted text message. The Logging Service provides the ability to log messages locally to a file or screen and optionally to a centralized logging aggregator.\nThe central logging aggregator (not part of this release) provides the capability for all components to log diagnostic information to a central and optionally persistent store. The logging information is then aggregated and ordered by timestamp. A coordinated, centralized log can be an extremely useful tool for diagnosing many types of distributed software problems. Structured logging will be used with the central logging aggregator.\nThe Logging Service is unique because it is required early in the lifecycle of a component and most components and CSW services themselves will want the ability to log information. It is often necessary to log messages while a component starts up. This means that the implementation of distributed logging must not depend upon other services (at least if the independence of services is desired). It also means that distributed logging will need to load quickly and provide proper behavior if the aggregating logging capability is needed.\nThe logging API provides familiar features similar to available logging libraries including logging levels and the ability to dynamically change the component’s logging configuration while the component is executing. This allows the ability to interactively log more detailed messages when a component encounters problems.","title":"Logging Service"},{"location":"/index.html#","text":"In the TMT software design, an Application or Sequence Component connects to Assemblies and causes actions by submitting commands. Assemblies connect to and command HCDs. The service that provides the command functionality called the Command Service (CCS).\nIn TMT, commands require peer-to-peer connections between the component sending a command and the component receiving the command. There is no reason to directly connect to a component unless that component will be commanded. The Location Service provides connection information for components sending commands with CCS.\nIn the system design each observing mode has a sequencer that consists of one or more OMOA Sequence Components. Commands flow down through the Sequence Components to the Assemblies, HCDs and hardware in a hierarchy.","title":"Command Service"},{"location":"/index.html#","text":"The framework provides templates for creating and running the kind of software components defined by TMT as well as service access interfaces for these components. It also provides application support for running multiple components on a host machine.\nThe framework also contains the structures that are common to components, such as commands and event structures.","title":"Framework"},{"location":"/index.html#http-based-services-api-documentation-can-be-found-","text":"","title":"HTTP-based services API documentation can be found here."},{"location":"/commons/getting-started.html","text":"","title":"Getting Started"},{"location":"/commons/getting-started.html#getting-started","text":"In this tutorial, you’ll see how to create a Scala/Java project using a giter8 template for CSW (csw.g8) which contains sample handlers for creating HCD and Assembly. It also contains a deploy project which is responsible for starting multiple components or containers. You can use this as a starting point for your own projects for writing component. We’ll use the sbt build tool which compiles, runs, and tests your projects among other related tasks.","title":"Getting Started"},{"location":"/commons/getting-started.html#installation","text":"Supported Operating Systems are: CentOS and MacOS\nMake sure you have the Java 8 JDK (also known as 1.8) Run javac -version in the command line and make sure you see javac 1.8.___ If you don’t have version 1.8 or higher, install the JDK Install sbt Mac Linux Install IntelliJ MAC Linux Install following IntelliJ Plugins Scala Scalafmt Recommended testing frameworks/tools: ScalaTest JUnit, JUnit Interface Note: These frameworks are typically downloaded and made available by the sbt tool by specifying them as dependencies. If you are using the giter8 template (see below), these dependencies are specified by default, and the sbt will resolve them when it runs.","title":"Installation"},{"location":"/commons/getting-started.html#create-project","text":"cd to an empty folder. Run the following command sbt new tmtsoftware/csw.g8. This pulls the ‘csw’ template from GitHub. If above command fails to pull template, then try running with full path sbt new https://github.com/tmtsoftware/csw.g8 Provide input details when prompted. Follow the template readme.md for detailed information about input parameters.\nLet’s take a look at what just got generated:\nIn this example, a project was created with default parameters. The complete project structure looks like this:\nAs you can see in below snapshot, template will create three projects: galil-assembly galil-hcd galil-deploy\ngalil-deploy project is used to create a concrete implementation. This allows for the construction of a complete binary package bundled with all dependencies, and a launching application.\n3. Template comes with csw-prod and other useful library dependencies. It also includes bunch of plugins as explained in below snapshot","title":"Create project"},{"location":"/commons/getting-started.html#add-new-sbt-project-module","text":"If you want to add a new project with name galil-io, then follow below steps:\nAdd external library dependencies required by galil-io in Libs.scala file, if it does not exist. val `akka-actor` = \"com.typesafe.akka\" %% \"akka-actor\" % \"2.5.11\"\n Map new/existing library dependencies in Dependencies.scala file against new project. val GalilIO = Seq( Libs.`akka-actor` )\n Include below snippet in build.sbt file, this will create new sbt project module. lazy val `galil-io` = project\n  .settings( libraryDependencies ++= Dependencies.GalilIO )\n If you new module depends on code from other modules within this project, use .dependsOn in your build.sbt file: lazy val `galil-io` = project\n  .settings( libraryDependencies ++= Dependencies.GalilIO )\n  .dependsOn(\n`galil-assembly`,\n`galil-hcd`\n  )\n Update the deployment dependencies: lazy val `galil-deploy` = project\n  .dependsOn(\n`galil-assembly`,\n`galil-hcd`,\n`galil-io`\n  )","title":"Add new sbt project module"},{"location":"/commons/create-component.html","text":"","title":"Creating a Component"},{"location":"/commons/create-component.html#creating-a-component","text":"This tutorial helps in creating a CSW component in Scala/Java. CSW components depend on the csw-framework package, which can be found here. This tutorial discusses constructing a HCD, but the principles apply to an Assembly as well. We will be constructing the Assembly in the next tutorial section Working with Mulitple Components.","title":"Creating a Component"},{"location":"/commons/create-component.html#anatomy-of-component","text":"A component consists of a supervisor actor, a Top Level Actor, a component handler and one or more worker actors. From all these, csw-framework provides supervisor actor, a Top Level Actor and abstract class of handlers. Component developers are expected to implement this handler which also acts as a gateway from framework to component code.","title":"Anatomy of Component"},{"location":"/commons/create-component.html#supervisor","text":"A Supervisor actor is the actor first started for any component. The main responsibilities that supervisor performs is as follows:\nImplement and manage the component lifecycle for the TLA and for the rest of the system (see Lifecycle below). Register itself with location service. Provide an administrative interface to the component to the rest of the system. For instance, the Container can perform certain administrative communication with the Supervisor such as restart or shutdown. Allow components outside of the Supervisor and TLA to monitor the lifecycle state of the TLA. This is particularly useful for testing. The test needs to know that the component is ready before it starts its test actions.\nNote Because the Supervisor registers itself with location service, it serves as the gateway for all incoming communications from external components/entities.\nThe source code of supervisor actor can be found here","title":"Supervisor"},{"location":"/commons/create-component.html#top-level-actor","text":"While the Supervisor works as the external interface for the component and the manager of Lifecycle, the functional implementation of a component is implemented in a Top Level Actor (TLA), spawned by supervisor actor for any component. However, the developer is not expected to implement TLA code directly. Instead, the functionality of the TLA is added by implementing the ComponentHandlers abstract class, consisting of a list of a methods, or hooks, called by the TLA during specific lifecycle and command events (see Handlers). The ComponentHandlers implementation is specified during constructing using that factory (see Constructing The Component)\nThe source code of the Top Level Actor can be found here.","title":"Top level actor"},{"location":"/commons/create-component.html#handlers","text":"The following hooks should be overridden in your ComponentHandlers implementation class:\ninitialize: called when component is starting up, prior to be put into the Running state. validateCommand: called when component receives a command. (see Validation) onSubmit: called on Submit command if validateCommand returns Accepted. onOneway: called on Oneway command if validateCommand returns Accepted. onGoOffline: called when component receives external message to go offline. onGoOnline: called when component receives external message to go online. onLocationTrackingEvent: called when a tracked dependency changes location state. (see Tracking Dependencies) onShutdown: called when component is shutting down.\nThe source code of ComponentHandlers can be found here.\nMore details about handler significance and invocation can be found here\nNote If the component developer wishes to write the handler implementation in java, then he/she needs to implement the java version of ComponentHandlers which is JComponentHandlers. The source code of JComponentHandlers can be found here. Any further reference to ComponentHandlers should implicitly also apply to JComponentHandlers.","title":"Handlers"},{"location":"/commons/create-component.html#constructing-the-component","text":"After writing the handlers, component developer needs to wire it up with framework. In order to do this, developer needs to implement a ComponentBehaviorFactory. This factory should to be configured in configuration file for the component (see example below). The csw-framework then picks up the full path of ComponentBehaviorFactory from configuration file and spawns the component handlers using this factory as a process of booting a component. The factory is instantiated using java reflection.\nNote If using the gitter8 template, this factory class will be implemented for you.\nThe sample code to implement the ComponentBehaviorFactory can be found here","title":"Constructing the Component"},{"location":"/commons/create-component.html#component-configuration-componentinfo-","text":"Component configuration contains details needed to spawn a component. This configuration resides in a configuration file for a particular component. The sample for HCD is as follows:\nname = \"GalilHcd\"\ncomponentType = hcd\nbehaviorFactoryClassName = \"org.tmt.nfiraos.galilhcd.GalilHcdBehaviorFactory\"\nprefix = \"galil.hcd\"\nlocationServiceUsage = RegisterOnly\nNote behaviorFactoryClassName refers to class name of the concrete implementation of ComponentBehaviorFactory, which is GalilHcdBehaviorFactory in above example.\nThe name and componentType is used to create the ComponentId representing a unique component in location service.\nThe locationServiceUsage is used by the Supervisor actor to decide whether to only register a component with location service or register and track other components.\nThe configuration file is parsed to a ComponentInfo object and injected in the Supervisor actor. It is then injected in ComponentHandlers while spawning a component.\nThe configuration can also contain a list of components and services it wishes to track as dependencies. See Tracking Dependencies.\nMore details about ComponentInfo can be found here.\nA sample configuration file can be found here.","title":"Component Configuration (ComponentInfo)"},{"location":"/commons/create-component.html#lifecycle","text":"A component can be in one of the following states of lifecycle:\nIdle Running RunningOffline Restart Shutdown Lock","title":"Lifecycle"},{"location":"/commons/create-component.html#idle","text":"The component initializes in the idle state. Top level actor calls the initialize hook of ComponentHandlers as first thing on boot-up. Component developers write their initialization logic in this hook. The logic could also do things like accessing the configuration service to fetch the hardware configurations to set the hardware to default positions.\nAfter the initialization, if the component would have configured RegisterAndTrack for locationServiceUsage then the Top Level Actor will start tracking the connections configured for that component. This use case is mostly applicable for Sequencers and Assemblies. HCDs mostly will have RegisterOnly configured for locationServiceUsage.\nThe Supervisor actor will now register itself with location service. Registering with location service will notify other components tracking this component with a LocationUpdated event containing a Location with a reference to the Supervisor actor.\nAfter successful registration, the component will transition to Running state.","title":"Idle"},{"location":"/commons/create-component.html#running","text":"When the supervisor actor receives Initialized message from the Top Level Actor after successful initialization, it registers itself with location service and transitions the component to Running state. Running state signifies that the component is accessible via location service, which allows other entities to communicate with it by sending commands via messages. Any commands received by supervisor actor will be forwarded to the Top Level Actor for processing.","title":"Running"},{"location":"/commons/create-component.html#runningoffline","text":"When the Supervisor actor receives GoOffline message, it transitions the component to RunningOffline state and forwards it to the Top Level Actor. The Top Level Actor then calls onGoOffline hook of ComponentHandlers.\nIf GoOnline message is received by the Supervisor actor then it transits the component back to Running state and forwards it to the Top Level Actor. The Top Level Actor then calls onGoOnline hook of ComponentHandlkers.\nNote In RunningOffline state, if any command is received, it is forwarded to underlying component hook through the Top Level Actor. It is then the responsibility of the component developer to check the isOnline flag provided by csw-framework and process the command accordingly.","title":"RunningOffline"},{"location":"/commons/create-component.html#restart","text":"When the Supervisor actor receives a Restart message, it will transit the component to the Restart state. Then, it will unregister itself from location service so that other components tracking this component will be notified and no commands are received while restart is in progress.\nThen, the Top Level Actor is stopped and postStop hook of the Top Level Actor will call the onShutdown hook of ComponentHandlers. Component developers are expected to write any cleanup of resources or logic that should be executed for graceful shutdown of component in this hook.\nAfter successful shutdown of component, the Supervisor actor will create the Top Level Actor again from scratch. This will cause the initialize hook of ComponentHandlers to be called again. After successful initialization of component, the Supervisor actor will register itself with location service.","title":"Restart"},{"location":"/commons/create-component.html#shutdown","text":"When the Supervisor actor receives a Shutdown message, it transitions the component to the Shutdown state. Any commands received while shutdown is in progress will be ignored. Then, it will stop the Top Level Actor. The postStop hook of the Top Level Actor will call the onShutdown hook of ComponentHandlers. Component developers are expected to write any cleanup of resources or logic that should be executed for graceful shutdown of component in this hook.","title":"Shutdown"},{"location":"/commons/create-component.html#lock","text":"When the Supervisor actor receives a Lock message, it transitions the component to the Lock state. Upon locking, the Supervisor will only accept the commands received from the component that locked the component and ignore all others.\nIn the Lock state, messages like Shutdown and Restart will also be ignored. A component must first be unlocked to accept these commands.\nLock messages are constructed with a duration value specified. When this duration expires, the component will automatically be unlocked. A component can be manually unlocked by sending an Unlock message.","title":"Lock"},{"location":"/commons/create-component.html#logging","text":"csw-framework will provide a LoggerFactory as dependency injection in constructor of ComponentHandlers. The LoggerFactory will have the component’s name predefined in it. The component developer is expected to use this factory to log statements.\nMore details on how to use LoggerFactory can be found here.","title":"Logging"},{"location":"/commons/create-component.html#receiving-commands","text":"A command is something that carries some metadata and a set of parameters. A component sends message to other components using commands. Various kinds of commands are as follows:\nSetup : Contains goal, command, or demand information to be used to configure the target OMOA component. Observe: Contains goal or demand information to be used by a detector. system. Properties and their value types will be standardized by the ESW for the ESW PDR. Wait: Sequencer only. Instructs a sequencer to pause until told to continue.\nMore details about creating commands can be found here.\nWhenever a command is sent to a component it is wrapped inside a command wrapper. There are two kinds of command wrapper:\nSubmit: A command is wrapped in submit when the completion result is expected from receiver component Oneway: A command is wrapped in oneway when the completion of command is not expected from receiver component but is determined by sender component by subscribing to receiver component’s state","title":"Receiving Commands"},{"location":"/commons/create-component.html#validation","text":"When a command is received by a component, the Top Level Actor will call the validateCommand hook of ComponentHandlers. Component developers are expected to perform appropriate validation of command, whether it is valid to execute, and return a CommandResponse. The CommandResponse returned from this hook will be sent back to sender directly by csw-framework.\nThe logic in validateCommand hook can used to handle commands of various durations. If the command can be executed immediately, then the component developer can return a final response directly in the validation step using a CompletedWithResult command response. This should be only used for commands that require a very small amount of time to execute. If the command will take longer, then component developer should return an intermediate response Accepted or Invalid specifying whether the command is valid to be executed or not, and process the command in the onSubmit or onOneway handlers (see Command Response).\nDifferent types of command responses and their significance can be found here.","title":"Validation"},{"location":"/commons/create-component.html#command-response","text":"The response returned from validateCommand hook of ComponentHandlers will be received by the Top Level Actor, who then sends the response back to sender. If the response returned was Accepted, then it either calls the onSubmit hook or the onOneway hook of ComponentHandlers depending on the wrapper(submit or oneway) in which the command was received.\nIf the command was received as a Submit, then the Top Level Actor adds the response returned from the validateCommand hook in the CommandResponseManager. If the response was Accepted, the TLA then calls the onSubmit hook of ComponentHandlers.\nIn case the command received by a component a Oneway, the response is not added to the CommandResponseManager, and the onOneway hook of ComponentHandlers is called.\nThe CommandResponseManager is responsible for managing and bookkeeping the command status of long running submit commands. The sender of the command (and any component, really) can query the command statuses or subscribe to changes in command statuses using CommandService.\nThe CommandService class provides helper methods for communicating with other components, and should be a component’s primary means of sending commands to other components. This will be described in the next tutorial section, Sending Commands.\nWhen the onSubmit hook is called, it is the responsibility of component developers to update the status of the received command in the CommandResponseManager as it changes. The instance of commandResponseManager is provided in ComponentHandlers which should be injected in any worker actor or other actor/class created for the component.\nMore details on methods available in CommandResponseManager can be found here.","title":"Command Response"},{"location":"/commons/create-component.html#building-and-running-component-in-standalone-mode","text":"Once the component is ready, it is started using the ContainerCmd object in standalone mode. The details about starting the ContainerCmd in standalone mode can be found here.\nTo run the component using the deployment package, perform the following steps:\nRun sbt <project>/universal:packageBin. This will create self contained zip in <project>/target/universal directory Unzip generated zip file and enter into bin directory Run the ./<project>-cmd-app --local --standalone <path-to-local-config-file-to-start-the-component>\nNote CSW Location Service cluster seed must be running, and appropriate environment variables set to run apps. See https://tmtsoftware.github.io/csw-prod/apps/cswclusterseed.html.","title":"Building and Running component in standalone mode"},{"location":"/commons/multiple-components.html","text":"","title":"Multiple Components"},{"location":"/commons/multiple-components.html#multiple-components","text":"In this part of the tutorial, we will demonstrate functionality involving multiple components. We will do this by creating an Assembly, demonstrating how to deploy start the Assembly and an HCD in a container, and having them communicate with each other.","title":"Multiple Components"},{"location":"/commons/multiple-components.html#creating-an-assembly","text":"Similar to the HCD in the previous page, to create an assembly, the component developer needs to implement the ComponentHandlers. More details about implementing ComponentHandlers can be found here.","title":"Creating an Assembly"},{"location":"/commons/multiple-components.html#component-configuration-componentinfo-","text":"Also similar to the HCD, we will need to create a ComponentInfo file for the Assembly. The following shows an example of ComponentInfo file for an Assembly:\nname = \"GalilAssembly\"\ncomponentType = assembly\nbehaviorFactoryClassName = \"org.tmt.nfiraos.galilassembly.GalilAssemblyBehaviorFactory\"\nprefix = \"galil.assembly\"\nlocationServiceUsage = RegisterAndTrackServices\nconnections = [\n  {\n    name: \"GalilHcd\"\n    componentType: hcd\n    connectionType: akka\n  }\n]\nNote There is a section for listing connections. These are the connections that the component will automatically track, and can be other components or services. When available, it may make sense to track things like the Event Service. These connections can also be specified for HCDs, but of course, they should not have any component dependencies.\nThe above shows a configuration file for running in standalone mode. If we want to run both the assembly and HCD in a container, the file would look like this:\nname = \"GalilAssemblyContainer\"\ncomponents: [\n  {\n    name = \"GalilAssembly\"\n    componentType = assembly\n    behaviorFactoryClassName = \"org.tmt.nfiraos.galilassembly.GalilAssemblyBehaviorFactory\"\n    prefix = \"galil.assembly\"\n    locationServiceUsage = RegisterAndTrackServices\n    connections = [\n      {\n        name: \"GalilHcd\"\n        componentType: hcd\n        connectionType: akka\n      }\n    ]\n  },\n  {\n    name = \"GalilHcd\"\n    componentType = hcd\n    behaviorFactoryClassName = \"org.tmt.nfiraos.galilhcd.GalilHcdBehaviorFactory\"\n    prefix = \"galil.hcd\"\n    locationServiceUsage = RegisterOnly\n  }\n]\nMore details about each configuration and its significance can be found here.\nAnother sample container configuration file can be found here.","title":"Component Configuration (ComponentInfo)"},{"location":"/commons/multiple-components.html#tracking-dependencies","text":"The connections that are defined in the configuration file for an assembly will be tracked by the csw-framework. For each connection the following details are configured:\n{\n    name: \"GalilHcd\"\n    componentType: hcd\n    connectionType: akka\n}\nThe name of the component, the type(hcd, service, etc) and the connection(akka, http, tcp) will be used to create a Connection object. The Connection object will be then used to track the location of a component using location service.\nThe Location object has one of the following types:\nAkkaLocation: Contains the remote address of the actorRef. The actorRef will be the Supervisor actor of a component. HttpLocation: Holds the HTTP URI of the web server, e.g. Configuration Service TcpLocation: Represents a TCP URI of the server, e.g. Event Service\nMore details about tracking a component using the location service can be found here.","title":"Tracking Dependencies"},{"location":"/commons/multiple-components.html#onlocationtrackingevent-handler","text":"For all the tracked connections, whenever a location is changed, added, or removed, one of the following events is generated:\nLocationUpdated: a location was added or changed LocationRemoved: a location is no longer available on the network\nWhenever such an event is generated, the Top level actor will call the onLocationTrackingEvent hook of ComponentHandlers with the event(LocationUpdated or LocationRemoved) as parameter of the hook.\nMore details about tracking connections can be found here.","title":"onLocationTrackingEvent Handler"},{"location":"/commons/multiple-components.html#trackconnection","text":"If the component developer wants to track a connection that is not configured in its configuration file then it can use the trackConnection method provided by csw-framework in ComponentHandlers. The trackConnection method will take the Connection instance. Information on how to create a connection instance can be found here.\nNote Connections tracked by csw-framework (from a configuration file) or by a component developer using the trackConnection method both will be received in the onLocationTrackingEvent hook of ComponentHandlers.","title":"trackConnection"},{"location":"/commons/multiple-components.html#sending-commands","text":"From the location information obtained either by tracking dependencies or manually resolving a location, a CommandService instance can be created to provide a command interface to the component.\nScala implicit val system: ActorSystem[Nothing] = ctx.system\n\nval eventualCommandService: Future[CommandService] = locationService.resolve(hcdConnection.of[AkkaLocation], 5.seconds).map {\n  case Some(hcdLocation: AkkaLocation) => new CommandService(hcdLocation)\n  case _                               => throw HcdNotFoundException()\n}\n\neventualCommandService.foreach { commandService ⇒\n  hcd = commandService\n} Java CompletableFuture<Optional<AkkaLocation>> resolvedHcdLocation = locationService.resolve(hcdConnection, FiniteDuration.apply(5, TimeUnit.SECONDS));\n\nCompletableFuture<JCommandService> eventualCommandService = resolvedHcdLocation.thenApply((Optional<AkkaLocation> hcdLocation) -> {\n    if (hcdLocation.isPresent())\n        return new JCommandService(hcdLocation.get(), ctx.getSystem());\n    else\n        throw new HcdNotFoundException();\n});\n\neventualCommandService.thenAccept((jcommandService) -> hcd = jcommandService);\nIf a component wants to send a command to another component, it uses a CommandService instance. The creation of aCommandService instance and its usage can be found here.\nIf a component wants to send multiple commands in response to a single received command, then it can use a CommandDistributor instance. The CommandDistributor will help in getting the aggregated response of multiple commands sent to other components. The component developer can use the aggregated response to update the CommandResponseManager with the appropriate status if the received command was in a Submit wrapper.\nMore details about creating a CommandDistributor instance and its usage can be found here.\nNote CommandDistributor can be used to get an aggregated response only if the multiple commands sent to other components are all wrapped in a Submit wrapper.","title":"Sending Commands"},{"location":"/commons/multiple-components.html#tracking-long-running-commands","text":"A command sent in a Submit wrapper that receives an Accepted response in return is considered as a long running command.\nWhen a component sends a long running command to another component, it may be interested in knowing the status of the command and take decisions based on that. In order to subscribe to the changes in command status, the sender component will have to use the subscribe method after submit or use submitAndSubscribe in CommandService.","title":"Tracking Long Running Commands"},{"location":"/commons/multiple-components.html#matchers","text":"When a component sends a command as Oneway to another component, it may be interested in knowing the receiver component’s CurrentState and match it against a desired state. In order to do that, the component developer can use the onewayAndMatch method of CommandService or use oneway and then use a Matcher explicitly to match a desired state with current state.\nMore details on how to use Matcher can be found here.","title":"Matchers"},{"location":"/commons/multiple-components.html#pubsub-connection","text":"A component might need to subscribe to the current state of any other component provided it knows the location of that component. In order to subscribe to current state, it may use the subscribeCurrentState method of the CommandService. More details about the usage of subscribeCurrentState can ber found here.\nIf a component wants to publish its current state then it can use the currentStatePublisher provided by csw-framework in ComponentHandlers. More details about the usage of currentStatePublisher can ber found here.","title":"PubSub Connection"},{"location":"/commons/multiple-components.html#deploying-and-running-components","text":"","title":"Deploying and Running Components"},{"location":"/commons/multiple-components.html#pre-requisite","text":"A project, for example with the name galil-deploy, contains applications (ContainerCmd and HostConfig coming from csw-framework) to run components. Make sure that the necessary dependencies are added in the galil-deploy.","title":"Pre-requisite"},{"location":"/commons/multiple-components.html#run","text":"Assuming that galil-deploy depends on galil-assembly and galil-hcd, to start the Assembly and HCD, follow the steps below:\nRun sbt galil-deploy/universal:packageBin, this will create self contained zip in galil-deploy/target/universal directory. Unzip the generated zip file and enter into bin directory. You will see four scripts in the bin directory (two bash scripts and two windows scripts). If you want to start multiple containers on a host machine, follow this guide here. If you want to start multiple components in container mode or single component in standalone mode, follow this guide here. Example to run container: ./galil-container-cmd-app --local ../../../../galil-deploy/src/main/resources/GalilAssemblyContainer.conf Example to run host config: ./galil-host-config-app --local ../../../../galil-deploy/src/main/resources/GalilHostConfig.conf -s ./galil-container-cmd-app\nNote The CSW Location Service cluster seed must be running and appropriate environment variables set to run the apps. See https://tmtsoftware.github.io/csw-prod/apps/cswclusterseed.html.","title":"Run"},{"location":"/commons/messages.html","text":"","title":"Messages"},{"location":"/commons/messages.html#messages","text":"In the distributed environment of TMT observatory, Components communicate with each other by sending asynchrnous Messages. These messages have a Command payload, which flows down through the sequencer components to the Assemblies, HCDs and finally to the hardware. At each hop Commands are validated, interpreted and further propagated making their journey to its destination. Commands provide flexible placeholders to store values to convey precise intent of the sender component.","title":"Messages"},{"location":"/commons/messages.html#dependencies","text":"sbt libraryDependencies += \"org.tmt\" %% \"csw-messages\" % \"0.1.2\"\ncsw-messages library provides out of the box support to cater to the diverse communication requirements. Consumer of this library will be able to create Commands, Events, States to store ParameterSets.\nKeys and Parameters How to Create a Parameter Primitive Datatypes Arrays Matrices Domain Specific Types Source Code for Examples Units Default Units for Keys SI Units CGS Units Astrophysical Units Imperial Units Others - Engineering Usage Examples Source Code for Examples Subsystem List of Subsystems Usage Examples Commands ObsId Prefix CommandName Setup Command Observe Command Wait Command JSON serialization Unique Key constraint Cloning a Command Source Code for Examples Events EventTime Observe Event System Event JSON Serialization Unique Key Constraint Protobuf Source Code for Examples State Variables DemandState CurrentState JSON Serialization Unique Key Constraint Source Code for Examples Result JSON serialization Unique Key Constraint Source Code for Examples","title":"Dependencies"},{"location":"/messages/keys-parameters.html","text":"","title":"Keys and Parameters"},{"location":"/messages/keys-parameters.html#keys-and-parameters","text":"Library offers a flexible and typesafe means to create Parameters to store values like primitive types, collection types or domain specific types.\nA Parameter is a Key and Value where the Value must be from a set of defined primitive types including binary data. The Value of a Parameter is always considered to be an Array of the type (i.e. if a single value is stored it is at array location 0). A Parameter is immutable; a modification to an existing Parameter will return a new instance.\nA Value can also have Units, which must be of the defined types. See Units for more information. At this time Units are informational only–no calculation or conversion support is provided. Some systems may provide a key value with different units, and receiver can inspect the Units to make a decision on how to handle the value.\nA ParameterSet is a Set of Parameter. Various other message types include a ParameterSet (e.g. Setup, Event). A key is unique in a ParameterSet since it is a Set.","title":"Keys and Parameters"},{"location":"/messages/keys-parameters.html#how-to-create-a-parameter","text":"choose an appropriate KeyType from below tables for your language(Scala/Java). calling the make method on KeyType and supplying a String keyName will return a suitably typed Key instance. explore the overloaded set and -> methods, which will allow you to store values of the based on chosen KeyType. e.g. JKeyTypes.BooleanKey will allow storing only java.lang.Boolean values.","title":"How to Create a Parameter"},{"location":"/messages/keys-parameters.html#primitive-datatypes","text":"Primitive Scala KeyType Java KeyType Boolean KeyType.BooleanKey JKeyTypes.BooleanKey Character KeyType.CharKey JKeyTypes.JCharKey Byte KeyType.ByteKey JKeyTypes.ByteKey Short KeyType.ShortKey JKeyTypes.ShortKey Long KeyType.LongKey JKeyTypes.LongKey Int KeyType.IntKey JKeyTypes.IntKey Float KeyType.FloatKey JKeyTypes.FloatKey Double KeyType.DoubleKey JKeyTypes.DoubleKey String KeyType.StringKey JKeyTypes.StringKey Timestamp KeyType.TimestampKey JKeyTypes.TimestampKey\nScala //declare keyname\nval s1: String = \"encoder\"\n\n//making 3 keys\nval k1: Key[Boolean] = KeyType.BooleanKey.make(s1)\nval k2: Key[Short]   = KeyType.ShortKey.make(\"RandomKeyName\")\nval k3: Key[String]  = KeyType.StringKey.make(s1)\n\n//storing a single value\nval booleanParam: Parameter[Boolean] = k1.set(true)\n\n//storing multiple values\nval paramWithShorts1: Parameter[Short] = k2.set(1, 2, 3, 4)\nval paramWithShorts2: Parameter[Short] = k2 -> (1, 2, 3, 4)\nval paramWithShorts3: Parameter[Short] = k2 -> Array[Short](1, 2, 3, 4)\n\n//associating units\nval weekDays: Array[String]            = Array(\"Sunday\", \"Monday\", \"Tuesday\")\nval paramWithUnits1: Parameter[String] = k3.set(weekDays, Units.day)\nval paramWithUnits2: Parameter[String] = k3 -> weekDays withUnits Units.day\n\n//deault unit is NoUnits\nassert(booleanParam.units === Units.NoUnits)\n\n//set units explicitly on an existing Parameter\nval paramWithUnits3: Parameter[Short] = paramWithShorts1.withUnits(Units.meter)\n\n//retrieve values from Parameter\nval allValues: Array[Short] = paramWithShorts1.values\n\n//retrieve just top value\nval head: Short = paramWithShorts1.head Java //making 3 keys\nString keyName = \"encoder\";\nKey<Boolean> k1 = JKeyTypes.BooleanKey().make(keyName);\nKey<Short> k2 = JKeyTypes.ShortKey().make(keyName);\nKey<String> k3 = JKeyTypes.StringKey().make(keyName);\n\n//storing a single value\nParameter<Boolean> booleanParam = k1.set(true);\n\n//storing multiple values\nShort[] shortArray = {1, 2, 3, 4};\nParameter<Short> paramWithManyShorts1 = k2.set(shortArray);\nParameter<Short> paramWithManyShorts2 = k2.set((short) 1, (short) 2, (short) 3, (short) 4);\n\n//associating units\nString[] weekDays = {\"Sunday\", \"Monday\", \"Tuesday\"};\nParameter<String> paramWithUnits1 = k3.set(weekDays, JUnits.day);\nParameter<String> paramWithUnits2 = k3.set(weekDays).withUnits(JUnits.day);\n\n//deault unit is NoUnits\nboolean hasDefaultUnit = booleanParam.units() == JUnits.NoUnits; //true\n\n//set units explicitly on an existing Parameter\nParameter<Short> paramWithUnits3 = paramWithManyShorts1.withUnits(JUnits.meter);\n\n//retrieve values from Parameter\nShort[] allValues = (Short[]) paramWithManyShorts1.values();\n\n//retrieve just top value\nShort head = paramWithManyShorts1.head();","title":"Primitive Datatypes"},{"location":"/messages/keys-parameters.html#arrays","text":"Primitive Scala KeyType Java KeyType ByteArray KeyType.ByteArrayKey JKeyTypes.ByteArrayKey ShortArray KeyType.ShortArrayKey JKeyTypes.ShortArrayKey LongArray KeyType.LongArrayKey JKeyTypes.LongArrayKey IntArray KeyType.IntArrayKey JKeyTypes.IntArrayKey FloatArray KeyType.FloatArrayKey JKeyTypes.FloatArrayKey DoubleArray KeyType.DoubleArrayKey JKeyTypes.DoubleArrayKey\nScala //make some arrays\nval arr1: Array[Double] = Array(1.0, 2.0, 3.0, 4.0, 5.0)\nval arr2: Array[Double] = Array(10.0, 20.0, 30.0, 40.0, 50.0)\n\n//keys\nval filterKey: Key[ArrayData[Double]] = KeyType.DoubleArrayKey.make(\"filter\")\n\n//Store some values using helper class ArrayData\nval p1: Parameter[ArrayData[Double]] = filterKey.set(ArrayData(arr1), ArrayData(arr2))\nval p2: Parameter[ArrayData[Double]] = filterKey -> ArrayData(arr1 ++ arr2) withUnits Units.liter\n\n//add units to existing parameters\nval p1AsCount = p1.withUnits(Units.count)\n\n//default unit is NoUnits\nassert(p1.units === Units.NoUnits)\n\n//retrieving values\nval head: Array[Double]                 = p1.head.data.toArray\nval allValues: Array[ArrayData[Double]] = p1.values Java //make some arrays\nDouble[] arr1 = {1.0, 2.0, 3.0, 4.0, 5.0};\nDouble[] arr2 = {10.0, 20.0, 30.0, 40.0, 50.0};\n\n//keys\nKey<ArrayData<Double>> filterKey = JKeyTypes.DoubleArrayKey().make(\"filter\");\n\n//Store some values using helper method in ArrayData\nParameter<ArrayData<Double>> p1 = filterKey.set(ArrayData.fromJavaArray(arr1), ArrayData.fromJavaArray(arr2));\nParameter<ArrayData<Double>> p2 = filterKey.set(ArrayData.fromJavaArray(arr2)).withUnits(JUnits.liter);\n\n//add units to existing parameters\nParameter<ArrayData<Double>> p1AsCount = p1.withUnits(JUnits.count);\n\n//default unit is NoUnits\nboolean bDefaultUnit = JUnits.NoUnits == p1.units();\n\n//retrieving values\nList<Double> head = p1.head().jValues();\nList<ArrayData<Double>> listOfArrayData = p1.jValues();\nDouble[] arrayOfDoubles = (Double[]) p2.jValues().get(0).values();","title":"Arrays"},{"location":"/messages/keys-parameters.html#matrices","text":"Primitive Scala KeyType Java KeyType ByteMatrix KeyType.ByteMatrixKey JKeyTypes.ByteMatrixKey ShortMatrix KeyType.ShortMatrixKey JKeyTypes.ShortMatrixKey LongMatrix KeyType.LongMatrixKey JKeyTypes.LongMatrixKey IntMatrix KeyType.IntMatrixKey JKeyTypes.IntMatrixKey FloatMatrix KeyType.FloatMatrixKey JKeyTypes.FloatMatrixKey DoubleMatrix KeyType.DoubleMatrixKey JKeyTypes.DoubleMatrixKey\nScala //make some arrays\nval m1: Array[Array[Byte]] = Array(Array[Byte](1, 2, 3), Array[Byte](4, 5, 6), Array[Byte](7, 8, 9))\nval m2: Array[Array[Byte]] = Array(Array[Byte](1, 2, 3, 4, 5), Array[Byte](10, 20, 30, 40, 50))\n\n//keys\nval encoderKey: Key[MatrixData[Byte]] = KeyType.ByteMatrixKey.make(\"encoder\")\n\n//Store some values using helper class MatrixData\nval p1: Parameter[MatrixData[Byte]] = encoderKey.set(MatrixData.fromArrays(m1))\nval p2: Parameter[MatrixData[Byte]] = encoderKey.set(m1, m2) withUnits Units.liter\n\n//add units to existing parameters\nval p1AsLiter = p1.withUnits(Units.liter)\n\n//default unit is NoUnits\nassert(p1.units === Units.NoUnits)\n\n//retrieving values\nval head: Array[Array[Byte]]           = p1.head.data.map(_.toArray).toArray\nval allValues: Array[MatrixData[Byte]] = p1.values Java //make some arrays\nByte[][] m1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\nByte[][] m2 = {{1, 2, 3, 4, 5}, {10, 20, 30, 40, 50}};\n\n//keys\nKey<MatrixData<Byte>> encoderKey = JKeyTypes.ByteMatrixKey().make(\"encoder\");\n\n//Store some values using helper method in ArrayData\nParameter<MatrixData<Byte>> p1 = encoderKey.set(\n        MatrixData.fromJavaArrays(Byte.class, m1),\n        MatrixData.fromJavaArrays(Byte.class, m2));\nParameter<MatrixData<Byte>> p2 = encoderKey.set(\n        MatrixData.fromJavaArrays(Byte.class, m2)\n).withUnits(JUnits.liter);\n\n//add units to existing parameters\nParameter<MatrixData<Byte>> p1AsLiter = p1.withUnits(JUnits.liter);\n\n//default unit is NoUnits\nboolean bDefaultUnit = JUnits.NoUnits == p1.units();\n\n//retrieving values\nMatrixData<Byte> head = p1.head();\nList<MatrixData<Byte>> matrixData1 = p1.jValues();\nList<MatrixData<Byte>> matrixData2 = p2.jValues();","title":"Matrices"},{"location":"/messages/keys-parameters.html#domain-specific-types","text":"Primitive Scala KeyType Java KeyType Choice KeyType.ChoiceKey JKeyTypes.ChoiceKey RaDec KeyType.RaDecKey JKeyTypes.RaDecKey Struct KeyType.StructKey JKeyTypes.StructKey","title":"Domain Specific Types"},{"location":"/messages/keys-parameters.html#choice","text":"A key for a choice item similar to an enumeration.\nScala //Choice\nval choices = Choices.from(\"A\", \"B\", \"C\")\n\n//keys\nval choice1Key: GChoiceKey = ChoiceKey.make(\"mode\", choices)\nval choice2Key: GChoiceKey = ChoiceKey.make(\n  \"mode-reset\",\n  Choices.fromChoices(Choice(\"c\"), Choice(\"b\"), Choice(\"a\"))\n)\n\n//store values\nval p1: Parameter[Choice] = choice1Key\n  .set(Array(Choice(\"A\")))\n  .withUnits(Units.foot)\nval p2: Parameter[Choice] = choice2Key.set(Array(Choice(\"c\")))\n\n//add units\nval paramWithFoot = p1.withUnits(Units.foot)\n\n//default unit is NoUnits\nassert(p2.units === Units.NoUnits)\n\n//retrieving values\nval head: Choice          = p1.head\nval values: Array[Choice] = p2.values\n Java //Choice\nfinal Choices choices = Choices.from(\"A\", \"B\", \"C\");\n\n//keys\nGChoiceKey choice1Key = JKeyTypes.ChoiceKey().make(\"mode\", choices);\nGChoiceKey choice2Key = JKeyTypes.ChoiceKey().make(\n        \"mode-reset\",\n        Choices.fromChoices(\n                new Choice(\"c\"),\n                new Choice(\"b\"),\n                new Choice(\"a\")));\n\n//store values\nParameter<Choice> p1 = choice1Key.set(new Choice(\"A\")).withUnits(JUnits.foot);\nParameter<Choice> p2 = choice2Key.set(new Choice(\"c\"));\n\n//add units\nParameter<Choice> paramWithFoot = p1.withUnits(JUnits.foot);\n\n//default unit is NoUnits\nboolean bDefaultUnit = JUnits.NoUnits == p2.units();\n\n//retrieving values\nChoice head = p1.head();\nList<Choice> values = p2.jValues();","title":"Choice"},{"location":"/messages/keys-parameters.html#radec","text":"Holds Ra(Right Ascension) and Dec(Declination) values\nScala //RaDec\nval raDec1: RaDec = RaDec(1.0, 2.0)\nval raDec2: RaDec = RaDec(3.0, 4.0)\n\n//keys\nval raDecKey: Key[RaDec] = KeyType.RaDecKey.make(\"raDecKey\")\n\n//store values\nval p1: Parameter[RaDec] = raDecKey.set(raDec1)\nval p2: Parameter[RaDec] = raDecKey -> Array(raDec1, raDec2)\n\n//add units\nval paramWithDegree = p1.withUnits(Units.degree)\n\n//default unit is NoUnits\nassert(p2.units === Units.NoUnits)\n\n//retrieving values\nval head: RaDec          = p1.head\nval values: Array[RaDec] = p2.values\n Java //RaDec\nRaDec raDec1 = new RaDec(1.0, 2.0);\nRaDec raDec2 = new RaDec(3.0, 4.0);\n\n//keys\nKey<RaDec> raDecKey = JKeyTypes.RaDecKey().make(\"raDecKey\");\n\n//store values\nParameter<RaDec> p1 = raDecKey.set(raDec1);\nParameter<RaDec> p2 = raDecKey.set(raDec1, raDec2).withUnits(JUnits.degree);\n\n//add units\nParameter<RaDec> paramWithDegree = p1.withUnits(JUnits.degree);\n\n//default unit is NoUnits\nboolean bDefaultUnit = JUnits.NoUnits == p1.units();\n\n//retrieving values\nRaDec head = p1.head();\nList<RaDec> values = p2.jValues();","title":"RaDec"},{"location":"/messages/keys-parameters.html#struct","text":"Stores a set of Parameters for telescope and instrument control. Lot of utility functions available for store, add, remove, list Keys and Paramete\nScala //keys\nval skey: Key[Struct] = StructKey.make(\"myStruct\")\n\nval ra    = KeyType.StringKey.make(\"ra\")\nval dec   = KeyType.StringKey.make(\"dec\")\nval epoch = KeyType.DoubleKey.make(\"epoch\")\n\n//initialize struct\nval struct1: Struct = Struct().madd(ra.set(\"12:13:14.1\"), dec.set(\"32:33:34.4\"), epoch.set(1950.0))\nval struct2: Struct = Struct().madd(dec.set(\"32:33:34.4\"), ra.set(\"12:13:14.1\"), epoch.set(1970.0))\n\n//make parameters\nval p1: Parameter[Struct] = skey.set(struct1)\nval p2: Parameter[Struct] = skey.set(struct1, struct2)\n\n//add units\nval paramWithLightYear = p1.withUnits(Units.lightyear)\n\n//default unit is NoUnits\nassert(p2.units === Units.NoUnits)\n\n//retrieving values\nval head: Struct          = p1.head\nval values: Array[Struct] = p2.values\n\n//get individual keys\nval firstKey: Option[Parameter[String]]  = struct1.get(KeyType.StringKey.make(\"ra\"))\nval secondKey: Option[Parameter[String]] = struct1.get(\"dec\", KeyType.StringKey)\nval thirdKey: Option[Parameter[Double]]  = struct1.get(\"epoch\", KeyType.DoubleKey)\n\n//access parameter using 'parameter' or 'apply' method\nassert(struct1.parameter(ra) === struct1(ra))\n\n//remove a parameter and verify it doesn't exist\nval mutated1: Struct = struct1.remove(ra) //using key\nval mutated2         = struct1.remove(firstKey.get)\nassert(mutated1.exists(ra) === false)\nassert(mutated2.exists(ra) === false)\n\n//find out missing keys\nval missingKeySet: Set[String] = mutated1.missingKeys(ra, dec, epoch, KeyType.FloatKey.make(\"missingKey\"))\nassert(missingKeySet === Set(\"ra\", \"missingKey\"))\n Java //keys\nKey<Struct> skey = JKeyTypes.StructKey().make(\"myStruct\");\n\nKey<String> ra = JKeyTypes.StringKey().make(\"ra\");\nKey<String> dec = JKeyTypes.StringKey().make(\"dec\");\nKey<Double> epoch = JKeyTypes.DoubleKey().make(\"epoch\");\n\n//initialize struct\nStruct struct1 = new Struct().madd(\n        ra.set(\"12:13:14.1\"),\n        dec.set(\"32:33:34.4\"),\n        epoch.set(1950.0));\nStruct struct2 = new Struct().madd(\n        dec.set(\"32:33:34.4\"),\n        ra.set(\"12:13:14.1\"),\n        epoch.set(1970.0));\n\n//make parameters\nParameter<Struct> p1 = skey.set(struct1);\nParameter<Struct> p2 = skey.set(struct1, struct2);\n\n//add units\nParameter<Struct> paramWithLightYear = p1.withUnits(JUnits.lightyear);\n\n//default unit is NoUnits\nboolean bDefaultUnit = JUnits.NoUnits == p1.units();\n\n//retrieving values\nStruct head = p1.head();\nList<Struct> structs = p2.jValues();\n\n//get individual keys\nOptional<Parameter<String>> firstKey = struct1.jGet(JKeyTypes.StringKey().make(\"ra\"));\nOptional<Parameter<String>> secondKey = struct1.jGet(\"dec\", JKeyTypes.StringKey());\nOptional<Parameter<Double>> thirdKey = struct1.jGet(\"epoch\", JKeyTypes.DoubleKey());\n\n//access parameter using 'parameter' and 'apply' method\nboolean bSuccess = struct1.parameter(ra) == struct1.apply(ra);\n\n//remove a parameter and verify it doesn't exist\nStruct mutated1 = struct1.remove(ra); //using key\nStruct mutated2 = struct1.remove(firstKey.get());\n\n//find out missing keys\nSet<String> missingKeySet = mutated1.jMissingKeys(ra, dec, epoch, JKeyTypes.StringKey().make(\"someRandomKey\"));\nList<String> expectedMissingKeys = Arrays.asList(\"ra\", \"someRandomKey\");","title":"Struct"},{"location":"/messages/keys-parameters.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source Code for Examples"},{"location":"/messages/units.html","text":"","title":"Units"},{"location":"/messages/units.html#units","text":"Listed below are Units of Measurement, supported by TMT observatory framework and are available as Enumerated values. Units are optionally attached to Parameter Keys.\nNote Units are made available via separate files, for consumption in Scala and Java code. Import csw.messages.params.models.Units for Scala Import csw.messages.javadsl.JUnits for Java.\nNote The set of supported Units will be modified as more required Units are discovered.","title":"Units"},{"location":"/messages/units.html#default-units-for-keys","text":"The default unit for TimestampKey(in Scala and Java both) is second. For all the remaining keys, default unit is NoUnits.","title":"Default Units for Keys"},{"location":"/messages/units.html#si-units","text":"Name Abbreviation Description angstrom Angstrom 10 -1 nm arcmin arcmin arc minute; angular measurement arcsec arcsec arc second: angular measurement day d day - 24 hours degree deg degree: agular measurement 1/360 of full rotation elvolt eV electron volt 1.6022x10-19 J gram g gram 10-3 kg hour h hour 3.6x10+3 s hertz Hz frequency joule J Joule: energy N m kelvin K Kelvin: temperature with a null point at absolute zero kilogram kg kilogram, base unit of mass in SI kilometer km kilometers - 10+3 m liter l liter, metric unit of volume 10+3 cm+3 meter m meter: base unit of length in SI marcsec mas milli arc second: angular measurement 10-3 arcsec millimeter mm millimeters - 10-3 m millisecond ms milliseconds - 10-3 s micron µm micron: alias for micrometer micrometer µm micron: 10-6 m minute min minute 6x10+1 s newton N Newton: force pascal Pa Pascal: pressure radian rad radian: angular measurement of the ratio between the length of an arc and its radius second s second: base unit of time in SI sday sday sidereal day is the time of one rotation of the Earth: 8.6164x10+4 s steradian sr steradian: unit of solid angle in SI - rad+2 microarcsec µas micro arcsec: angular measurement volt V Volt: electric potential or electromotive force watt W Watt: power week wk week - 7 d year yr year - 3.6525x10+2 d","title":"SI Units"},{"location":"/messages/units.html#cgs-units","text":"Name Abbreviation Description coulomb C coulomb: electric charge centimeter cm centimeter erg erg erg: CGS unit of energy","title":"CGS Units"},{"location":"/messages/units.html#astrophysical-units","text":"Name Abbreviation Description au AU astronomical unit: approximately the mean Earth-Sun distance jansky Jy Jansky: spectral flux density - 10-26 W/Hz m+2 lightyear lyr light year - 9.4607x10+15 m mag mag stellar magnitude","title":"Astrophysical Units"},{"location":"/messages/units.html#imperial-units","text":"Name Abbreviation Description cal cal thermochemical calorie: pre-SI metric unit of energy foot ft international foot - 1.2x10+1 inch inch inch international inch - 2.54 cm pound lb international avoirdupois pound - 1.6x10+1 oz mile mi international mile - 5.28x10+3 ft ounce oz international avoirdupois ounce yard yd international yard - 3 ft","title":"Imperial Units"},{"location":"/messages/units.html#others-engineering","text":"Name Abbreviation Description NoUnits none scalar - no units specified encoder enc encoder counts count ct counts as for an encoder or detector pix pix pixel","title":"Others - Engineering"},{"location":"/messages/units.html#usage-examples","text":"Scala //declare keyname\nval s1: String = \"encoder\"\n\n//making 3 keys\nval k1: Key[Boolean] = KeyType.BooleanKey.make(s1)\nval k2: Key[Short]   = KeyType.ShortKey.make(\"RandomKeyName\")\nval k3: Key[String]  = KeyType.StringKey.make(s1)\n\n//storing a single value, default unit is NoUnits\nval bParam: Parameter[Boolean] = k1.set(true)\nval bDefaultUnitSet: Boolean   = bParam.units === Units.NoUnits //true\n\n//default unit for TimestampKey\nval tParam: Parameter[Instant] = KeyType.TimestampKey.make(\"now\").set(Instant.now())\nval defaultTimeUnit: Units     = tParam.units //is second\n\n//storing multiple values\nval paramOfShorts: Parameter[Short] = k2.set(1, 2, 3, 4)\n\n//values to store\nval weekDays: Array[String] = Array(\"Sunday\", \"Monday\", \"Tuesday\")\n\n//associating units via set\nval paramWithUnits1: Parameter[String] = k3.set(weekDays, Units.day)\n//associating units via withUnits\nval paramWithUnits2: Parameter[String] = k3 -> weekDays withUnits Units.count\n//change existing unit\nval paramWithUnits3: Parameter[Short] = paramOfShorts.withUnits(Units.meter) Java //declare keyname\nString s1 = \"encoder\";\n\n//making 3 keys\nKey<Boolean> k1 = JKeyTypes.BooleanKey().make(s1);\nKey<Short> k2 = JKeyTypes.ShortKey().make(\"RandomKeyName\");\nKey<String> k3 = JKeyTypes.StringKey().make(s1);\n\n//storing a single value, default unit is NoUnits\nParameter<Boolean> bParam = k1.set(true);\nBoolean bDefaultUnitSet = bParam.units() == JUnits.NoUnits; //true\n\n//default unit for TimestampKey\nParameter<Instant> tParam = JKeyTypes\n        .TimestampKey()\n        .make(\"now\")\n        .set(Instant.now());\nUnits defaultTimeUnit = tParam.units(); //is second\n\n//storing multiple values\nParameter<Short> paramOfShorts = k2.set(\n        (short) 1,\n        (short) 2,\n        (short) 3,\n        (short) 4\n);\n\n//values to store\nString[] weekDays = {\"Sunday\", \"Monday\", \"Tuesday\"};\n\n//associating units via set\nParameter<String> paramWithUnits1 = k3.set(weekDays, JUnits.day);\n//associating units via withUnits\nParameter<String> paramWithUnits2 = k3.set(weekDays).withUnits(JUnits.day);\n//change existing unit\nParameter<Short> paramWithUnits3 = paramOfShorts.withUnits(JUnits.meter);","title":"Usage Examples"},{"location":"/messages/units.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source Code for Examples"},{"location":"/messages/subsystem.html","text":"","title":"Subsystem"},{"location":"/messages/subsystem.html#subsystem","text":"TMT Observatory system is composed of many subsystems. The subsystems that are known participants in the TMT Software System are predefined and the list is covered under the Subsystem enumeration. They are identified using a 3 or 4 letter abbreviation.\nSusbsystem values are used to construct Prefix and are used in communication vehicles such as Commands, Events and States.\nNote Subsystems are made available via separate files, for consumption in Scala and Java code. Import csw.messages.params.models.Subsystem for Scala Import csw.messages.javadsl.JSubsystem for Java.","title":"Subsystem"},{"location":"/messages/subsystem.html#list-of-subsystems","text":"Abbreviation Susbsystem name AOESW AO Executive Software APS Alignment and Phasing System CIS Communications and Information Systems CSW Common Software DMS Data Management System DPS Data Processing System ENC Enclosure ESEN Engineering Sensor System ESW Executive Software System GMS Global Metrology System Controls IRIS InfraRed Imaging Spectrometer IRMS Infrared Multi-Slit Spectrometer LGSF Lasert Guide Star Facility M1CS M1 Control System M2CS M2 Control System M3CS M3 Control System MCS Mount Control System NFIRAOS Narrow Field Infrared AO System NSCU NFIRAOS Science Calibration Unit OSS Observatory Safety System PFCS Prime Focus Camera Controls PSFR NFIRAOS AO PSF Reconstructor RTC NFIRAOS Real-time Controller RPG NFIRAOS AO Reconstructor Parameter Generator SCMS Site Conditions Monitoring System SOSS Science Operations Support System STR Telescope Structure SUM Summit Facility TCS Telescope Control System TINC Prime Focus Camera Controls WFOS Wide Field Optical Spectrometer TEST Testing System BAD Unknown/default Subsystem","title":"List of Subsystems"},{"location":"/messages/subsystem.html#usage-examples","text":"The usage examples can be found in Events, Commands, States","title":"Usage Examples"},{"location":"/messages/commands.html","text":"","title":"Commands"},{"location":"/messages/commands.html#commands","text":"Commands are parameter sets called Setup, Observe, and Wait. A command is created with the source of the command, given by a prefix, the name of the command, and an optional ObsId. Parameters are added to the command as needed. As the ESW design is developed, these command structures may evolve.","title":"Commands"},{"location":"/messages/commands.html#obsid","text":"An ObsID, or observation Id, indicates the observation the command is associated with. It can be constructed by creating an instance of ObsId.\nScala val obsId: ObsId = ObsId(\"Obs001\") Java ObsId obsId = new ObsId(\"Obs001\");","title":"ObsId"},{"location":"/messages/commands.html#prefix","text":"The source of the command is given by the prefix, which should be the full name of the component sending the command. A prefix can be constructed with a string, but must start with a valid subsystem as in Subsystem. A component developer should supply a valid prefix string and the subsystem will be automatically parsed from it. An example of a valid string prefix is “nfiraos.ncc.trombone”.\nSee below examples:\nScala //using constructor, supplying subsystem and prefix both\nval prefix1: Prefix = Prefix(Subsystem.NFIRAOS, \"nfiraos.ncc.trombone\")\n\n//just by supplying prefix\nval prefix2: Prefix = Prefix(\"tcs.mobie.blue.filter\")\n\n//invalid prefix string that cant be mapped to a valid subsystem,\n// will automatically get Subsystem.BAD\nval badPrefix: Prefix = Prefix(\"abcdefgh\")\n\n//use implicit conversion to convert from String to Prefix\nval prefix3: Prefix = \"wfos.prog.cloudcover\" Java //using constructor, supplying subsystem and prefix both\nPrefix prefix1 = new Prefix(JSubsystem.NFIRAOS, \"nfiraos.ncc.trombone\");\n\n//just by supplying prefix\nPrefix prefix2 = new Prefix(\"tcs.mobie.blue.filter\");\n\n//invalid prefix string that cant be mapped to a valid subsystem,\n// will automatically get Subsystem.BAD\nPrefix badPrefix = new Prefix(\"abcdefgh\");","title":"Prefix"},{"location":"/messages/commands.html#commandname","text":"Each command has a name given as a string. The CommandName object wraps the string name. The string should be continuous with no spaces.","title":"CommandName"},{"location":"/messages/commands.html#setup-command","text":"This command is used to describe a goal that a system should match. Component developer will require to supply following arguments to create a Setup command.\nPrefix: the source of the command as described above CommandName: a simple string name for the command (no spaces) ObsId: an optional observation Id. paramSet: Optional Set of Parameters. Default is empty.\nScala //keys\nval k1: Key[Int]    = KeyType.IntKey.make(\"encoder\")\nval k2: Key[String] = KeyType.StringKey.make(\"stringThing\")\nval k2bad: Key[Int] = KeyType.IntKey.make(\"missingKey\")\nval k3: Key[Int]    = KeyType.IntKey.make(\"filter\")\nval k4: Key[Float]  = KeyType.FloatKey.make(\"correction\")\n\n//prefix\nval prefix: Prefix = Prefix(\"wfos.red.detector\")\n\n//parameters\nval i1: Parameter[Int]    = k1.set(22)\nval i2: Parameter[String] = k2.set(\"A\")\n\n//create Setup, add sequentially using add\nval sc1: Setup = Setup(prefix, CommandName(\"move\"), Some(obsId)).add(i1).add(i2)\n\n//access keys\nval k1Exists: Boolean = sc1.exists(k1) //true\n\n//access parameters\nval tryParam1: Try[Parameter[Int]] = Try(sc1(k1))    //success\nval tryk2Bad: Try[Parameter[Int]]  = Try(sc1(k2bad)) //failure\n\n//add more than one parameters, using madd\nval sc2: Setup     = sc1.madd(k3.set(1, 2, 3, 4).withUnits(Units.day), k4.set(1.0f, 2.0f))\nval paramSize: Int = sc2.size\n\n//add binary payload\nval byteKey1: Key[Byte] = ByteKey.make(\"byteKey1\")\nval byteKey2: Key[Byte] = ByteKey.make(\"byteKey2\")\nval bytes1: Array[Byte] = Array[Byte](10, 20)\nval bytes2: Array[Byte] = Array[Byte](30, 40)\n\nval b1: Parameter[Byte] = byteKey1.set(bytes1)\nval b2: Parameter[Byte] = byteKey2.set(bytes2)\n\nval sc3: Setup = Setup(prefix, CommandName(\"move\"), Some(obsId), Set(b1, b2))\n\n//remove a key\nval sc4: Setup = sc3.remove(b1)\n\n//list all keys\nval allKeys: Set[String] = sc4.paramSet.map(_.keyName)\n Java //keys\nKey<Integer> k1 = JKeyTypes.IntKey().make(\"encoder\");\nKey<String> k2 = JKeyTypes.StringKey().make(\"stringThing\");\nKey<Integer> k2bad = JKeyTypes.IntKey().make(\"missingKey\");\nKey<Integer> k3 = JKeyTypes.IntKey().make(\"filter\");\nKey<Float> k4 = JKeyTypes.FloatKey().make(\"correction\");\n\n//prefix\nString prefixName = \"wfos.red.detector\";\n\n//parameters\nParameter<Integer> i1 = k1.set(22);\nParameter<String> i2 = k2.set(\"A\");\n\n//create setup, add sequentially using add\nSetup sc1 = new Setup(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(i1).add(i2);\n\n//access keys\nBoolean k1Exists = sc1.exists(k1); //true\n\n//access parameters\nOptional<Parameter<Integer>> optParam1 = sc1.jGet(k1); //present\nOptional<Parameter<Integer>> optK2Bad = sc1.jGet(k2bad); //absent\n\n//add more than one parameters, using madd\nSetup sc2 = sc1.madd(k3.set(1, 2, 3, 4).withUnits(JUnits.day), k4.set(1.0f, 2.0f));\nint paramSize = sc2.size();\n\n//add binary payload\nKey<Byte> byteKey1 = JKeyTypes.ByteKey().make(\"byteKey1\");\nKey<Byte> byteKey2 = JKeyTypes.ByteKey().make(\"byteKey2\");\nByte[] bytes1 = {10, 20};\nByte[] bytes2 = {30, 40};\n\nParameter<Byte> b1 = byteKey1.set(bytes1);\nParameter<Byte> b2 = byteKey2.set(bytes2);\n\nSetup sc3 = new Setup(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(b1).add(b2);\n\n//remove a key\nSetup sc4 = sc3.remove(b1);\n\n//list all keys\njava.util.List<String> allKeys = sc4.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Setup Command"},{"location":"/messages/commands.html#observe-command","text":"This command describes a science observation. Sent only to Science Detector Assemblies and Sequencers.\nScala //keys\nval k1: Key[Boolean] = KeyType.BooleanKey.make(\"repeat\")\nval k2: Key[Int]     = KeyType.IntKey.make(\"expTime\")\nval k2bad: Key[Int]  = KeyType.IntKey.make(\"missingKey\")\nval k3: Key[Int]     = KeyType.IntKey.make(\"filter\")\nval k4: Key[Instant] = KeyType.TimestampKey.make(\"creation-time\")\n\n//prefix\nval prefix: Prefix = Prefix(\"wfos.red.detector\")\n\n//parameters\nval i1: Parameter[Boolean] = k1.set(true, false, true, false)\nval i2: Parameter[Int]     = k2.set(1, 2, 3, 4)\n\n//create Observe, add sequentially using add\nval oc1: Observe = Observe(prefix, CommandName(\"move\"), Some(obsId)).add(i1).add(i2)\n\n//access parameters using apply method\nval k1Param: Parameter[Boolean] = oc1.get(k1).get //true\nval values: Array[Boolean]      = k1Param.values\n\n//access parameters\nval tryParam1: Try[Parameter[Boolean]] = Try(oc1(k1))    //success\nval tryk2Bad: Try[Parameter[Int]]      = Try(oc1(k2bad)) //failure\n\n//add more than one parameters, using madd\nval oc2: Observe   = oc1.madd(k3.set(1, 2, 3, 4).withUnits(Units.day), k4.set(Instant.now()))\nval paramSize: Int = oc2.size\n\n//update existing key with set\nval oc3: Observe = oc1.add(k2.set(5, 6, 7, 8))\n\n//remove a key\nval oc4: Observe = oc2.remove(k4)\n Java //keys\nKey<Boolean> k1 = JKeyTypes.BooleanKey().make(\"repeat\");\nKey<Integer> k2 = JKeyTypes.IntKey().make(\"expTime\");\nKey<Integer> k2bad = JKeyTypes.IntKey().make(\"missingKey\");\nKey<Integer> k3 = JKeyTypes.IntKey().make(\"filter\");\nKey<Instant> k4 = JKeyTypes.TimestampKey().make(\"creation-time\");\n\n//prefix\nString prefixName = \"wfos.red.detector\";\n\n//parameters\nBoolean[] boolArray = {true, false, true, false};\nParameter<Boolean> i1 = k1.set(boolArray);\nParameter<Integer> i2 = k2.set(1, 2, 3, 4);\n\n//create Observe, add sequentially using add\nObserve oc1 = new Observe(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(i1).add(i2);\n\n//access parameters\nOptional<Parameter<Boolean>> k1Param = oc1.jGet(k1); //present\njava.util.List<Boolean> values = k1Param.get().jValues();\n\n//access parameters\nOptional<Parameter<ArrayData<Float>>> k2BadParam = oc1.jGet(k2bad.keyName(), JKeyTypes.FloatArrayKey());\n\n//add more than one parameters, using madd\nObserve oc2 = oc1.madd(k3.set(1, 2, 3, 4).withUnits(JUnits.day), k4.set(Instant.now()));\nint paramSize = oc2.size();\n\n//update existing key with set\nInteger[] intArray = {5, 6, 7, 8};\nObserve oc3 = oc1.add(k2.set(intArray));\n\n//remove a key\nObserve oc4 = oc2.remove(k4);\n\n//list all keys\njava.util.List<String> allKeys = oc4.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Observe Command"},{"location":"/messages/commands.html#wait-command","text":"This command causes a Sequencer to wait until notified.\nScala //keys\nval k1: Key[Boolean] = KeyType.BooleanKey.make(\"repeat\")\nval k2: Key[Int]     = KeyType.IntKey.make(\"expTime\")\nval k2bad: Key[Int]  = KeyType.IntKey.make(\"missingKey\")\nval k3: Key[Int]     = KeyType.IntKey.make(\"filter\")\nval k4: Key[Instant] = KeyType.TimestampKey.make(\"creation-time\")\n\n//parameters\nval i1: Parameter[Boolean] = k1.set(true, false, true, false)\nval i2: Parameter[Int]     = k2.set(1, 2, 3, 4)\n\n//prefix\nval prefix: Prefix = Prefix(\"wfos.red.detector\")\n\n//create wait, add sequentially using add\nval wc1: Wait = Wait(prefix, CommandName(\"move\"), Some(obsId)).add(i1).add(i2)\n\n//access params using get method\nval k1Param: Option[Parameter[Boolean]] = wc1.get(k1)\nval values: Array[Boolean]              = k1Param.map(_.values).getOrElse(Array.empty[Boolean])\n\n//access parameters\nval tryParam1: Try[Parameter[Boolean]] = Try(wc1(k1))    //success\nval tryk2Bad: Try[Parameter[Int]]      = Try(wc1(k2bad)) //failure\n\n//add more than one parameters, using madd\nval wc2: Wait      = wc1.madd(k3.set(1, 2, 3, 4).withUnits(Units.day), k4.set(Instant.now()))\nval paramSize: Int = wc2.size\n\n//update existing key with set\nval wc3: Wait = wc1.add(k2.set(5, 6, 7, 8))\n\n//remove a key\nval wc4: Wait = wc2.remove(k4)\n Java //keys\nKey<Boolean> k1 = JKeyTypes.BooleanKey().make(\"repeat\");\nKey<Integer> k2 = JKeyTypes.IntKey().make(\"expTime\");\nKey<Integer> k2bad = JKeyTypes.IntKey().make(\"missingKey\");\nKey<Integer> k3 = JKeyTypes.IntKey().make(\"filter\");\nKey<Instant> k4 = JKeyTypes.TimestampKey().make(\"creation-time\");\n\n//prefix\nString prefixName = \"wfos.red.detector\";\n\n//parameters\nBoolean[] boolArray = {true, false, true, false};\nParameter<Boolean> i1 = k1.set(boolArray);\nParameter<Integer> i2 = k2.set(1, 2, 3, 4);\n\n//create Wait, add sequentially using add\nWait wc1 = new Wait(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(i1).add(i2);\n\n//access parameters using jGet\nOptional<Parameter<Boolean>> k1Param = wc1.jGet(k1); //present\njava.util.List<Boolean> values = k1Param.get().jValues();\n\n//access parameters\nOptional<Parameter<ArrayData<Float>>> k2BadParam = wc1.jGet(\"absentKeyHere\", JKeyTypes.FloatArrayKey());\n\n//add more than one parameters, using madd\nWait wc2 = wc1.madd(k3.set(1, 2, 3, 4).withUnits(JUnits.day), k4.set(Instant.now()));\nint paramSize = wc2.size();\n\n//update existing key with set\nInteger[] intArray = {5, 6, 7, 8};\nWait wc3 = wc1.add(k2.set(intArray));\n\n//remove a key\nWait wc4 = wc2.remove(k4);\n\n//list all keys\njava.util.List<String> allKeys = wc4.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Wait Command"},{"location":"/messages/commands.html#json-serialization","text":"Commands can be serialized to JSON. The library has provided JsonSupport helper class and methods to serialize Setup, Observe and Wait commands.\nScala import play.api.libs.json.{JsValue, Json}\n\n//key\nval k1: Key[MatrixData[Double]] = DoubleMatrixKey.make(\"myMatrix\")\n//values\nval m1: MatrixData[Double] = MatrixData.fromArrays(\n  Array(1.0, 2.0, 3.0),\n  Array(4.1, 5.1, 6.1),\n  Array(7.2, 8.2, 9.2)\n)\n\n//prefix\nval prefix: Prefix = Prefix(\"wfos.red.detector\")\n\n//parameter\nval i1: Parameter[MatrixData[Double]] = k1.set(m1)\n\n//commands\nval sc: Setup   = Setup(prefix, CommandName(\"move\"), Some(obsId)).add(i1)\nval oc: Observe = Observe(prefix, CommandName(\"move\"), Some(obsId)).add(i1)\nval wc: Wait    = Wait(prefix, CommandName(\"move\"), Some(obsId)).add(i1)\n\n//json support - write\nval scJson: JsValue = JsonSupport.writeSequenceCommand(sc)\nval ocJson: JsValue = JsonSupport.writeSequenceCommand(oc)\nval wcJson: JsValue = JsonSupport.writeSequenceCommand(wc)\n\n//optionally prettify\nval str: String = Json.prettyPrint(scJson)\n\n//construct command from string\nval scFromPrettyStr = JsonSupport.readSequenceCommand[Setup](Json.parse(str))\n\n//json support - read\nval sc1: Setup   = JsonSupport.readSequenceCommand[Setup](scJson)\nval oc1: Observe = JsonSupport.readSequenceCommand[Observe](ocJson)\nval wc1: Wait    = JsonSupport.readSequenceCommand[Wait](wcJson) Java //key\nKey<MatrixData<Double>> k1 = JKeyTypes.DoubleMatrixKey().make(\"myMatrix\");\n\n//values\nDouble[][] doubles = {{1.0, 2.0, 3.0}, {4.1, 5.1, 6.1}, {7.2, 8.2, 9.2}};\nMatrixData<Double> m1 = MatrixData.fromJavaArrays(Double.class, doubles);\n\n//parameter\nParameter<MatrixData<Double>> i1 = k1.set(m1);\n\nString prefixName = \"wfos.blue.filter\";\n\n//commands\nSetup sc = new Setup(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(i1);\nObserve oc = new Observe(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(i1);\nWait wc = new Wait(new Prefix(prefixName), new CommandName(\"move\"), Optional.of(obsId)).add(i1);\n\n//json support - write\nJsValue scJson = JavaJsonSupport.writeSequenceCommand(sc);\nJsValue ocJson = JavaJsonSupport.writeSequenceCommand(oc);\nJsValue wcJson = JavaJsonSupport.writeSequenceCommand(wc);\n\n//optionally prettify\nString str = Json.prettyPrint(scJson);\n\n//construct command from string\nSetup sc1 = JavaJsonSupport.readSequenceCommand(Json.parse(str));\nObserve oc1 = JavaJsonSupport.readSequenceCommand(ocJson);\nWait wc1 = JavaJsonSupport.readSequenceCommand(wcJson);","title":"JSON serialization"},{"location":"/messages/commands.html#unique-key-constraint","text":"By design, a ParameterSet in a Setup, Observe, or Wait command is optimized to store only unique keys. When using add or madd methods on commands to add new parameters, if the parameter being added has a key which is already present in the paramSet, the already stored parameter will be replaced by the given parameter.\nNote If the Set is created by component developers and given directly while creating a command, then it will be the responsibility of component developers to maintain uniqueness with parameters based on key.\nHere are some examples that illustrate this point:\nScala //keys\nval encoderKey: Key[Int] = KeyType.IntKey.make(\"encoder\")\nval filterKey: Key[Int]  = KeyType.IntKey.make(\"filter\")\nval miscKey: Key[Int]    = KeyType.IntKey.make(\"misc.\")\n\n//prefix\nval prefix: Prefix = Prefix(\"wfos.red.detector\")\n\n//params\nval encParam1: Parameter[Int] = encoderKey.set(1)\nval encParam2: Parameter[Int] = encoderKey.set(2)\nval encParam3: Parameter[Int] = encoderKey.set(3)\n\nval filterParam1: Parameter[Int] = filterKey.set(1)\nval filterParam2: Parameter[Int] = filterKey.set(2)\nval filterParam3: Parameter[Int] = filterKey.set(3)\n\nval miscParam1 = miscKey.set(100)\n\n//Setup command with duplicate key via constructor\nval setup: Setup =\n  Setup(prefix,\n        CommandName(\"move\"),\n        Some(obsId),\n        Set(encParam1, encParam2, encParam3, filterParam1, filterParam2, filterParam3))\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nval uniqueKeys1 = setup.paramSet.toList.map(_.keyName)\n\n//try adding duplicate keys via add + madd\nval changedSetup: Setup = setup\n  .add(encParam3)\n  .madd(\n    filterParam1,\n    filterParam2,\n    filterParam3\n  )\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nval uniqueKeys2: List[String] = changedSetup.paramSet.toList.map(_.keyName)\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nval finalSetUp: Setup = setup.madd(Set(miscParam1, encParam1))\n//now contains encoderKey, filterKey, miscKey\nval uniqueKeys3: List[String] = finalSetUp.paramSet.toList.map(_.keyName) Java //keys\nKey<Integer> encoderKey = JKeyTypes.IntKey().make(\"encoder\");\nKey<Integer> filterKey = JKeyTypes.IntKey().make(\"filter\");\nKey<Integer> miscKey = JKeyTypes.IntKey().make(\"misc.\");\n\n//prefix\nString prefix = \"wfos.blue.filter\";\n\n//params\nParameter<Integer> encParam1 = encoderKey.set(1);\nParameter<Integer> encParam2 = encoderKey.set(2);\nParameter<Integer> encParam3 = encoderKey.set(3);\n\nParameter<Integer> filterParam1 = filterKey.set(1);\nParameter<Integer> filterParam2 = filterKey.set(2);\nParameter<Integer> filterParam3 = filterKey.set(3);\n\nParameter<Integer> miscParam1 = miscKey.set(100);\n\n//Setup command with duplicate key via madd\nSetup setup = new Setup(new Prefix(prefix), new CommandName(\"move\"), Optional.of(obsId)).madd(\n        encParam1,\n        encParam2,\n        encParam3,\n        filterParam1,\n        filterParam2,\n        filterParam3);\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nList<String> uniqueKeys1 = setup.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//try adding duplicate keys via add + madd\nSetup changedSetup = setup.add(encParam3).madd(filterParam1, filterParam2, filterParam3);\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nList<String> uniqueKeys2 = changedSetup.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nSetup finalSetUp = setup.madd(miscParam1, encParam1);\n//now contains encoderKey, filterKey, miscKey\nList<String> uniqueKeys3 = finalSetUp.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Unique Key constraint"},{"location":"/messages/commands.html#cloning-a-command","text":"In order to track the completion of a command, every command that is sent must have a unique RunId. If you wish to resubmit a previously sent Setup, the cloneCommand method must be used prior to submission to create a new command from existing parameters, but with a new RunId.\nScala val setup  = Setup(prefix, commandName, Some(obsId)).madd(i1)\nval setup2 = setup.cloneCommand\n\nval observe  = Observe(prefix, commandName, Some(obsId)).madd(i1)\nval observe2 = observe.cloneCommand\n\nval wait  = Wait(prefix, commandName, Some(obsId)).madd(i1)\nval wait2 = wait.cloneCommand Java Setup setup = new Setup(new Prefix(prefix), commandName, Optional.of(obsId)).add(encoderParam);\nSetup setup2 = setup.cloneCommand();\n\nObserve observe = new Observe(new Prefix(prefix), commandName, Optional.empty()).add(encoderParam);\nObserve observe2 = observe.cloneCommand();\n\nWait wait = new Wait(new Prefix(prefix), commandName, Optional.of(obsId)).add(encoderParam);\nWait wait2 = wait.cloneCommand();","title":"Cloning a Command"},{"location":"/messages/commands.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source Code for Examples"},{"location":"/messages/events.html","text":"","title":"Events"},{"location":"/messages/events.html#events","text":"Events are the most basic type of asynchronous notification in TMT when an activity occurs somewhere in the TMT system and other components need to be notified. Each type of event has a unique purpose and unique information, but they all share same structural features. All events have EventInfo and ParameterSet.\nNote csw-messages library offers out of the box support to serialize Events using Protobuf, so that events can be produced and consumed by JVM(Java virtual machine) as well as Non-JVM applications. For more on this Protobuf support section below.","title":"Events"},{"location":"/messages/events.html#eventtime","text":"It captures the instance of a time in UTC format. To create current instance of time use default constructor. For other utility functions, see below examples:\nScala //default constructor will return current time in UTC\nval now: EventTime = EventTime()\n\n//using constructor\nval anHourAgo: EventTime = EventTime(Instant.now().minusSeconds(3600))\n\n//current event time using utility function\nval currentTime: EventTime = EventTime.toCurrent\n\n//some past time using utility function\nval aDayAgo = EventTime.toEventTime(Instant.now.minusSeconds(86400))\n Java //apply returns current time in UTC\nEventTime now = EventTime.apply();\n\n//using constructor\nEventTime anHourAgo = new EventTime(Instant.now().minusSeconds(3600));\n\n//return current time in UTC\nEventTime currentTime = EventTime.toCurrent();\n\n//some past time using utility function\nEventTime aDayAgo = EventTime.toEventTime(Instant.now().minusSeconds(86400));","title":"EventTime"},{"location":"/messages/events.html#observe-event","text":"ObserveEvent is used to describe an event within a standardized data acquisition process. Published only by Science Detector Assemblies, who emit ObserveEvents during their exposures to signal the occurrence of specific activities/actions during the acquisition of data. Observe Events are published by the detector system using the Event Service.\nScala //keys\nval k1: Key[Int]    = KeyType.IntKey.make(\"encoder\")\nval k2: Key[Int]    = KeyType.IntKey.make(\"windspeed\")\nval k3: Key[String] = KeyType.StringKey.make(\"filter\")\nval k4: Key[Int]    = KeyType.IntKey.make(\"notUsed\")\n\n//prefixes\nval ck1   = Prefix(\"wfos.prog.cloudcover\")\nval name1 = EventName(\"filter wheel\")\nval ck3   = Prefix(\"wfos.red.detector\")\nval name3 = EventName(\"iris\")\n\n//parameters\nval p1: Parameter[Int]    = k1.set(22)\nval p2: Parameter[Int]    = k2.set(44)\nval p3: Parameter[String] = k3.set(\"A\", \"B\", \"C\", \"D\")\n\n//Create ObserveEvent using madd\nval se1: ObserveEvent = ObserveEvent(ck1, name1).madd(p1, p2)\n//Create ObserveEvent using apply\nval se2: ObserveEvent = ObserveEvent(ck3, name3, Set(p1, p2))\n//Create ObserveEvent and use add\nval se3: ObserveEvent = ObserveEvent(ck3, name3).add(p1).add(p2).add(p3)\n\n//access keys\nval k1Exists: Boolean = se1.exists(k1) //true\n\n//access Parameters\nval p4: Option[Parameter[Int]] = se1.get(k1)\n\n//access values\nval v1: Array[Int] = se1(k1).values\nval v2: Array[Int] = se2.parameter(k2).values\n//k4 is missing\nval missingKeys: Set[String] = se3.missingKeys(k1, k2, k3, k4)\n\n//remove keys\nval se4: ObserveEvent = se3.remove(k3)\n Java //keys\nKey<Integer> k1 = JKeyTypes.IntKey().make(\"encoder\");\nKey<Integer> k2 = JKeyTypes.IntKey().make(\"windspeed\");\nKey<String> k3 = JKeyTypes.StringKey().make(\"filter\");\nKey<Integer> k4 = JKeyTypes.IntKey().make(\"notUsed\");\n\n//prefixes\nPrefix prefix1 = new Prefix(\"wfos.prog.cloudcover\");\nEventName name1 = new EventName(\"filter wheel\");\nPrefix prefix2 = new Prefix(\"wfos.red.detector\");\nEventName name2 = new EventName(\"iris\");\n\n//parameters\nParameter<Integer> p1 = k1.set(22);\nParameter<Integer> p2 = k2.set(44);\nParameter<String> p3 = k3.set(\"A\", \"B\", \"C\", \"D\");\n\n//Create ObserveEvent using madd\nObserveEvent oc1 = new ObserveEvent(prefix1, name1).madd(p1, p2);\n//Create ObserveEvent using add\nObserveEvent oc2 = new ObserveEvent(prefix2, name2).add(p1).add(p2);\n//Create ObserveEvent and use add\nObserveEvent oc3 = new ObserveEvent(prefix2, name2).add(p1).add(p2).add(p3);\n\n//access keys\nBoolean k1Exists = oc1.exists(k1); //true\n\n//access Parameters\nOptional<Parameter<Integer>> p4 = oc1.jGet(k1);\n\n//access values\nList<Integer> v1 = oc1.jGet(k1).get().jValues();\nList<Integer> v2 = oc2.parameter(k2).jValues();\n//k4 is missing\nSet<String> missingKeys = oc3.jMissingKeys(k1, k2, k3, k4);\n\n//remove keys\nObserveEvent oc4 = oc3.remove(k3);","title":"Observe Event"},{"location":"/messages/events.html#system-event","text":"SystemEvent is used to describe a demand or other algorithm input from one component to the other. It is also used to publish internal state or status values of a component that may be of interest to other components in the system.\nScala //keys\nval k1: Key[Int]    = KeyType.IntKey.make(\"encoder\")\nval k2: Key[Int]    = KeyType.IntKey.make(\"windspeed\")\nval k3: Key[String] = KeyType.StringKey.make(\"filter\")\nval k4: Key[Int]    = KeyType.IntKey.make(\"notUsed\")\n\n//prefixes\nval ck1   = Prefix(\"wfos.prog.cloudcover\")\nval name1 = EventName(\"filter wheel\")\nval ck3   = Prefix(\"wfos.red.detector\")\nval name3 = EventName(\"iris\")\n\n//parameters\nval p1: Parameter[Int]    = k1.set(22)\nval p2: Parameter[Int]    = k2.set(44)\nval p3: Parameter[String] = k3.set(\"A\", \"B\", \"C\", \"D\")\n\n//Create SystemEvent using madd\nval se1: SystemEvent = SystemEvent(ck1, name1).madd(p1, p2)\n//Create SystemEvent using apply\nval se2: SystemEvent = SystemEvent(ck3, name3, Set(p1, p2))\n//Create SystemEvent and use add\nval se3: SystemEvent = SystemEvent(ck3, name3).add(p1).add(p2).add(p3)\n\n//access keys\nval k1Exists: Boolean = se1.exists(k1) //true\n\n//access Parameters\nval p4: Option[Parameter[Int]] = se1.get(k1)\n\n//access values\nval v1: Array[Int] = se1(k1).values\nval v2: Array[Int] = se2.parameter(k2).values\n//k4 is missing\nval missingKeys: Set[String] = se3.missingKeys(k1, k2, k3, k4)\n\n//remove keys\nval se4: SystemEvent = se3.remove(k3)\n\n//add more than one parameters, using madd\nval se5: SystemEvent = se4.madd(k3.set(\"X\", \"Y\", \"Z\").withUnits(Units.day), k4.set(99, 100))\nval paramSize: Int   = se5.size\n\n//update existing key with set\nval se6: SystemEvent = se5.add(k2.set(5, 6, 7, 8))\n Java //keys\nKey<Integer> k1 = JKeyTypes.IntKey().make(\"encoder\");\nKey<Integer> k2 = JKeyTypes.IntKey().make(\"windspeed\");\nKey<String> k3 = JKeyTypes.StringKey().make(\"filter\");\nKey<Integer> k4 = JKeyTypes.IntKey().make(\"notUsed\");\n\n//prefixes\nPrefix prefix1 = new Prefix(\"wfos.prog.cloudcover\");\nEventName name1 = new EventName(\"filter wheel\");\nPrefix prefix2 = new Prefix(\"wfos.red.detector\");\nEventName name2 = new EventName(\"iris\");\n\n//parameters\nParameter<Integer> p1 = k1.set(22);\nParameter<Integer> p2 = k2.set(44);\nParameter<String> p3 = k3.set(\"A\", \"B\", \"C\", \"D\");\n\n//Create SystemEvent using madd\nSystemEvent se1 = new SystemEvent(prefix1, name1).madd(p1, p2);\n//Create SystemEvent using add\nSystemEvent se2 = new SystemEvent(prefix2, name2).add(p1).add(p2);\n//Create SystemEvent and use add\nSystemEvent se3 = new SystemEvent(prefix2, name2).add(p1).add(p2).add(p3);\n\n//access keys\nBoolean k1Exists = se1.exists(k1); //true\n\n//access Parameters\nOptional<Parameter<Integer>> p4 = se1.jGet(k1);\n\n//access values\nList<Integer> v1 = se1.jGet(k1).get().jValues();\nList<Integer> v2 = se2.parameter(k2).jValues();\n//k4 is missing\nSet<String> missingKeys = se3.jMissingKeys(k1, k2, k3, k4);\n\n//remove keys\nSystemEvent se4 = se3.remove(k3);","title":"System Event"},{"location":"/messages/events.html#json-serialization","text":"Events can be serialized to JSON. The library has provided JsonSupport helper class and methods to serialize Status, Observe and System events.\nScala import play.api.libs.json.{JsValue, Json}\n\n//key\nval k1: Key[MatrixData[Double]] = DoubleMatrixKey.make(\"myMatrix\")\n\nval name1  = EventName(\"filter wheel\")\nval prefix = Prefix(\"wfos.blue.filter\")\n\n//values\nval m1: MatrixData[Double] = MatrixData.fromArrays(\n  Array(1.0, 2.0, 3.0),\n  Array(4.1, 5.1, 6.1),\n  Array(7.2, 8.2, 9.2)\n)\n//parameter\nval i1: Parameter[MatrixData[Double]] = k1.set(m1)\n//events\nval observeEvent: ObserveEvent = ObserveEvent(prefix, name1).add(i1)\nval systemEvent: SystemEvent   = SystemEvent(prefix, name1).add(i1)\n\n//json support - write\nval observeJson: JsValue = JsonSupport.writeEvent(observeEvent)\nval systemJson: JsValue  = JsonSupport.writeEvent(systemEvent)\n\n//optionally prettify\nval str: String = Json.prettyPrint(systemJson)\n\n//construct command from string\nval systemEventFromPrettyStr: SystemEvent = JsonSupport.readEvent[SystemEvent](Json.parse(str))\n\n//json support - read\nval observeEvent1: ObserveEvent = JsonSupport.readEvent[ObserveEvent](observeJson)\nval systemEvent1: SystemEvent   = JsonSupport.readEvent[SystemEvent](systemJson) Java //key\nKey<MatrixData<Double>> k1 = JKeyTypes.DoubleMatrixKey().make(\"myMatrix\");\n\n//prefixes\nPrefix prefix1 = new Prefix(\"wfos.blue.filter\");\nEventName name1 = new EventName(\"filter wheel\");\n\n//values\nDouble[][] doubles = {{1.0, 2.0, 3.0}, {4.1, 5.1, 6.1}, {7.2, 8.2, 9.2}};\nMatrixData<Double> m1 = MatrixData.fromJavaArrays(Double.class, doubles);\n\n//parameter\nParameter<MatrixData<Double>> i1 = k1.set(m1);\n\n\n//events\nObserveEvent observeEvent = new ObserveEvent(prefix1, name1).add(i1);\nSystemEvent systemEvent = new SystemEvent(prefix1, name1).add(i1);\n\n//json support - write\nJsValue observeJson = JavaJsonSupport.writeEvent(observeEvent);\nJsValue systemJson = JavaJsonSupport.writeEvent(systemEvent);\n\n//optionally prettify\nString str = Json.prettyPrint(systemJson);\n\n//construct DemandState from string\nSystemEvent statusFromPrettyStr = JavaJsonSupport.readEvent(Json.parse(str));\n\n//json support - read\nObserveEvent observeEvent1 = JavaJsonSupport.readEvent(observeJson);\nSystemEvent systemEvent1 = JavaJsonSupport.readEvent(systemJson);","title":"JSON Serialization"},{"location":"/messages/events.html#unique-key-constraint","text":"By choice, a ParameterSet in either ObserveEvent or SystemEvent event will be optimized to store only unique keys. When using add or madd methods on events to add new parameters, if the parameter being added has a key which is already present in the paramSet, the already stored parameter will be replaced by the given parameter.\nNote If the Set is created by component developers and given directly while creating an event, then it will be the responsibility of component developers to maintain uniqueness with parameters based on key.\nHere are some examples that illustrate this point:\nScala //keys\nval encoderKey: Key[Int] = KeyType.IntKey.make(\"encoder\")\nval filterKey: Key[Int]  = KeyType.IntKey.make(\"filter\")\nval miscKey: Key[Int]    = KeyType.IntKey.make(\"misc.\")\n\n//prefix\nval prefix = Prefix(\"wfos.blue.filter\")\n\nval name1 = EventName(\"filter wheel\")\n\n//params\nval encParam1 = encoderKey.set(1)\nval encParam2 = encoderKey.set(2)\n\nval encParam3    = encoderKey.set(3)\nval filterParam1 = filterKey.set(1)\nval filterParam2 = filterKey.set(2)\n\nval filterParam3 = filterKey.set(3)\n\nval miscParam1 = miscKey.set(100)\n//StatusEvent with duplicate key via constructor\nval systemEvent =\n  SystemEvent(prefix, name1, Set(encParam1, encParam2, encParam3, filterParam1, filterParam2, filterParam3))\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nval uniqueKeys1 = systemEvent.paramSet.toList.map(_.keyName)\n\n//try adding duplicate keys via add + madd\nval changedStatusEvent = systemEvent\n  .add(encParam3)\n  .madd(\n    filterParam1,\n    filterParam2,\n    filterParam3\n  )\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nval uniqueKeys2 = changedStatusEvent.paramSet.toList.map(_.keyName)\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nval finalStatusEvent = systemEvent.madd(Set(miscParam1, encParam1))\n//now contains encoderKey, filterKey, miscKey\nval uniqueKeys3 = finalStatusEvent.paramSet.toList.map(_.keyName) Java //keys\nKey<Integer> encoderKey = JKeyTypes.IntKey().make(\"encoder\");\nKey<Integer> filterKey = JKeyTypes.IntKey().make(\"filter\");\nKey<Integer> miscKey = JKeyTypes.IntKey().make(\"misc.\");\n\n//prefix\nPrefix prefix1 = new Prefix(\"wfos.blue.filter\");\nEventName name1 = new EventName(\"filter wheel\");\n\n//params\nParameter<Integer> encParam1 = encoderKey.set(1);\nParameter<Integer> encParam2 = encoderKey.set(2);\nParameter<Integer> encParam3 = encoderKey.set(3);\n\nParameter<Integer> filterParam1 = filterKey.set(1);\nParameter<Integer> filterParam2 = filterKey.set(2);\nParameter<Integer> filterParam3 = filterKey.set(3);\n\nParameter<Integer> miscParam1 = miscKey.set(100);\n\n//StatusEvent with duplicate key via madd\nSystemEvent event = new SystemEvent(prefix1, name1).madd(\n        encParam1,\n        encParam2,\n        encParam3,\n        filterParam1,\n        filterParam2,\n        filterParam3);\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nList<String> uniqueKeys1 = event.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//try adding duplicate keys via add + madd\nSystemEvent changedEvent = event.add(encParam3).madd(filterParam1, filterParam2, filterParam3);\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nList<String> uniqueKeys2 = changedEvent.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nSystemEvent finalEvent = changedEvent.madd(miscParam1, encParam1);\n//now contains encoderKey, filterKey, miscKey\nList<String> uniqueKeys3 = finalEvent.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Unique Key Constraint"},{"location":"/messages/events.html#protobuf","text":"Protobuf aka Protocol buffers, are a language-neutral, platform-neutral extensible mechanism for serializing structured data. For more, visit Protobuf home page\nIn TMT observatory, subsystems and components could be running on JVM(Java virtual machine) and Non-JVM platform. This leads to solving a non-trivial problem of a Non-JVM component wanting to consume an Event produced by a JVM component. Amongst the available options for data over the wire, Protobuf was chosen for its performance, data compression and official/unofficial support many mainstream languages.\ncsw-messages library enhances the Protobuf support, by providing out of the box helper methods, to convert events from/to protobuf binary data.\nProtobuf Code generation for Non-JVM languages The protobuf schema is defined in csw_protobuf directory. The contained .proto files can be fed to a protoc compiler in the language of your choice and it will do the required code generation.\nHere are some examples:\nScala //Key\nval raDecKey = RaDecKey.make(\"raDecKey\")\n\n//values\nval raDec1 = RaDec(10.20, 40.20)\nval raDec2 = RaDec(100.20, 400.20)\n\n//parameters\nval param = raDecKey.set(raDec1, raDec2).withUnits(arcmin)\n\nval prefix = Prefix(\"wfos.blue.filter\")\nval name   = EventName(\"filter wheel\")\n//events\nval observeEvent: ObserveEvent = ObserveEvent(prefix, name).add(param)\nval systemEvent1: SystemEvent  = SystemEvent(prefix, name).add(param)\nval systemEvent2: SystemEvent =\n  SystemEvent(prefix, name).add(param)\n\n//convert events to protobuf bytestring\nval byteArray2: PbEvent = observeEvent.toPb\nval byteArray3: PbEvent = systemEvent1.toPb\nval byteArray4: PbEvent = systemEvent2.toPb\n\n//convert protobuf bytestring to events\nval pbObserveEvent: ObserveEvent = ObserveEvent.fromPb(byteArray2)\nval pbSystemEvent1: SystemEvent  = SystemEvent.fromPb(byteArray3)\nval pbSystemEvent2: SystemEvent  = SystemEvent.fromPb(byteArray4) Java //prefixes\nPrefix prefix1 = new Prefix(\"wfos.blue.filter\");\nEventName name1 = new EventName(\"filter wheel\");\nPrefix prefix2 = new Prefix(\"wfos.prog.cloudcover\");\nEventName name2 = new EventName(\"iris\");\n\n//Key\nKey<RaDec> raDecKey = JKeyTypes.RaDecKey().make(\"raDecKey\");\n\n//values\nRaDec raDec1 = new RaDec(10.20, 40.20);\nRaDec raDec2 = new RaDec(100.20, 400.20);\n\n//parameters\nParameter<RaDec> param = raDecKey.set(raDec1, raDec2).withUnits(JUnits.arcmin);\n\n//events\nObserveEvent observeEvent = new ObserveEvent(prefix1, name1).add(param);\nSystemEvent systemEvent1 = new SystemEvent(prefix1, name1).add(param);\nSystemEvent systemEvent2 = new SystemEvent(prefix2, name2).add(param);\n\n//convert events to protobuf bytestring\nPbEvent byteArray2 = observeEvent.toPb();\nPbEvent byteArray3 = systemEvent1.toPb();\nPbEvent byteArray4 = systemEvent2.toPb();\n\n//convert protobuf bytestring to events\nObserveEvent pbObserveEvent = ObserveEvent.fromPb(byteArray2);\nSystemEvent pbSystemEvent1 = SystemEvent.fromPb(byteArray3);\nSystemEvent pbSystemEvent2 = SystemEvent.fromPb(byteArray4);","title":"Protobuf"},{"location":"/messages/events.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source Code for Examples"},{"location":"/messages/states.html","text":"","title":"State Variables"},{"location":"/messages/states.html#state-variables","text":"These state variables are used when an Assembly wants to track the status of a command sent to an HCD using a matcher. For more information, see Publishing State.\nA states represent a component’s internal state. There are two types called CurrentState and DemandState. They both share the same structural features. All state variables have Prefix and ParameterSet.\nThe PubSub feature of the HCD provides CurrentState values to the PubSub subscriber.","title":"State Variables"},{"location":"/messages/states.html#demandstate","text":"A state variable that indicates the demand or requested state.\nScala //prefix\nval prefix = Prefix(\"wfos.prog.cloudcover\")\n\n//key\nval charKey: Key[Char]         = KeyType.CharKey.make(\"charKey\")\nval intKey: Key[Int]           = KeyType.IntKey.make(\"intKey\")\nval booleanKey: Key[Boolean]   = KeyType.BooleanKey.make(\"booleanKey\")\nval timestampKey: Key[Instant] = KeyType.TimestampKey.make(\"timestampKey\")\nval notUsedKey: Key[String]    = KeyType.StringKey.make(\"notUsed\")\n\n//parameters\nval charParam: Parameter[Char]       = charKey.set('A', 'B', 'C').withUnits(NoUnits)\nval intParam: Parameter[Int]         = intKey.set(1, 2, 3).withUnits(meter)\nval booleanParam: Parameter[Boolean] = booleanKey.set(true, false)\nval timestamp: Parameter[Instant]    = timestampKey.set(Instant.now)\n\n//create DemandState and use sequential add\nval ds1: DemandState = DemandState(prefix).add(charParam).add(intParam)\n//create DemandState and add more than one Parameters using madd\nval ds2: DemandState = DemandState(prefix).madd(intParam, booleanParam)\n//create DemandState using apply\nval ds3: DemandState = DemandState(prefix, Set(timestamp))\n\n//access keys\nval charKeyExists: Boolean = ds1.exists(charKey) //true\n\n//access Parameters\nval p1: Option[Parameter[Int]] = ds1.get(intKey)\n\n//access values\nval v1: Array[Char]    = ds1(charKey).values\nval v2: Array[Boolean] = ds2.parameter(booleanKey).values\nval missingKeys: Set[String] = ds3.missingKeys(\n  charKey,\n  intKey,\n  booleanKey,\n  timestampKey,\n  notUsedKey\n)\n\n//remove keys\nval ds4: DemandState = ds3.remove(timestampKey)\n\n//update existing keys - set it back by an hour\nval ds5: DemandState = ds3.add(timestampKey.set(Instant.now().minusSeconds(3600)))\n Java //prefix\nString prefix = \"wfos.prog.cloudcover\";\n\n//keys\nKey<Character> charKey = JKeyTypes.CharKey().make(\"charKey\");\nKey<Integer> intKey = JKeyTypes.IntKey().make(\"intKey\");\nKey<Boolean> booleanKey = JKeyTypes.BooleanKey().make(\"booleanKey\");\nKey<Instant> timestampKey = JKeyTypes.TimestampKey().make(\"timestampKey\");\nKey<String> notUsedKey = JKeyTypes.StringKey().make(\"notUsed\");\n\n\nObsId obsId = new ObsId(\"Obs001\");\n\n//parameters\nParameter<Character> charParam = charKey.set('A', 'B', 'C').withUnits(NoUnits);\nParameter<Integer> intParam = intKey.set(1, 2, 3).withUnits(meter);\nParameter<Boolean> booleanParam = booleanKey.set(true, false);\nParameter<Instant> timestamp = timestampKey.set(Instant.now());\n\n//create DemandState and use sequential add\nDemandState ds1 = new DemandState(prefix).add(charParam).add(intParam);\n//create DemandState and add more than one Parameters using madd\nDemandState ds2 = new DemandState(prefix).madd(intParam, booleanParam);\n//create DemandState using apply\nDemandState ds3 = new DemandState(prefix).add(timestamp);\n\n//access keys\nBoolean charKeyExists = ds1.exists(charKey); //true\n\n//access Parameters\nOptional<Parameter<Integer>> p1 = ds1.jGet(intKey);\n\n//access values\nList<Character> v1 = ds1.jGet(charKey).get().jValues();\nList<Boolean> v2 = ds2.parameter(booleanKey).jValues();\nSet<String> missingKeys = ds3.jMissingKeys(charKey,\n        intKey,\n        booleanKey,\n        timestampKey,\n        notUsedKey);\n\n//remove keys\nDemandState ds4 = ds3.remove(timestampKey);\n\n//update existing keys - set it back by an hour\nDemandState ds5 = ds3.add(timestampKey.set(Instant.now().minusSeconds(3600)));","title":"DemandState"},{"location":"/messages/states.html#currentstate","text":"A state variable that is published by a component that describes its internal state. Used by Assemblies to determine command completion in Command Service.\nScala //prefix\nval prefix = Prefix(\"wfos.prog.cloudcover\")\n\n//key\nval charKey      = KeyType.CharKey.make(\"charKey\")\nval intKey       = KeyType.IntKey.make(\"intKey\")\nval booleanKey   = KeyType.BooleanKey.make(\"booleanKey\")\nval timestampKey = KeyType.TimestampKey.make(\"timestampKey\")\nval notUsedKey   = KeyType.StringKey.make(\"notUsed\")\n\n//parameters\nval charParam    = charKey.set('A', 'B', 'C').withUnits(NoUnits)\nval intParam     = intKey.set(1, 2, 3).withUnits(meter)\nval booleanParam = booleanKey.set(true, false)\nval timestamp    = timestampKey.set(Instant.now)\n\n//create CurrentState and use sequential add\nval cs1 = CurrentState(prefix).add(charParam).add(intParam)\n//create CurrentState and add more than one Parameters using madd\nval cs2 = CurrentState(prefix).madd(intParam, booleanParam)\n//create CurrentState using apply\nval cs3 = CurrentState(prefix, Set(timestamp))\n\n//access keys\nval charKeyExists = cs1.exists(charKey) //true\n\n//access Parameters\nval p1: Option[Parameter[Int]] = cs1.get(intKey)\n\n//access values\nval v1: Array[Char]    = cs1(charKey).values\nval v2: Array[Boolean] = cs2.parameter(booleanKey).values\nval missingKeys: Set[String] = cs3.missingKeys(\n  charKey,\n  intKey,\n  booleanKey,\n  timestampKey,\n  notUsedKey\n)\n\n//remove keys\nval cs4 = cs3.remove(timestampKey)\n\n//update existing keys - set it back by an hour\nval cs5 = cs3.add(timestampKey.set(Instant.now().minusSeconds(3600)))\n Java //prefix\nString prefix = \"wfos.prog.cloudcover\";\n\n//keys\nKey<Character> charKey = JKeyTypes.CharKey().make(\"charKey\");\nKey<Integer> intKey = JKeyTypes.IntKey().make(\"intKey\");\nKey<Boolean> booleanKey = JKeyTypes.BooleanKey().make(\"booleanKey\");\nKey<Instant> timestampKey = JKeyTypes.TimestampKey().make(\"timestampKey\");\nKey<String> notUsedKey = JKeyTypes.StringKey().make(\"notUsed\");\n\n\nObsId obsId = new ObsId(\"Obs001\");\n\n//parameters\nParameter<Character> charParam = charKey.set('A', 'B', 'C').withUnits(NoUnits);\nParameter<Integer> intParam = intKey.set(1, 2, 3).withUnits(meter);\nParameter<Boolean> booleanParam = booleanKey.set(true, false);\nParameter<Instant> timestamp = timestampKey.set(Instant.now());\n\n//create CurrentState and use sequential add\nCurrentState cs1 = new CurrentState(prefix).add(charParam).add(intParam);\n//create CurrentState and add more than one Parameters using madd\nCurrentState cs2 = new CurrentState(prefix).madd(intParam, booleanParam);\n//create CurrentState using apply\nCurrentState cs3 = new CurrentState(prefix).add(timestamp);\n\n//access keys\nBoolean charKeyExists = cs1.exists(charKey); //true\n\n//access Parameters\nOptional<Parameter<Integer>> p1 = cs1.jGet(intKey);\n\n//access values\nList<Character> v1 = cs1.jGet(charKey).get().jValues();\nList<Boolean> v2 = cs2.parameter(booleanKey).jValues();\nSet<String> missingKeys = cs3.jMissingKeys(charKey,\n        intKey,\n        booleanKey,\n        timestampKey,\n        notUsedKey);\n\n//remove keys\nCurrentState cs4 = cs3.remove(timestampKey);\n\n//update existing keys - set it back by an hour\nCurrentState cs5 = cs3.add(timestampKey.set(Instant.now().minusSeconds(3600)));","title":"CurrentState"},{"location":"/messages/states.html#json-serialization","text":"State variables can be serialized to JSON. The library has provided JsonSupport helper class and methods to serialize DemandState and CurrentState.\nScala import play.api.libs.json.{JsValue, Json}\n\n//key\nval k1: Key[MatrixData[Double]] = DoubleMatrixKey.make(\"myMatrix\")\n//values\nval m1: MatrixData[Double] = MatrixData.fromArrays(\n  Array(1.0, 2.0, 3.0),\n  Array(4.1, 5.1, 6.1),\n  Array(7.2, 8.2, 9.2)\n)\n\n//parameter\nval p1: Parameter[MatrixData[Double]] = k1.set(m1)\n\n//state variables\nval ds: DemandState  = DemandState(Prefix(\"wfos.blue.filter\")).add(p1)\nval cs: CurrentState = CurrentState(Prefix(\"wfos.blue.filter\")).add(p1)\n\n//json support - write\nval dsJson: JsValue = JsonSupport.writeStateVariable(ds)\nval csJson: JsValue = JsonSupport.writeStateVariable(cs)\n\n//optionally prettify\nval str: String = Json.prettyPrint(dsJson)\n\n//construct command from string\nval scFromPrettyStr = JsonSupport.readStateVariable[DemandState](Json.parse(str))\n\n//json support - read\nval ds1: DemandState  = JsonSupport.readStateVariable[DemandState](dsJson)\nval cs1: CurrentState = JsonSupport.readStateVariable[CurrentState](csJson) Java //key\nKey<MatrixData<Double>> k1 = JKeyTypes.DoubleMatrixKey().make(\"myMatrix\");\n\n//values\nDouble[][] doubles = {{1.0, 2.0, 3.0}, {4.1, 5.1, 6.1}, {7.2, 8.2, 9.2}};\nMatrixData<Double> m1 = MatrixData.fromJavaArrays(Double.class, doubles);\n\n//parameter\nParameter<MatrixData<Double>> i1 = k1.set(m1);\n\n//state variables\nDemandState ds = new DemandState(\"wfos.blue.filter\").add(i1);\nCurrentState cs = new CurrentState(\"wfos.blue.filter\").add(i1);\n\n//json support - write\nJsValue dsJson = JavaJsonSupport.writeStateVariable(ds);\nJsValue csJson = JavaJsonSupport.writeStateVariable(cs);\n\n//optionally prettify\nString str = Json.prettyPrint(dsJson);\n\n//construct DemandState from string\nDemandState dsFromPrettyStr = JavaJsonSupport.readStateVariable(Json.parse(str));\n\n//json support - read\nDemandState ds1 = JavaJsonSupport.readStateVariable(dsJson);\nCurrentState cs1 = JavaJsonSupport.readStateVariable(csJson);","title":"JSON Serialization"},{"location":"/messages/states.html#unique-key-constraint","text":"By design, a ParameterSet in either DemandState or CurrentState will be optimized to store only unique keys. When using add or madd methods on events to add new parameters, if the parameter being added has a key which is already present in the paramSet, the already stored parameter will be replaced by the given parameter.\nNote If the Set is created by component developers and given directly while creating an event, then it will be the responsibility of component developers to maintain uniqueness with parameters based on key.\nHere are some examples that illustrate this point:\nScala //keys\nval encoderKey: Key[Int] = KeyType.IntKey.make(\"encoder\")\nval filterKey: Key[Int]  = KeyType.IntKey.make(\"filter\")\nval miscKey: Key[Int]    = KeyType.IntKey.make(\"misc.\")\n\n//prefix\nval prefix = \"wfos.blue.filter\"\n\n//params\nval encParam1 = encoderKey.set(1)\nval encParam2 = encoderKey.set(2)\nval encParam3 = encoderKey.set(3)\n\nval filterParam1 = filterKey.set(1)\nval filterParam2 = filterKey.set(2)\nval filterParam3 = filterKey.set(3)\n\nval miscParam1 = miscKey.set(100)\n\n//DemandState with duplicate key via constructor\nval statusEvent = DemandState(\n  prefix,\n  Set(encParam1, encParam2, encParam3, filterParam1, filterParam2, filterParam3)\n)\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nval uniqueKeys1 = statusEvent.paramSet.toList.map(_.keyName)\n\n//try adding duplicate keys via add + madd\nval changedStatusEvent = statusEvent\n  .add(encParam3)\n  .madd(\n    filterParam1,\n    filterParam2,\n    filterParam3\n  )\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nval uniqueKeys2 = changedStatusEvent.paramSet.toList.map(_.keyName)\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nval finalStatusEvent = statusEvent.madd(Set(miscParam1, encParam1))\n//now contains encoderKey, filterKey, miscKey\nval uniqueKeys3 = finalStatusEvent.paramSet.toList.map(_.keyName) Java //keys\nKey<Integer> encoderKey = JKeyTypes.IntKey().make(\"encoder\");\nKey<Integer> filterKey = JKeyTypes.IntKey().make(\"filter\");\nKey<Integer> miscKey = JKeyTypes.IntKey().make(\"misc.\");\n\n//prefix\nString prefix = \"wfos.blue.filter\";\n\n//params\nParameter<Integer> encParam1 = encoderKey.set(1);\nParameter<Integer> encParam2 = encoderKey.set(2);\nParameter<Integer> encParam3 = encoderKey.set(3);\n\nParameter<Integer> filterParam1 = filterKey.set(1);\nParameter<Integer> filterParam2 = filterKey.set(2);\nParameter<Integer> filterParam3 = filterKey.set(3);\n\nParameter<Integer> miscParam1 = miscKey.set(100);\n\n//Demand state with duplicate key via madd\nDemandState state = new DemandState(prefix).madd(\n        encParam1,\n        encParam2,\n        encParam3,\n        filterParam1,\n        filterParam2,\n        filterParam3);\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nList<String> uniqueKeys1 = state.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//try adding duplicate keys via add + madd\nDemandState changedState = state.add(encParam3).madd(filterParam1, filterParam2, filterParam3);\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nList<String> uniqueKeys2 = changedState.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nDemandState finalState = changedState.madd(miscParam1, encParam1);\n//now contains encoderKey, filterKey, miscKey\nList<String> uniqueKeys3 = finalState.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Unique Key Constraint"},{"location":"/messages/states.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source Code for Examples"},{"location":"/messages/result.html","text":"","title":"Result"},{"location":"/messages/result.html#result","text":"Components use Results to return results in the form of a ParameterSet.\nCreating a Result Requires:\nPrefix Set[Parameter]\nScala //keys\nval k1: Key[Int]    = KeyType.IntKey.make(\"encoder\")\nval k2: Key[Int]    = KeyType.IntKey.make(\"windspeed\")\nval k3: Key[String] = KeyType.StringKey.make(\"filter\")\nval k4: Key[Int]    = KeyType.IntKey.make(\"notUsed\")\n\n//prefixes\nval prefix = \"wfos.prog.cloudcover\"\n\n//parameters\nval p1: Parameter[Int]    = k1.set(22)\nval p2: Parameter[Int]    = k2.set(44)\nval p3: Parameter[String] = k3.set(\"A\", \"B\", \"C\", \"D\")\n\n//Create Result using madd\nval r1: Result = Result(prefix).madd(p1, p2)\n//Create Result using apply\nval r2: Result = Result(prefix, Set(p1, p2))\n//Create Result and use add\nval r3: Result = Result(prefix).add(p1).add(p2).add(p3)\n\n//access keys\nval k1Exists: Boolean = r1.exists(k1) //true\n\n//access Parameters\nval p4: Option[Parameter[Int]] = r1.get(k1)\n\n//access values\nval v1: Array[Int] = r1(k1).values\nval v2: Array[Int] = r2.parameter(k2).values\n//k4 is missing\nval missingKeys: Set[String] = r3.missingKeys(k1, k2, k3, k4)\n\n//remove keys\nval r4: Result = r3.remove(k3) Java //keys\nKey<Integer> k1 = JKeyTypes.IntKey().make(\"encoder\");\nKey<Integer> k2 = JKeyTypes.IntKey().make(\"windspeed\");\nKey<String> k3 = JKeyTypes.StringKey().make(\"filter\");\nKey<Integer> k4 = JKeyTypes.IntKey().make(\"notUsed\");\n\n//prefix\nString prefix = \"wfos.prog.cloudcover\";\n\nObsId obsId = new ObsId(\"Obs001\");\n\n//parameters\nParameter<Integer> p1 = k1.set(22);\nParameter<Integer> p2 = k2.set(44);\nParameter<String> p3 = k3.set(\"A\", \"B\", \"C\", \"D\");\n\n//Create Result using madd\nResult r1 = new Result(prefix).madd(p1, p2);\n//Create Result using madd\nResult r2 = new Result(prefix).madd(p1, p2);\n//Create Result and use madd, add\nResult r3 = new Result(prefix).madd(p1, p2).add(p3);\n\n//access keys\nBoolean k1Exists = r1.exists(k1); //true\n\n//access Parameters\nOptional<Parameter<Integer>> p4 = r1.jGet(k1);\n\n//access values\nList<Integer> v1 = r1.jGet(k1).get().jValues();\nList<Integer> v2 = r2.parameter(k2).jValues();\n\n//k4 is missing\nSet<String> missingKeys = r3.jMissingKeys(k1, k2, k3, k4);\n\n//remove keys\nResult r4 = r3.remove(k3);","title":"Result"},{"location":"/messages/result.html#json-serialization","text":"State variables can be serialized to JSON. The library has provided JsonSupport helper class and methods to serialize DemandState and CurrentState.\nScala import play.api.libs.json.{JsValue, Json}\n\n//key\nval k1: Key[MatrixData[Double]] = DoubleMatrixKey.make(\"myMatrix\")\n//values\nval m1: MatrixData[Double] = MatrixData.fromArrays(\n  Array(1.0, 2.0, 3.0),\n  Array(4.1, 5.1, 6.1),\n  Array(7.2, 8.2, 9.2)\n)\n\n//prefixes\nval prefix = \"wfos.prog.cloudcover\"\n\n//parameter\nval i1: Parameter[MatrixData[Double]] = k1.set(m1)\n\n//result\nval result: Result = Result(prefix).add(i1)\n\n//json support - write\nval resultJson: JsValue = JsonSupport.writeResult(result)\n\n//optionally prettify\nval str: String = Json.prettyPrint(resultJson)\n\n//construct result from string\nval scFromPrettyStr: Result = JsonSupport.readResult(Json.parse(str))\n\n//json support - read\nval result1: Result = JsonSupport.readResult(resultJson) Java //key\nKey<MatrixData<Double>> k1 = JKeyTypes.DoubleMatrixKey().make(\"myMatrix\");\n\n//values\nDouble[][] doubles = {{1.0, 2.0, 3.0}, {4.1, 5.1, 6.1}, {7.2, 8.2, 9.2}};\nMatrixData<Double> m1 = MatrixData.fromJavaArrays(Double.class, doubles);\n\n//parameter\nParameter<MatrixData<Double>> i1 = k1.set(m1);\n\n//ObsId\nObsId obsId = new ObsId(\"Obs001\");\n\n//prefix\nString prefix = \"wfos.prog.cloudcover\";\n\n//result\nResult result = new Result(prefix).add(i1);\n\n//json support - write\nJsValue resultJson = JavaJsonSupport.writeResult(result);\n\n//optionally prettify\nString str = Json.prettyPrint(resultJson);\n\n//construct result from string\nResult result1 = JavaJsonSupport.readResult(Json.parse(str));","title":"JSON serialization"},{"location":"/messages/result.html#unique-key-constraint","text":"By choice, a ParameterSet in Result will be optimized to store only unique keys. In other words, trying to store multiple keys with same name, will be automatically optimized by removing duplicates.\nNote Parameters are stored in a Set, which is an unordered collection of items. Hence, it’s not predictable whether first or last duplicate copy will be retained. Hence, cautiously avoid adding duplicate keys.\nHere are some examples that illustrate this point:\nScala //keys\nval encoderKey: Key[Int] = KeyType.IntKey.make(\"encoder\")\nval filterKey: Key[Int]  = KeyType.IntKey.make(\"filter\")\nval miscKey: Key[Int]    = KeyType.IntKey.make(\"misc.\")\n\n//prefix\nval prefix = \"wfos.blue.filter\"\n\n//params\nval encParam1 = encoderKey.set(1)\nval encParam2 = encoderKey.set(2)\nval encParam3 = encoderKey.set(3)\n\nval filterParam1 = filterKey.set(1)\nval filterParam2 = filterKey.set(2)\nval filterParam3 = filterKey.set(3)\n\nval miscParam1 = miscKey.set(100)\n\n//Setup command with duplicate key via constructor\nval result = Result(prefix, Set(encParam1, encParam2, encParam3, filterParam1, filterParam2, filterParam3))\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nval uniqueKeys1 = result.paramSet.toList.map(_.keyName)\n\n//try adding duplicate keys via add + madd\nval changedResult = result\n  .add(encParam3)\n  .madd(\n    filterParam1,\n    filterParam2,\n    filterParam3\n  )\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nval uniqueKeys2 = changedResult.paramSet.toList.map(_.keyName)\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nval finalResult = result.madd(Set(miscParam1, encParam1))\n//now contains encoderKey, filterKey, miscKey\nval uniqueKeys3 = finalResult.paramSet.toList.map(_.keyName) Java //keys\nKey<Integer> encoderKey = JKeyTypes.IntKey().make(\"encoder\");\nKey<Integer> filterKey = JKeyTypes.IntKey().make(\"filter\");\nKey<Integer> miscKey = JKeyTypes.IntKey().make(\"misc.\");\n\n//ObsId\nObsId obsId = new ObsId(\"Obs001\");\n\n//prefix\nString prefix = \"wfos.blue.filter\";\n\n//params\nParameter<Integer> encParam1 = encoderKey.set(1);\nParameter<Integer> encParam2 = encoderKey.set(2);\nParameter<Integer> encParam3 = encoderKey.set(3);\n\nParameter<Integer> filterParam1 = filterKey.set(1);\nParameter<Integer> filterParam2 = filterKey.set(2);\nParameter<Integer> filterParam3 = filterKey.set(3);\n\nParameter<Integer> miscParam1 = miscKey.set(100);\n\n//Setup command with duplicate key via madd\nResult result = new Result(prefix).madd(encParam1, encParam2, encParam3, filterParam1, filterParam2, filterParam3);\n//four duplicate keys are removed; now contains one Encoder and one Filter key\nList<String> uniqueKeys1 = result.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//try adding duplicate keys via add + madd\nResult changedResult = result.add(encParam3).madd(filterParam1, filterParam2, filterParam3);\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nList<String> uniqueKeys2 = changedResult.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nResult finalResult = result.madd(miscParam1, encParam1);\n//now contains encoderKey, filterKey, miscKey\nList<String> uniqueKeys3 = finalResult.jParamSet().stream().map(Parameter::keyName).collect(Collectors.toList());","title":"Unique Key Constraint"},{"location":"/messages/result.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source Code for Examples"},{"location":"/commons/framework.html","text":"","title":"Framework for creating components (HCD, Assembly, Container)"},{"location":"/commons/framework.html#framework-for-creating-components-hcd-assembly-container-","text":"csw-framework library provides support for creating a component as defined by the TMT.","title":"Framework for creating components (HCD, Assembly, Container)"},{"location":"/commons/framework.html#dependencies","text":"sbt libraryDependencies += \"org.tmt\" %% \"csw-framework\" % \"0.1.2\"\nSource code for examples ComponentInfo Creating an Assembly or Hcd Component Lifecycle support initialize onShutdown isOnline onGoOffline onGoOnline Handling commands Managing Command State addOrUpdateCommand addSubCommand updateSubCommand query subscribe Tracking Connections onLocationTrackingEvent Publishing State Handling Exceptions Deploying Components ContainerCmd Container for deployment Standalone components","title":"Dependencies"},{"location":"/commons/framework.html#source-code-for-examples","text":"Assembly Scala Example HCD Scala Example Assembly Java Example HCD Java Example","title":"Source code for examples"},{"location":"/framework/describing-components.html","text":"","title":"ComponentInfo"},{"location":"/framework/describing-components.html#componentinfo","text":"ComponentInfo model describes a component by specifying following details It is usually described as a configuration file but can also be created programmatically.\nAssemblyInfo name = \"Sample_Assembly\"\ncomponentType = assembly\nbehaviorFactoryClassName = package.component.SampleAssembly\nprefix = abc.sample.prefix\nlocationServiceUsage = RegisterAndTrackServices\nconnections = [\n    {\n      name: \"Sample_Assembly\"\n      componentType: assembly\n      connectionType: akka\n    }\n  ]\n HcdInfo name = \"Sample_Hcd\"\ncomponentType = hcd\nbehaviorFactoryClassName = package.component.SampleHcd\nprefix = abc.sample.prefix\nlocationServiceUsage = RegisterOnly\nFollowing is the summary of properties in the ComponentInfo config/model:\nname : The name of the component componentType : The type of the component which could be Container, Assembly, Hcd or Service behaviorFactoryClassName : The fully qualified name of the class which extends the factory class ComponentBehaviorFactory prefix : A valid subsystem to which this component belongs. connections : A collection of connections of the components or services which will be used by this component. This information can be used in accordance with the locationServiceUsage property to track these components or services by the framework. locationServiceUsage : Indicates how the location service should be leveraged for this component by the framework. Following values are supported: DoNotRegister : Do not register this component with location service RegisterOnly : Register this component with location service RegisterAndTrackServices : Register this component with location service as well as track the components/services mentioned against connections property","title":"ComponentInfo"},{"location":"/framework/creating-components.html","text":"","title":"Creating an Assembly or Hcd Component"},{"location":"/framework/creating-components.html#creating-an-assembly-or-hcd-component","text":"An Assembly or HCD is implemented by extending the ComponentHandlers base class. These handlers are executed by an Akka Actor (Top Level Actor or TLA) defined in the framework which handles the lifecycle and supervision of this component.\nAssembly/Scala class AssemblyComponentHandlers(\n    ctx: ActorContext[TopLevelActorMessage],\n    componentInfo: ComponentInfo,\n    commandResponseManager: CommandResponseManager,\n    currentStatePublisher: CurrentStatePublisher,\n    locationService: LocationService,\n    loggerFactory: LoggerFactory\n) extends ComponentHandlers(\n      ctx,\n      componentInfo,\n      commandResponseManager,\n      currentStatePublisher,\n      locationService,\n      loggerFactory: LoggerFactory\n    ) Assembly/Java public class JAssemblyComponentHandlers extends JComponentHandlers {\n\n    private final ActorContext<TopLevelActorMessage> ctx;\n    private final ComponentInfo componentInfo;\n    private final CommandResponseManager commandResponseManager;\n    private final CurrentStatePublisher currentStatePublisher;\n    private final ILocationService locationService;\n    private ILogger log;\n    private IConfigClientService configClient;\n    private Map<Connection, Optional<JCommandService>> runningHcds;\n    private ActorRef<DiagnosticPublisherMessages> diagnosticPublisher;\n    private ActorRef<CommandResponse> commandResponseAdapter;\n\n    public JAssemblyComponentHandlers(\n            akka.actor.typed.javadsl.ActorContext<TopLevelActorMessage> ctx,\n            ComponentInfo componentInfo,\n            CommandResponseManager commandResponseManager,\n            CurrentStatePublisher currentStatePublisher,\n            ILocationService locationService,\n            JLoggerFactory loggerFactory\n\n    ) {\n        super(ctx, componentInfo, commandResponseManager, currentStatePublisher, locationService, loggerFactory);\n        this.ctx = ctx;\n        this.componentInfo = componentInfo;\n        this.commandResponseManager = commandResponseManager;\n        this.currentStatePublisher = currentStatePublisher;\n        this.locationService = locationService;\n        log = loggerFactory.getLogger(this.getClass());\n        configClient = JConfigClientFactory.clientApi(Adapter.toUntyped(ctx.getSystem()), locationService);\n\n        runningHcds = new HashMap<>();\n        commandResponseAdapter = TestProbe.<CommandResponse>create(ctx.getSystem()).ref();\n    } Hcd/Scala class HcdComponentHandlers(\n    ctx: ActorContext[TopLevelActorMessage],\n    componentInfo: ComponentInfo,\n    commandResponseManager: CommandResponseManager,\n    currentStatePublisher: CurrentStatePublisher,\n    locationService: LocationService,\n    loggerFactory: LoggerFactory\n) extends ComponentHandlers(\n      ctx,\n      componentInfo,\n      commandResponseManager,\n      currentStatePublisher,\n      locationService,\n      loggerFactory: LoggerFactory\n    ) Hcd/Java public class JHcdComponentHandlers extends JComponentHandlers {\n\n    private final ActorContext<TopLevelActorMessage> ctx;\n    private final ComponentInfo componentInfo;\n    private final CommandResponseManager commandResponseManager;\n    private final CurrentStatePublisher currentStatePublisher;\n    private final ILocationService locationService;\n    private ILogger log;\n    private IConfigClientService configClient;\n    private ConfigData hcdConfig;\n    private ActorRef<WorkerActorMsg> worker;\n    private int current;\n    private int stats;\n\n    public JHcdComponentHandlers(\n            akka.actor.typed.javadsl.ActorContext<TopLevelActorMessage> ctx,\n            ComponentInfo componentInfo,\n            CommandResponseManager commandResponseManager,\n            CurrentStatePublisher currentStatePublisher,\n            ILocationService locationService,\n            JLoggerFactory loggerFactory\n\n    ) {\n        super(ctx, componentInfo, commandResponseManager, currentStatePublisher, locationService, loggerFactory);\n        this.ctx = ctx;\n        this.componentInfo = componentInfo;\n        this.commandResponseManager = commandResponseManager;\n        this.currentStatePublisher = currentStatePublisher;\n        this.locationService = locationService;\n        log = loggerFactory.getLogger(this.getClass());\n    }\nNote Converting a typed actor system to an untyped actor system The ctx available to the component is of type akka.actor.typed.scaladsl.ActorContext in Scala or akka.actor.typed.javadsl.ActorContext in Java. This context can be used to get resources such as actor system which is also typed. In order to get the untyped version of an actor system or actor references, Akka has provided some implicit extension methods in Scala and static methods in Java which can be used by adding the following import: import akka.actor.typed.scaladsl.adapter._ for Scala and, import akka.actor.typed.javadsl.Adapter.* for Java\nA component can be created by a factory which extends ComponentBehaviorFactory base class and provides a definition of handlers method to return the appropriate implementation of ComponentHandlers.\nAssembly/Scala class AssemblyComponentBehaviorFactory extends ComponentBehaviorFactory {\n  protected override def handlers(\n      ctx: ActorContext[TopLevelActorMessage],\n      componentInfo: ComponentInfo,\n      commandResponseManager: CommandResponseManager,\n      currentStatePublisher: CurrentStatePublisher,\n      locationService: LocationService,\n      loggerFactory: LoggerFactory\n  ): ComponentHandlers =\n    new AssemblyComponentHandlers(\n      ctx,\n      componentInfo,\n      commandResponseManager,\n      currentStatePublisher,\n      locationService,\n      loggerFactory\n    )\n} Assembly/Java public class JAssemblyComponentBehaviorFactory extends JComponentBehaviorFactory {\n\n    @Override\n    public JComponentHandlers jHandlers(\n            ActorContext<TopLevelActorMessage> ctx,\n            ComponentInfo componentInfo,\n            CommandResponseManager commandResponseManager,\n            CurrentStatePublisher currentStatePublisher,\n            ILocationService locationService,\n            JLoggerFactory loggerFactory\n    ) {\n        return new JAssemblyComponentHandlers(ctx, componentInfo, commandResponseManager, currentStatePublisher, locationService, loggerFactory);\n    }\n} Hcd/Scala class HcdComponentBehaviorFactory extends ComponentBehaviorFactory {\n  protected override def handlers(\n      ctx: ActorContext[TopLevelActorMessage],\n      componentInfo: ComponentInfo,\n      commandResponseManager: CommandResponseManager,\n      currentStatePublisher: CurrentStatePublisher,\n      locationService: LocationService,\n      loggerFactory: LoggerFactory\n  ): ComponentHandlers =\n    new HcdComponentHandlers(ctx, componentInfo, commandResponseManager, currentStatePublisher, locationService, loggerFactory)\n} Hcd/Java public class JHcdComponentBehaviorFactory extends JComponentBehaviorFactory {\n\n    @Override\n    public JComponentHandlers jHandlers(\n            ActorContext<TopLevelActorMessage> ctx,\n            ComponentInfo componentInfo,\n            CommandResponseManager commandResponseManager,\n            CurrentStatePublisher currentStatePublisher,\n            ILocationService locationService,\n            JLoggerFactory loggerFactory\n    ) {\n        return new JHcdComponentHandlers(ctx, componentInfo, commandResponseManager, currentStatePublisher, locationService, loggerFactory);\n    }\n}","title":"Creating an Assembly or Hcd Component"},{"location":"/framework/handling-lifecycle.html","text":"","title":"Lifecycle support"},{"location":"/framework/handling-lifecycle.html#lifecycle-support","text":"","title":"Lifecycle support"},{"location":"/framework/handling-lifecycle.html#initialize","text":"The initialize handler is invoked when the component is created. This is different than constructor initialization to allow non-blocking asynchronous operations. The component can initialize state such as configuration to be fetched from Configuration Service, location of components or services to be fetched from Location Service etc. These vary from component to component.\nAssembly/Scala override def initialize(): Future[Unit] = async {\n\n  // Initialization could include following steps :\n\n  // 1. fetch config (preferably from configuration service)\n  val calculationConfig = await(getAssemblyConfig)\n\n  // 2. create a worker actor which is used by this assembly\n  val worker: ActorRef[WorkerActorMsg] = ctx.spawnAnonymous(WorkerActor.make(calculationConfig))\n\n  // 3. find a Hcd connection from the connections provided in componentInfo\n  val maybeConnection =\n    componentInfo.connections.find(connection ⇒ connection.componentId.componentType == ComponentType.HCD)\n\n  // 4. If an Hcd is found as a connection, resolve its location from location service and create other\n  // required worker actors required by this assembly\n\n  maybeConnection match {\n    case Some(_) ⇒\n      resolveHcd().map {\n        case Some(hcd) ⇒\n          runningHcds = runningHcds.updated(maybeConnection.get, Some(new CommandService(hcd)(ctx.system)))\n          diagnosticsPublisher = ctx.spawnAnonymous(DiagnosticsPublisher.make(runningHcds(maybeConnection.get).get, worker))\n          commandHandler = ctx.spawnAnonymous(CommandHandler.make(calculationConfig, runningHcds(maybeConnection.get)))\n        case None ⇒ // do something\n      }\n    case None ⇒ Future.successful(Unit)\n  }\n\n} Assembly/Java @Override\npublic CompletableFuture<Void> jInitialize() {\n\n    // fetch config (preferably from configuration service)\n    CompletableFuture<ConfigData> configDataCompletableFuture = getAssemblyConfig();\n\n    // create a worker actor which is used by this assembly\n    CompletableFuture<ActorRef<WorkerActorMsg>> worker =\n            configDataCompletableFuture.thenApply(config -> ctx.spawnAnonymous(WorkerActor.make(config)));\n\n    // find a Hcd connection from the connections provided in componentInfo\n    Optional<Connection> mayBeConnection = componentInfo.getConnections().stream()\n            .filter(connection -> connection.componentId().componentType() == JComponentType.HCD)\n            .findFirst();\n\n    // If an Hcd is found as a connection, resolve its location from location service and create other\n    // required worker actors required by this assembly\n    return mayBeConnection.map(connection ->\n            worker.thenAcceptBoth(resolveHcd(), (workerActor, hcdLocation) -> {\n                if (!hcdLocation.isPresent())\n                    throw new HcdNotFoundException();\n                else\n                    runningHcds.put(connection, Optional.of(new JCommandService(hcdLocation.get(), ctx.getSystem())));\n                diagnosticPublisher = ctx.spawnAnonymous(JDiagnosticsPublisherFactory.make(new JCommandService(hcdLocation.get(), ctx.getSystem()), workerActor));\n            })).get();\n\n} Hcd/Scala override def initialize(): Future[Unit] = async {\n\n  // fetch config (preferably from configuration service)\n  val hcdConfig = await(getHcdConfig)\n\n  // create a worker actor which is used by this hcd\n  val worker: ActorRef[WorkerActorMsg] = ctx.spawnAnonymous(WorkerActor.make(hcdConfig))\n\n  // initialise some state by using the worker actor created above\n  current = await(worker ? InitialState)\n  stats = await(worker ? GetStatistics)\n\n} Hcd/Java @Override\npublic CompletableFuture<Void> jInitialize() {\n\n    // fetch config (preferably from configuration service)\n    getConfig().thenAccept(config -> hcdConfig = config);\n\n    // create a worker actor which is used by this hcd\n    worker = ctx.spawnAnonymous(WorkerActor.make(hcdConfig));\n\n    // initialise some state by using the worker actor created above\n    CompletionStage<Integer> askCurrent = AskPattern.ask(worker, WorkerActorMsgs.JInitialState::new, new Timeout(5, TimeUnit.SECONDS), ctx.getSystem().scheduler());\n    CompletableFuture<Void> currentFuture = askCurrent.thenAccept(c -> current = c).toCompletableFuture();\n\n    CompletionStage<Integer> askStats = AskPattern.ask(worker, WorkerActorMsgs.JInitialState::new, new Timeout(5, TimeUnit.SECONDS), ctx.getSystem().scheduler());\n    CompletableFuture<Void> statsFuture = askStats.thenAccept(s -> stats = s).toCompletableFuture();\n\n    return CompletableFuture.allOf(currentFuture, statsFuture);\n}","title":"initialize"},{"location":"/framework/handling-lifecycle.html#onshutdown","text":"The onShutdown handler can be used for carrying out the tasks which will allow the component to shutdown gracefully.\nAssembly/Scala override def onShutdown(): Future[Unit] = async {\n  // clean up resources\n} Assembly/Java @Override\npublic CompletableFuture<Void> jOnShutdown() {\n    // clean up resources\n    return new CompletableFuture<>();\n} Hcd/Scala override def onShutdown(): Future[Unit] = async {\n  // clean up resources\n} Hcd/Java @Override\npublic CompletableFuture<Void> jOnShutdown() {\n    return CompletableFuture.runAsync(() -> {\n        // clean up resources\n    });\n}","title":"onShutdown"},{"location":"/framework/handling-lifecycle.html#isonline","text":"A component has access to isOnline boolean flag which can be used to determine if the component is online or offline state.","title":"isOnline"},{"location":"/framework/handling-lifecycle.html#ongooffline","text":"A component can be notified to run in offline mode in case it is not in use. The component can change its behavior if needed as a part of this handler.\nAssembly/Scala override def onGoOffline(): Unit = {\n  // do something when going offline\n} Assembly/Java @Override\npublic void onGoOffline() {\n    // do something when going offline\n} Hcd/Scala override def onGoOffline(): Unit = {\n  // do something when going offline\n} Hcd/Java @Override\npublic void onGoOffline() {\n    // do something when going offline\n}","title":"onGoOffline"},{"location":"/framework/handling-lifecycle.html#ongoonline","text":"A component can be notified to run in online mode again in case it was put to run in offline mode. The component can change its behavior if needed as a part of this handler.\nAssembly/Scala override def onGoOnline(): Unit = {\n  // do something when going online\n} Assembly/Java @Override\npublic void onGoOnline() {\n    // do something when going online\n} Hcd/Scala override def onGoOnline(): Unit = {\n  // do something when going online\n} Hcd/Java @Override\npublic void onGoOnline() {\n    // do something when going online\n}","title":"onGoOnline"},{"location":"/framework/handling-lifecycle.html#handling-commands","text":"","title":"Handling commands"},{"location":"/framework/handling-lifecycle.html#validatecommand","text":"A command can be sent as a Submit or Oneway message to the component actor. If a command can be completed immediately, a CommandResponse indicating the final response for the command can be returned. If a command requires time for processing, the component is required to validate the ControlCommand received and return a validation result as Accepted or Invalid. The final response for a command sent as Submit can be obtained by the sender command by querying or subscribing for this response to the component as described here.\nAssembly/Scala override def validateCommand(controlCommand: ControlCommand): CommandResponse = controlCommand match {\n  case _: Setup   ⇒ Accepted(controlCommand.runId) // validation for setup goes here\n  case _: Observe ⇒ Accepted(controlCommand.runId) // validation for observe goes here\n} Assembly/Java @Override\npublic CommandResponse validateCommand(ControlCommand controlCommand) {\n    if (controlCommand instanceof Setup) {\n        // validation for setup goes here\n        // after validation of the controlCommand, update its status of successful validation as Accepted\n        CommandResponse.Accepted accepted = new CommandResponse.Accepted(controlCommand.runId());\n        commandResponseManager.addOrUpdateCommand(controlCommand.runId(), accepted);\n        return new CommandResponse.Accepted(controlCommand.runId());\n    } else if (controlCommand instanceof Observe) {\n        // validation for observe goes here\n        return new CommandResponse.Accepted(controlCommand.runId());\n    } else {\n        return new CommandResponse.Invalid(controlCommand.runId(), new CommandIssue.AssemblyBusyIssue(\"Command not supported\"));\n    }\n} Hcd/Scala override def validateCommand(controlCommand: ControlCommand): CommandResponse = controlCommand match {\n  case _: Setup   ⇒ Accepted(controlCommand.runId) // validation for setup goes here\n  case _: Observe ⇒ Accepted(controlCommand.runId) // validation for observe goes here\n} Hcd/Java @Override\npublic CommandResponse validateCommand(ControlCommand controlCommand) {\n    if (controlCommand instanceof Setup) {\n        // validation for setup goes here\n        return new CommandResponse.Accepted(controlCommand.runId());\n    } else if (controlCommand instanceof Observe) {\n        // validation for observe goes here\n        return new CommandResponse.Accepted(controlCommand.runId());\n    } else {\n        return new CommandResponse.CommandNotAvailable(controlCommand.runId());\n    }\n}\nIf a response can be provided immediately, a final CommandResponse such as CommandCompleted or Error can be sent from this handler.","title":"validateCommand"},{"location":"/framework/handling-lifecycle.html#onsubmit","text":"On receiving a command as Submit, the onSubmit handler is invoked for a component only if the validateCommand handler returns Accepted. In case a command is received as a submit, command response should be updated in the CommandResponseManager. CommandResponseManager is an actor whose reference commandResponseManager is available in the ComponentHandlers.\nAssembly/Scala override def onSubmit(controlCommand: ControlCommand): Unit = controlCommand match {\n  case setup: Setup     ⇒ submitSetup(setup) // includes logic to handle Submit with Setup config command\n  case observe: Observe ⇒ submitObserve(observe) // includes logic to handle Submit with Observe config command\n} Assembly/Java @Override\npublic void onSubmit(ControlCommand controlCommand) {\n    if (controlCommand instanceof Setup)\n        submitSetup((Setup) controlCommand); // includes logic to handle Submit with Setup config command\n    else if (controlCommand instanceof Observe)\n        submitObserve((Observe) controlCommand); // includes logic to handle Submit with Observe config command\n} Hcd/Scala override def onSubmit(controlCommand: ControlCommand): Unit = controlCommand match {\n  case setup: Setup     ⇒ submitSetup(setup) // includes logic to handle Submit with Setup config command\n  case observe: Observe ⇒ submitObserve(observe) // includes logic to handle Submit with Observe config command\n} Hcd/Java @Override\npublic void onSubmit(ControlCommand controlCommand) {\n    if (controlCommand instanceof Setup)\n        submitSetup((Setup) controlCommand); // includes logic to handle Submit with Setup config command\n    else if (controlCommand instanceof Observe)\n        submitObserve((Observe) controlCommand); // includes logic to handle Submit with Observe config command\n}","title":"onSubmit"},{"location":"/framework/handling-lifecycle.html#ononeway","text":"On receiving a command as Oneway, the onOneway handler is invoked for a component only if the validateCommand handler returns Accepted.In case a command is received as a oneway, command response should not be provided to the sender.\nAssembly/Scala override def onOneway(controlCommand: ControlCommand): Unit = controlCommand match {\n  case setup: Setup     ⇒ onewaySetup(setup) // includes logic to handle Oneway with Setup config command\n  case observe: Observe ⇒ onewayObserve(observe) // includes logic to handle Oneway with Observe config command\n} Assembly/Java @Override\npublic void onOneway(ControlCommand controlCommand) {\n    if (controlCommand instanceof Setup)\n        onewaySetup((Setup) controlCommand); // includes logic to handle Oneway with Setup config command\n    else if (controlCommand instanceof Observe)\n        onewayObserve((Observe) controlCommand); // includes logic to handle Oneway with Observe config command\n} Hcd/Scala override def onOneway(controlCommand: ControlCommand): Unit = controlCommand match {\n  case setup: Setup     ⇒ onewaySetup(setup) // includes logic to handle Oneway with Setup config command\n  case observe: Observe ⇒ onewayObserve(observe) // includes logic to handle Oneway with Setup config command\n} Hcd/Java @Override\npublic void onOneway(ControlCommand controlCommand) {\n    if (controlCommand instanceof Setup)\n        onewaySetup((Setup) controlCommand); // includes logic to handle Oneway with Setup config command\n    else if (controlCommand instanceof Observe)\n        onewayObserve((Observe) controlCommand); // includes logic to handle Oneway with Observe config command\n}","title":"onOneway"},{"location":"/framework/managing-command-state.html","text":"","title":"Managing Command State"},{"location":"/framework/managing-command-state.html#managing-command-state","text":"A component has access to commandResponseManager which is used to manage the state of commands during its execution. On receiving a command as a part of onSubmit, the component framework adds the command to an internal CommandResponseManager. The component should then update the status of the command using the following API provided in commandResponseManager:","title":"Managing Command State"},{"location":"/framework/managing-command-state.html#addorupdatecommand","text":"Add a new command or update the status of an existing command.\nScala // after validation of the controlCommand, update its status of successful validation as Accepted\ncommandResponseManager.addOrUpdateCommand(controlCommand.runId, Accepted(controlCommand.runId)) Java // after validation of the controlCommand, update its status of successful validation as Accepted\nCommandResponse.Accepted accepted = new CommandResponse.Accepted(controlCommand.runId());\ncommandResponseManager.addOrUpdateCommand(controlCommand.runId(), accepted);","title":"addOrUpdateCommand"},{"location":"/framework/managing-command-state.html#addsubcommand","text":"A received command can be often split into two or more sub-commands. The status of original command can then be derived from the status of the sub-commands. In order to achieve this, a component has to first add the sub-commands against in relation to the parent command using this method.\nScala shortSetup = Setup(prefix, shortRunning, controlCommand.maybeObsId)\ncommandResponseManager.addSubCommand(commandId, shortSetup.runId) Java Prefix prefix = new Prefix(\"wfos.red.detector\");\nSetup subCommand = new Setup(prefix, new CommandName(\"sub-command-1\"), sc.jMaybeObsId());\ncommandResponseManager.addSubCommand(sc.runId(), subCommand.runId());\n\nSetup subCommand2 = new Setup(prefix, new CommandName(\"sub-command-2\"), sc.jMaybeObsId());\ncommandResponseManager.addSubCommand(sc.runId(), subCommand2.runId());","title":"addSubCommand"},{"location":"/framework/managing-command-state.html#updatesubcommand","text":"Update the CommandResponse of the sub-command which would trigger the automatic derivation of the status of the original/parent command when status of all the sub-commands have been updated. A CommandResponse indicating failure such as Invalid or Error in any one of the sub-commands would result in the error status of the parent command. Status of any other sub-commands wil not be considered in this case.\nScala // An original command is split into sub-commands and sent to a component. The result of the command is\n// obtained by subscribing to the component with the sub command id.\nhcdComponent.subscribe(controlCommand.runId).map {\n  case _: Completed ⇒\n    controlCommand.runId match {\n      case id if id == shortSetup.runId ⇒\n        currentStatePublisher.publish(CurrentState(shortSetup.source, Set(choiceKey.set(shortCmdCompleted))))\n        // As the commands get completed, the results are updated in the commandResponseManager\n        commandResponseManager.updateSubCommand(id, Completed(id))\n      case id if id == mediumSetup.runId ⇒\n        currentStatePublisher.publish(CurrentState(mediumSetup.source, Set(choiceKey.set(mediumCmdCompleted))))\n        commandResponseManager.updateSubCommand(id, Completed(id))\n      case id if id == longSetup.runId ⇒\n        currentStatePublisher.publish(CurrentState(longSetup.source, Set(choiceKey.set(longCmdCompleted))))\n        commandResponseManager.updateSubCommand(id, Completed(id))\n    } Java // An original command is split into sub-commands and sent to a component. The result of the command is\n// obtained by subscribing to the component with the sub command id.\nJCommandService componentCommandService = runningHcds.get(componentInfo.getConnections().get(0)).get();\ncomponentCommandService.subscribe(subCommand2.runId(), Timeout.durationToTimeout(FiniteDuration.apply(5, TimeUnit.SECONDS)))\n        .thenAccept(commandResponse -> {\n            if (commandResponse.resultType() instanceof CommandResponse.Completed) {\n                // As the commands get completed, the results are updated in the commandResponseManager\n                commandResponseManager.updateSubCommand(subCommand2.runId(), commandResponse);\n            } else {\n                // do something\n            }\n        });\nNote It may be the case that the component wants to avoid automatic inference of a command based on the result of the sub-commands. It should refrain from updating the status of the sub-commands in this case and update the status of the parent command directly as required.","title":"updateSubCommand"},{"location":"/framework/managing-command-state.html#query","text":"Query for the result of a command that is already present in the component’s CommandResponseManager.\nScala // query CommandResponseManager to get the current status of Command, for example: Accepted/Completed/Invalid etc.\ncommandResponseManager\n  .query(controlCommand.runId)\n  .map(\n    _ ⇒ () // may choose to publish current state to subscribers or do other operations\n  ) Java // query CommandResponseManager to get the current status of Command, for example: Accepted/Completed/Invalid etc.\ncommandResponseManager\n        .jQuery(subCommand.runId(), Timeout.durationToTimeout(FiniteDuration.apply(5, \"seconds\")))\n        .thenAccept(commandResponse -> {\n            // may choose to publish current state to subscribers or do other operations\n        });","title":"query"},{"location":"/framework/managing-command-state.html#subscribe","text":"Subscribe for the result of a command that is already present in the component’s CommandResponseManager and perform action on the change in status.\nScala // subscribe to the status of original command received and publish the state when its status changes to\n// Completed\ncommandResponseManager.subscribe(\n  controlCommand.runId, {\n    case Completed(_) ⇒\n      currentStatePublisher.publish(CurrentState(controlCommand.source, Set(choiceKey.set(longRunningCmdCompleted))))\n    case _ ⇒\n  }\n) Java // subscribe to the status of original command received and publish the state when its status changes to\n// Completed\ncommandResponseManager.jSubscribe(subCommand.runId(), commandResponse -> {\n    if (commandResponse.resultType() instanceof CommandResponse.Completed) {\n        Key<String> stringKey = JKeyTypes.StringKey().make(\"sub-command-status\");\n        CurrentState currentState = new CurrentState(sc.source().prefix());\n        currentStatePublisher.publish(currentState.madd(stringKey.set(\"complete\")));\n    } else {\n        // do something\n    }\n});","title":"subscribe"},{"location":"/framework/tracking-connections.html","text":"","title":"Tracking Connections"},{"location":"/framework/tracking-connections.html#tracking-connections","text":"The component framework tracks the set of connections specified for a component in ComponentInfo if the locationServiceUsage property is set to RegisterAndTrackServices. The framework also provides a helper trackConnection method to track any connection other than those present in ComponentInfo.","title":"Tracking Connections"},{"location":"/framework/tracking-connections.html#onlocationtrackingevent","text":"The onLocationTrackingEvent handler can be used to take action on the TrackingEvent for a particular connection. This event could be for the connections in ComponentInfo tracked automatically or for the connections tracked explicitly using trackConnection method.\nAssembly/Scala override def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = trackingEvent match {\n  case LocationUpdated(location)   ⇒ // do something for the tracked location when it is updated\n  case LocationRemoved(connection) ⇒ // do something for the tracked location when it is no longer available\n} Assembly/Java @Override\npublic void onLocationTrackingEvent(TrackingEvent trackingEvent) {\n    if (trackingEvent instanceof LocationUpdated) {\n        // do something for the tracked location when it is updated\n    } else if (trackingEvent instanceof LocationRemoved) {\n        // do something for the tracked location when it is no longer available\n    }\n} Hcd/Scala override def onLocationTrackingEvent(trackingEvent: TrackingEvent): Unit = trackingEvent match {\n  case LocationUpdated(location)   ⇒ // do something for the tracked location when it is updated\n  case LocationRemoved(connection) ⇒ // do something for the tracked location when it is no longer available\n} Hcd/Java @Override\npublic void onLocationTrackingEvent(TrackingEvent trackingEvent) {\n    if (trackingEvent instanceof LocationUpdated) {\n        // do something for the tracked location when it is updated\n    } else if (trackingEvent instanceof LocationRemoved) {\n        // do something for the tracked location when it is no longer available\n    }\n}","title":"onLocationTrackingEvent"},{"location":"/framework/publishing-state.html","text":"","title":"Publishing State"},{"location":"/framework/publishing-state.html#publishing-state","text":"A component has access to a currentStatePublisher Actor, which can be used to publish its CurrentState. Any subscriber of this component will receive the published state.\nNote This feature is provided for optimized communicaton between an Assembly and an HCD only. See Matching state for command completion.\nScala // Publish the CurrentState using parameter set created using a sample Choice parameter\ncurrentStatePublisher.publish(CurrentState(prefix, Set(choiceKey.set(initChoice)))) Java CurrentState initState = currentState.add(SampleComponentState.choiceKey().set(SampleComponentState.initChoice()));\ncurrentStatePublisher.publish(initState);","title":"Publishing State"},{"location":"/framework/handling-exceptions.html","text":"","title":"Handling Exceptions"},{"location":"/framework/handling-exceptions.html#handling-exceptions","text":"A component should create exceptions belonging to following two types:\nFailureRestart : As a part of any handler, if an exception can be handled by restarting the component, an exception of type FailureRestart should be thrown to let the framework restart the component. The component’s state will be cleared/reinitialized. The onInitialize handler will be invoked again. Scala case class HcdNotFoundException() extends FailureRestart(\"Could not resolve hcd location. Initialization failure.\")\n\nprivate def resolveHcd(): Future[Option[AkkaLocation]] = {\n  val maybeConnection = componentInfo.connections.find(connection ⇒ connection.componentId.componentType == ComponentType.HCD)\n  maybeConnection match {\n    case Some(hcd) ⇒\n      locationService.resolve(hcd.of[AkkaLocation], 5.seconds).map {\n        case loc @ Some(akkaLocation) ⇒ loc\n        case None                     ⇒\n          // Hcd connection could not be resolved for this Assembly. One option to handle this could be to automatic restart which can give enough time\n          // for the Hcd to be available\n          throw HcdNotFoundException()\n      }\n    case _ ⇒ Future.successful(None)\n  }\n} Java class HcdNotFoundException extends FailureRestart {\n    HcdNotFoundException() {\n        super(\"Could not resolve hcd location. Initialization failure.\");\n    }\n}\n\nprivate CompletableFuture<Optional<AkkaLocation>> resolveHcd() {\n    // find a Hcd connection from the connections provided in componentInfo\n    Optional<Connection> mayBeConnection = componentInfo.getConnections().stream()\n            .filter(connection -> connection.componentId().componentType() == JComponentType.HCD)\n            .findFirst();\n\n    // If an Hcd is found as a connection, resolve its location from location service and create other\n    // required worker actors required by this assembly\n    if (mayBeConnection.isPresent()) {\n        CompletableFuture<Optional<AkkaLocation>> resolve = locationService.resolve(mayBeConnection.get().<AkkaLocation>of(), FiniteDuration.apply(5, TimeUnit.SECONDS));\n        return resolve.thenCompose((Optional<AkkaLocation> resolvedHcd) -> {\n            if (resolvedHcd.isPresent())\n                return CompletableFuture.completedFuture(resolvedHcd);\n            else\n                throw new ConfigNotAvailableException();\n        });\n    } else\n        return CompletableFuture.completedFuture(Optional.empty());\n} FailureStop : As a part of any handler, an exception can be thrown of type FailureStop which will result in terminating the component. The onShutdown handler will be invoked to facilitate graceful shutdown. Scala case class ConfigNotAvailableException() extends FailureStop(\"Configuration not available. Initialization failure.\")\n\nprivate def getAssemblyConfig: Future[ConfigData] = {\n\n  configClient.getActive(Paths.get(\"tromboneAssemblyContext.conf\")).flatMap {\n    case Some(config) ⇒ Future.successful(config) // do work\n    case None         ⇒\n      // required configuration could not be found in the configuration service. Component can choose to stop until the configuration is made available in the\n      // configuration service and started again\n      throw ConfigNotAvailableException()\n  }\n} Java class ConfigNotAvailableException extends FailureStop {\n    ConfigNotAvailableException() {\n        super(\"Configuration not available. Initialization failure.\");\n    }\n}\n\nprivate CompletableFuture<ConfigData> getAssemblyConfig() throws ConfigNotAvailableException {\n    // required configuration could not be found in the configuration service. Component can choose to stop until the configuration is made available in the\n    // configuration service and started again\n    return configClient.getActive(Paths.get(\"tromboneAssemblyContext.conf\"))\n            .thenApply((Optional<ConfigData> maybeConfigData) -> {\n                return maybeConfigData.<ConfigNotAvailableException>orElseThrow(() -> new ConfigNotAvailableException());\n            });\n}","title":"Handling Exceptions"},{"location":"/framework/deploying-components.html","text":"","title":"Deploying Components"},{"location":"/framework/deploying-components.html#deploying-components","text":"","title":"Deploying Components"},{"location":"/framework/deploying-components.html#containercmd","text":"ContainerCmd is a helper utility provided as a part of framework. This helps component writers to start their components inside container.\nA main application needs to be created which uses framework provided utility csw.framework.deploy.containercmd.ContainerCmd to start a container or standalone component. The utility supports following parameters which can be provided as arguments to the application :\nfully qualified path of the configuration file local if the above path is a path to a file available on local disk. If this argument is not provided the file will be looked up in the configuration service using the same path. standalone if the configuration file describes a component to be run in standalone mode. If this argument is not provided the application expects a configuration file describing a container component and will use it to start a container with all the components as described in the file.\nScala object ContainerCmdApp extends App {\n\n  ContainerCmd.start(\"Container-Cmd-App\", args)\n\n} Java public class JContainerCmdApp {\n\n    public static void main(String args[]) {\n        JContainerCmd.start(\"JContainer-Cmd-App\", args, Optional.empty());\n    }\n\n}\nNote It is not necessary to have name of the application as ContainerCmdApp/JContainerCmdApp, user can choose any name.\nStarting a standalone component from a local configuration file\n`./container-cmd-app --standalone --local /assembly/config/assembly.conf`\nStarting a container component from a configuration file available in configuration service\n`./container-cmd-app /assembly/config/assembly.conf`","title":"ContainerCmd"},{"location":"/framework/deploying-components.html#container-for-deployment","text":"A container is a component which starts one or more Components and keeps track of the components within a single JVM process. When started, the container also registers itself with the Location Service. The components to be hosted by the container is defined using a ContainerInfo model which has a set of ComponentInfo objects. It is usually described as a configuration file but can also be created programmatically.\nSampleContainerInfo name = \"Sample_Container\"\ncomponents: [\n  {\n    name = \"SampleAssembly\"\n    componentType = assembly\n    behaviorFactoryClassName = package.component.SampleAssembly\n    prefix = abc.sample.prefix\n    locationServiceUsage = RegisterAndTrackServices\n    connections = [\n      {\n        name: Sample_Hcd_1\n        componentType: hcd\n        connectionType: akka\n      },\n      {\n        name: Sample_Hcd_2\n        componentType: hcd\n        connectionType: akka\n      },\n      {\n        name: Sample_Hcd_3\n        componentType: hcd\n        connectionType: akka\n      }\n    ]\n  },\n  {\n    name = \"Sample_Hcd_1\"\n    componentType = hcd\n    behaviorFactoryClassName = package.component.SampleHcd\n    prefix = abc.sample.prefix\n    locationServiceUsage = RegisterOnly\n  },\n  {\n    name = \"Sample_Hcd_2\"\n    componentType: hcd\n    behaviorFactoryClassName: package.component.SampleHcd\n    prefix: abc.sample.prefix\n    locationServiceUsage = RegisterOnly\n  }\n]","title":"Container for deployment"},{"location":"/framework/deploying-components.html#standalone-components","text":"A component can be run alone in a Standalone mode without sharing its jvm space with any other component.\nSample Info for an assembly name = \"Monitor_Assembly\"\ncomponentType = assembly\nbehaviorFactoryClassName = csw.common.components.command.ComponentBehaviorFactoryForCommand\nprefix = tcs.mobie.blue.monitor\nlocationServiceUsage = RegisterOnly","title":"Standalone components"},{"location":"/commons/command.html","text":"","title":"Communication using Commands"},{"location":"/commons/command.html#communication-using-commands","text":"csw-command library provides support for command based communication between components.\nThis section describes how to communicate with any other component using commands. To check how to manage commands received, please visit Managing Command State","title":"Communication using Commands"},{"location":"/commons/command.html#dependencies","text":"sbt libraryDependencies += \"org.tmt\" %% \"csw-command\" % \"0.1.2\"","title":"Dependencies"},{"location":"/commons/command.html#command-based-communication-between-components","text":"A component can send Commands to other components. The commands can be sent as following two types of messages:\nSubmit - A command is sent as Submit when the result of completion is desired. Oneway - A command is sent as Oneway when the result of completion is not desired.\nA Oneway should only be used between an Assembly and an HCD. It is also used when tracking completion using a Matcher (see below).\nThe following responses can be received as a CommandResponse after sending a command with Submit or Oneway:\nAccepted : The command is validated and will be executed, this is returned for a long-running action. Completed : The command has been executed successfully. CompletedWithResult : The command is executed successfully and generated some result as a parameter set. Invalid : The command is not valid and will not be executed. A reason is provided. NoLongerValid : The command can no longer be executed (will be deprecated) Error : The command has failed in execution. A reason is provided. Cancelled : The command was cancelled. CommandNotAvailable : A queried command is not available. NotAllowed : The command cannot be executed currently because of the current state of the destination component. Eg. another command is in execution in the presence of which it cannot accept any other command to execute or some other reason.\nA command sent as Submit or Oneway is validated by the receiving component before actual execution. If the validation is successful, the actual execution can happen in two ways :\nImmediate Completion - The component receiving the command can determine if the command can be executed immediately and thus provide the final execution response directly without sending a response for validation. This should be reserved for actions that do not take long to complete.\nScala val eventualResponse: Future[CommandResponse] = async {\n  await(assemblyComponent.submit(Setup(prefix, immediateCmd, obsId))) match {\n    case response: Completed ⇒\n      //do something with completed result\n      response\n    case otherResponse ⇒\n      // do something with other response which is not expected\n      otherResponse\n  }\n} Java CompletableFuture<CommandResponse> eventualCommandResponse =\n        hcdCmdService\n                .submit(imdInvalidCommand, timeout)\n                .thenApply(\n                        response -> {\n                            if (response instanceof Completed) {\n                                //do something with completed result\n                            }\n                            return response;\n                        }\n                );\nLong Running Actions - The component receiving the command may determine that the command cannot be executed immediately. In this case, the component provides a Accepted response as an acknowledgement and maintains the state of the command. The sender can query the state of a particular command at a later time or use the subscribe method to get the final response when the execution is completed.\nThe sender component can use the following with the command id (RunId) of an executing command to get the current status, completion response and/or result of the command\nQuery - Query the current state of an executing command\nScala val setupForQuery = Setup(prefix, longRunning, Some(obsId))\nassemblyCommandService.submit(setupForQuery)\n\n//do some work before querying for the result of above command as needed\n\nval eventualResponse: Future[CommandResponse] = assemblyCommandService.query(setupForQuery.runId) Java hcdCmdService.submit(controlCommand, timeout);\n\n// do some work before querying for the result of above command as needed\n\nCompletableFuture<CommandResponse> queryResponse = hcdCmdService.query(controlCommand.runId(), timeout);\nSubscribe - It is also possible to subscribe to asynchronously get command response updates for an executing command. At least one response is always delivered.\nScala val eventualCommandResponse = assemblyCommandService.submit(setup).flatMap {\n  case _: Accepted ⇒ assemblyCommandService.subscribe(setup.runId)\n  case _           ⇒ Future(CommandResponse.Error(setup.runId, \"\"))\n} Java CompletableFuture<CommandResponse> testCommandResponse =\n        hcdCmdService\n                .submit(controlCommand, timeout)\n                .thenCompose(commandResponse -> {\n                    if (commandResponse instanceof CommandResponse.Accepted)\n                        return hcdCmdService.subscribe(commandResponse.runId(), timeout);\n                    else\n                        return CompletableFuture.completedFuture(new CommandResponse.Error(commandResponse.runId(), \"test error\"));\n                });","title":"Command based communication between components"},{"location":"/commons/command.html#commandservice","text":"A helper/wrapper is provided called CommandService that provides a convenient way to use the Command Service with a component discovered using Location Service. A CommandService instance is created using the value from the Location Service. This CommandService instance will has methods for communicating with the component.\nThe API can be exercised as follows for different scenarios of command-based communication:","title":"CommandService"},{"location":"/commons/command.html#submit","text":"Submit a command and get a CommandResponse as a Future. The CommandResponse can be a response from validation (Accepted, Invalid) or a final Response in case of immediate completion.\nScala/immediate-response val eventualResponse: Future[CommandResponse] = async {\n  await(assemblyComponent.submit(Setup(prefix, immediateCmd, obsId))) match {\n    case response: Completed ⇒\n      //do something with completed result\n      response\n    case otherResponse ⇒\n      // do something with other response which is not expected\n      otherResponse\n  }\n} Java/immediate-response CompletableFuture<CommandResponse> eventualCommandResponse =\n        hcdCmdService\n                .submit(imdInvalidCommand, timeout)\n                .thenApply(\n                        response -> {\n                            if (response instanceof Completed) {\n                                //do something with completed result\n                            }\n                            return response;\n                        }\n                ); Scala/validation-response // `setupWithTimeoutMatcher` is a sample setup payload intended to be used when command response is not determined\n// using matcher\nval submitCommandResponseF: Future[Unit] = async {\n  val initialResponse: CommandResponse = await(assemblyComponent.submit(setupWithTimeoutMatcher))\n  initialResponse match {\n    case accepted: Accepted ⇒\n    // do Something\n    case invalid: Invalid ⇒\n    // do Something\n    case x ⇒\n    // do Something\n  }\n} Java/validation-response CompletableFuture submitCommandResponseF = hcdCmdService\n        .oneway(setup, timeout)\n        .thenAccept(initialCommandResponse -> {\n            if (initialCommandResponse instanceof CommandResponse.Accepted) {\n                //do something\n            } else if (initialCommandResponse instanceof CommandResponse.Invalid) {\n                //do something\n            } else {\n                //do something\n            }\n        });","title":"submit"},{"location":"/commons/command.html#oneway","text":"Send a command as a Oneway and get a CommandResponse as a Future. The CommandResponse can be a response of validation (Accepted, Invalid) or a final Response.\nScala // `setupWithTimeoutMatcher` is a sample setup payload intended to be used when command response is not determined\n// using matcher\nval onewayCommandResponseF: Future[Unit] = async {\n  val initialResponse: CommandResponse = await(assemblyComponent.oneway(setupWithTimeoutMatcher))\n  initialResponse match {\n    case accepted: Accepted ⇒\n    // do Something\n    case invalid: Invalid ⇒\n    // do Something\n    case x ⇒\n    // do Something\n  }\n} Java CompletableFuture onewayCommandResponseF = hcdCmdService\n        .oneway(setup, timeout)\n        .thenAccept(initialCommandResponse -> {\n            if (initialCommandResponse instanceof CommandResponse.Accepted) {\n                //do something\n            } else if (initialCommandResponse instanceof CommandResponse.Invalid) {\n                //do something\n            } else {\n                //do something\n            }\n        });","title":"oneway"},{"location":"/commons/command.html#subscribe","text":"Subscribe for the result of a long-running command which was sent as Submit to get a CommandResponse as a Future.\nScala val eventualCommandResponse = assemblyCommandService.submit(setup).flatMap {\n  case _: Accepted ⇒ assemblyCommandService.subscribe(setup.runId)\n  case _           ⇒ Future(CommandResponse.Error(setup.runId, \"\"))\n} Java CompletableFuture<CommandResponse> testCommandResponse =\n        hcdCmdService\n                .submit(controlCommand, timeout)\n                .thenCompose(commandResponse -> {\n                    if (commandResponse instanceof CommandResponse.Accepted)\n                        return hcdCmdService.subscribe(commandResponse.runId(), timeout);\n                    else\n                        return CompletableFuture.completedFuture(new CommandResponse.Error(commandResponse.runId(), \"test error\"));\n                });","title":"subscribe"},{"location":"/commons/command.html#query","text":"Query for the result of a long-running command which was sent as Submit to get a CommandResponse as a Future.\nScala val setupForQuery = Setup(prefix, longRunning, Some(obsId))\nassemblyCommandService.submit(setupForQuery)\n\n//do some work before querying for the result of above command as needed\n\nval eventualResponse: Future[CommandResponse] = assemblyCommandService.query(setupForQuery.runId) Java hcdCmdService.submit(controlCommand, timeout);\n\n// do some work before querying for the result of above command as needed\n\nCompletableFuture<CommandResponse> queryResponse = hcdCmdService.query(controlCommand.runId(), timeout);","title":"query"},{"location":"/commons/command.html#submitandsubscribe","text":"Submit a command and Subscribe for the result if it was successfully validated as Accepted to get a final CommandResponse as a Future.\nScala val setupForSubscribe = Setup(prefix, longRunning, Some(obsId))\nval response          = assemblyCommandService.submitAndSubscribe(setupForSubscribe) Java CompletableFuture<CommandResponse> finalResponseCompletableFuture = hcdCmdService.submitAndSubscribe(failureResCommand1, timeout);\nCommandResponse actualValidationResponse = finalResponseCompletableFuture.get();","title":"submitAndSubscribe"},{"location":"/commons/command.html#onewayandmatch","text":"Send a command and match the published state from the component using a StateMatcher. If the match is successful a Completed response is provided as a future. In case of a failure or unmatched state, Error CommandResponse is provided as a Future.\nScala val eventualResponse1: Future[CommandResponse] = assemblyComponent.onewayAndMatch(setupWithMatcher, demandMatcher) Java // create a DemandMatcher which specifies the desired state to be matched.\nStateMatcher stateMatcher = new DemandMatcher(new DemandState(prefix().prefix()).add(param), false, timeout);\n\n// create matcher instance\nMatcher matcher1 = new Matcher(hcdLocation.componentRef().narrow(), demandMatcher, ec, mat);\n\n// start the matcher so that it is ready to receive state published by the source\nCompletableFuture<MatcherResponse> matcherResponse = matcher1.jStart();\n\nCompletableFuture<CommandResponse> matchedCommandResponse =\n        hcdCmdService.onewayAndMatch(setup, stateMatcher, timeout);","title":"onewayAndMatch"},{"location":"/commons/command.html#submitallandgetresponse","text":"Submit multiple commands and get one CommandResponse as a Future of CommandResponse for all commands. If all the commands were successful, a CommandResponse as Completed will be returned. If any one of the command fails, an Error will be returned.\nScala val responseOfMultipleCommands = hcdComponent.submitAllAndGetResponse(Set(setupHcd1, setupHcd2))\n Java Setup setupHcd1 = new Setup(prefix(), shortRunning(), Optional.empty()).add(encoderParam);\nSetup setupHcd2 = new Setup(prefix(), mediumRunning(), Optional.empty()).add(encoderParam);\n\nHashMap<JCommandService, Set<ControlCommand>> componentsToCommands = new HashMap<JCommandService, Set<ControlCommand>>() {\n    {\n        put(hcdCmdService, new HashSet<ControlCommand>(Arrays.asList(setupHcd1, setupHcd2)));\n    }\n};\n\nCompletableFuture<CommandResponse> commandResponse = hcdCmdService\n        .submitAllAndGetResponse(\n                new HashSet<ControlCommand>(Arrays.asList(setupHcd1, setupHcd2)),\n                timeout\n        );","title":"submitAllAndGetResponse"},{"location":"/commons/command.html#submitallandgetfinalresponse","text":"Submit multiple commands and get final CommandResponse for all as one CommandResponse. If all the commands were successful, a CommandResponse as Completed will be returned. If any one of the command fails, an Error will be returned. For long running commands, it will subscribe for the result of those which were successfully validated as Accepted and get the final CommandResponse.\nScala val finalResponseOfMultipleCommands = hcdComponent.submitAllAndGetFinalResponse(Set(setupHcd1, setupHcd2))\n Java Setup setupHcd1 = new Setup(prefix(), shortRunning(), Optional.empty()).add(encoderParam);\nSetup setupHcd2 = new Setup(prefix(), mediumRunning(), Optional.empty()).add(encoderParam);\n\nHashMap<JCommandService, Set<ControlCommand>> componentsToCommands = new HashMap<JCommandService, Set<ControlCommand>>() {\n    {\n        put(hcdCmdService, new HashSet<ControlCommand>(Arrays.asList(setupHcd1, setupHcd2)));\n    }\n};\n\nCompletableFuture<CommandResponse> finalCommandResponse = hcdCmdService\n        .submitAllAndGetFinalResponse(\n                new HashSet<ControlCommand>(Arrays.asList(setupHcd1, setupHcd2)),\n                timeout\n        );","title":"submitAllAndGetFinalResponse"},{"location":"/commons/command.html#subscribecurrentstate","text":"This method can be used to subscribe to the CurrentState of the component by providing a callback. Subscribing results into a handle of CurrentStateSubscription which can be used to unsubscribe the subscription.\nScala // subscribe to the current state of an assembly component and use a callback which forwards each received\n// element to a test probe actor\nassemblyCommandService.subscribeCurrentState(probe.ref ! _) Java // subscribe to the current state of an assembly component and use a callback which forwards each received\n// element to a test probe actor\nCurrentStateSubscription subscription = hcdCmdService.subscribeCurrentState(currentState -> probe.ref().tell(currentState));","title":"subscribeCurrentState"},{"location":"/commons/command.html#matching-state-for-command-completion","text":"A Matcher is provided for matching state against a desired state. The matcher is created with a source of state identified by its ActorRef and an instance of StateMatcher which defines the state and criteria for matching. Several instances of StateMatcher are available for common use. These are DemandMatcherAll for matching the entire DemandState against the current state, DemandMatcher for matching state with or without units against the current state and PresenceMatcher which checks if a matching state is found with a provided prefix.\nScala // create a DemandMatcher which specifies the desired state to be matched.\nval demandMatcher = DemandMatcher(DemandState(prefix, Set(param)), withUnits = false, timeout)\n\n// create matcher instance\nval matcher = new Matcher(assemblyLocation.componentRef, demandMatcher)\n\n// start the matcher so that it is ready to receive state published by the source\nval matcherResponseF: Future[MatcherResponse] = matcher.start\n\n// submit command and if the command is successfully validated, check for matching of demand state against current state\nval eventualCommandResponse: Future[CommandResponse] = async {\n  val initialResponse = await(assemblyComponent.oneway(setupWithMatcher))\n  initialResponse match {\n    case _: Accepted ⇒\n      val matcherResponse = await(matcherResponseF)\n      // create appropriate response if demand state was matched from among the published state or otherwise\n      matcherResponse match {\n        case MatchCompleted  ⇒ Completed(setupWithMatcher.runId)\n        case MatchFailed(ex) ⇒ Error(setupWithMatcher.runId, ex.getMessage)\n      }\n    case invalid: Invalid ⇒\n      matcher.stop()\n      invalid\n    case x ⇒ x\n  }\n}\n\nval commandResponse = Await.result(eventualCommandResponse, timeout.duration) Java // create a DemandMatcher which specifies the desired state to be matched.\nDemandMatcher demandMatcher = new DemandMatcher(new DemandState(prefix().prefix()).add(param), false, timeout);\n\n// create matcher instance\nMatcher matcher = new Matcher(hcdLocation.componentRef().narrow(), demandMatcher, ec, mat);\n\n// start the matcher so that it is ready to receive state published by the source\nCompletableFuture<MatcherResponse> matcherResponseFuture = matcher.jStart();\n\n// submit command and if the command is successfully validated, check for matching of demand state against current state\nCompletableFuture<CommandResponse> commandResponseToBeMatched = hcdCmdService\n        .oneway(setup, timeout)\n        .thenCompose(initialCommandResponse -> {\n            if (initialCommandResponse instanceof CommandResponse.Accepted) {\n                return matcherResponseFuture.thenApply(matcherResponse -> {\n                    // create appropriate response if demand state was matched from among the published state or otherwise\n                    if (matcherResponse.getClass().isAssignableFrom(MatcherResponses.jMatchCompleted().getClass()))\n                        return new Completed(initialCommandResponse.runId());\n                    else\n                        return new CommandResponse.Error(initialCommandResponse.runId(), \"Match not completed\");\n                });\n            } else {\n                matcher.stop();\n                return CompletableFuture.completedFuture(initialCommandResponse);\n            }\n        });\n\nCommandResponse actualResponse = commandResponseToBeMatched.get();","title":"Matching state for command completion"},{"location":"/commons/command.html#distributing-commands","text":"CommandDistributor is a utility for distributing commands to multiple components and get an aggregated response.","title":"Distributing commands"},{"location":"/commons/command.html#aggregated-validation-response","text":"A component can send one or more commands to one or more components using a Map[ComponentRef, Set[ControlCommand], and get an aggregated response of validation as Accepted if all the commands were successfully validated. An Error response is returned otherwise\nScala val aggregatedValidationResponse = CommandDistributor(\n  Map(assemblyCommandService → Set(setupAssembly1, setupAssembly2), hcdComponent → Set(setupHcd1, setupHcd2))\n).aggregatedValidationResponse() Java CompletableFuture<CommandResponse> cmdValidationResponseF =\n        new JCommandDistributor(componentsToCommands).\n                aggregatedValidationResponse(timeout, ec, mat);","title":"aggregated validation response"},{"location":"/commons/command.html#aggregated-completion-response","text":"A component can send one or more commands to one or more components using a Map[ComponentRef, Set[ControlCommand]. The utility handles subscribing for final completion result for all the commands post successful validation and get an aggregated response of completion as Completed if all the commands were successfully completed. An Error response is returned otherwise.\nScala val aggregatedResponse = CommandDistributor(\n  Map(assemblyCommandService → Set(setupAssembly1, setupAssembly2), hcdComponent → Set(setupHcd1, setupHcd2))\n).aggregatedCompletionResponse() Java CompletableFuture<CommandResponse> cmdCompletionResponseF =\n        new JCommandDistributor(componentsToCommands).\n                aggregatedCompletionResponse(timeout, ec, mat);","title":"aggregated completion response"},{"location":"/commons/services.html","text":"","title":"Services"},{"location":"/commons/services.html#services","text":"Location Service Configuration Service Logging Service","title":"Services"},{"location":"/services/location.html","text":"","title":"Location Service"},{"location":"/services/location.html#location-service","text":"The Location Service handles component (i.e., Applications, Sequencers, Assemblies, HCDs, and Services) registration and discovery in the distributed TMT software system.\nCSW Location Service cluster seed must be running, and appropriate environment variables set to run apps. See https://tmtsoftware.github.io/csw-prod/apps/cswclusterseed.html.\nA component’s location information can be used by other components and services to connect to it and use it. An example of location information is:\nhost address/port pairs URL/URIs paths connection protocols log-admin actor reference\nasync handling in scala and java examples. Scala: async marks a block of asynchronous code and allows to await the computation till the Future is complete. For more info, please refer: https://github.com/scala/async Java non-blocking example: The code snippets use CompletableFuture and its thenAsync, thenApply methods. This style allows to compose multiple Futures and not block the calling thread till Futures are complete. Java blocking example: The code snippets use CompletableFuture using get blocking call. This style blocks the calling thread till the Future is complete.","title":"Location Service"},{"location":"/services/location.html#dependencies","text":"To use the Location Service without using the framework, add this to your build.sbt file:\nsbt libraryDependencies += \"org.tmt\" %% \"csw-location\" % \"0.1.2\"","title":"Dependencies"},{"location":"/services/location.html#create-location-service","text":"Note that before using this API, the csw-cluster-seed application (the main seed node for the location service cluster) should be running at a known location in the network (or at multiple locations) and the necessary configuration, environment variables or system properties should be defined to point to the correct host and port number(s).\nLocationServiceFactory provides a make method to create an instance of the LocationService API. This call will look for configuration or environment variable settings as described here: ClusterSettings.\nScala private val locationService = LocationServiceFactory.make() Java private ILocationService locationService = JLocationServiceFactory.make();","title":"Create Location Service"},{"location":"/services/location.html#shutdown-location-service","text":"This example demonstrates how to disconnect from the Location Service. Shutdown will terminate the application’s ActorSystem leave the cluster.\nNote: All the services registered via this instance of LocationService will continue to be available for other cluster members.\nScala // Only call this once per application\nAwait.result(locationService.shutdown(ActorTerminatedReason), 20.seconds) Java locationService.shutdown(CoordinatedShutdownReasons.actorTerminatedReason()).get();","title":"Shutdown Location Service"},{"location":"/services/location.html#creating-components-connections-and-registrations","text":"An Application, Sequencer, Assembly, HCD, or Service component may need to be used by another component as part of normal observatory operations. It must register its location information with Location Service so that other components can find it.\nComponents have a name and a type, such as Container, HCD, Assembly, Service.\nConnections are the means to reach components and are categorized as Akka, HTTP, or Tcp type connections.\nRegistrations are service endpoints stored in Location Service.\nThe register API takes a Registration parameter and returns a future registration result. If registration fails for some reason, the returned future will fail with an exception. (Registration will fail if the csw-cluster-seed application is not running or could not be found or if the given component name was already registered.)\nThe following example shows registration of both UnTyped ActorRef and Typed ActorRef:\nScala // logAdminActorRef handles dynamically setting/getting log level of the component\nprivate val logAdminActorRef: ActorRef[LogControlMessages] =\n  LogAdminActorFactory.make(context.system)\n\nprivate val registrationFactory = new RegistrationFactory(logAdminActorRef)\n\n// add some dummy registrations for illustrative purposes\n\n// dummy http connection\nval httpPort                          = 8080\nval httpConnection                    = HttpConnection(ComponentId(\"configuration\", ComponentType.Service))\nval httpRegistration                  = HttpRegistration(httpConnection, httpPort, \"path123\", logAdminActorRef)\nval httpRegResult: RegistrationResult = Await.result(locationService.register(httpRegistration), 2.seconds)\n\n// ************************************************************************************************************\n\n// import scaladsl adapter to implicitly convert UnTyped ActorRefs to Typed ActorRef[Nothing]\nimport akka.actor.typed.scaladsl.adapter._\n\n// dummy HCD connection\nval hcdConnection = AkkaConnection(ComponentId(\"hcd1\", ComponentType.HCD))\nval hcdRegistration: AkkaRegistration = registrationFactory.akkaTyped(\n  hcdConnection,\n  \"nfiraos.ncc.tromboneHcd\",\n  context.actorOf(Props(new akka.actor.Actor {\n    override def receive: Receive = {\n      case \"print\" => log.info(\"hello world\")\n    }\n  }), name = \"my-actor-1\")\n)\n\n// Register UnTyped ActorRef with Location service. Import scaladsl adapter to implicitly convert\n// UnTyped ActorRefs to Typed ActorRef[Nothing]\nval hcdRegResult: RegistrationResult = Await.result(locationService.register(hcdRegistration), 2.seconds)\n\n// ************************************************************************************************************\n\ndef behavior(): Behavior[String] = Behaviors.setup { ctx =>\n  Behaviors.same\n}\nval typedActorRef: ActorRef[String] = context.system.spawn(behavior(), \"typed-actor-ref\")\n\nval assemblyConnection = AkkaConnection(ComponentId(\"assembly1\", ComponentType.Assembly))\n\n// Register Typed ActorRef[String] with Location Service\nval assemblyRegistration: AkkaRegistration =\n  registrationFactory.akkaTyped(assemblyConnection, \"nfiraos.ncc.tromboneAssembly\", typedActorRef)\n\nval assemblyRegResult: RegistrationResult = Await.result(locationService.register(assemblyRegistration), 2.seconds) Java // logAdminActorRef handles dynamically setting/getting log level of the component\nakka.actor.typed.ActorRef<LogControlMessages> logAdminActorRef = LogAdminActorFactory.make(context().system());\n\n// dummy http connection\nHttpConnection httpConnection = new HttpConnection(new ComponentId(\"configuration\", JComponentType.Service));\nHttpRegistration httpRegistration = new HttpRegistration(httpConnection, 8080, \"path123\", logAdminActorRef);\nhttpRegResult = locationService.register(httpRegistration).get();\n\n// ************************************************************************************************************\n\n// dummy HCD connection\nAkkaConnection hcdConnection = new AkkaConnection(new ComponentId(\"hcd1\", JComponentType.HCD));\nActorRef actorRef = getContext().actorOf(Props.create(AbstractActor.class, () -> new AbstractActor() {\n            @Override\n            public Receive createReceive() {\n                return ReceiveBuilder.create().build();\n            }\n        }),\n        \"my-actor-1\"\n);\n\nRegistrationFactory registrationFactory = new RegistrationFactory(logAdminActorRef);\n\n// Register UnTyped ActorRef with Location service. Use javadsl Adapter to convert UnTyped ActorRefs\n// to Typed ActorRef[Nothing]\nAkkaRegistration hcdRegistration = registrationFactory.akkaTyped(hcdConnection, \"nfiraos.ncc.tromboneHcd\", Adapter.toTyped(actorRef));\nhcdRegResult = locationService.register(hcdRegistration).get();\n\n// ************************************************************************************************************\n\nBehavior<String> behavior = Behaviors.setup(ctx -> {\n    return Behaviors.same();\n});\nakka.actor.typed.ActorRef<String> typedActorRef = Adapter.spawn(context(), behavior, \"typed-actor-ref\");\n\nAkkaConnection assemblyConnection = new AkkaConnection(new ComponentId(\"assembly1\", JComponentType.Assembly));\n\n// Register Typed ActorRef[String] with Location Service\nAkkaRegistration assemblyRegistration = registrationFactory.akkaTyped(assemblyConnection, \"nfiraos.ncc.tromboneAssembly\", typedActorRef);\nassemblyRegResult = locationService.register(assemblyRegistration).get();\nNote Notice the logAdminActorRef that is used while registering any connection. It is used to dynamically change the log level of a component. For an application, make sure there is only one logAdminActorRef used for all registrations. The source code of LogAdminActor can be found here.\nNote The AkkaRegistration api takes only Typed ActorRefs. Hence, to register an UnTyped ActorRef for an akka connection, it needs to be adapted to Typed ActorRef[Nothing]. This can be achieved using adapter provided for scaladsl and javadsl. The usage of adapter is shown in above snippet for scala and java both. Also, note that for components, the registration will be taken care of via csw-framework. Hence, component developers won’t register any connections during their development. So, above demonstration of registering connections is for explanatory and testing purpose only.","title":"Creating Components, Connections and Registrations"},{"location":"/services/location.html#creating-actorref-for-registration","text":"Make sure the ActorSystem used to start actors using the location service is created using ActorSystemFactory as follows:\nScala implicit val system: ActorSystem =\n  ActorSystemFactory.remote(\"csw-examples-locationServiceClient\") Java ActorSystem actorSystem = ActorSystemFactory.remote(\"csw-examples-locationServiceClient\");\nThis is required to start a remote ActorSystem on the same network interface where the csw-cluster is running. All the ActorRefs created using this ActorSystem will be available for communication from other components that are part of csw-cluster.","title":"Creating ActorRef for Registration"},{"location":"/services/location.html#resolving-connections","text":"The list API returns a list of the currently registered connections from the Location Service.\nA connection of interest can be looked up using the resolve or find methods:\nresolve gets the location for a connection from the local cache. If not found in the cache, it waits for the event to arrive within the specified time limit and returns None on failure.\nfind returns the location for a connection from the local cache and returns None if not found there.\nScala // find connection to LocationServiceExampleComponent in location service\n// [do this before starting LocationServiceExampleComponent.  this should return Future[None]]\nval exampleConnection: AkkaConnection = LocationServiceExampleComponent.connection\n\nlog.info(s\"Attempting to find $exampleConnection\",\n         Map(Keys.OBS_ID → \"foo_obs_id\", \"exampleConnection\" → exampleConnection.name))\nval findResult: Option[AkkaLocation] = Await.result(locationService.find(exampleConnection), timeout)\n\nlog.info(s\"Result of the find call: $findResult\") Java // find connection to LocationServiceExampleComponent in location service\n// [do this before starting LocationServiceExampleComponent.  this should return Future[None]]\n\nlog.info(\"Attempting to find \" + exampleConnection,\n        new HashMap<String, Object>() {{\n            put(JKeys.OBS_ID, \"foo_obs_id\");\n            put(\"exampleConnection\", exampleConnection.name());\n        }});\n\nOptional<AkkaLocation> findResult = locationService.find(exampleConnection).get();\nif (findResult.isPresent()) {\n    log.info(\"Find result: \" + connectionInfo(findResult.get().connection()));\n} else {\n    log.info(() -> \"Result of the find call : None\");\n}\nThe logging output from the above example when the given component is not registered should include:\n[INFO] Attempting to find connection AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))\n[INFO] Result of the find call: None\nAn example of the resolve command is shown in the following:\nScala // resolve connection to LocationServiceExampleComponent\n// [start LocationServiceExampleComponent after this command but before timeout]\nlog.info(s\"Attempting to resolve $exampleConnection with a wait of $waitForResolveLimit ...\")\n\nval resolveResultF: Future[Option[AkkaLocation]] = locationService.resolve(exampleConnection, waitForResolveLimit)\nval resolveResult: Option[AkkaLocation]          = Await.result(resolveResultF, waitForResolveLimit + timeout)\nresolveResult match {\n  case Some(result) ⇒\n    log.info(s\"Resolve result: ${locationInfoToString(result)}\")\n  case None ⇒\n    log.info(s\"Timeout waiting for location $exampleConnection to resolve.\")\n} Java // resolve connection to LocationServiceExampleComponent\n// [start LocationServiceExampleComponent after this command but before timeout]\nFiniteDuration waitForResolveLimit = new FiniteDuration(30, TimeUnit.SECONDS);\n\nlog.info(() -> \"Attempting to resolve \" + exampleConnection + \" with a wait of \" + waitForResolveLimit + \"...\", () -> {\n    Map<String, Object> map = new HashMap<>();\n    map.put(JKeys.OBS_ID, \"foo_obs_id\");\n    map.put(\"exampleConnection\", exampleConnection.name());\n    return map;\n});\n\nOptional<AkkaLocation> resolveResult = locationService.resolve(exampleConnection, waitForResolveLimit).get();\nif (resolveResult.isPresent()) {\n    log.info(() -> \"Resolve result: \" + connectionInfo(resolveResult.get().connection()));\n} else {\n    log.info(() -> \"Timeout waiting for location \" + exampleConnection + \" to resolve.\");\n}\nThe logging output from the above example should include:\n[INFO] Attempting to resolve AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly)) with a wait of 30 seconds ...\nIf you then start the LocationServiceExampleComponentApp, the following message will be logged:\n[INFO] Resolve result: LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\nIf not, eventually the operation will timeout and the output should read:\n[INFO] Timeout waiting for location AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly)) to resolve.\nNote The resolve and find api returns the concrete Location type i.e. Akkalocation, HttpLocation or TcpLocation as demonstrated in this section. Once the akka location is found or resolved, we need to retain the type to the actorRef, since the explicit type annotation is removed from the program, before it is executed at run-time (refer type erasure). Use following AkkaLocation api to get the correct Typed ActorRef: Scala // If the component type is HCD or Assembly, use this to get the correct ActorRef\nval typedComponentRef: ActorRef[ComponentMessage] = akkaLocation.componentRef\n\n// If the component type is Container, use this to get the correct ActorRef\nval typedContainerRef: ActorRef[ContainerMessage] = akkaLocation.containerRef Java // If the component type is HCD or Assembly, use this to get the correct ActorRef\nakka.actor.typed.ActorRef<ComponentMessage> typedComponentRef = akkaLocation.componentRef();\n\n// If the component type is Container, use this to get the correct ActorRef\nakka.actor.typed.ActorRef<ContainerMessage> typedContainerRef = akkaLocation.containerRef();","title":"Resolving Connections"},{"location":"/services/location.html#filtering","text":"The list API and its variants offer means to inquire about available connections with the Location Service. The parameter-less list returns all available connections\nScala // list connections in location service\nval connectionList: List[Location] = Await.result(locationService.list, timeout)\nlog.info(\"All Registered Connections:\")\nconnectionList.foreach(c => log.info(s\"--- ${locationInfoToString(c)}\")) Java // list connections in location service\nList<Location> connectionList = locationService.list().get();\nlog.info(\"All Registered Connections:\");\nfor (Location loc : connectionList) {\n    log.info(\"--- \" + connectionInfo(loc.connection()));\n}\nThe log output from the above should contain:\n[INFO] All Registered Connections:\n[INFO] --- configuration-service-http, component type=Service, connection type=HttpType\n[INFO] --- hcd1-hcd-akka, component type=HCD, connection type=AkkaType\n[INFO] --- LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\n[INFO] --- redis-service-tcp, component type=Service, connection type=TcpType\n[INFO] --- assembly1-assembly-akka, component type=Assembly, connection type=AkkaType\nOther variants are filters using ConnectionType, ComponentType, and hostname.\nFiltering by component type is shown below:\nScala // filter connections based on component type\nval componentList: List[Location] = Await.result(locationService.list(ComponentType.Assembly), timeout)\nlog.info(\"Registered Assemblies:\")\ncomponentList.foreach(c => log.info(s\"--- ${locationInfoToString(c)}\")) Java // filter connections based on component type\nList<Location> componentList = locationService.list(JComponentType.Assembly).get();\nlog.info(\"Registered Assemblies:\");\nfor (Location loc : componentList) {\n    log.info(\"--- \" + connectionInfo(loc.connection()));\n}\nThe log output from the above code should contain:\n[INFO] Registered Assemblies:\n[INFO] --- LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\n[INFO] --- assembly1-assembly-akka, component type=Assembly, connection type=AkkaType\nFiltering by connection type is shown below:\nScala // filter connections based on connection type\nval akkaList: List[Location] = Await.result(locationService.list(ConnectionType.AkkaType), timeout)\nlog.info(\"Registered Akka connections:\")\nakkaList.foreach(c => log.info(s\"--- ${locationInfoToString(c)}\")) Java // filter connections based on connection type\nList<Location> akkaList = locationService.list(JConnectionType.AkkaType).get();\nlog.info(\"Registered Akka connections:\");\nfor (Location loc : akkaList) {\n    log.info(\"--- \" + connectionInfo(loc.connection()));\n}\nThe log output should contain:\n[INFO] Registered Akka connections:\n[INFO] --- hcd1-hcd-akka, component type=HCD, connection type=AkkaType\n[INFO] --- LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\n[INFO] --- assembly1-assembly-akka, component type=Assembly, connection type=AkkaType\nFiltering akka connections by prefix is shown below:\nScala // filter akka locations based on prefix\nval akkaLocations: List[AkkaLocation] = Await.result(locationService.listByPrefix(\"nfiraos.ncc\"), timeout)\nlog.info(\"Registered akka locations for nfiraos.ncc\")\nakkaLocations.foreach(c ⇒ log.info(s\"--- ${locationInfoToString(c)}\")) Java List<AkkaLocation> akkaLocations = locationService.listByPrefix(\"nfiraos.ncc\").get();\nlog.info(\"Registered akka locations for nfiraos.ncc\");\nfor (Location loc : akkaLocations) {\n    log.info(\"--- \" + connectionInfo(loc.connection()));\n}\nThe log output should contain:\n[INFO] Registered akka locations for nfiraos.ncc\n[INFO] --- hcd1-hcd-akka, component type=HCD, connection type=AkkaType\n[INFO] --- assembly1-assembly-akka, component type=Assembly, connection type=AkkaType","title":"Filtering"},{"location":"/services/location.html#tracking-and-subscribing","text":"The lifecycle of a connection of interest can be followed using either the track API or the subscribe API.\nThese methods take a Connection instance as a parameter. A Connection need not already be registered with Location Service. It’s alright to track connections that will be registered in future.\nA track API returns two values: * A source that will emit a stream of TrackingEvents for the connection. * A Killswitch to turn off the stream when no longer needed.\nThe Akka stream API provides many building blocks to process this stream, such as Flow and Sink. In the example below, Sink.actorRef is used to forward any location messages received to the current actor (self).\nA consumer can shut down the stream using the Killswitch.\nThe subscribe API allows the caller to track a connection and receive the TrackingEvent notifications via a callback.\nThe API expects following parameters : * An existing connection or a connection to be registered in the future. * A callback that implements Consumer, receives the TrackEvent as a parameter.\nIn return it gives a Killswitch that can be used to turn off the event notifications and release the supplied callback, if required.\nScala // the following two methods are examples of two ways to track a connection.\n// both are implemented but only one is really needed.\n\n// Method1: track connection to LocationServiceExampleComponent\n// Calls track method for example connection and forwards location messages to this actor\n//\nlog.info(s\"Starting to track $exampleConnection\")\nlocationService\n  .track(exampleConnection)\n  .to(Sink.actorRef(self, AllDone))\n  .run()\n//track returns a Killswitch, that can be used to turn off notifications arbitarily\n//in this case track a connection for 5 seconds, after that schedule switching off the stream\nval killswitch = locationService\n  .track(httpConnection)\n  .toMat(Sink.foreach(println))(Keep.left)\n  .run()\ncontext.system.scheduler.scheduleOnce(5.seconds) {\n  killswitch.shutdown()\n}\n\n// Method2: subscribe to LocationServiceExampleComponent events\nlog.info(s\"Starting a subscription to $exampleConnection\")\nlocationService.subscribe(\n  exampleConnection,\n  trackingEvent => {\n    // the following println is to distinguish subscription events from tracking events\n    log.info(\"subscription event\")\n    self ! trackingEvent\n  }\n) Java // the following two methods are examples of two ways to track a connection.\n// both are implemented but only one is really needed.\n\n// track connection to LocationServiceExampleComponent\n// Calls track method for example connection and forwards location messages to this actor\nMaterializer mat = ActorMaterializer.create(getContext());\nlog.info(\"Starting to track \" + exampleConnection);\nlocationService.track(exampleConnection).toMat(Sink.actorRef(getSelf(), AllDone.class), Keep.both()).run(mat);\n\n//track returns a Killswitch, that can be used to turn off notifications arbitarily\n//in this case track a connection for 5 seconds, after that schedule switching off the stream\nPair pair = locationService.track(exampleConnection).toMat(Sink.ignore(), Keep.both()).run(mat);\ncontext().system().scheduler().scheduleOnce(\n        Duration.create(5, TimeUnit.SECONDS),\n        () -> ((KillSwitch) pair.first()).shutdown(),\n        context().system().dispatcher());\n\n// subscribe to LocationServiceExampleComponent events\nlog.info(\"Starting a subscription to \" + exampleConnection);\nlocationService.subscribe(exampleConnection, trackingEvent -> {\n    log.info(\"subscription event\");\n    getSelf().tell(trackingEvent, ActorRef.noSender());\n});\nThe log output should contain the following:\n[INFO] Starting to track AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly)) LocationUpdated(HttpLocation(HttpConnection(ComponentId(configuration,Service)),http://131.215.210.170:8080/path123))\n[INFO] Starting a subscription to AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))\n[INFO] Subscribing to connection LocationServiceExampleComponent-assembly-akka\n[INFO] Location updated LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\n[INFO] subscription event\n[INFO] Location updated LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\nIf you now stop the LocationServiceExampleComponentApp, it would log:\n[INFO] subscription event\n[INFO] Location removed AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))\n[INFO] Location removed AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))\nIf you start the LocationServiceExampleComponentApp again, the log output should be:\n[INFO] subscription event\n[INFO] Location updated LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\n[INFO] Location updated LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\nNote: the line after the words “subscription event” in our example is generated by the subscription, and the other line is from tracking. These two events could come in any order.","title":"Tracking and Subscribing"},{"location":"/services/location.html#unregistering","text":"One of the ways to unregister a service is by calling unregister on registration result received from register API.\nScala val unregisterF = async {\n  httpRegResult.unregister()\n  hcdRegResult.unregister()\n  assemblyRegResult.unregister()\n}\nAwait.result(unregisterF, 5.seconds) Java httpRegResult.unregister();\nhcdRegResult.unregister();\nassemblyRegResult.unregister();","title":"Unregistering"},{"location":"/services/location.html#source-code-for-examples","text":"Scala Example JavaBlocking Example","title":"Source code for examples"},{"location":"/services/config.html","text":"","title":"Configuration Service"},{"location":"/services/config.html#configuration-service","text":"Configuration Service provides a centralized persistent store for any configuration file used in the TMT Software System. All versions of configuration files are retained, providing a historical record of each configuration file.\nNote that in order to use the APIs described here, the Location Service (csw-cluster-seed) and Configuration Service Server needs to be running somewhere in the local network and the necessary configuration, environment variables or system properties should be defined to point to the correct host and port number(s) for the Location Service seed nodes.\nThis service will be part of the observatory cluster and exposes Rest endpoints that can be accessed over HTTP. Component developers can use the csw-config-client library in their code. The library wraps the low level communication with Configuration Service Server and exposes simple to use methods to access and manage configuration files.","title":"Configuration Service"},{"location":"/services/config.html#dependencies","text":"To use the Configuration Service without using the framework, add this to your build.sbt file:\nsbt libraryDependencies += \"org.tmt\" %% \"csw-config-client\" % \"0.1.2\"","title":"Dependencies"},{"location":"/services/config.html#rules-and-checks","text":"The config file path must not contain !#<>$%&'@^``~+,;= or any whitespace character If the input file is > 10MB or has lot of non ASCII characters, then for optimization, server will archive it in annex store. Large and binary files can be forced to go to ‘annex’ store by using a annex=true flag in create operation. API functions accept date-time values in UTC timezone. (e.g. 2017-05-17T08:00:24.246Z)","title":"Rules and Checks"},{"location":"/services/config.html#model-classes","text":"ConfigData : Represents the contents of the files being managed. It wraps stream of ByteString. ConfigFileInfo : Represents information about a config file stored in the config service. ConfigFileRevision : Represents information about a specific version of a config file. ConfigId : Represents identifier associated with a revision of configuration file, often generated by create or update methods. ConfigMetadata : Represents metadata information about ConfigServer. FileType : Represents the type of storage for a configuration file. Currently two types are supported Normal(small, text files) and Annex(Large, Binary files).","title":"Model Classes"},{"location":"/services/config.html#api-flavors","text":"The Configuration Service is used to provide the runtime settings for components. When a component is started, it will use a limited “clientAPI” to obtain the “active” configuration from the Configuration Service, and use those settings for its execution.\nTo change the active configuration, an administrative tool with access to the full “admin API” must be used. These tools would have the ability to create, delete, and update configurations, as well as retrieve past configurations and their history. Any time a new configuration is to be used by a component, the user must use one of these tools (via CLI, perhaps) to set the active configuration for a component. Since a history of active configurations is maintained by the service, the settings of each component each time it is run can be retrieved, and the system configuration at any moment can be recreated.\nclientAPI : Must be used in Assembly and HCD components. Available functions are: {exists | getActive} adminAPI : Full functionality exposed by Configuration Service Server is available with this API. Expected to be used administrators. Available functions are: {create | update | getById | getLatest | getByTime | delete | list | history | historyActive | setActiveVersion | resetActiveVersion | getActiveVersion | getActiveByTime | getMetadata | exists | getActive}\nComponent developers must use clientAPI.","title":"API Flavors"},{"location":"/services/config.html#accessing-clientapi-and-adminapi","text":"ConfigClientFactory exposes functions to get clientAPI and adminAPI. Both the functions require Location Service instance which is used to resolve ConfigServer.\nNote Components should only use the client API. The Admin API may be used from an engineering user interface. The CSW Config Client CLI application is provided with this functionality.\nScala //config client API\nval clientApi: ConfigClientService = ConfigClientFactory.clientApi(actorSystem, locationService)\n//config admin API\nval adminApi: ConfigService = ConfigClientFactory.adminApi(actorSystem, locationService) Java //config client API\nIConfigClientService clientApi = JConfigClientFactory.clientApi(actorRuntime.actorSystem(), clientLocationService);\n//config admin API\nIConfigService adminApi = JConfigClientFactory.adminApi(actorRuntime.actorSystem(), clientLocationService);","title":"Accessing clientAPI and adminAPI"},{"location":"/services/config.html#exists","text":"Function checks if the file exists at specified path in the repository. If it exists it returns Future of Boolean\nScala //construct the path\nval filePath = Paths.get(\"/tmt/trmobone/assembly/hcd.conf\")\n\nval doneF = async {\n  // create file using admin API\n  await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"First commit\"))\n\n  //check if file exists with config service\n  val exists: Boolean = await(clientApi.exists(filePath))\n  exists shouldBe true\n}\nAwait.result(doneF, 5.seconds) Java Path filePath = Paths.get(\"/tmt/trmobone/assembly/hcd.conf\");\n\n// create file using admin API\nadminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"commit config file\").get();\n\nBoolean exists = clientApi.exists(filePath).get();\nAssert.assertTrue(exists);","title":"exists"},{"location":"/services/config.html#getactive","text":"Function retrieves currently active file for a given path from config service. It returns a Future of Option of ConfigData.\nScala val defaultStrConf: String = \"foo { bar { baz : 1234 } }\"\nval doneF = async {\n  // construct the path\n  val filePath = Paths.get(\"/tmt/trmobone/assembly/hcd.conf\")\n\n  await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"First commit\"))\n\n  val activeFile: Option[ConfigData] = await(clientApi.getActive(filePath))\n  await(activeFile.get.toStringF) shouldBe defaultStrConf\n}\nAwait.result(doneF, 5.seconds) Java String defaultStrConf = \"foo { bar { baz : 1234 } }\";\n// construct the path\nPath filePath = Paths.get(\"/tmt/trmobone/assembly/hcd.conf\");\n\nadminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"First commit\").get();\n\nConfigData activeFile = clientApi.getActive(filePath).get().get();\nAssert.assertEquals(activeFile.toJConfigObject(mat).get().getString(\"foo.bar.baz\"), \"1234\");","title":"getActive"},{"location":"/services/config.html#create","text":"Takes input ConfigData and creates the configuration in the repository at a specified path\nScala   async {\n    //construct ConfigData from String containing ASCII text\n    val configString: String =\n      \"\"\"\n    // Name: ComponentType ConnectionType\n    {\n      name: lgsTromboneHCD\n      type: Hcd\n      connectionType: [akka]\n    }\n    \"\"\".stripMargin\n    val config1: ConfigData = ConfigData.fromString(configString)\n\n    //construct ConfigData from a local file containing binary data\n    val srcFilePath         = getClass.getClassLoader.getResource(\"smallBinary.bin\").toURI\n    val config2: ConfigData = ConfigData.fromPath(Paths.get(srcFilePath))\n\n    //construct ConfigData from Array[Byte] by reading a local file\n    val stream: InputStream    = getClass.getClassLoader.getResourceAsStream(\"smallBinary.bin\")\n    def byteArray: Array[Byte] = Stream.continually(stream.read).takeWhile(_ != -1).map(_.toByte).toArray\n    val config3                = ConfigData.fromBytes(byteArray)\n\n    //store the config, at a specified path as normal text file\n    val id1: ConfigId =\n      await(adminApi.create(Paths.get(\"/hcd/trombone/overnight.conf\"), config1, false, \"review done\"))\n\n    //store the config, at a specified path as a binary file in annex store\n    val id2: ConfigId =\n      await(adminApi.create(Paths.get(\"/hcd/trombone/firmware.bin\"), config2, true, \"smoke test done\"))\n\n    //store the config, at a specified path as a binary file in annex store\n    val id3: ConfigId =\n      await(adminApi.create(Paths.get(\"/hcd/trombone/debug.bin\"), config3, true, \"new file from vendor\"))\n\n    //CAUTION: for demo example setup these IDs are returned. Don't assume them in production setup.\n    id1 shouldEqual ConfigId(1)\n    id2 shouldEqual ConfigId(3)\n    id3 shouldEqual ConfigId(5)\n  }\nAwait.result(futC, 2.seconds) Java //construct ConfigData from String containing ASCII text\nString configString = \"axisName11111 = tromboneAxis\\naxisName22222 = tromboneAxis2\\naxisName3 = tromboneAxis3333\";\nConfigData config1 = ConfigData.fromString(configString);\n\n//construct ConfigData from a local file containing binary data\nURI srcFilePath = getClass().getClassLoader().getResource(\"smallBinary.bin\").toURI();\nConfigData config2 = ConfigData.fromPath(Paths.get(srcFilePath));\n\nConfigId id1 = adminApi.create(Paths.get(\"/hcd/trombone/overnight.conf\"), config1, false, \"review done\").get();\nConfigId id2 = adminApi.create(Paths.get(\"/hcd/trombone/firmware.bin\"), config2, true, \"smoke test done\").get();\n\n//CAUTION: for demo example setup these IDs are returned. Don't assume them in production setup.\nAssert.assertEquals(id1, new ConfigId(\"1\"));\nAssert.assertEquals(id2, new ConfigId(\"3\"));","title":"create"},{"location":"/services/config.html#update","text":"Takes input ConfigData and overwrites the configuration specified in the repository\nScala val futU = async {\n  val destPath = Paths.get(\"/hcd/trombone/debug.bin\")\n  val newId = await(\n    adminApi\n      .update(destPath, ConfigData.fromString(defaultStrConf), comment = \"debug statements\")\n  )\n\n  //validate the returned id\n  newId shouldEqual ConfigId(7)\n}\nAwait.result(futU, 2.seconds) Java Path destPath = Paths.get(\"/hcd/trombone/overnight.conf\");\nConfigId newId = adminApi.update(destPath, ConfigData.fromString(defaultStrConf), \"added debug statements\").get();\n\n//validate the returned id\nAssert.assertEquals(newId, new ConfigId(\"5\"));","title":"update"},{"location":"/services/config.html#delete","text":"Deletes a file located at specified path in the repository\nScala val futD = async {\n  val unwantedFilePath = Paths.get(\"/hcd/trombone/debug.bin\")\n  await(adminApi.delete(unwantedFilePath, \"no longer needed\"))\n  //validates the file is deleted\n  await(adminApi.getLatest(unwantedFilePath)) shouldBe None\n}\nAwait.result(futD, 2.seconds) Java Path unwantedFilePath = Paths.get(\"/hcd/trombone/overnight.conf\");\nadminApi.delete(unwantedFilePath, \"no longer needed\").get();\nAssert.assertEquals(adminApi.getLatest(unwantedFilePath).get(), Optional.empty());","title":"delete"},{"location":"/services/config.html#getbyid","text":"Returns file at a given path and matching revision Id\nScala val doneF = async {\n  // create a file using API first\n  val filePath = Paths.get(\"/tmt/trmobone/assembly/hcd.conf\")\n  val id: ConfigId =\n    await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"First commit\"))\n\n  //validate\n  val actualData = await(adminApi.getById(filePath, id)).get\n  await(actualData.toStringF) shouldBe defaultStrConf\n}\nAwait.result(doneF, 2.seconds) Java Path filePath = Paths.get(\"/tmt/trmobone/assembly/hcd.conf\");\nConfigId id = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"First commit\").get();\n\n//validate\nConfigData actualData = adminApi.getById(filePath, id).get().get();\nAssert.assertEquals(defaultStrConf, actualData.toJStringF(mat).get());","title":"getById"},{"location":"/services/config.html#getlatest","text":"Returns the latest versio of file stored at the given path.\nScala val assertionF: Future[Assertion] = async {\n  //create a file\n  val filePath = Paths.get(\"/test.conf\")\n  await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"initial configuration\"))\n\n  //override the contents\n  val newContent = \"I changed the contents!!!\"\n  await(adminApi.update(filePath, ConfigData.fromString(newContent), \"changed!!\"))\n\n  //get the latest file\n  val newConfigData = await(adminApi.getLatest(filePath)).get\n  //validate\n  await(newConfigData.toStringF) shouldBe newContent\n}\nAwait.result(assertionF, 2.seconds) Java //create a file\nPath filePath = Paths.get(\"/test.conf\");\nConfigId id = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"initial configuration\").get();\n\n//override the contents\nString newContent = \"I changed the contents!!!\";\nadminApi.update(filePath, ConfigData.fromString(newContent), \"changed!!\").get();\n\n//get the latest file\nConfigData newConfigData = adminApi.getLatest(filePath).get().get();\n//validate\nAssert.assertEquals(newConfigData.toJStringF(mat).get(), newContent);","title":"getLatest"},{"location":"/services/config.html#getbytime","text":"Gets the file at the given path as it existed at a given time-instance. Note:\nIf time-instance is before the file was created, the initial version is returned. If time-instance is after the last change, the most recent version is returned.\nScala val assertionF = async {\n  val tInitial = Instant.MIN\n  //create a file\n  val filePath = Paths.get(\"/a/b/c/test.conf\")\n  await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"initial configuration\"))\n\n  //override the contents\n  val newContent = \"I changed the contents!!!\"\n  await(adminApi.update(filePath, ConfigData.fromString(newContent), \"changed!!\"))\n\n  val initialData: ConfigData = await(adminApi.getByTime(filePath, tInitial)).get\n  await(initialData.toStringF) shouldBe defaultStrConf\n\n  val latestData = await(adminApi.getByTime(filePath, Instant.now())).get\n  await(latestData.toStringF) shouldBe newContent\n}\nAwait.result(assertionF, 2.seconds) Java Instant tInitial = Instant.now();\n\n//create a file\nPath filePath = Paths.get(\"/test.conf\");\nConfigId id = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"initial configuration\").get();\n\n//override the contents\nString newContent = \"I changed the contents!!!\";\nadminApi.update(filePath, ConfigData.fromString(newContent), \"changed!!\").get();\n\nConfigData initialData = adminApi.getByTime(filePath, tInitial).get().get();\nAssert.assertEquals(defaultStrConf, initialData.toJStringF(mat).get());\n\nConfigData latestData = adminApi.getByTime(filePath, Instant.now()).get().get();\nAssert.assertEquals(newContent, latestData.toJStringF(mat).get());","title":"getByTime"},{"location":"/services/config.html#list","text":"For a given FileType(Annex or Normal) and an optional pattern string, it will list all files whose path matches the given pattern. Some pattern examples are: “/path/hcd/*.*”, “a/b/c/d.*”, “.*.conf”, “.*hcd.*”\nScala //Here's a list of tuples containing FilePath and FileTyepe(Annex / Normal)\nval paths: List[(Path, FileType)] = List[(Path, FileType)](\n  (Paths.get(\"a/c/trombone.conf\"), FileType.Annex),\n  (Paths.get(\"a/b/c/hcd/hcd.conf\"), FileType.Normal),\n  (Paths.get(\"a/b/assembly/assembly1.fits\"), FileType.Annex),\n  (Paths.get(\"a/b/c/assembly/assembly2.fits\"), FileType.Normal),\n  (Paths.get(\"testing/test.conf\"), FileType.Normal)\n)\n\n//create config files at those paths\npaths map {\n  case (path, fileType) ⇒\n    val createF = async {\n      await(\n        adminApi.create(path, ConfigData.fromString(defaultStrConf), FileType.Annex == fileType, \"initial commit\")\n      )\n    }\n    Await.result(createF, 2.seconds)\n}\n\nval assertionF = async {\n  //retrieve list of all files; for demonstration purpose show validate return values\n  await(adminApi.list()).map(info ⇒ info.path).toSet shouldBe paths.map {\n    case (path, fileType) ⇒ path\n  }.toSet\n\n  //retrieve list of files based on type; for demonstration purpose validate return values\n  await(adminApi.list(Some(FileType.Annex))).map(info ⇒ info.path).toSet shouldBe paths.collect {\n    case (path, fileType) if (fileType == FileType.Annex) ⇒ path\n  }.toSet\n  await(adminApi.list(Some(FileType.Normal))).map(info ⇒ info.path).toSet shouldBe paths.collect {\n    case (path, fileType) if (fileType == FileType.Normal) ⇒ path\n  }.toSet\n\n  //retrieve list using pattern; for demonstration purpose validate return values\n  await(adminApi.list(None, Some(\".*.conf\"))).map(info ⇒ info.path.toString).toSet shouldBe Set(\n    \"a/b/c/hcd/hcd.conf\",\n    \"a/c/trombone.conf\",\n    \"testing/test.conf\"\n  )\n  //retrieve list using pattern and file type; for demonstration purpose validate return values\n  await(adminApi.list(Some(FileType.Normal), Some(\".*.conf\"))).map(info ⇒ info.path.toString).toSet shouldBe\n  Set(\"a/b/c/hcd/hcd.conf\", \"testing/test.conf\")\n  await(adminApi.list(Some(FileType.Annex), Some(\"a/c.*\"))).map(info ⇒ info.path.toString).toSet shouldBe\n  Set(\"a/c/trombone.conf\")\n  await(adminApi.list(Some(FileType.Normal), Some(\"test.*\"))).map(info ⇒ info.path.toString).toSet shouldBe\n  Set(\"testing/test.conf\")\n}\nAwait.result(assertionF, 2.seconds) Java Path trombonePath = Paths.get(\"a/c/trombone.conf\");\nPath hcdPath = Paths.get(\"a/b/c/hcd/hcd.conf\");\nPath fits1Path = Paths.get(\"a/b/assembly/assembly1.fits\");\nPath fits2Path = Paths.get(\"a/b/c/assembly/assembly2.fits\");\nPath testConfPath = Paths.get(\"testing/test.conf\");\n\nString comment = \"initial commit\";\n\n//create files\nConfigId tromboneId = adminApi.create(trombonePath, ConfigData.fromString(defaultStrConf), true, comment).get();\nConfigId hcdId = adminApi.create(hcdPath, ConfigData.fromString(defaultStrConf), false, comment).get();\nConfigId fits1Id = adminApi.create(fits1Path, ConfigData.fromString(defaultStrConf), true, comment).get();\nConfigId fits2Id = adminApi.create(fits2Path, ConfigData.fromString(defaultStrConf), false, comment).get();\nConfigId testId = adminApi.create(testConfPath, ConfigData.fromString(defaultStrConf), true, comment).get();\n\n//retrieve full list; for demonstration purpose validate return values\nAssert.assertEquals(new HashSet<ConfigId>(Arrays.asList(tromboneId, hcdId, fits1Id, fits2Id, testId)),\n    adminApi.list().get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));\n\n//retrieve list of files based on type; for demonstration purpose validate return values\nAssert.assertEquals(new HashSet<>(Arrays.asList(tromboneId, fits1Id, testId)),\n    adminApi.list(JFileType.Annex).get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));\nAssert.assertEquals(new HashSet<>(Arrays.asList(hcdId, fits2Id)),\n    adminApi.list(JFileType.Normal).get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));\n\n//retrieve list using pattern; for demonstration purpose validate return values\nAssert.assertEquals(new HashSet<>(Arrays.asList(tromboneId, hcdId, testId)),\n    adminApi.list(\".*.conf\").get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));\n//retrieve list using pattern and file type; for demonstration purpose validate return values\nAssert.assertEquals(new HashSet<>(Arrays.asList(tromboneId, testId)),\n    adminApi.list(JFileType.Annex, \".*.conf\").get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));\nAssert.assertEquals(new HashSet<>(Arrays.asList(tromboneId)),\n    adminApi.list(JFileType.Annex, \"a/c.*\").get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));\nAssert.assertEquals(new HashSet<>(Arrays.asList(testId)),\n    adminApi.list(JFileType.Annex, \"test.*\").get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));","title":"list"},{"location":"/services/config.html#history","text":"Returns the history of revisions of the file at the given path for a range of period specified by from and to. The size of the list can be restricted using maxResults. Returns the history of active revisions of the file at the given path for a range of period specified by from and to. The size of the list can be restricted using maxResults.\nScala val assertionF = async {\n  val filePath = Paths.get(\"/a/test.conf\")\n  val id0      = await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"first commit\"))\n\n  //override the contents twice\n  val tBeginUpdate = Instant.now()\n  val id1          = await(adminApi.update(filePath, ConfigData.fromString(\"changing contents\"), \"second commit\"))\n  val id2          = await(adminApi.update(filePath, ConfigData.fromString(\"changing contents again\"), \"third commit\"))\n  val tEndUpdate   = Instant.now()\n\n  //full file history\n  val fullHistory = await(adminApi.history(filePath))\n  fullHistory.map(_.id) shouldBe List(id2, id1, id0)\n  fullHistory.map(_.comment) shouldBe List(\"third commit\", \"second commit\", \"first commit\")\n\n  //drop initial revision and take only update revisions\n  await(adminApi.history(filePath, tBeginUpdate, tEndUpdate)).map(_.id) shouldBe List(id2, id1)\n\n  //take last two revisions\n  await(adminApi.history(filePath, maxResults = 2)).map(_.id) shouldBe List(id2, id1)\n}\nAwait.result(assertionF, 3.seconds) Java Path filePath = Paths.get(\"/a/test.conf\");\nConfigId id0 = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"first commit\").get();\n\n//override the contents twice\nInstant tBeginUpdate = Instant.now();\nConfigId id1 = adminApi.update(filePath, ConfigData.fromString(\"changing contents\"), \"second commit\").get();\nConfigId id2 = adminApi.update(filePath, ConfigData.fromString(\"changing contents again\"), \"third commit\").get();\nInstant tEndUpdate = Instant.now();\n\n//full file history\nList<ConfigFileRevision> fullHistory = adminApi.history(filePath).get();\nAssert.assertEquals(new ArrayList<>(Arrays.asList(id2, id1, id0)),\n    fullHistory.stream().map(ConfigFileRevision::id).collect(Collectors.toList()));\nAssert.assertEquals(new ArrayList<>(Arrays.asList(\"third commit\", \"second commit\", \"first commit\")),\n    fullHistory.stream().map(ConfigFileRevision::comment).collect(Collectors.toList()));\n\n//drop initial revision and take only update revisions\nAssert.assertEquals(new ArrayList<>(Arrays.asList(id2, id1)),\n    adminApi.history(filePath, tBeginUpdate, tEndUpdate).get().stream().map(ConfigFileRevision::id).collect(Collectors.toList()));\n//take last two revisions\nAssert.assertEquals(new ArrayList<>(Arrays.asList(id2, id1)),\n    adminApi.history(filePath, 2).get().stream().map(ConfigFileRevision::id).collect(Collectors.toList()));","title":"history"},{"location":"/services/config.html#managing-active-versions","text":"Following API functions are available to manage the active version of a config file. In its lifetime a config file undergoes many revisions. An active version is a specific revision from a file’s history and it is set by administrators.\nhistoryActive : Returns the history of active revisions of the file at the given path for a range of period specified by from and to. The size of the list can be restricted using maxResults. setActiveVersion : Sets the “active version” to be the version provided for the file at the given path. If this method is never called in a config’s lifetime, the active version will always be the version returned by create function. resetActiveVersion : Resets the “active version” of the file at the given path to the latest version. getActiveVersion : Returns the revision Id which represents the “active version” of the file at the given path. getActiveByTime : Returns the content of active version of the file existed at given instant\nScala val assertionF = async {\n  val tBegin   = Instant.now()\n  val filePath = Paths.get(\"/a/test.conf\")\n  //create will make the 1st revision active with a default comment\n  val id1 = await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, \"first\"))\n  await(adminApi.historyActive(filePath)).map(_.id) shouldBe List(id1)\n  //ensure active version is set\n  await(adminApi.getActiveVersion(filePath)).get shouldBe id1\n\n  //override the contents four times\n  await(adminApi.update(filePath, ConfigData.fromString(\"changing contents\"), \"second\"))\n  val id3 = await(adminApi.update(filePath, ConfigData.fromString(\"changing contents again\"), \"third\"))\n  val id4 = await(adminApi.update(filePath, ConfigData.fromString(\"final contents\"), \"fourth\"))\n  val id5 = await(adminApi.update(filePath, ConfigData.fromString(\"final final contents\"), \"fifth\"))\n\n  //update doesn't change the active revision\n  await(adminApi.historyActive(filePath)).map(_.id) shouldBe List(id1)\n\n  //play with active version\n  await(adminApi.setActiveVersion(filePath, id3, s\"$id3 active\"))\n  await(adminApi.setActiveVersion(filePath, id4, s\"$id4 active\"))\n  await(adminApi.getActiveVersion(filePath)).get shouldBe id4\n  val tEnd = Instant.now()\n  //reset active version to latest\n  await(adminApi.resetActiveVersion(filePath, \"latest active\"))\n  await(adminApi.getActiveVersion(filePath)).get shouldBe id5\n  //finally set initial version as active\n  await(adminApi.setActiveVersion(filePath, id1, s\"$id1 active\"))\n  await(adminApi.getActiveVersion(filePath)).get shouldBe id1\n\n  //validate full history\n  val fullHistory = await(adminApi.historyActive(filePath))\n  fullHistory.map(_.id) shouldBe List(id1, id5, id4, id3, id1)\n  fullHistory.map(_.comment) shouldBe List(s\"$id1 active\",\n                                           \"latest active\",\n                                           s\"$id4 active\",\n                                           s\"$id3 active\",\n                                           \"initializing active file with the first version\")\n\n  //drop initial revision and take only update revisions\n  val fragmentedHistory = await(adminApi.historyActive(filePath, tBegin, tEnd))\n  fragmentedHistory.size shouldBe 3\n\n  //take last three revisions\n  await(adminApi.historyActive(filePath, maxResults = 3)).map(_.id) shouldBe List(id1, id5, id4)\n\n  //get contents of active version at a specified instance\n  val initialContents = await(adminApi.getActiveByTime(filePath, tBegin)).get\n  await(initialContents.toStringF) shouldBe defaultStrConf\n}\nAwait.result(assertionF, 5.seconds) Java Instant tBegin = Instant.now();\nPath filePath = Paths.get(\"/a/test.conf\");\n\n//create will make the 1st revision active with a default comment\nConfigId id1 = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, \"first commit\").get();\nAssert.assertEquals(new ArrayList<>(Arrays.asList(id1)),\n    adminApi.historyActive(filePath).get().stream().map(ConfigFileRevision::id).collect(Collectors.toList()));\n//ensure active version is set\nAssert.assertEquals(id1, adminApi.getActiveVersion(filePath).get().get());\n\n//override the contents four times\nadminApi.update(filePath, ConfigData.fromString(\"changing contents\"), \"second\").get();\nConfigId id3 = adminApi.update(filePath, ConfigData.fromString(\"changing contents again\"), \"third\").get();\nConfigId id4 = adminApi.update(filePath, ConfigData.fromString(\"final contents\"), \"fourth\").get();\nConfigId id5 = adminApi.update(filePath, ConfigData.fromString(\"final final contents\"), \"fifth\").get();\n\n//update doesn't change the active revision\nAssert.assertEquals(id1, adminApi.getActiveVersion(filePath).get().get());\n\n//play with active version\nadminApi.setActiveVersion(filePath, id3, \"id3 active\").get();\nadminApi.setActiveVersion(filePath, id4, \"id4 active\").get();\nAssert.assertEquals(id4, adminApi.getActiveVersion(filePath).get().get());\nInstant tEnd = Instant.now();\n\n//reset active version to latest\nadminApi.resetActiveVersion(filePath, \"latest active\").get();\nAssert.assertEquals(id5, adminApi.getActiveVersion(filePath).get().get());\n//finally set initial version as active\nadminApi.setActiveVersion(filePath, id1, \"id1 active\").get();\nAssert.assertEquals(id1, adminApi.getActiveVersion(filePath).get().get());\n\n//validate full history\nList<ConfigFileRevision> fullHistory = adminApi.historyActive(filePath).get();\nAssert.assertEquals(new ArrayList<>(Arrays.asList(id1, id5, id4, id3, id1)),\n        fullHistory.stream().map(ConfigFileRevision::id).collect(Collectors.toList()));\nAssert.assertEquals(new ArrayList<>(Arrays.asList(\"id1 active\", \"latest active\", \"id4 active\", \"id3 active\",\n        \"initializing active file with the first version\")),\n        fullHistory.stream().map(ConfigFileRevision::comment).collect(Collectors.toList()));\n\n//drop initial revision and take only update revisions\nList<ConfigFileRevision> fragmentedHistory = adminApi.historyActive(filePath, tBegin, tEnd).get();\nAssert.assertEquals(3, fragmentedHistory.size());\n\n//take last three revisions\nAssert.assertEquals(new ArrayList<>(Arrays.asList(id1, id5, id4)),\n        adminApi.historyActive(filePath, 3).get().stream().map(ConfigFileRevision::id).collect(Collectors.toList()));\n\n//get contents of active version at a specified instance\nString initialContents = adminApi.getActiveByTime(filePath, tBegin).get().get().toJStringF(mat).get();\nAssert.assertEquals(defaultStrConf, initialContents);","title":"Managing active versions"},{"location":"/services/config.html#getmetadata","text":"Used to get metadata information about config service. It includes:\nrepository directory annex directory min annex file size max config file size\nScala val assertF = async {\n  val metaData: ConfigMetadata = await(adminApi.getMetadata)\n  //repository path must not be empty\n  metaData.repoPath should not be empty\n}\nAwait.result(assertF, 2.seconds) Java ConfigMetadata metadata = adminApi.getMetadata().get();\n//repository path must not be empty\nAssert.assertNotEquals(metadata.repoPath(), \"\");","title":"getMetaData"},{"location":"/services/config.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source code for examples"},{"location":"/services/logging.html","text":"","title":"Logging Service"},{"location":"/services/logging.html#logging-service","text":"Logging Service library provides an advanced logging facility for csw components and services.\nNote With this release of CSW, only the local logging is provided. A future release will provide the centralized logging facility.","title":"Logging Service"},{"location":"/services/logging.html#dependencies","text":"To use the Logging Service without using the framework, add this to your build.sbt file:\nsbt libraryDependencies += \"org.tmt\" %% \"csw-logging\" % \"0.1.2\"","title":"Dependencies"},{"location":"/services/logging.html#configuration","text":"These are the relevant default configuration values for logging\nlogging.conf csw-logging {\n\n    # Default appender and is recommended only for dev setup.\n    # To use multiple appenders give comma separated list of appenders.\n    appenders = [\"csw.services.logging.appenders.StdOutAppender$\"]\n\n    # Recommended for production setup - Uncomment below line and comment above to enable FileAppender\n    #appenders = [\"csw.services.logging.appenders.FileAppender$\"]\n\n    component-log-levels {\n      # By default each compoent will use log level specified by `csw-logging.logLevel`. If required, this block allows\n      # overriding log level configuration for one/more components.\n      # -- Example --\n      # TromboneHcd = debug\n      # TromboneAssembly = error\n    }\n\n    appender-config {\n      file {\n        # Include standard headers\n        fullHeaders = true\n        # Sort the fields in Json objects\n        sorted = true\n        # Directory to hold log files.\n        logPath = \"/tmp/\"\n        # Common log messages below this level are removed, none removed when set to trace\n        logLevelLimit = trace\n        # Flag to turn file rotation ON or OFF. Currently log file is rotated daily at 12:00 pm UTC time. By turning this flag off\n        # file rotation will not happen.\n        rotate = true\n      }\n      stdout {\n        # Include standard headers\n        fullHeaders = false\n        # Use colors for log levels\n        color = true\n        # The maximum number of character that should be on a line\n        # This is only a goal; in practice some may contain more characters.\n        width = 80\n        # Print summary counts when logger is closed\n        summary = true\n        # pretty output - multiple line json\n        pretty = false\n        # Messages below this level are removed, none removed when set to trace\n        logLevelLimit = trace\n        # false Json output; true simple one line text output\n        oneLine = false\n      }\n    }\n    # If component does not specify their log level in component-log-levels block,\n    # Then this will be considered as default log level for that component.\n    logLevel = info\n    # Log level for slf4j messages\n    slf4jLogLevel = info\n    # Log level for Akka messages\n    akkaLogLevel = warn\n    # Enable timing logging\n    time = false\n    # Enable garbage collection logging\n    gc = false\n}\nIMPORTANT !!! It is required to include logging.conf that is shipped with this library in application.conf as follows: include \"logging.conf\"\n Default configuration values can be then overridden in application.conf.\nAlso logLevel for each component can be set in application.conf as follows:\ncomponent-log-levels {\n    tromboneHcd = debug\n    tromboneAssembly = error\n  }\nNote Here tromboneHcd and tromboneAssembly is the name of component that will be registered with LocationService. By default all components will log at level specified by csw-logging.logLevel.\nLibrary provides StdOutAppender as default logging appender. To use FileAppender or some custom appender along-with StdOutAppender, override appenders property to include multiple appender in csv format as follows:\nappenders = [\"csw.services.logging.appenders.FileAppender$\", \"csw.services.logging.appenders.StdOutAppender$\"]\nNote Make sure to provide full path of the appender since it will be spawned using java reflection. In csw code base, a working example of custom appender can be found at: Custom Appender\nFor StdOutAppender specify the format of log statements in csw-logging.stdout via csw-logging.stdout.pretty and csw-logging.stdout.oneLine.\nTurning pretty on or off will produce log statements in following format:\npretty=true {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"LocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"@version\":\"0.1\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53618/user/$a\",\n \"class\":\"csw.services.location.LocationServiceExampleClient\",\n \"file\":\"LocationServiceExampleClientApp.scala\",\n \"line\":149,\n \"message\":\"Result of the find call: None\",\n \"timestamp\":\"2017-11-30T10:58:03.102Z\"\n }\n pretty=false {\"@componentName\":\"my-component-name\",\"@host\":\"INsaloni.local\",\"@name\":\"LocationServiceExampleClient\",\"@severity\":\"INFO\",\"@version\":\"0.1\",\"actor\":\"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53618/user/$a\",\"class\":\"csw.services.location.LocationServiceExampleClient\",\"file\":\"LocationServiceExampleClientApp.scala\",\"line\":149,\"message\":\"Result of the find call: None\",\"timestamp\":\"2017-11-24T04:16:42.108Z\"}\nSimilarly, turning oneLine on will produce log statements in following format:\noneLine=true [INFO] Attempting to find connection (LocationServiceExampleClientApp.scala 131)\nNote If oneLine is set to true then value of pretty will be ignored","title":"Configuration"},{"location":"/services/logging.html#log-levels","text":"Following Log levels are supported by csw-logging library\nFATAL ERROR WARN INFO DEBUG TRACE\nLibrary allows separate log levels for the logging API(logLevel), Akka logging(akkaLogLevel), and Slf4J(slf4jLogLevel). The initial values of these are set in the configuration file as seen above. These can be overriden in the application.conf file.\nThese values can also be changed dynamically by calling methods on LoggingSystem class.","title":"Log Levels"},{"location":"/services/logging.html#log-structure","text":"All messages are logged by default as Json. Logs can contain following fields:\n@componentName: The name of the component if present @host: The local host name @name: The name of the application being run @version: The version of the application being run @severity: The message level: trace, debug, info, warn, error or fatal actor: The path for an actor when using ActorLogging class: The class for ClassLogging or ActorLogging file: The file containing the log call kind: Either slf4j or akka. Not present for logger API line: The line where the message was logged message: The log message timestamp: The UTC time when the message was logged trace: Information for any exception specified in the logging call\nNote @host, @name and @version will appear in log statements only if fullHeaders is set as true in the configuration file and line will appear only in log statements from Scala classes/actors. This is typical for Java logging tools, and is due to the lack of macro support in Java.","title":"Log Structure"},{"location":"/services/logging.html#enable-component-logging","text":"Component developers will have an instance of LoggerFactory available from csw-framework. This instance will already have a componentName set by csw-framework which will appear in log statements against @componentName tag. Next, to get the Logger from LoggerFactory use one of the following ways:\nScala Class class SampleClass(loggerFactory: LoggerFactory) {\n\n  val log: Logger = loggerFactory.getLogger\n} Java Class public class JSampleClass {\n\n    public JSampleClass(JLoggerFactory loggerFactory) {\n        ILogger log = loggerFactory.getLogger(getClass());\n    }\n}\nScala Actor class SampleActor(loggerFactory: LoggerFactory) extends akka.actor.Actor {\n\n  //context is available from akka.actor.Actor\n  val log: Logger = loggerFactory.getLogger(context)\n\n  override def receive = ???\n} Java Actor class JSampleActor extends akka.actor.AbstractActor {\n\n    public JSampleActor(JLoggerFactory loggerFactory) {\n\n        //context() is available from akka.actor.AbstractActor\n        ILogger log = loggerFactory.getLogger(context(), getClass());\n    }\n\n    @Override\n    public Receive createReceive() {\n        return null;\n    }\n}\nScala Typed Actor class SampleTypedActor(loggerFactory: LoggerFactory, ctx: ActorContext[ComponentMessage]) {\n\n  val log: Logger = loggerFactory.getLogger(ctx)\n} Java Typed Actor class JSampleTypedActor {\n\n    public JSampleTypedActor(JLoggerFactory loggerFactory, ActorContext<ComponentMessage> ctx) {\n        ILogger log = loggerFactory.getLogger(ctx, getClass());\n    }\n}\nNote The LoggerFactory can be changed to JLoggerFactory by using asJava method and JLoggerFactory can be changed to LoggerFactory by using asScala method","title":"Enable Component Logging"},{"location":"/services/logging.html#enable-generic-logging","text":"In case there is a need to log statements without @componentName tag, which can be due to unavailability of componentName in some utility code, then use the GenericLoggerFactory as follows:\nScala Class class GenericClass {\n\n  val log: Logger = GenericLoggerFactory.getLogger\n} Java Class public class JGenericClass {\n\n    ILogger log = JGenericLoggerFactory.getLogger(getClass());\n}\nScala Actor class GenericActor extends akka.actor.AbstractActor {\n\n  //context is available from akka.actor.Actor\n  val log: Logger = GenericLoggerFactory.getLogger(context)\n\n  override def createReceive() = ???\n} Java Actor class JGenericActor extends akka.actor.AbstractActor {\n\n    //context() is available from akka.actor.AbstractActor\n    ILogger log = JGenericLoggerFactory.getLogger(context(), getClass());\n\n    @Override\n    public Receive createReceive() {\n        return null;\n    }\n}\nScala Typed Actor class GenericTypedActor(ctx: ActorContext[ComponentMessage]) {\n\n  val log: Logger = GenericLoggerFactory.getLogger(ctx)\n} Java Typed Actor class JGenericTypedActor {\n\n    public JGenericTypedActor(ActorContext<ComponentMessage> ctx) {\n        ILogger log = JGenericLoggerFactory.getLogger(ctx, getClass());\n    }\n}\nlog variable is now available in scala and java classes to write log statements as explained in next segment.","title":"Enable Generic Logging"},{"location":"/services/logging.html#log-statements","text":"Logging statements are used very much like existing logging services such as log4j. For Java, there is an additional way of writing log messages using Supplier methods (lambdas). The use of lambdas is more efficient since the computations in a message (e.g. string concatenation) are not performed unless the message is actually being logged. Therefore, these supplier methods should be used in cases where high performance is required (see performance results below).\nA basic info statement can be written as follows:\nScala log.info(s\"Result of the find call: $findResult\") Java log.info(\"Find result: \" + connectionInfo(findResult.get().connection())); Java (Supplier) log.info(() -> \"Resolve result: \" + connectionInfo(resolveResult.get().connection()));\nThe output of log statement will be:\nScala {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"LocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"@version\":\"0.1\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53618/user/$a\",\n \"class\":\"csw.services.location.LocationServiceExampleClient\",\n \"file\":\"LocationServiceExampleClientApp.scala\",\n \"line\":149,\n \"message\":\"Result of the find call: None\",\n \"timestamp\":\"2017-11-30T10:58:03.102Z\"\n }\n Java {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"JLocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"@version\":\"0.1\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53625/user/LocationServiceExampleClient\",\n \"class\":\"csw.services.location.JLocationServiceExampleClient\",\n \"message\":\"Result of the find call : None\",\n \"timestamp\":\"2017-11-30T11:02:54.691Z\"\n}\n Java (Supplier) {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"JLocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53625/user/LocationServiceExampleClient\",\n \"class\":\"csw.services.location.JLocationServiceExampleClient\",\n \"message\":\n   \"Resolve result: LocationServiceExampleComponent-assembly-akka, component type=Assembly, connection type=AkkaType\",\n \"timestamp\":\"2017-07-26T19:44:58.636Z\"\n}\nLibrary allows usage of Map in message as follows:\nScala log.info(s\"Attempting to find $exampleConnection\",\n         Map(Keys.OBS_ID → \"foo_obs_id\", \"exampleConnection\" → exampleConnection.name)) Java log.info(\"Attempting to find \" + exampleConnection,\n        new HashMap<String, Object>() {{\n            put(JKeys.OBS_ID, \"foo_obs_id\");\n            put(\"exampleConnection\", exampleConnection.name());\n        }}); Java (Supplier) log.info(() -> \"Attempting to resolve \" + exampleConnection + \" with a wait of \" + waitForResolveLimit + \"...\", () -> {\n    Map<String, Object> map = new HashMap<>();\n    map.put(JKeys.OBS_ID, \"foo_obs_id\");\n    map.put(\"exampleConnection\", exampleConnection.name());\n    return map;\n});\nThe output of log statement will be:\nScala {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"LocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"@version\":\"0.1\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53618/user/$a\",\n \"class\":\"csw.services.location.LocationServiceExampleClient\",\n \"exampleConnection\":\"LocationServiceExampleComponent-assembly-akka\",\n \"file\":\"LocationServiceExampleClientApp.scala\",\n \"line\":143,\n \"message\":\n   \"Attempting to find AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))\",\n \"obsId\":\"foo_obs_id\",\n \"timestamp\":\"2017-11-30T10:58:03.097Z\"\n}\n Java {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"JLocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"@version\":\"0.1\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53625/user/LocationServiceExampleClient\",\n \"class\":\"csw.services.location.JLocationServiceExampleClient\",\n \"exampleConnection\":\"LocationServiceExampleComponent-assembly-akka\",\n \"message\":\n   \"Attempting to find AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly))\",\n \"obsId\":\"foo_obs_id\",\n \"timestamp\":\"2017-11-30T11:02:54.686Z\"\n}\n Java (Supplier) {\"@componentName\":\"my-component-name\",\n \"@host\":\"INsaloni.local\",\n \"@name\":\"JLocationServiceExampleClient\",\n \"@severity\":\"INFO\",\n \"@version\":\"0.1\",\n \"actor\":\n   \"akka.tcp://csw-examples-locationServiceClient@10.131.23.195:53625/user/LocationServiceExampleClient\",\n \"class\":\"csw.services.location.JLocationServiceExampleClient\",\n \"exampleConnection\":\"LocationServiceExampleComponent-assembly-akka\",\n \"message\":\n   \"Attempting to resolve AkkaConnection(ComponentId(LocationServiceExampleComponent,Assembly)) with a wait of 30 seconds...\",\n \"obsId\":\"foo_obs_id\",\n \"timestamp\":\"2017-11-24T04:22:02.589Z\"\n}\nLibrary allows to log an error with its full stacktrace as follows:\nScala val runtimeException = new RuntimeException(s\"Received unexpected message $x\")\nlog.error(runtimeException.getMessage, ex = runtimeException) Java } catch (InterruptedException | ExecutionException ex) {\n    log.info(ex.getMessage(), ex);\n    throw ex;\n} Java (Supplier) RuntimeException runtimeException = new RuntimeException(\"Received unexpected message \" + x);\nlog.info(() -> runtimeException.getMessage(), runtimeException);","title":"Log Statements"},{"location":"/services/logging.html#create-loggerfactory","text":"","title":"Create LoggerFactory"},{"location":"/services/logging.html#available-for-test-understanding-purpose","text":"In order to create a LoggerFactory with a custom componentName refer the following code:\nScala val loggerFactory: LoggerFactory = new LoggerFactory(\"my-component-name\")\n\n// convert a scala LoggerFactory to java JLoggerFactory\nval jLoggerFactory: JLoggerFactory = loggerFactory.asJava Java JLoggerFactory jLoggerFactory = new JLoggerFactory(\"my-component-name\");\n\n// convert a java JLoggerFactory to scala LoggerFactory\nLoggerFactory loggerFactory = jLoggerFactory.asScala();","title":"Available for test/understanding purpose"},{"location":"/services/logging.html#create-loggingsystem","text":"","title":"Create LoggingSystem"},{"location":"/services/logging.html#available-for-test-understanding-purpose","text":"For logging statements to appear in the program, start LoggingSystem at an earliest location in an application. Also note, LoggingSystem should be started only once in an application. The name used while creating LoggingSystem will be used to create the folder and dump all logging files.\nScala private val host = InetAddress.getLocalHost.getHostName\n// Only call this once per application\nval loggingSystem: LoggingSystem = LoggingSystemFactory.start(\"LocationServiceExampleClient\", \"0.1\", host, system) Java String host = InetAddress.getLocalHost().getHostName();\nloggingSystem = JLoggingSystemFactory.start(\"JLocationServiceExampleClient\", \"0.1\", host, actorSystem);\nNote The hostname that is provided while creating LoggingSystem will appear in log statements against @host tag","title":"Available for test/understanding purpose"},{"location":"/services/logging.html#stop-loggingsystem","text":"","title":"Stop LoggingSystem"},{"location":"/services/logging.html#available-for-test-understanding-purpose","text":"Please ensure to stop LoggingSystem before application exits.\nScala // Only call this once per application\nAwait.result(loggingSystem.stop, 30.seconds) Java // Only call this once per application\nloggingSystem.javaStop().get();","title":"Available for test/understanding purpose"},{"location":"/services/logging.html#source-code-for-examples","text":"Scala Example Java Example","title":"Source code for examples"},{"location":"/services/logging.html#performance","text":"Performance results documented on this page is measured in terms of Throughput and obtained with the JMH Java benchmark harness. Sourcecode for all the JMH benchmarks can be found here at CSW Benchmarks\nWikipedia definition of Throughput is the maximum rate of production or the maximum rate at which something can be processed. In our case, throughput is defined as how many messages can be logged in a certain period of time.","title":"Performance"},{"location":"/services/logging.html#test-machine-configuration-","text":"MacBook Pro (Retina, 15-inch, Mid 2015) Processor Name: Intel Core i7 Processor Speed: 2.8 GHz No. of Processors: 1 No. of Cores: 4 L2 Cache (per Core): 256 KB L3 Cache: 6 MB Memory: 16 GB 1600 MHz DDR3 JDK: 1.8.0_121","title":"Test Machine Configuration :"},{"location":"/services/logging.html#scala-logging-appenders-throughput","text":"Above graph includes the throughput results for File and StdOut appender’s using scala’s logging API. Java’s logging API throughput results are included further down this page. As shown in the above graph, experiment was carried out for 1, 2, 4, 8 and 16 threads. That means, multiple threads are logging messages concurrently.\nNote Numbers indicated in the graph does not mean that those number of messages are actually written to file or console. These are the number of logging messages sent to LogActor asynchronously for the period of one second. It is the responsibility of LogActor to write these messages to file or console. LogActor uses BoundedMailbox with a mailbox-capacity = 262144, messages are dropped if mailbox gets full.","title":"Scala Logging : Appender’s Throughput"},{"location":"/services/logging.html#scala-and-java-logging-throughput-comparision-log-level-enabled-vs-disabled-","text":"Below graph depicts the throughput of Java’s logging API (String and Supplier) and scala’s logging API when log level was enabled and disabled.\nNote Log Level Enabled : Results are obtained for log.info when default log level was set to info, that means the logging messages were sent to LogActor for writing it to file. Log Level Disabled : Results are obtained for log.trace when default log level was set to info, that means the logging messages were not written to file.\nThis graph is produced based on the result generated by JE2ELoggingBenchmark and E2ELoggingBenchmark\nNote As you can see in the above graph, Supplier version of Java log API and by name of scala API is very efficient and throughput is much higher than String version. It is recommended to use Supplier API by java developers.","title":"Scala And Java Logging : Throughput Comparision (Log Level Enabled vs Disabled)"},{"location":"/services/logging.html#acknowledgement","text":"The codebase in csw-logging module is based on persist-logging library. We appreciate efforts put in by authors of the persist-logging library which made our development fast and easy.","title":"Acknowledgement"},{"location":"/commons/apps.html","text":"","title":"Applications"},{"location":"/commons/apps.html#applications","text":"csw-cluster-seed csw-location-agent csw-config-server csw-config-client-cli csw-host-config","title":"Applications"},{"location":"/apps/cswclusterseed.html","text":"","title":"csw-cluster-seed"},{"location":"/apps/cswclusterseed.html#csw-cluster-seed","text":"This application will start a CSW cluster seed required for all clustered services like Location Service. It is required that you start one or more seed applications before consuming Location Service. Even though a single seed app is good enough to make use of Location Service it is recommended that in production you deploy more than one instance on different machines to get fault tolerance in case one of the machines hosting the seed crashes.","title":"csw-cluster-seed"},{"location":"/apps/cswclusterseed.html#prerequisite","text":"The command sbt csw-cluster-seed/universal:publishLocal will publish necessary artifacts to run csw-cluster-seed application.\nThe target of above command is a zip file titled “csw-cluster-seed.zip” and its path will be printed on console. Unzip this file and switch current working directory to the extracted folder. Choose appropriate instructions from below based on requirement ie single seed or multiple seeds.","title":"Prerequisite"},{"location":"/apps/cswclusterseed.html#if-deploying-a-single-seed-application","text":"The steps below describe how to run cluster seed on a single machine. This can be a requirement for testing or demo purpose.\nPreparation: Find out the IP address and dedicated port for running the seed. Assume that IP is 192.168.1.21 and port is 3552.\nProvisioning: Make sure you have the environment variable clusterSeeds set to the IP address and port as in 192.168.1.21:3552\nRunning: Switch to application directory and run this command - ./bin/csw-cluster-seed --clusterPort=3552","title":"If Deploying a Single Seed Application"},{"location":"/apps/cswclusterseed.html#if-deploying-two-seed-applications","text":"The steps below describe how to run cluster seed on multiple machines, which is the recommended set-up for production usage.\nPreparation: Identify machines which are to run cluster seeds. Let’s assume they are two for now, and the IP address for machine1 is 192.168.1.21 and for machine2 is 192.168.1.22. Also, they will both have dedicated port 3552 to run the seeds.\nProvisioning: Make sure you have the environment variable clusterSeeds set to 192.168.1.21:3552,192.168.1.22:3552 on machine1 and machine2.\nSwitch to application directory and run this command on machine1 and machine2 - ./bin/csw-cluster-seed --clusterPort=3552","title":"If Deploying Two Seed Applications"},{"location":"/apps/cswclusterseed.html#help","text":"Use the following command to get help on the options available with this app.\n./bin/csw-cluster-seed --help","title":"Help"},{"location":"/apps/cswclusterseed.html#version","text":"Use the following command to get version information for this app.\n./bin/csw-cluster-seed --version","title":"Version"},{"location":"/apps/cswlocationagent.html","text":"","title":"csw-location-agent"},{"location":"/apps/cswlocationagent.html#csw-location-agent","text":"A utility application that starts a given external program, registers a comma separated list of services with the Location Service and unregisters them when the program exits.","title":"csw-location-agent"},{"location":"/apps/cswlocationagent.html#command-line-parameter-options","text":"--names is a required parameter. It needs to be a list of comma separated service names without a space after comma. --command is an optional parameter. The command that starts the target application. Use use %port to specify the port number. If parameter is not provided value $name.command from config file will be picked up. If value in config file is not found, the service names provided will be registered with Location Service. --port the optional port number the application listens on (default: use value of $name.port from config file, or use a random, free port.) an optional config file in HOCON format. Will be automatically picked based on –names parameter (Options specified as: $name.command, $name.port, etc.) --delay the number of milliseconds to wait for the app to start before registering it with the Location Service (default: 1000) --no-exit For testing: prevents application from exiting after running command --help Prints the help message. --version Prints the version of the application.","title":"Command line parameter options"},{"location":"/apps/cswlocationagent.html#examples","text":"Example: csw-location-agent –name “redis” –command “redis-server /usr/local/etc/redis.conf” –port 6379 Explanation: Application will start redis server on port 6379(default redis port) and will register a TcpConnection for the same with Location Service\nExample: csw-location-agent –name “foo” –command “sleep 30” Explanation: Explanation: Application will sleep for 30 seconds. Then, will register a service named foo on a random port with Location Service. Once sleep is over after 30 seconds, will unregister foo service.\nExample: csw-location-agent –name “myHttpService” –command “python -m SimpleHTTPServer 8080” –port 8080 Explanation: Application will start a simple HTTP service on port 8080. Then, will register myHttpService as a TCP service with Location Service.\nExample: csw-location-agent –help Explanation: Prints help message\nExample: csw-location-agent –version Explanation: Prints application version","title":"Examples"},{"location":"/apps/cswonfigserverapp.html","text":"","title":"csw-config-server"},{"location":"/apps/cswonfigserverapp.html#csw-config-server","text":"A HTTP server application that hosts Configuration Service.","title":"csw-config-server"},{"location":"/apps/cswonfigserverapp.html#prerequisites","text":"The HTTP server hosting Configuration Service needs to be part of csw-cluster so that it can be consumed by other components. A required check before starting configuration service is to ensure the csw-cluster is setup and seed nodes are available. Kindly refer to this cluster-seed setup for more information about cluster-seed setup.","title":"Prerequisites"},{"location":"/apps/cswonfigserverapp.html#command-line-parameter-options","text":"--initRepo is an optional parameter. When supplied, server will try to initialize a repository if it does not exist. --port is an optional parameter. When specified the HTTP server will start on this port. Default will be 4000. --help prints the help message. --version prints the version of the application.","title":"Command line parameter options"},{"location":"/apps/cswonfigserverapp.html#examples","text":"Example: csw-config-server –initRepo Explanation: Start HTTP server on default port 4000. Initialize repository if it does not exist and register it with Location Service\nExample: csw-config-server –initRepo –port 4001 Explanation: Start HTTP server on port 4001. Initialize repository if it does not exist and register it with Location Service\nExample: csw-config-server –help Explanation: Prints help message\nExample: csw-config-server –version Explanation: Prints application version","title":"Examples"},{"location":"/apps/cswconfigclientcli.html","text":"","title":"csw-config-client-cli"},{"location":"/apps/cswconfigclientcli.html#csw-config-client-cli","text":"A command line application that facilitates interaction with Configuration Service. It accepts various commands to store, retrieve, list and manage configuration files.","title":"csw-config-client-cli"},{"location":"/apps/cswconfigclientcli.html#supported-commands","text":"Note: Exactly one operation must be specified from this list - {create | update | get | delete | list | history | setActiveVersion | resetActiveVersion | getActiveVersion | getActiveByTime | getMetadata | exists | getActive}","title":"Supported Commands"},{"location":"/apps/cswconfigclientcli.html#admin-api","text":"The commands listed below will be used by administrators and maintainers of Configuration Service.","title":"Admin API"},{"location":"/apps/cswconfigclientcli.html#create","text":"Takes an input source file and creates the configuration in the repository at a specified path.\n‘relativeRepoPath’ is path in the repository -i, --in is input file path --annex is optional parameter. Add this option to specify if the input file must be save to annex store. It usually is the case if file is binary/large(>10 MiB) -c, --comment optional create comment","title":"create"},{"location":"/apps/cswconfigclientcli.html#update","text":"Overwrites the file specified in the repository by the input file.\n‘path’ is path in the repository -i, --in is input file path -c, --comment optional create comment","title":"update"},{"location":"/apps/cswconfigclientcli.html#get","text":"Retrieves a file for a given path and saves it to the output file. The latest file is fetched if neither date nor id is specified.\n‘relativeRepoPath’ is path in the repository. -o, --out is output file path --id optional. if specified this id will be matched --date optional. if specified will get the file matching this date. Format: 2017-04-16T16:15:23.503Z","title":"get"},{"location":"/apps/cswconfigclientcli.html#delete","text":"Deletes the file at the specified path in the repository.\n‘relativeRepoPath’ is path in the repository -c, --comment optional delete comment","title":"delete"},{"location":"/apps/cswconfigclientcli.html#list","text":"Lists the files in the repository. Can’t use ‘–annex’ and ‘–normal’ together.\n--annex optional parameter. List all files that are of annex type. --normal optional parameter. List all files that are of normal type. --pattern optional parameter. List all files whose path matches the given pattern. e.g. “/path/hcd/*.*”, “a/b/c/d.*”, “.*.conf”, “.*hcd.*”","title":"list"},{"location":"/apps/cswconfigclientcli.html#history","text":"Shows the version history of the file in the repository.\n‘relativeRepoPath’ is path in the repository --max optional parameter. maximum no of files to be retrieved","title":"history"},{"location":"/apps/cswconfigclientcli.html#setactiveversion","text":"Sets the active version of the file in the repository.\n‘relativeRepoPath’ is path in the repository --id optional parameter. version id of the repository file to set as active. -c, --comment optional delete comment","title":"setActiveVersion"},{"location":"/apps/cswconfigclientcli.html#resetactiveversion","text":"Resets the active version to the latest version for the specified file path.\n‘relativeRepoPath’ is path in the repository -c, --comment optional reset comment","title":"resetActiveVersion"},{"location":"/apps/cswconfigclientcli.html#getactiveversion","text":"Gets the id of the active version of the file in the repository.\n‘relativeRepoPath’ is path in the repository","title":"getActiveVersion"},{"location":"/apps/cswconfigclientcli.html#getactivebytime","text":"Gets the file that was active at a specified time.\n‘relativeRepoPath’ is path in the repository -o, --out is output file path --date optional. if specified will get the active file matching this date. Format: 2017-04-16T16:15:23.503Z","title":"getActiveByTime"},{"location":"/apps/cswconfigclientcli.html#getmetadata","text":"Gets the metadata of Configuration Service server e.g. repository directory, annex directory, min annex file size, max config file size.","title":"getMetadata"},{"location":"/apps/cswconfigclientcli.html#client-api","text":"The following commands are available for component developers.","title":"Client API"},{"location":"/apps/cswconfigclientcli.html#exists","text":"Checks if the file exists at specified path in the repository.\n‘relativeRepoPath’ is path in the repository","title":"exists"},{"location":"/apps/cswconfigclientcli.html#getactive","text":"Retrieves active file for a given path from Configuration Service and writes it to the output file. * ‘relativeRepoPath’ is path in the repository * -o, --out is output file path","title":"getActive"},{"location":"/apps/cswconfigclientcli.html#about-this-application","text":"","title":"About this application"},{"location":"/apps/cswconfigclientcli.html#help","text":"Prints the help message.","title":"–help"},{"location":"/apps/cswconfigclientcli.html#version","text":"Prints the version of the application.","title":"–version"},{"location":"/apps/cswconfigclientcli.html#examples","text":"Example: csw-config-client-cli “create” “/path/hcd/trombone.conf” -i “/Users/admin/configs/trombone.conf” -c “Initial version” Explanation: Creates a config file at path ‘/path/hcd/trombone.conf’, using local file at “/Users/admin/configs/trombone.conf”, with “Initial version” as a comment.\nExample: csw-config-client-cli “create” “/path/hcd/trombone.conf” -i “/Users/admin/large-configs/bigBinary.conf” –annex Explanation: Creates a config file at path ‘/path/hcd/trombone.conf’, using local file at “/Users/admin/large-configs/bigBinary.conf”, file will be stored in annex store.\nExample: csw-config-client-cli “update” “/path/hcd/trombone.conf” -i “/Users/foo/new_trombone.conf” -c “new conf for next observation” Explanation: Updates repository file “/path/hcd/trombone.conf”, with a local file at “/Users/foo/new_trombone.conf”, using a specified comment.\nExample: csw-config-client-cli “get” “/path/hcd/trombone.conf” -o “/Users/bar/temp/latest_trombone.conf” Explanation: Gets repository file “/path/hcd/trombone.conf”, stores at local disk location “/Users/bar/temp/latest_trombone.conf”\nExample: csw-config-client-cli “get” “/path/hcd/trombone.conf” -o “/Users/bar/temp/old_trombone.conf” –id “10” Explanation: Gets version revision 10 of repository file “/path/hcd/trombone.conf”, stores at local disk location “/Users/bar/temp/old_trombone.conf”\nExample: csw-config-client-cli “getActive” “/path/hcd/trombone.conf” -o “/Users/bar/temp/scheduled_trombone.conf” Explanation: Gets currently active version of repository file “/path/hcd/trombone.conf”, stores at local disk location “/Users/bar/temp/scheduled_trombone.conf”\nExample: csw-config-client-cli “exists” “/path/hcd/trombone.conf” Explanation: True if repository file “/path/hcd/trombone.conf” exists, false otherwise\nExample: csw-config-client-cli “delete” “/path/hcd/outdated_trombone.conf” -c “monthly maintainance activity” Explanation: Deletes repository file “/path/hcd/outdated_trombone.conf” if it exists using a comment\nExample: csw-config-client-cli “history” “/path/hcd/trombone.conf” “–max” 25 Explanation: Prints history of repository file “/path/hcd/trombone.conf”, with only 25 entries.\nExample: csw-config-client-cli “setActiveVersion” “/path/hcd/trombone.conf” –id “4” -c “restoring last successful version.” Explanation: Sets revision 4 to be active for repository file “/path/hcd/trombone.conf”, using a comment.\nExample: csw-config-client-cli “resetActiveVersion” “/path/hcd/trombone.conf” -c “testing most recent config” Explanation: Sets latest revision to be active for repository file “/path/hcd/trombone.conf”, using a comment.\nExample: csw-config-client-cli “getActiveVersion” “/path/hcd/trombone.conf” Explanation: Gets active version ID for repository file “/path/hcd/trombone.conf”.\nExample: csw-config-client-cli “getActiveByTime” “/path/hcd/trombone.conf” -o “/usr/tmp/last_week_trombone.conf” –date “2017-05-09T07:29:53.242Z” Explanation: Gets version of repository file “/path/hcd/trombone.conf”, that was active on “2017-05-09T07:29:53.242Z” and saves it on local disk.\nExample: csw-config-client-cli “getMetadata” Explanation: Prins the metadata on screen.","title":"Examples"},{"location":"/apps/hostconfig.html","text":"","title":"csw-host-config"},{"location":"/apps/hostconfig.html#csw-host-config","text":"This is just a helper to create a host configuration application. A component/subsystem is can create their own host configuration application using this helper, to be more precise every github repository should have one host configuration application. The reason for having one app per repo is, when you run universal:publish task, it will generate zip which will be self contained (will have all the required dependencies) and can be deployed independently on any machine.\nThis application will start multiple containers on a given host machine and each container will have single/multiple components.","title":"csw-host-config"},{"location":"/apps/hostconfig.html#how-to-create","text":"Scala object HostConfigApp extends App {\n\n  HostConfig.start(\"Host-Config-App\", args)\n\n} Java public class JHostConfigApp {\n\n    public static void main(String args[]) {\n        JHostConfig.start(\"JHost-Config-App\", args);\n    }\n\n}\nNote It is not necessary to have a name of the application as HostConfigApp/JHostConfigApp, user can choose this name.","title":"How to create"},{"location":"/apps/hostconfig.html#command-line-parameter-options","text":"--local is an optional parameter. When supplied, get the host configuration file from local machine located at hostConfigPath, else fetch it from config service <file> is a mandatory parameter. It specifies Host configuration file path -s, --container-script <script-path> specifies the path of generated shell script of container command app from task universal:packageBin (sbt-native-packager task) --help prints the help of the application. --version prints the version of the application.","title":"Command line parameter options"},{"location":"/apps/hostconfig.html#examples","text":"","title":"Examples"},{"location":"/apps/hostconfig.html#pre-requisites","text":"Run sbt project/universal:packageBin command. Here project contains HostConfigApp and ContainerCmdApp and it depends on required components. Ex. Hcd’s, Assembly’s etc. Navigate to project/target/universal directory Unzip file created with projects name Navigate to bin directory from unzipped content\nSbt task: sbt project/universal:packageBin creates following four scripts in bin directory:\ntrombone-host-config-app : Responsible for starting multiple containers. It takes hostconfig.conf file as an argument which contains list of container specifications. trombone-container-cmd-app : Responsible for starting single container or component in standalone mode. It takes containerConfig.conf file as an argument which contains single container specifications. trombone-host-config-app.bat : For windows machine. trombone-container-cmd-app.bat : For windows machine.\nExample: ./trombone-host-config-app hostconfig.conf -s ./trombone-container-cmd-app Explanation: Fetch hostconfig.conf from configuration service which contains multiple container configuration, then invoke trombone-container-cmd-app script per container configuration which spawns container\nExample: ./trombone-host-config-app --local hostconfig.conf -s ./trombone-container-cmd-app Explanation: Fetch and parse hostconfig.conf from current directory which contains multiple container configuration, then invoke trombone-container-cmd-app script per container configuration which spawns container\nNote In above examples, we are passing argument: -s ./trombone-container-cmd-app to ./trombone-host-config-app. here -s stands for script and following to that is script name, in our case its trombone-container-cmd-app. and if you notice, trombone-container-cmd-app does not take container configuration file. hostconfig.conf passed to trombone-host-config-app contains location of container configuration files. Host config app internally parses hostconfig.conf and passes container configuration file location to trombone-container-cmd-app. Find more details of ContainerCmd application here.","title":"Pre-requisites"},{"location":"/apps/hostconfig.html#where-does-it-fit-in-overall-deployment-strategy-may-change-","text":"","title":"Where does it fit in overall deployment strategy (may change)"},{"location":"/apps/hostconfig.html#custom-host-configuration","text":"hostconfig.conf # This is a host configuration file which contains list of containers to be spawned by host configuration app\ncontainers: [\n  {\n    # mode can be one of Container or Standalone\n    mode: \"Container\"\n    # path of individual container configuration file\n    configFilePath: \"/Users/salonivithalani/Desktop/tw_tmt/csw-prod/examples/src/main/resources/assemblyContainer.conf\"\n    # provide 'Remote' if file needs to fetched from config service else\n    # provide 'Local' to fetch file from local machine\n    configFileLocation: \"Local\"\n  },\n  {\n    mode: \"Standalone\"\n    configFilePath: \"/Users/salonivithalani/Desktop/tw_tmt/csw-prod/examples/src/main/resources/hcdStandalone.conf\"\n    configFileLocation: \"Local\"\n  }\n]","title":"Custom Host Configuration"},{"location":"/apps/hostconfig.html#help","text":"Use the following command to get help on the options available with this app\n./bin/trombone-host-config-app --help","title":"Help"},{"location":"/apps/hostconfig.html#version","text":"Use the following command to get version information for this app\n./bin/trombone-host-config-app --version","title":"Version"},{"location":"/apps/hostconfig.html#systemd-configuration","text":"Using systemd, you can configure host configuration application to spawn containers on a machine to be run automatically on system startup.\nFor detailed information on systemd configuration, please refer readme.md","title":"Systemd configuration"},{"location":"/commons/testing.html","text":"","title":"Testing"},{"location":"/commons/testing.html#testing","text":"This page will help you getting started with testing your applications.","title":"Testing"},{"location":"/commons/testing.html#unit-tests","text":"The goal of unit testing is to break you application into the smallest testable units, and test them individually, isolating a specific piece of functionality and ensuring it is working correctly. It is always good idea to write more unit test cases and relatively fewer component and integration tests. If you want to get an idea of how many tests you should have in different types of testing phases (Unit/Component/Integration), refer this blog\nUnit testing simple scala/java classes or objects is straight forward. You can mock external dependencies using Mockito. Refer to the Mockito section for more details.\nThe folloowing links provide guides for testing applications using different modules of Akka:\nAkka Untyped Actors Akka Typed Actors Akka Streams","title":"Unit Tests"},{"location":"/commons/testing.html#multi-jvm-tests","text":"Testing asynchronous distributed systems requires special tooling/framework support. Sbt has a plugin called sbt-multi-jvm which helps to test systems across multiple JVMs or machines. This is especially useful for integration testing where multiple systems communicate with each other.\nYou can find more details on multi-JVM tests here.\nYou can also refer csw-prod for writing your own multi-JVM tests. For example: CommandServiceTest.scala\nIn case you want to run your multi-JVM tests across machines, refer this multi-node testing guide here.","title":"Multi-JVM Tests"},{"location":"/commons/testing.html#mockito","text":"Mocks are used so that unit tests can be written independent of dependencies. csw-prod uses Mockito for writing unit tests. ScalaTest comes with MockitoSugar trait which provides some basic syntax sugar for Mockito.\nFor example: ContainerBehaviorTest.scala","title":"Mockito"},{"location":"/commons/testing.html#acceptance-tests","text":"This section explains how and where csw-prod maintains and executes acceptance tests. If you are a component writer and want to maintain acceptance tests, you can create a repo similar to csw-acceptance and update dependencies, projects as per your need.\nAs required by TMT Systems Engineering, the acceptance pipeline runs all the existing Java and Scala tests from csw-prod repo on published bintray binaries rather than directly on source code.\nMore information can be found here.\nBelow are the two separate Jenkins pipelines to run csw-prod acceptance tests:\nAcceptance Dev Pipeline Automatically triggered every night to get fast feedback and intended for developer’s visibility. Acceptance Release Pipeline Automatically triggered on completion of csw-prod-release pipeline. csw-prod-release pipeline published CSW artifacts to bintray, and must be manually triggered by an administrator.\nNote csw-prod-release pipeline is responsible for following tasks: build and run csw-prod tests publish binaries to bintray publish paradox documentation publish apps and release notes to github releases trigger acceptance-release pipeline\nAcceptance pipelines can also be triggered manually via an HTTP end point, for STIL acceptance tesing, for example. Using the security token obtained from the Jenkins pipeline settings (available upon request), run the curl cmd as shown below:\nFor triggering acceptance-dev pipeline, run below\ncurl -G 'http://ec2-35-154-215-191.ap-south-1.compute.amazonaws.com:8080/job/acceptance-dev/buildWithParameters'  \\\n    --data-urlencode token=$DEV_TOKEN \\\n    --data-urlencode DEV_VERSION=0.1-SNAPSHOT \\\n    --data-urlencode BUILD_ENV=DEV\nFor triggering acceptance-release pipeline, run below: (Modify parameters as applicable)\ncurl -G '$REMOTE_JENKINS_URL/job/$JOB_NAME/buildWithParameters' \\\n    --data-urlencode token=$RELEASE_TOKEN \\\n    --data-urlencode RELEASE_VERSION=$RELEASE_VERSION \\\n    --data-urlencode BUILD_ENV=PROD","title":"Acceptance Tests"},{"location":"/commons/sbt-tasks.html","text":"","title":"sbt tasks"},{"location":"/commons/sbt-tasks.html#sbt-tasks","text":"csw-prod uses multiple plugins in the sbt ecosystem to help accomplish a variety of tasks.\nplugin task Description default in sbt test compile and run all tests including scala tests, java tests, multi-jvm/multi-node tests default in sbt test:test compile and run all tests excluding multi-jvm/multi-node tests default in sbt publishLocal install your libraries in local Ivy repository so they can be added as dependencies to other projects sbt-multi-jvm multi-jvm:test provides support for running applications (objects with main methods) and ScalaTest tests in multiple JVMs at the same time. sbt-site makeSite generates project’s webpage in the target/site directory sbt-ghpages ghpagesPushSite publish project website to GitHub Pages sbt-github-release githubRelease creates Github releases with proper release notes and optional artifact uploading. Releases in Github are first-class objects with changelogs and binary assets that present a full project history beyond Git artifacts. They’re accessible from a repository’s homepage. sbt-bintray publish upload and release artifacts into bintray (command requires proper bintray credentials. Intended for TMT staff.) sbt-native-packager stage locally install your app in target/universal/stage/bin/ so you can run it locally without having the app packaged. sbt-native-packager universal:packageBin Generates a universal zip file","title":"sbt tasks"},{"location":"/commons/manuals.html","text":"","title":"Manuals"},{"location":"/commons/manuals.html#manuals","text":"Complete user guide on how to use common software platform, Scaladoc and Javadoc API’s can be found below:","title":"Manuals"},{"location":"/commons/manuals.html#","text":"","title":"Javadoc"},{"location":"/commons/manuals.html#","text":"","title":"Scaladoc"},{"location":"/messages/protobuf-support.html","text":"","title":"Protobuf support"},{"location":"/messages/protobuf-support.html#protobuf-support","text":"","title":"Protobuf support"}]}