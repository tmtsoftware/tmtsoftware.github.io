<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="docs">
<meta name="generator" content="Paradox, paradox-material-theme, mkdocs-material=1.11.0">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.languages" content="">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="docs">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Configuration service Â· TMT Common Software (CSW)</title>
<script src="../lib/modernizr/modernizr.min.js"></script>
<link rel="stylesheet" href="../assets/stylesheets/application-0741cbeb94.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
data-md-color-primary="indigo"
data-md-color-accent="indigo">
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
<label class="md-overlay" data-md-component="overlay" for="drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="TMT Common Software (CSW)" class="md-header-nav__button md-logo">
<i class="md-icon md-icon--home"></i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<span class="md-flex__ellipsis md-header-nav__title">
Configuration service
</span>
</div>
<form name="search" style="display: none">
<input type="text" name="query">
</form>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<div class="md-nav__button md-logo">
<i class="md-icon md-icon--home"></i>
</div>
<a href="../index.html" title="TMT Common Software (CSW)">
TMT Common Software (CSW)
</a>
</label>
<ul>
  <li><a href="../manuals.html" class="page">Manuals</a></li>
  <li><a href="../apps.html" class="page">Applications</a>
  <ul>
    <li><a href="../apps/cswclusterseed.html" class="page">csw-cluster-seed</a></li>
    <li><a href="../apps/cswlocationagent.html" class="page">csw-location-agent</a></li>
    <li><a href="../apps/cswonfigserverapp.html" class="page">csw-config-server</a></li>
    <li><a href="../apps/cswconfigclientcli.html" class="page">csw-config-client-cli</a></li>
    <li><a href="../apps/hostconfig.html" class="page">csw-host-config</a></li>
  </ul></li>
  <li><a href="../services.html" class="page">Services</a>
  <ul>
    <li><a href="../services/location.html" class="page">Location service</a></li>
    <li><a href="../services/config.html" class="active page">Configuration service</a></li>
    <li><a href="../services/logging.html" class="page">Logging service</a></li>
    <li><a href="../services/messages.html" class="page">csw-messages</a></li>
  </ul></li>
  <li><a href="../framework.html" class="page">Framework for creating components (HCD, Assembly, Container)</a>
  <ul>
    <li><a href="../framework/describing-components.html" class="page">ComponentInfo</a></li>
    <li><a href="../framework/creating-components.html" class="page">Creating an Assembly or Hcd Component</a></li>
    <li><a href="../framework/handling-lifecycle.html" class="page">Lifecycle support</a></li>
    <li><a href="../framework/managing-command-state.html" class="page">Managing Command State</a></li>
    <li><a href="../framework/tracking-connections.html" class="page">Tracking Connections</a></li>
    <li><a href="../framework/publishing-state.html" class="page">Publishing State</a></li>
    <li><a href="../framework/handling-exceptions.html" class="page">Handling Exceptions</a></li>
    <li><a href="../framework/deploying-components.html" class="page">Deploying Components</a></li>
  </ul></li>
  <li><a href="../command.html" class="page">Communication using Commands</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="toc">Table of contents</label>
<ul>
  <li><a href="../services/config.html#configuration-service" class="header">Configuration service</a>
  <ul>
    <li><a href="../services/config.html#artifacts" class="header">Artifacts</a></li>
    <li><a href="../services/config.html#rules-and-checks" class="header">Rules and checks</a></li>
    <li><a href="../services/config.html#model-classes" class="header">Model classes</a></li>
    <li><a href="../services/config.html#api-flavors" class="header">API flavors</a></li>
    <li><a href="../services/config.html#accessing-clientapi-and-adminapi" class="header">Accessing clientAPI and adminAPI</a></li>
    <li><a href="../services/config.html#exists" class="header">exists</a></li>
    <li><a href="../services/config.html#getactive" class="header">getActive</a></li>
    <li><a href="../services/config.html#create" class="header">create</a></li>
    <li><a href="../services/config.html#update" class="header">update</a></li>
    <li><a href="../services/config.html#delete" class="header">delete</a></li>
    <li><a href="../services/config.html#getbyid" class="header">getById</a></li>
    <li><a href="../services/config.html#getlatest" class="header">getLatest</a></li>
    <li><a href="../services/config.html#getbytime" class="header">getByTime</a></li>
    <li><a href="../services/config.html#list" class="header">list</a></li>
    <li><a href="../services/config.html#history" class="header">history</a></li>
    <li><a href="../services/config.html#managing-active-versions" class="header">Managing active versions</a></li>
    <li><a href="../services/config.html#getmetadata" class="header">getMetaData</a></li>
    <li><a href="../services/config.html#source-code-for-examples" class="header">Source code for examples</a></li>
  </ul></li>
</ul>
</nav>

<div class="md-nav__title--site md-version" title="Version">
<i class="md-icon">label_outline</i> 0.1*
</div>
</nav>

</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="toc">Table of contents</label>
<ul>
  <li><a href="../services/config.html#configuration-service" class="header">Configuration service</a>
  <ul>
    <li><a href="../services/config.html#artifacts" class="header">Artifacts</a></li>
    <li><a href="../services/config.html#rules-and-checks" class="header">Rules and checks</a></li>
    <li><a href="../services/config.html#model-classes" class="header">Model classes</a></li>
    <li><a href="../services/config.html#api-flavors" class="header">API flavors</a></li>
    <li><a href="../services/config.html#accessing-clientapi-and-adminapi" class="header">Accessing clientAPI and adminAPI</a></li>
    <li><a href="../services/config.html#exists" class="header">exists</a></li>
    <li><a href="../services/config.html#getactive" class="header">getActive</a></li>
    <li><a href="../services/config.html#create" class="header">create</a></li>
    <li><a href="../services/config.html#update" class="header">update</a></li>
    <li><a href="../services/config.html#delete" class="header">delete</a></li>
    <li><a href="../services/config.html#getbyid" class="header">getById</a></li>
    <li><a href="../services/config.html#getlatest" class="header">getLatest</a></li>
    <li><a href="../services/config.html#getbytime" class="header">getByTime</a></li>
    <li><a href="../services/config.html#list" class="header">list</a></li>
    <li><a href="../services/config.html#history" class="header">history</a></li>
    <li><a href="../services/config.html#managing-active-versions" class="header">Managing active versions</a></li>
    <li><a href="../services/config.html#getmetadata" class="header">getMetaData</a></li>
    <li><a href="../services/config.html#source-code-for-examples" class="header">Source code for examples</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#configuration-service" name="configuration-service" class="anchor"><span class="anchor-link"></span></a>Configuration service</h1>
<p>Configuration Service provides a centralized persistent store for any configuration file used in the TMT Software System. All versions of configuration files are retained, providing a historical record of each configuration file.</p>
<p>Note that in order to use the APIs described here, the <a href="../services/location.html">location service</a> (<a href="../apps/cswclusterseed.html">csw-cluster-seed</a>) and <a href="../apps/cswonfigserverapp.html">config service server</a> need to be running somewhere in the local network and the necessary configuration, environment variables or system properties should be defined to point to the correct host and port number(s) for the location service seed nodes.</p>
<p>This service will be part of the observatory cluster and exposes Rest endpoints that can be accessed over HTTP. Component developers can use the csw-config-client library in their code. The library wraps the low level communication with ConfigServer and exposes simple to use methods to access and manage configuration files.</p>
<h2><a href="#artifacts" name="artifacts" class="anchor"><span class="anchor-link"></span></a>Artifacts</h2>
<dl>
  <dt>sbt</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;org.tmt&quot; %% &quot;csw-config-client&quot; % &quot;0.1-SNAPSHOT&quot;
</code></pre></dd>
  <dt>maven</dt>
  <dd>
  <pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
 &lt;groupId&gt;org.tmt&lt;/groupId&gt;
 &lt;artifactId&gt;csw-config-client_2.12&lt;/artifactId&gt;
 &lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;
 &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;
</code></pre></dd>
  <dt>gradle</dt>
  <dd>
  <pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: &quot;org.tmt&quot;, name: &quot;csw-config-client_2.12&quot;, version: &quot;0.1-SNAPSHOT&quot;
}
</code></pre></dd>
</dl>
<h2><a href="#rules-and-checks" name="rules-and-checks" class="anchor"><span class="anchor-link"></span></a>Rules and checks</h2>
<ul>
  <li>The config file path must not contain <code>!#&lt;&gt;$%&amp;&#39;@^``~+,;=</code> or <code>any whitespace character</code></li>
  <li>If the input file is &gt; 10MB or has lot of non ASCII characters, then for optimization, server will archive it in <code>annex</code> store.</li>
  <li>Large and binary files can be forced to go to &lsquo;annex&rsquo; store by using a <code>annex=true</code> flag in <code>create</code> operation.</li>
  <li>API functions accept date-time values in UTC timezone. (e.g. 2017-05-17T08:00:24.246Z)</li>
</ul>
<h2><a href="#model-classes" name="model-classes" class="anchor"><span class="anchor-link"></span></a>Model classes</h2>
<ul>
  <li><strong>ConfigData</strong> : Represents the contents of the files being managed. It wraps stream of ByteString.</li>
  <li><strong>ConfigFileInfo</strong> : Represents information about a config file stored in the config service.</li>
  <li><strong>ConfigFileRevision</strong> : Represents information about a specific version of a config file.</li>
  <li><strong>ConfigId</strong> : Represents identifier associated with a revision of configuration file, often generated by <code>create</code> or <code>update</code> methods.</li>
  <li><strong>ConfigMetadata</strong> : Represents metadata information about ConfigServer.</li>
  <li><strong>FileType</strong> : Represents the type of storage for a configuration file. Currently two types are supported <code>Normal</code>(small, text files) and <code>Annex</code>(Large, Binary files).</li>
</ul>
<h2><a href="#api-flavors" name="api-flavors" class="anchor"><span class="anchor-link"></span></a>API flavors</h2>
<p>The Configuration Service is used to provide the runtime settings for components. When a component is started, it will use a limited &ldquo;clientAPI&rdquo; to obtain the &ldquo;active&rdquo; configuration from the Configuration Service, and use those settings for its execution. To change the active configuration, an administrative tool with access to the full &ldquo;admin API&rdquo; must be used. These tools would have the ability to create, delete, and update configurations, as well as retrieve past configurations and their history. Any time a new configuration is to be used by a component, the user must use one of these tools (via CLI, perhaps) to set the active configuration for a component. Since a history of active configurations is maintained by the service, the settings of each component each time it is run can be retrieved, and the system configuration at any moment can be recreated.</p>
<ul>
  <li><strong>clientAPI</strong> : Expected to be consumed by component developers. Available functions are: <code>{exists | getActive}</code></li>
  <li><strong>adminAPI</strong> : Full functionality exposed by ConfigServer is available with this API. Expected to be used administrators. Available functions are: <code>{create | update | getById | getLatest | getByTime | delete | list | history | historyActive | setActiveVersion | resetActiveVersion | getActiveVersion | getActiveByTime | getMetadata | exists | getActive}</code></li>
</ul><div class="callout warning "><div class="callout-title">Component developers are recommended to use clientAPI.</div></div>
<h2><a href="#accessing-clientapi-and-adminapi" name="accessing-clientapi-and-adminapi" class="anchor"><span class="anchor-link"></span></a>Accessing clientAPI and adminAPI</h2>
<p>ConfigClientFactory exposes functions to get clientAPI and adminAPI. Both the functions require LocationService instance which is used to resolve ConfigServer.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">//config client API
val clientApi: ConfigClientService = ConfigClientFactory.clientApi(actorSystem, locationService)
//config admin API
val adminApi: ConfigService = ConfigClientFactory.adminApi(actorSystem, locationService)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">//config client API
IConfigClientService clientApi = JConfigClientFactory.clientApi(actorRuntime.actorSystem(), clientLocationService);
//config admin API
IConfigService adminApi = JConfigClientFactory.adminApi(actorRuntime.actorSystem(), clientLocationService);</code></pre></dd>
</dl>
<h2><a href="#exists" name="exists" class="anchor"><span class="anchor-link"></span></a>exists</h2>
<p>Function checks if the file exists at specified path in the repository. If it exists it returns Future of Boolean</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">//construct the path
val filePath = Paths.get(&quot;/tmt/trmobone/assembly/hcd.conf&quot;)

val doneF = async {
  // create file using admin API
  await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, &quot;First commit&quot;))

  //check if file exists with config service
  val exists: Boolean = await(clientApi.exists(filePath))
  exists shouldBe true
}
Await.result(doneF, 5.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Path filePath = Paths.get(&quot;/tmt/trmobone/assembly/hcd.conf&quot;);

// create file using admin API
adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, &quot;commit config file&quot;).get();

Boolean exists = clientApi.exists(filePath).get();
Assert.assertTrue(exists);</code></pre></dd>
</dl>
<h2><a href="#getactive" name="getactive" class="anchor"><span class="anchor-link"></span></a>getActive</h2>
<p>Function retrieves currently active file for a given path from config service. It returns a Future of Option of ConfigData.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val defaultStrConf: String = &quot;foo { bar { baz : 1234 } }&quot;
val doneF = async {
  // construct the path
  val filePath = Paths.get(&quot;/tmt/trmobone/assembly/hcd.conf&quot;)

  await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, &quot;First commit&quot;))

  val activeFile: Option[ConfigData] = await(clientApi.getActive(filePath))
  await(activeFile.get.toStringF) shouldBe defaultStrConf
}
Await.result(doneF, 5.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">String defaultStrConf = &quot;foo { bar { baz : 1234 } }&quot;;
// construct the path
Path filePath = Paths.get(&quot;/tmt/trmobone/assembly/hcd.conf&quot;);

adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, &quot;First commit&quot;).get();

ConfigData activeFile = clientApi.getActive(filePath).get().get();
Assert.assertEquals(activeFile.toJConfigObject(mat).get().getString(&quot;foo.bar.baz&quot;), &quot;1234&quot;);</code></pre></dd>
</dl>
<h2><a href="#create" name="create" class="anchor"><span class="anchor-link"></span></a>create</h2>
<p>Takes input ConfigData and creates the configuration in the repository at a specified path</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">  async {
    //construct ConfigData from String containing ASCII text
    val configString: String =
      &quot;&quot;&quot;
    // Name: ComponentType ConnectionType
    {
      name: lgsTromboneHCD
      type: Hcd
      connectionType: [akka]
    }
    &quot;&quot;&quot;.stripMargin
    val config1: ConfigData = ConfigData.fromString(configString)

    //construct ConfigData from a local file containing binary data
    val srcFilePath         = getClass.getClassLoader.getResource(&quot;smallBinary.bin&quot;).toURI
    val config2: ConfigData = ConfigData.fromPath(Paths.get(srcFilePath))

    //construct ConfigData from Array[Byte] by reading a local file
    val stream: InputStream    = getClass.getClassLoader.getResourceAsStream(&quot;smallBinary.bin&quot;)
    def byteArray: Array[Byte] = Stream.continually(stream.read).takeWhile(_ != -1).map(_.toByte).toArray
    val config3                = ConfigData.fromBytes(byteArray)

    //store the config, at a specified path as normal text file
    val id1: ConfigId =
      await(adminApi.create(Paths.get(&quot;/hcd/trombone/overnight.conf&quot;), config1, false, &quot;review done&quot;))

    //store the config, at a specified path as a binary file in annex store
    val id2: ConfigId =
      await(adminApi.create(Paths.get(&quot;/hcd/trombone/firmware.bin&quot;), config2, true, &quot;smoke test done&quot;))

    //store the config, at a specified path as a binary file in annex store
    val id3: ConfigId =
      await(adminApi.create(Paths.get(&quot;/hcd/trombone/debug.bin&quot;), config3, true, &quot;new file from vendor&quot;))

    //CAUTION: for demo example setup these IDs are returned. Don&#39;t assume them in production setup.
    id1 shouldEqual ConfigId(1)
    id2 shouldEqual ConfigId(3)
    id3 shouldEqual ConfigId(5)
  }
Await.result(futC, 2.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">//construct ConfigData from String containing ASCII text
String configString = &quot;axisName11111 = tromboneAxis\naxisName22222 = tromboneAxis2\naxisName3 = tromboneAxis3333&quot;;
ConfigData config1 = ConfigData.fromString(configString);

//construct ConfigData from a local file containing binary data
URI srcFilePath = getClass().getClassLoader().getResource(&quot;smallBinary.bin&quot;).toURI();
ConfigData config2 = ConfigData.fromPath(Paths.get(srcFilePath));

ConfigId id1 = adminApi.create(Paths.get(&quot;/hcd/trombone/overnight.conf&quot;), config1, false, &quot;review done&quot;).get();
ConfigId id2 = adminApi.create(Paths.get(&quot;/hcd/trombone/firmware.bin&quot;), config2, true, &quot;smoke test done&quot;).get();

//CAUTION: for demo example setup these IDs are returned. Don&#39;t assume them in production setup.
Assert.assertEquals(id1, new ConfigId(&quot;1&quot;));
Assert.assertEquals(id2, new ConfigId(&quot;3&quot;));</code></pre></dd>
</dl>
<h2><a href="#update" name="update" class="anchor"><span class="anchor-link"></span></a>update</h2>
<p>Takes input ConfigData and overwrites the configuration specified in the repository</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val futU = async {
  val destPath = Paths.get(&quot;/hcd/trombone/debug.bin&quot;)
  val newId = await(
    adminApi
      .update(destPath, ConfigData.fromString(defaultStrConf), comment = &quot;debug statements&quot;)
  )

  //validate the returned id
  newId shouldEqual ConfigId(7)
}
Await.result(futU, 2.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Path destPath = Paths.get(&quot;/hcd/trombone/overnight.conf&quot;);
ConfigId newId = adminApi.update(destPath, ConfigData.fromString(defaultStrConf), &quot;added debug statements&quot;).get();

//validate the returned id
Assert.assertEquals(newId, new ConfigId(&quot;5&quot;));</code></pre></dd>
</dl>
<h2><a href="#delete" name="delete" class="anchor"><span class="anchor-link"></span></a>delete</h2>
<p>Deletes a file located at specified path in the repository</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val futD = async {
  val unwantedFilePath = Paths.get(&quot;/hcd/trombone/debug.bin&quot;)
  await(adminApi.delete(unwantedFilePath, &quot;no longer needed&quot;))
  //validates the file is deleted
  await(adminApi.getLatest(unwantedFilePath)) shouldBe None
}
Await.result(futD, 2.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Path unwantedFilePath = Paths.get(&quot;/hcd/trombone/overnight.conf&quot;);
adminApi.delete(unwantedFilePath, &quot;no longer needed&quot;).get();
Assert.assertEquals(adminApi.getLatest(unwantedFilePath).get(), Optional.empty());</code></pre></dd>
</dl>
<h2><a href="#getbyid" name="getbyid" class="anchor"><span class="anchor-link"></span></a>getById</h2>
<p>Returns file at a given path and matching revision Id</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val doneF = async {
  // create a file using API first
  val filePath = Paths.get(&quot;/tmt/trmobone/assembly/hcd.conf&quot;)
  val id: ConfigId =
    await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, &quot;First commit&quot;))

  //validate
  val actualData = await(adminApi.getById(filePath, id)).get
  await(actualData.toStringF) shouldBe defaultStrConf
}
Await.result(doneF, 2.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Path filePath = Paths.get(&quot;/tmt/trmobone/assembly/hcd.conf&quot;);
ConfigId id = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, &quot;First commit&quot;).get();

//validate
ConfigData actualData = adminApi.getById(filePath, id).get().get();
Assert.assertEquals(defaultStrConf, actualData.toJStringF(mat).get());</code></pre></dd>
</dl>
<h2><a href="#getlatest" name="getlatest" class="anchor"><span class="anchor-link"></span></a>getLatest</h2>
<p>Returns the latest versio of file stored at the given path.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val assertionF: Future[Assertion] = async {
  //create a file
  val filePath = Paths.get(&quot;/test.conf&quot;)
  await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, &quot;initial configuration&quot;))

  //override the contents
  val newContent = &quot;I changed the contents!!!&quot;
  await(adminApi.update(filePath, ConfigData.fromString(newContent), &quot;changed!!&quot;))

  //get the latest file
  val newConfigData = await(adminApi.getLatest(filePath)).get
  //validate
  await(newConfigData.toStringF) shouldBe newContent
}
Await.result(assertionF, 2.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">//create a file
Path filePath = Paths.get(&quot;/test.conf&quot;);
ConfigId id = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, &quot;initial configuration&quot;).get();

//override the contents
String newContent = &quot;I changed the contents!!!&quot;;
adminApi.update(filePath, ConfigData.fromString(newContent), &quot;changed!!&quot;).get();

//get the latest file
ConfigData newConfigData = adminApi.getLatest(filePath).get().get();
//validate
Assert.assertEquals(newConfigData.toJStringF(mat).get(), newContent);</code></pre></dd>
</dl>
<h2><a href="#getbytime" name="getbytime" class="anchor"><span class="anchor-link"></span></a>getByTime</h2>
<p>Gets the file at the given path as it existed at a given time-instance. Note: </p>
<ul>
  <li>If time-instance is before the file was created, the initial version is returned.</li>
  <li>If time-instance is after the last change, the most recent version is returned.</li>
</ul>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val assertionF = async {
  val tInitial = Instant.MIN
  //create a file
  val filePath = Paths.get(&quot;/a/b/c/test.conf&quot;)
  await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, &quot;initial configuration&quot;))

  //override the contents
  val newContent = &quot;I changed the contents!!!&quot;
  await(adminApi.update(filePath, ConfigData.fromString(newContent), &quot;changed!!&quot;))

  val initialData: ConfigData = await(adminApi.getByTime(filePath, tInitial)).get
  await(initialData.toStringF) shouldBe defaultStrConf

  val latestData = await(adminApi.getByTime(filePath, Instant.now())).get
  await(latestData.toStringF) shouldBe newContent
}
Await.result(assertionF, 2.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Instant tInitial = Instant.now();

//create a file
Path filePath = Paths.get(&quot;/test.conf&quot;);
ConfigId id = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, &quot;initial configuration&quot;).get();

//override the contents
String newContent = &quot;I changed the contents!!!&quot;;
adminApi.update(filePath, ConfigData.fromString(newContent), &quot;changed!!&quot;).get();

ConfigData initialData = adminApi.getByTime(filePath, tInitial).get().get();
Assert.assertEquals(defaultStrConf, initialData.toJStringF(mat).get());

ConfigData latestData = adminApi.getByTime(filePath, Instant.now()).get().get();
Assert.assertEquals(newContent, latestData.toJStringF(mat).get());</code></pre></dd>
</dl>
<h2><a href="#list" name="list" class="anchor"><span class="anchor-link"></span></a>list</h2>
<p>For a given FileType(Annex or Normal) and an optional pattern string, it will list all files whose path matches the given pattern. Some pattern examples are: &ldquo;/path/hcd/*.*&rdquo;, &ldquo;a/b/c/d.*&rdquo;, &ldquo;.*.conf&rdquo;, &ldquo;.*hcd.*&rdquo;</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">//Here&#39;s a list of tuples containing FilePath and FileTyepe(Annex / Normal)
val paths: List[(Path, FileType)] = List[(Path, FileType)](
  (Paths.get(&quot;a/c/trombone.conf&quot;), FileType.Annex),
  (Paths.get(&quot;a/b/c/hcd/hcd.conf&quot;), FileType.Normal),
  (Paths.get(&quot;a/b/assembly/assembly1.fits&quot;), FileType.Annex),
  (Paths.get(&quot;a/b/c/assembly/assembly2.fits&quot;), FileType.Normal),
  (Paths.get(&quot;testing/test.conf&quot;), FileType.Normal)
)

//create config files at those paths
paths map {
  case (path, fileType) â
    val createF = async {
      await(
        adminApi.create(path, ConfigData.fromString(defaultStrConf), FileType.Annex == fileType, &quot;initial commit&quot;)
      )
    }
    Await.result(createF, 2.seconds)
}

val assertionF = async {
  //retrieve list of all files; for demonstration purpose show validate return values
  await(adminApi.list()).map(info â info.path).toSet shouldBe paths.map {
    case (path, fileType) â path
  }.toSet

  //retrieve list of files based on type; for demonstration purpose validate return values
  await(adminApi.list(Some(FileType.Annex))).map(info â info.path).toSet shouldBe paths.collect {
    case (path, fileType) if (fileType == FileType.Annex) â path
  }.toSet
  await(adminApi.list(Some(FileType.Normal))).map(info â info.path).toSet shouldBe paths.collect {
    case (path, fileType) if (fileType == FileType.Normal) â path
  }.toSet

  //retrieve list using pattern; for demonstration purpose validate return values
  await(adminApi.list(None, Some(&quot;.*.conf&quot;))).map(info â info.path.toString).toSet shouldBe Set(
    &quot;a/b/c/hcd/hcd.conf&quot;,
    &quot;a/c/trombone.conf&quot;,
    &quot;testing/test.conf&quot;
  )
  //retrieve list using pattern and file type; for demonstration purpose validate return values
  await(adminApi.list(Some(FileType.Normal), Some(&quot;.*.conf&quot;))).map(info â info.path.toString).toSet shouldBe
  Set(&quot;a/b/c/hcd/hcd.conf&quot;, &quot;testing/test.conf&quot;)
  await(adminApi.list(Some(FileType.Annex), Some(&quot;a/c.*&quot;))).map(info â info.path.toString).toSet shouldBe
  Set(&quot;a/c/trombone.conf&quot;)
  await(adminApi.list(Some(FileType.Normal), Some(&quot;test.*&quot;))).map(info â info.path.toString).toSet shouldBe
  Set(&quot;testing/test.conf&quot;)
}
Await.result(assertionF, 2.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Path trombonePath = Paths.get(&quot;a/c/trombone.conf&quot;);
Path hcdPath = Paths.get(&quot;a/b/c/hcd/hcd.conf&quot;);
Path fits1Path = Paths.get(&quot;a/b/assembly/assembly1.fits&quot;);
Path fits2Path = Paths.get(&quot;a/b/c/assembly/assembly2.fits&quot;);
Path testConfPath = Paths.get(&quot;testing/test.conf&quot;);

String comment = &quot;initial commit&quot;;

//create files
ConfigId tromboneId = adminApi.create(trombonePath, ConfigData.fromString(defaultStrConf), true, comment).get();
ConfigId hcdId = adminApi.create(hcdPath, ConfigData.fromString(defaultStrConf), false, comment).get();
ConfigId fits1Id = adminApi.create(fits1Path, ConfigData.fromString(defaultStrConf), true, comment).get();
ConfigId fits2Id = adminApi.create(fits2Path, ConfigData.fromString(defaultStrConf), false, comment).get();
ConfigId testId = adminApi.create(testConfPath, ConfigData.fromString(defaultStrConf), true, comment).get();

//retrieve full list; for demonstration purpose validate return values
Assert.assertEquals(new HashSet&lt;ConfigId&gt;(Arrays.asList(tromboneId, hcdId, fits1Id, fits2Id, testId)),
    adminApi.list().get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));

//retrieve list of files based on type; for demonstration purpose validate return values
Assert.assertEquals(new HashSet&lt;&gt;(Arrays.asList(tromboneId, fits1Id, testId)),
    adminApi.list(JFileType.Annex).get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));
Assert.assertEquals(new HashSet&lt;&gt;(Arrays.asList(hcdId, fits2Id)),
    adminApi.list(JFileType.Normal).get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));

//retrieve list using pattern; for demonstration purpose validate return values
Assert.assertEquals(new HashSet&lt;&gt;(Arrays.asList(tromboneId, hcdId, testId)),
    adminApi.list(&quot;.*.conf&quot;).get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));
//retrieve list using pattern and file type; for demonstration purpose validate return values
Assert.assertEquals(new HashSet&lt;&gt;(Arrays.asList(tromboneId, testId)),
    adminApi.list(JFileType.Annex, &quot;.*.conf&quot;).get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));
Assert.assertEquals(new HashSet&lt;&gt;(Arrays.asList(tromboneId)),
    adminApi.list(JFileType.Annex, &quot;a/c.*&quot;).get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));
Assert.assertEquals(new HashSet&lt;&gt;(Arrays.asList(testId)),
    adminApi.list(JFileType.Annex, &quot;test.*&quot;).get().stream().map(ConfigFileInfo::id).collect(Collectors.toSet()));</code></pre></dd>
</dl>
<h2><a href="#history" name="history" class="anchor"><span class="anchor-link"></span></a>history</h2>
<p>Returns the history of revisions of the file at the given path for a range of period specified by <code>from</code> and <code>to</code>. The size of the list can be restricted using <code>maxResults</code>. Returns the history of active revisions of the file at the given path for a range of period specified by <code>from</code> and <code>to</code>. The size of the list can be restricted using <code>maxResults</code>.</p>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val assertionF = async {
  val filePath = Paths.get(&quot;/a/test.conf&quot;)
  val id0      = await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, &quot;first commit&quot;))

  //override the contents twice
  val tBeginUpdate = Instant.now()
  val id1          = await(adminApi.update(filePath, ConfigData.fromString(&quot;changing contents&quot;), &quot;second commit&quot;))
  val id2          = await(adminApi.update(filePath, ConfigData.fromString(&quot;changing contents again&quot;), &quot;third commit&quot;))
  val tEndUpdate   = Instant.now()

  //full file history
  val fullHistory = await(adminApi.history(filePath))
  fullHistory.map(_.id) shouldBe List(id2, id1, id0)
  fullHistory.map(_.comment) shouldBe List(&quot;third commit&quot;, &quot;second commit&quot;, &quot;first commit&quot;)

  //drop initial revision and take only update revisions
  await(adminApi.history(filePath, tBeginUpdate, tEndUpdate)).map(_.id) shouldBe List(id2, id1)

  //take last two revisions
  await(adminApi.history(filePath, maxResults = 2)).map(_.id) shouldBe List(id2, id1)
}
Await.result(assertionF, 3.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Path filePath = Paths.get(&quot;/a/test.conf&quot;);
ConfigId id0 = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, &quot;first commit&quot;).get();

//override the contents twice
Instant tBeginUpdate = Instant.now();
ConfigId id1 = adminApi.update(filePath, ConfigData.fromString(&quot;changing contents&quot;), &quot;second commit&quot;).get();
ConfigId id2 = adminApi.update(filePath, ConfigData.fromString(&quot;changing contents again&quot;), &quot;third commit&quot;).get();
Instant tEndUpdate = Instant.now();

//full file history
List&lt;ConfigFileRevision&gt; fullHistory = adminApi.history(filePath).get();
Assert.assertEquals(new ArrayList&lt;&gt;(Arrays.asList(id2, id1, id0)),
    fullHistory.stream().map(ConfigFileRevision::id).collect(Collectors.toList()));
Assert.assertEquals(new ArrayList&lt;&gt;(Arrays.asList(&quot;third commit&quot;, &quot;second commit&quot;, &quot;first commit&quot;)),
    fullHistory.stream().map(ConfigFileRevision::comment).collect(Collectors.toList()));

//drop initial revision and take only update revisions
Assert.assertEquals(new ArrayList&lt;&gt;(Arrays.asList(id2, id1)),
    adminApi.history(filePath, tBeginUpdate, tEndUpdate).get().stream().map(ConfigFileRevision::id).collect(Collectors.toList()));
//take last two revisions
Assert.assertEquals(new ArrayList&lt;&gt;(Arrays.asList(id2, id1)),
    adminApi.history(filePath, 2).get().stream().map(ConfigFileRevision::id).collect(Collectors.toList()));</code></pre></dd>
</dl>
<h2><a href="#managing-active-versions" name="managing-active-versions" class="anchor"><span class="anchor-link"></span></a>Managing active versions</h2>
<p>Following API functions are available to manage the active version of a config file. In it&rsquo;s lifetime a config file undergoes many revisions. An active version is a specific revision from a file&rsquo;s history and it is set by administrators. </p>
<ul>
  <li><strong>historyActive</strong> : Returns the history of active revisions of the file at the given path for a range of period specified by <code>from</code> and <code>to</code>. The size of the list can be restricted using <code>maxResults</code>.</li>
  <li><strong>setActiveVersion</strong> : Sets the &ldquo;active version&rdquo; to be the version provided for the file at the given path. If this method is never called in a config&rsquo;s lifetime, the active version will always be the version returned by <code>create</code> function.</li>
  <li><strong>resetActiveVersion</strong> : Resets the &ldquo;active version&rdquo; of the file at the given path to the latest version.</li>
  <li><strong>getActiveVersion</strong> : Returns the revision Id which represents the &ldquo;active version&rdquo; of the file at the given path.</li>
  <li><strong>getActiveByTime</strong> : Returns the content of active version of the file existed at given instant</li>
</ul>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val assertionF = async {
  val tBegin   = Instant.now()
  val filePath = Paths.get(&quot;/a/test.conf&quot;)
  //create will make the 1st revision active with a default comment
  val id1 = await(adminApi.create(filePath, ConfigData.fromString(defaultStrConf), annex = false, &quot;first&quot;))
  await(adminApi.historyActive(filePath)).map(_.id) shouldBe List(id1)
  //ensure active version is set
  await(adminApi.getActiveVersion(filePath)).get shouldBe id1

  //override the contents four times
  await(adminApi.update(filePath, ConfigData.fromString(&quot;changing contents&quot;), &quot;second&quot;))
  val id3 = await(adminApi.update(filePath, ConfigData.fromString(&quot;changing contents again&quot;), &quot;third&quot;))
  val id4 = await(adminApi.update(filePath, ConfigData.fromString(&quot;final contents&quot;), &quot;fourth&quot;))
  val id5 = await(adminApi.update(filePath, ConfigData.fromString(&quot;final final contents&quot;), &quot;fifth&quot;))

  //update doesn&#39;t change the active revision
  await(adminApi.historyActive(filePath)).map(_.id) shouldBe List(id1)

  //play with active version
  await(adminApi.setActiveVersion(filePath, id3, s&quot;$id3 active&quot;))
  await(adminApi.setActiveVersion(filePath, id4, s&quot;$id4 active&quot;))
  await(adminApi.getActiveVersion(filePath)).get shouldBe id4
  val tEnd = Instant.now()
  //reset active version to latest
  await(adminApi.resetActiveVersion(filePath, &quot;latest active&quot;))
  await(adminApi.getActiveVersion(filePath)).get shouldBe id5
  //finally set initial version as active
  await(adminApi.setActiveVersion(filePath, id1, s&quot;$id1 active&quot;))
  await(adminApi.getActiveVersion(filePath)).get shouldBe id1

  //validate full history
  val fullHistory = await(adminApi.historyActive(filePath))
  fullHistory.map(_.id) shouldBe List(id1, id5, id4, id3, id1)
  fullHistory.map(_.comment) shouldBe List(s&quot;$id1 active&quot;,
                                           &quot;latest active&quot;,
                                           s&quot;$id4 active&quot;,
                                           s&quot;$id3 active&quot;,
                                           &quot;initializing active file with the first version&quot;)

  //drop initial revision and take only update revisions
  val fragmentedHistory = await(adminApi.historyActive(filePath, tBegin, tEnd))
  fragmentedHistory.size shouldBe 3

  //take last three revisions
  await(adminApi.historyActive(filePath, maxResults = 3)).map(_.id) shouldBe List(id1, id5, id4)

  //get contents of active version at a specified instance
  val initialContents = await(adminApi.getActiveByTime(filePath, tBegin)).get
  await(initialContents.toStringF) shouldBe defaultStrConf
}
Await.result(assertionF, 5.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">Instant tBegin = Instant.now();
Path filePath = Paths.get(&quot;/a/test.conf&quot;);

//create will make the 1st revision active with a default comment
ConfigId id1 = adminApi.create(filePath, ConfigData.fromString(defaultStrConf), false, &quot;first commit&quot;).get();
Assert.assertEquals(new ArrayList&lt;&gt;(Arrays.asList(id1)),
    adminApi.historyActive(filePath).get().stream().map(ConfigFileRevision::id).collect(Collectors.toList()));
//ensure active version is set
Assert.assertEquals(id1, adminApi.getActiveVersion(filePath).get().get());

//override the contents four times
adminApi.update(filePath, ConfigData.fromString(&quot;changing contents&quot;), &quot;second&quot;).get();
ConfigId id3 = adminApi.update(filePath, ConfigData.fromString(&quot;changing contents again&quot;), &quot;third&quot;).get();
ConfigId id4 = adminApi.update(filePath, ConfigData.fromString(&quot;final contents&quot;), &quot;fourth&quot;).get();
ConfigId id5 = adminApi.update(filePath, ConfigData.fromString(&quot;final final contents&quot;), &quot;fifth&quot;).get();

//update doesn&#39;t change the active revision
Assert.assertEquals(id1, adminApi.getActiveVersion(filePath).get().get());

//play with active version
adminApi.setActiveVersion(filePath, id3, &quot;id3 active&quot;).get();
adminApi.setActiveVersion(filePath, id4, &quot;id4 active&quot;).get();
Assert.assertEquals(id4, adminApi.getActiveVersion(filePath).get().get());
Instant tEnd = Instant.now();

//reset active version to latest
adminApi.resetActiveVersion(filePath, &quot;latest active&quot;).get();
Assert.assertEquals(id5, adminApi.getActiveVersion(filePath).get().get());
//finally set initial version as active
adminApi.setActiveVersion(filePath, id1, &quot;id1 active&quot;).get();
Assert.assertEquals(id1, adminApi.getActiveVersion(filePath).get().get());

//validate full history
List&lt;ConfigFileRevision&gt; fullHistory = adminApi.historyActive(filePath).get();
Assert.assertEquals(new ArrayList&lt;&gt;(Arrays.asList(id1, id5, id4, id3, id1)),
        fullHistory.stream().map(ConfigFileRevision::id).collect(Collectors.toList()));
Assert.assertEquals(new ArrayList&lt;&gt;(Arrays.asList(&quot;id1 active&quot;, &quot;latest active&quot;, &quot;id4 active&quot;, &quot;id3 active&quot;,
        &quot;initializing active file with the first version&quot;)),
        fullHistory.stream().map(ConfigFileRevision::comment).collect(Collectors.toList()));

//drop initial revision and take only update revisions
List&lt;ConfigFileRevision&gt; fragmentedHistory = adminApi.historyActive(filePath, tBegin, tEnd).get();
Assert.assertEquals(3, fragmentedHistory.size());

//take last three revisions
Assert.assertEquals(new ArrayList&lt;&gt;(Arrays.asList(id1, id5, id4)),
        adminApi.historyActive(filePath, 3).get().stream().map(ConfigFileRevision::id).collect(Collectors.toList()));

//get contents of active version at a specified instance
String initialContents = adminApi.getActiveByTime(filePath, tBegin).get().get().toJStringF(mat).get();
Assert.assertEquals(defaultStrConf, initialContents);</code></pre></dd>
</dl>
<h2><a href="#getmetadata" name="getmetadata" class="anchor"><span class="anchor-link"></span></a>getMetaData</h2>
<p>Used to get metadata information about config service. It includes:</p>
<ul>
  <li>repository directory</li>
  <li>annex directory</li>
  <li>min annex file size</li>
  <li>max config file size</li>
</ul>
<dl>
  <dt>Scala</dt>
  <dd>
  <pre class="prettyprint"><code class="language-scala">val assertF = async {
  val metaData: ConfigMetadata = await(adminApi.getMetadata)
  //repository path must not be empty
  metaData.repoPath should not be empty
}
Await.result(assertF, 2.seconds)</code></pre></dd>
  <dt>Java</dt>
  <dd>
  <pre class="prettyprint"><code class="language-java">ConfigMetadata metadata = adminApi.getMetadata().get();
//repository path must not be empty
Assert.assertNotEquals(metadata.repoPath(), &quot;&quot;);</code></pre></dd>
</dl>
<h2><a href="#source-code-for-examples" name="source-code-for-examples" class="anchor"><span class="anchor-link"></span></a>Source code for examples</h2>
<ul>
  <li><a href="https://github.com/tmtsoftware/csw-prod/tree/master/examples/src/test/scala/csw/services/config/ConfigClientExampleTest.scala">Scala Example</a></li>
  <li><a href="https://github.com/tmtsoftware/csw-prod/tree/master/examples/src/test/java/csw/services/config/JConfigClientExampleTest.java">Java Example</a></li>
</ul>
</div>
<div>
<a href="https://github.com/tmtsoftware/csw-prod/tree/master/docs/src/main/services/config.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.1*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../services/location.html" title="Location service" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Location service
</span>
</div>
</a>
<a href="../services/logging.html" title="Logging service" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Logging service
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox" title="Paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/" title="Paradox Material Theme">Paradox Material Theme</a>

</div>
<div class="md-footer-social">
</div>

</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application-268d62d82d.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({url:{base:".././"}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
