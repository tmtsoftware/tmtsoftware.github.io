{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"TMT JavaScript/Typescript Library"},{"location":"/index.html#tmt-javascript-typescript-library","text":"","title":"TMT JavaScript/Typescript Library"},{"location":"/index.html#esw-ts","text":"Javascript/Typescript library for building web applications inside TMT observatory. ESW-TS library is available on npm registry.","title":"ESW-TS"},{"location":"/index.html#motivation-behind-esw-ts","text":"TMT observatory will be using many web applications to observe and manage the observatory instruments. Web applications will require backend interface information for communication. These services provided by the ESW-TS library will help in encapsulating that internal information therefore, making it easier for UI developers to develop web app without having to worry about programming around the TMT backend.","title":"Motivation behind ESW-TS"},{"location":"/index.html#how-to-use-esw-ts","text":"For using ESW-TS library, you will need to have some kind of model which determines the flow of creating the web application in the first place and which TMT backend services that application will be using in its lifetime.\nDefine Application features / components. Depending on those features, decide which services will be required to build them from the available services. Develop & Build application components on top of the service.\nWhile using any of the service, you will be required to use some internal models for making API request and those domain models like (Prefix, ComponentId, etc) are provided in the ESW-TS to ease the development of web application.","title":"How to use ESW-TS"},{"location":"/index.html#library-contents","text":"Getting Started Installation Create starter project Params Commands ObsId Prefix CommandName Setup Command Observe Command Wait Command Unique Key constraint Events EventTime System Event Observe Event Unique Key Constraint Keys and Parameters How to create a Parameter using the helper functions Primitive Datatypes Array Datatypes Matrix Datatypes Domain Specific Types Coordinate Types Result Subsystem List of Subsystems Usage Examples State variables CurrentState Units Default Units for Keys SI Units CGS Units Astrophysical Units Imperial Units Others - Engineering Usage Examples Javascript Adapter (csw-aas-js) Dependencies Application Configuration Components AuthContextProvider Consumer Login Logout CheckLogin RealmRole Technical Description Response Handling Error Handling Error Types Service Error Client Side Error Error Handling pattern Services Admin Service Creation of Admin Service Usages of Admin Service Fetching LogMetadata Setting LogLevel of a component Alarm Service Creation of Alarm Service Usages of Alarm Service Setting alarm Severity Command Service Creation of Command Service Type of Actions Control Commands Usages of Command Service Validating Command Submitting a Command SubmitAndWait SubmitAllAndWait Oneway Query QueryFinal SubscribeCurrentState Config Service Rules and Checks Model Classes Creation of Config Service Usages of Config Service create update getActive getLatest getById getByTime exists delete list history getMetadata Managing active versions historyActive setActiveVersion resetActiveVersion getActiveVersion getActiveByTime Event Service Creation of Event Service Usages of Event Service Publishing an Event Get events Subscribe to the events Location Service Creation of Location Service Usages of Location Service Listing & Filtering Locations Resolving Connection Unregister a Connection Tracking Connection Logging Service Creation of Logging Service APIs Usages of Logging service Creating Log for an incident Technical Design Documentation Architectural overview Agent Service Creation of Agent Service Usages of Agent Service Spawning a Sequence Manager Spawning a Sequence Component Kill Component Sequencer Service Creation of Sequencer Service Creating SequenceCommands Creating a Sequence Usages of Sequencer Service Sequence Manager Service Creation of Sequence Manager Service APIs csw-aas-js - Javascript adapter csw-aas-js Implementation Project setup Keycloak Working of csw-aas-js Service Contract Type Definitions","title":"Library Contents"},{"location":"/common/getting-started.html","text":"","title":"Getting Started"},{"location":"/common/getting-started.html#getting-started","text":"In this tutorial, you’ll see how to create a UI starter project using a giter8 template which uses ESW-TS library. You can use this as a starting point for your own UI applications.","title":"Getting Started"},{"location":"/common/getting-started.html#installation","text":"node is mandatory to be installed on a machine for using ESW-TS. To install the latest version of node, visit the official website.","title":"Installation"},{"location":"/common/getting-started.html#create-starter-project","text":"It is recommended to use Giter8 template esw-ui-template.g8 to get started with building web application. Follow readme.md for more details on how to use the template to create starter project. ESW-TS comes pre-packaged as a dependency in the template.\nIf you already have a UI application and want to add ESW-TS dependency, then\nTo install the latest version of ESW-TS from npm\nnpm install @tmtsoftware/esw-ts\nOr, to install a specific version\nnpm install @tmtsoftware/esw-ts@{version}","title":"Create starter project"},{"location":"/params/index.html","text":"","title":"Params"},{"location":"/params/index.html#params","text":"In the distributed environment of TMT observatory, Components communicate with each other by sending asynchronous Messages. These messages have a Command payload, which flows down through the Sequencer components to the Assemblies, HCDs and finally to the hardware. At each hop Commands are validated, interpreted and further propagated making their journey to its destination. Commands provide flexible placeholders to store values to convey precise intent of the sender component.\nParams module plays a significant role as it caters to the diverse communication requirements. Consumer of this module will be able to create Commands, Events, States to store ParameterSets.\nParams has following models :\nCommands ObsId Prefix CommandName Setup Command Observe Command Wait Command Unique Key constraint Events EventTime System Event Observe Event Unique Key Constraint Keys and Parameters How to create a Parameter using the helper functions Primitive Datatypes Array Datatypes Matrix Datatypes Domain Specific Types Coordinate Types Result Subsystem List of Subsystems Usage Examples State variables CurrentState Units Default Units for Keys SI Units CGS Units Astrophysical Units Imperial Units Others - Engineering Usage Examples\nType definition for all common models used by services can be found here","title":"Params"},{"location":"/params/commands.html","text":"","title":"Commands"},{"location":"/params/commands.html#commands","text":"Commands are parameter sets called Setup, Observe, and Wait. A command is created with the source of the command, given by a prefix, the name of the command, and an optional ObsId. Parameters are added to the command as needed.","title":"Commands"},{"location":"/params/commands.html#obsid","text":"An ObsID, or observation ID, indicates the observation the command is associated with. It is a simple string.\nTypescript const obsId: string = 'Obs001'","title":"ObsId"},{"location":"/params/commands.html#prefix","text":"The source of the command is given by the prefix, which should be the full name of the component sending the command. A prefix can be constructed with a string, but must start with a valid subsystem as in Subsystem. A component developer should supply a valid prefix string and the subsystem will be automatically parsed from it. An example of a valid string prefix is “nfiraos.ncc.trombone”.\nType definition can be found @here\nSee below examples:\nTypescript const prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')","title":"Prefix"},{"location":"/params/commands.html#commandname","text":"Each command has a name given as a string. The string should be continuous with no spaces.","title":"CommandName"},{"location":"/params/commands.html#setup-command","text":"This command is used to describe a goal that a system should match. The component developer is required to supply following arguments to create a Setup command.\nPrefix: the source of the command as described above CommandName: a simple string name for the command (no spaces) ObsId: an optional observation id. paramSet: Optional Set of Parameters. Default is empty.\nType definition for ControlCommand can be found here\nTypescript const obsId: string = 'Obs001'\nconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')\nconst commandName = 'move'\nconst filterKey = intArrayKey('filter')\nconst filterParam: Parameter<IntArrayKey> = filterKey.set([\n  [1, 2, 3],\n  [4, 5, 6]\n])\n\nconst setup: Setup = new Setup(prefix, commandName, [filterParam], obsId)","title":"Setup Command"},{"location":"/params/commands.html#observe-command","text":"This command describes a science observation. It is intended to only be sent to Science Detector Assemblies and Sequencers.\nType definition for ControlCommand can be found here\nTypescript const obsId: string = 'Obs001'\nconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')\nconst commandName = 'move'\nconst filterKey = intArrayKey('filter')\nconst filterParam: Parameter<IntArrayKey> = filterKey.set([\n  [1, 2, 3],\n  [4, 5, 6]\n])\n\nconst observe: Observe = new Observe(\n  prefix,\n  commandName,\n  [filterParam],\n  obsId\n)","title":"Observe Command"},{"location":"/params/commands.html#wait-command","text":"This command causes a Sequencer to wait until notified. It can only be sent to Sequencers.\nType definition for ControlCommand can be found here\nTypescript const obsId: string = 'Obs001'\nconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')\nconst commandName = 'move'\nconst filterKey = intArrayKey('filter')\nconst filterParam: Parameter<IntArrayKey> = filterKey.set([\n  [1, 2, 3],\n  [4, 5, 6]\n])\n\nconst wait: Wait = new Wait(prefix, commandName, [filterParam], obsId)","title":"Wait Command"},{"location":"/params/commands.html#unique-key-constraint","text":"By design, a ParameterSet in a Setup, Observe, or Wait command is optimized to store only unique keys. When using add or madd methods on commands to add new parameters, if the parameter being added has a key which is already present in the paramSet, the already stored parameter will be replaced by the given parameter.\nNote If the Set is created by component developers and given directly while creating a command, then it will be the responsibility of component developers to maintain uniqueness with parameters based on key.\nHere are some examples that illustrate this point:\nTypescript const obsId: string = 'Obs001'\nconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')\nconst commandName = 'move'\nconst filterKey = intArrayKey('filter')\nconst randomKey = stringKey('directions')\nconst filterParam: Parameter<IntArrayKey> = filterKey.set([[1, 2, 3]])\nconst param1 = randomKey.set(['east', 'west'])\nconst param2 = randomKey.set(['north', 'south'])\n\nconst wait: Wait = new Wait(prefix, commandName, [filterParam], obsId)\nwait.madd([param1, param2])\n\n//duplicate keys will not be added. Should contain one randomKey and one Filter key\nwait.paramSet.forEach((x) => console.log(x.keyName))","title":"Unique Key constraint"},{"location":"/params/events.html","text":"","title":"Events"},{"location":"/params/events.html#events","text":"Events are the most basic type of asynchronous notification in TMT when an activity occurs somewhere in the TMT system and other components need to be notified. Each type of event has a unique purpose and unique information, but they all share same structural features. All events have EventInfo and a ParameterSet.\nType definition for Event can be found here","title":"Events"},{"location":"/params/events.html#eventtime","text":"Each event includes its time of creation in UTC format. You can access that eventTime as follows:\nTypescript const source = new Prefix('IRIS', 'filter.wheel')\nconst eventName = new EventName('temperatures')\nconst event = SystemEvent.make(source, eventName)\n\n// accessing eventTime\nconst eventTime = event.eventTime","title":"EventTime"},{"location":"/params/events.html#system-event","text":"SystemEvent is the type used to describe the majority of events in the system. An example is a demand that is the output of an algorithm in one component that is used as an input to another. SystemEvent is also used to publish internal state or status values of a component that may be of interest to other components in the system.","title":"System Event"},{"location":"/params/events.html#example-snippets-for-creation-of-system-event-","text":"Typescript //keys\nconst k1 = intKey('encoder')\nconst k2 = intKey('speed')\nconst k3 = stringKey('filter')\nconst k4 = intKey('notUsed')\n\n//prefixes\nconst ck1 = Prefix.fromString('wfos.red.filter')\nconst name1 = new EventName('filterWheel')\nconst ck3 = Prefix.fromString('iris.imager.filter')\nconst name3 = new EventName('status')\n\n//parameters\nconst p1: Parameter<IntKey> = k1.set([22])\nconst p2: Parameter<IntKey> = k2.set([44])\nconst p3: Parameter<StringKey> = k3.set(['A', 'B', 'C', 'D'])\n\n//Create SystemEvent using madd\nconst se1: SystemEvent = SystemEvent.make(ck1, name1).madd([p1, p2])\n//Create SystemEvent using make\nconst se2: SystemEvent = SystemEvent.make(ck3, name3, [p1, p2])\n//Create SystemEvent and use add\nconst se3: SystemEvent = SystemEvent.make(ck3, name3).add(p1).add(p2).add(p3)\n\n//access keys\nconst k1Exists: Boolean = se1.exists(k1) //true\n\n//access Parameters\nconst p4: Option<Parameter<IntKey>> = se1.get(k1)\n\n//access values\nconst v1: Option<number[]> = se1.get(k1)?.values\nconst v2: Option<number[]> = se2.get(k2)?.values\n\n//remove keys\nconst se4: SystemEvent = se3.remove(k3)\n\n//add more than one parameters, using madd\nconst se5: SystemEvent = se4.madd([k3.set(['X', 'Y', 'Z']), k4.set([99, 100])])\nconst paramSize: number = se5.size()\n\n//update existing key with set\nconst se6: SystemEvent = se5.add(k2.set([5, 6, 7, 8]))","title":"Example snippets for creation of system event :"},{"location":"/params/events.html#observe-event","text":"ObserveEvent are standardized events used to describe an activities within the data acquisition process. These events are typically published by Science Detector Assemblies, which emit ObserveEvents during their exposures to signal the occurrence of specific activities/actions during the acquisition of data.","title":"Observe Event"},{"location":"/params/events.html#example-snippets-for-creation-of-observe-event-","text":"Typescript //keys\nconst k1 = intKey('readoutsCompleted')\nconst k2 = intKey('coaddsCompleted')\nconst k3 = stringKey('fileID')\nconst k4 = intKey('notUsed')\n\n//prefixes\nconst ck1 = Prefix.fromString('iris.ifu.detectorAssembly')\nconst name1 = new EventName('readoutEnd')\nconst ck3 = Prefix.fromString('wfos.red.detector')\nconst name3 = new EventName('exposureStarted')\n\n//parameters\nconst p1: Parameter<IntKey> = k1.set([4])\nconst p2: Parameter<IntKey> = k2.set([2])\nconst p3: Parameter<StringKey> = k3.set(['WFOS-RED-0001'])\n\n//Create ObserveEvent using madd\nconst se1: ObserveEvent = ObserveEvent.make(ck1, name1).madd([p1, p2])\n//Create ObserveEvent using apply\nconst se2: ObserveEvent = ObserveEvent.make(ck3, name3, [p1, p2])\n//Create ObserveEvent and use add\nconst se3: ObserveEvent = ObserveEvent.make(ck3, name3)\n  .add(p1)\n  .add(p2)\n  .add(p3)\n\n//access keys\nconst k1Exists: Boolean = se1.exists(k1) //true\n\n//access Parameters\nconst p4: Option<Parameter<IntKey>> = se1.get(k1)\n\n//access values\nconst v1: Option<number[]> = se1.get(k1)?.values\nconst v2: Option<number[]> = se2.get(k2)?.values\n\n//remove keys\nconst se4: ObserveEvent = se3.remove(k3)","title":"Example snippets for creation of observe event :"},{"location":"/params/events.html#unique-key-constraint","text":"By choice, a ParameterSet in either ObserveEvent or SystemEvent event will be optimized to store only unique keys. When using add or madd methods on events to add new parameters, if the parameter being added has a key which is already present in the paramSet, the already stored parameter will be replaced by the given parameter.\nNote If the Set is created by component developers and given directly while creating an event, then it will be the responsibility of component developers to maintain uniqueness with parameters based on key.","title":"Unique Key Constraint"},{"location":"/params/events.html#here-are-some-examples-that-illustrate-this-point-","text":"Typescript //keys\nconst encoderKey = intKey('encoder')\nconst filterKey = intKey('filter')\nconst miscKey = intKey('misc')\n\n//prefix\nconst prefix = Prefix.fromString('wfos.blue.filter')\n\nconst name1 = new EventName('filterWheel')\n\n//params\nconst encParam1 = encoderKey.set([1])\nconst encParam2 = encoderKey.set([2])\n\nconst encParam3 = encoderKey.set([3])\nconst filterParam1 = filterKey.set([1])\nconst filterParam2 = filterKey.set([2])\n\nconst filterParam3 = filterKey.set([3])\n\nconst miscParam1 = miscKey.set([100])\n//StatusEvent with duplicate key via constructor\nconst systemEvent = SystemEvent.make(prefix, name1, [\n  encParam1,\n  encParam2,\n  encParam3,\n  filterParam1,\n  filterParam2,\n  filterParam3\n])\n\n//try adding duplicate keys via add + madd\nconst changedStatusEvent = systemEvent\n  .add(encParam3)\n  .madd([filterParam1, filterParam2, filterParam3])\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nconst uniqueKeys2 = changedStatusEvent.paramSet.map((x) => x.keyName)\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nconst finalStatusEvent = systemEvent.madd([miscParam1, encParam1])\n//now contains encoderKey, filterKey, miscKey\nconst uniqueKeys3 = finalStatusEvent.paramSet.map((x) => x.keyName)","title":"Here are some examples that illustrate this point:"},{"location":"/params/keys-and-parameters.html","text":"","title":"Keys and Parameters"},{"location":"/params/keys-and-parameters.html#keys-and-parameters","text":"The library offers a flexible and typesafe means to create Parameters to store values like primitive types, collection types or domain specific types.\nA Parameter is a Key and Value where the Value must be from a set of defined primitive types including binary data. The Value of a Parameter is always considered to be an Array of the type (i.e. if a single value is stored it is at array location 0). A Parameter is immutable; a modification to an existing Parameter will return a new instance.\nA Value can also have Units, which must be of the defined types. See Units for more information. At this time Units are informational only–no calculation or conversion support is provided. Some systems may provide a key value with different units, and receiver can inspect the Units to make a decision on how to handle the value.\nA ParameterSet is a Set of Parameter. Various other message types include a ParameterSet (e.g. Setup, Event). A key is unique in a ParameterSet since it is a Set.","title":"Keys and Parameters"},{"location":"/params/keys-and-parameters.html#how-to-create-a-parameter-using-the-helper-functions","text":"Choose an appropriate KeyType from the tables below. Calling the set method on KeyType helper and supplying a string keyName will return a suitably typed parameter instance.","title":"How to create a Parameter using the helper functions"},{"location":"/params/keys-and-parameters.html#example-snippets-for-creating-parameter-of-simple-array-and-matrix-type-","text":"Typescript // primitives\nconst booleanParam: Parameter<BooleanKey> = booleanKey('flag').set([false])\n\nconst intParam: Parameter<IntKey> = intKey('RandomKeyName').set([123, 12432])\n// intParam.keyName === 'RandomKeyName'\n// intParam.keyTag === 'IntKey'\n// intParam.values === [123, 12432]\n// intParam.units === 'NoUnits' // default unit is `NoUnits`\n// -------------\n\n// arrays\nconst filterkey = intArrayKey('filter')\nconst filterParam: Parameter<IntArrayKey> = filterkey.set([\n  [1, 2, 3],\n  [4, 5, 6]\n])\n// -------------\n\n// matrices\nconst positionMatrixKey = byteMatrixKey('positions', 'meter')\nconst positions: Parameter<ByteMatrixKey> = positionMatrixKey.set([\n  [\n    [1, 2],\n    [3, 4]\n  ],\n  [\n    [5, 6],\n    [7, 8]\n  ]\n])","title":"Example snippets for creating parameter of simple, array and matrix type."},{"location":"/params/keys-and-parameters.html#primitive-datatypes","text":"Primitive Typescript Key Type Helper functions Int IntKey intKey Long LongKey longKey Short ShortKey shortKey Float FloatKey floatKey Double DoubleKey doubleKey Byte ByteKey byteKey String StringKey stringKey Char CharKey charKey Boolean BooleanKey booleanKey UTCTime UTCTimeKey utcTimeKey TAITime TAITimeKey taiTimeKey","title":"Primitive Datatypes"},{"location":"/params/keys-and-parameters.html#array-datatypes","text":"Primitive Typescript Key Type Helper functions IntArray IntArrayKey intArrayKey LongArray LongArrayKey longArrayKey ShortArray ShortArrayKey shortArrayKey FloatArray FloatArrayKey floatArrayKey DoubleArray DoubleArrayKey doubleArrayKey ByteArray ByteArrayKey byteArrayKey","title":"Array Datatypes"},{"location":"/params/keys-and-parameters.html#matrix-datatypes","text":"Primitive Typescript Key Type Helper functions IntMatrix IntMatrixKey intMatrixKey LongMatrix LongMatrixKey longMatrixKey ShortMatrix ShortMatrixKey shortMatrixKey FloatMatrix FloatMatrixKey floatMatrixKey DoubleMatrix DoubleMatrixKey doubleMatrixKey ByteMatrix ByteMatrixKey byteMatrixKey","title":"Matrix Datatypes"},{"location":"/params/keys-and-parameters.html#domain-specific-types","text":"choice : A key for a choice item similar to an enumeration struct : Structs can be used to create a hierarchy of parameters\nPrimitive Typescript Key Type Helper functions Choice ChoiceKey choiceKey Struct StructKey Struct","title":"Domain Specific Types"},{"location":"/params/keys-and-parameters.html#example-snippets-for-creating-choice-and-struct-parameters","text":"Typescript // choice key\n\nconst choices = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] as const\n\nconst weekDaysKey = choiceKey('weekDaysKey', choices)\nconst weekDayParam = weekDaysKey.set('Mon', 'Wed')\n// weekDayParam === Parameter('weekDaysKey', 'ChoiceKey', ['Mon', 'Wed'], 'NoUnits')\n\n// -------------\n\n// example for struct key\n// leaf parameters\nconst ra: Parameter<StringKey> = stringKey('ra').set(['12:13:14.1'])\nconst dec = stringKey('dec').set(['32:33:34.4'])\nconst epoch = doubleKey('epoch').set([1970.0])\n\n// initialise struct key\nconst struct = new Struct().add(ra)\nstruct.madd([dec, epoch])\n\n// create struct Parameter using structKey\nconst structParameter = structKey('my struct').set([struct])","title":"Example snippets for creating choice and struct parameters"},{"location":"/params/keys-and-parameters.html#coordinate-types","text":"Primitive Typescript Key Type Helper functions RaDec RaDecKey raDecKey EqCoord EqCoordKey eqCoordKey SolarSystemCoord SolarSystemCoordKey solarSystemCoordKey MinorPlanetCoord MinorPlanetCoordKey minorPlanetCoordKey CometCoord CometCoordKey cometCoordKey AltAzCoord AltAzCoordKey altAzCoordKey Coord (*) CoordKey coordKey","title":"Coordinate Types"},{"location":"/params/keys-and-parameters.html#example-snippet-for-creating-coordinate-parameters","text":"Typescript const cometCoord = new CometCoord(\n  'BASE',\n  2000,\n  324000000000,\n  7200000000,\n  360000000000,\n  1.4,\n  0.234\n)\nconst cometParam: Parameter<CometCoordKey> = cometCoordKey(\n  'comet key',\n  'degree'\n).set([cometCoord])\n\n//coord key is base trait of all coordinate key types.\nconst coordParam: Parameter<CoordKey> = coordKey('base coordinate').set([\n  cometCoord\n])\nNote Note that since Coord is the base trait of the other coordinate types, you can use it as the key for any of the coordinate types.","title":"Example snippet for creating coordinate parameters"},{"location":"/params/result.html","text":"","title":"Result"},{"location":"/params/result.html#result","text":"Components use Results to return results of a command in the form of a ParameterSet. Result is the value that is returned as an argument to the Completed SubmitResponse.\nType definition for Result can be found here\nFollowing snippet shows how to create a Result :\nTypescript //keys\n\nconst k1 = intKey('encoder')\nconst k2 = intKey('windspeed')\nconst k3 = stringKey('filter')\nconst k4 = intKey('notUsed')\n\n//prefixes\nconst prefix = Prefix.fromString('wfos.prog.cloudcover')\n\n//parameters\nconst p1: Parameter<IntKey> = k1.set([22])\nconst p2: Parameter<IntKey> = k2.set([44])\nconst p3: Parameter<StringKey> = k3.set(['A', 'B', 'C', 'D'])\n\n//Create Result using madd\nconst r1: Result = new Result().madd([p1, p2])\n//Create Result using apply\nconst r2: Result = new Result([p1, p2])\n//Create Result and use add\nconst r3: Result = new Result().add(p1).add(p2).add(p3)\n\n//access keys\nconst k1Exists: Boolean = r1.exists(k1) //true\n\n//access Parameters\nconst p4: Option<Parameter<IntKey>> = r1.get(k1)\n\n//access values\nconst v1: Option<number[]> = r1.get(k1)?.values\nconst v2: Option<number[]> = r2.get(k2)?.values\n\n//remove keys\nconst r4: Result = r3.remove(k3)","title":"Result"},{"location":"/params/subsystem.html","text":"","title":"Subsystem"},{"location":"/params/subsystem.html#subsystem","text":"TMT Observatory system is composed of many subsystems. The subsystems that are known participants in the TMT Software System are predefined and the list is covered under the Subsystem enumeration. They are identified using an abbreviation typically of 3 or 4 letters.\nSusbsystem values are used to construct Prefix and are used in communication vehicles such as Commands, Events and States.\nType definition for Subsystem can be found here","title":"Subsystem"},{"location":"/params/subsystem.html#list-of-subsystems","text":"Abbreviation Susbsystem name AOESW AO Executive Software APS Alignment and Phasing System CIS Communications and Information Systems CLN Mirror Cleaning System CRYO Cryogenic Cooling System CSW Common Software DMS Data Management System DPS Data Processing System ESEN Engineering Sensor System ESW Executive Software System FMCS Facility Management Control System GMS Global Metrology System Controls IRIS InfraRed Imaging Spectrometer LGSF Lasert Guide Star Facility M1CS M1 Control System MODHIS Multi-Object Diffraction-limited High-resolution Infrared Spectrograph NFIRAOS Narrow Field Infrared AO System NSCU NFIRAOS Science Calibration Unit OSS Observatory Safety System PFCS Prime Focus Camera Controls PSFR NFIRAOS AO PSF Reconstructor REFR Refrigeration Control System RTC NFIRAOS Real-time Controller RPG NFIRAOS AO Reconstructor Parameter Generator SCMS Site Conditions Monitoring System SOSS Science Operations Support System TCS Telescope Control System WFOS Wide Field Optical Spectrometer Container Container subsystem","title":"List of Subsystems"},{"location":"/params/subsystem.html#usage-examples","text":"The usage examples can be found in Events, Commands, States","title":"Usage Examples"},{"location":"/params/state-variables.html","text":"","title":"State variables"},{"location":"/params/state-variables.html#state-variables","text":"State variables are used when an UI for Assembly wants to track the status of a command sent to an HCD using a matcher.\nA state represents some aspect of a component’s internal state which is captured in CurrentState. All state variables have Prefix and ParameterSet.\nThe PubSub feature of the HCD provides CurrentState values to the PubSub subscriber.","title":"State variables"},{"location":"/params/state-variables.html#currentstate","text":"A state variable that is published by a component that describes its internal state. Used by Assemblies to determine command completion in Command Service.\nType definition for CurrentState can be found here\nTypescript //prefix\n\nconst prefix = Prefix.fromString('wfos.prog.cloudcover')\n\n//key\nconst charKey1 = charKey('charKey')\nconst intKey1 = intKey('intKey', 'meter')\nconst booleanKey1 = booleanKey('booleanKey')\nconst utcTimeKey1 = utcTimeKey('utcTimeKey')\nconst notUsedKey = stringKey('notUsed')\n\n//parameters\nconst charParam = charKey1.set(['A', 'B', 'C'])\nconst intParam = intKey1.set([1, 2, 3])\nconst booleanParam = booleanKey1.set([true, false])\nconst utcTime = utcTimeKey1.set([new Date().toUTCString()])\n\n//create CurrentState and use sequential add\nconst cs1 = new CurrentState(prefix, 'testStateName')\n  .add(charParam)\n  .add(intParam)\n//create CurrentState and add more than one Parameters using madd\nconst cs2 = new CurrentState(prefix, 'testStateName').madd([\n  intParam,\n  booleanParam\n])\n//create CurrentState using apply\nconst cs3 = new CurrentState(prefix, 'testStateName', [utcTime])\n\n//access keys\nconst charKeyExists = cs1.exists(charKey1) //true\n\n//access Parameters\nconst p1: Option<Parameter<IntKey>> = cs1.get(intKey1)\n\n//access values\nconst v1: Option<string[]> = cs1.get(charKey1)?.values\nconst v2: Option<boolean[]> = cs2.get(booleanKey1)?.values\n\n//remove keys\nconst cs4 = cs3.remove(utcTimeKey1)\n\n//update existing keys - set it back by an hour\nvar today = new Date()\ntoday.setHours(today.getHours() - 1)\nconst cs5 = cs3.add(utcTimeKey1.set([today.toUTCString()]))","title":"CurrentState"},{"location":"/params/units.html","text":"","title":"Units"},{"location":"/params/units.html#units","text":"Listed below are Units of Measurement, supported by TMT observatory framework and are available as Enumerated values. Units are optionally attached to Parameter Keys.\nType definition for Units can be found here\nNote The set of supported Units will be modified as more required Units will be discovered.","title":"Units"},{"location":"/params/units.html#default-units-for-keys","text":"The default unit for UTCTimeKey and TAITimeKey is second. For all the remaining keys, default unit is NoUnits.","title":"Default Units for Keys"},{"location":"/params/units.html#si-units","text":"Name Abbreviation Description angstrom Angstrom 10 -1 nm arcmin arcmin arc minute; angular measurement arcsec arcsec arc second: angular measurement day d day - 24 hours degree deg degree: agular measurement 1/360 of full rotation elvolt eV electron volt 1.6022x10-19 J gram g gram 10-3 kg hour h hour 3.6x10+3 s hertz Hz frequency joule J Joule: energy N m kelvin K Kelvin: temperature with a null point at absolute zero kilogram kg kilogram, base unit of mass in SI kilometer km kilometers - 10+3 m liter l liter, metric unit of volume 10+3 cm+3 meter m meter: base unit of length in SI marcsec mas milli arc second: angular measurement 10-3 arcsec millimeter mm millimeters - 10-3 m millisecond ms milliseconds - 10-3 s micron µm micron: alias for micrometer micrometer µm micron: 10-6 m minute min minute 6x10+1 s newton N Newton: force pascal Pa Pascal: pressure radian rad radian: angular measurement of the ratio between the length of an arc and its radius second s second: base unit of time in SI sday sday sidereal day is the time of one rotation of the Earth: 8.6164x10+4 s steradian sr steradian: unit of solid angle in SI - rad+2 microarcsec µas micro arcsec: angular measurement volt V Volt: electric potential or electromotive force watt W Watt: power week wk week - 7 d year yr year - 3.6525x10+2 d","title":"SI Units"},{"location":"/params/units.html#cgs-units","text":"Name Abbreviation Description coulomb C coulomb: electric charge centimeter cm centimeter erg erg erg: CGS unit of energy","title":"CGS Units"},{"location":"/params/units.html#astrophysical-units","text":"Name Abbreviation Description au AU astronomical unit: approximately the mean Earth-Sun distance jansky Jy Jansky: spectral flux density - 10-26 W/Hz m+2 lightyear lyr light year - 9.4607x10+15 m mag mag stellar magnitude","title":"Astrophysical Units"},{"location":"/params/units.html#imperial-units","text":"Name Abbreviation Description cal cal thermochemical calorie: pre-SI metric unit of energy foot ft international foot - 1.2x10+1 inch inch inch international inch - 2.54 cm pound lb international avoirdupois pound - 1.6x10+1 oz mile mi international mile - 5.28x10+3 ft ounce oz international avoirdupois ounce yard yd international yard - 3 ft","title":"Imperial Units"},{"location":"/params/units.html#others-engineering","text":"Name Abbreviation Description NoUnits none scalar - no units specified encoder enc encoder counts count ct counts as for an encoder or detector pix pix pixel","title":"Others - Engineering"},{"location":"/params/units.html#usage-examples","text":"Typescript //declare keyName\nconst s1: string = 'encoder'\n\n//making 2 keys\nconst k1 = booleanKey(s1)\nconst k2 = shortKey('RandomKeyName', 'meter')\n\n//storing a single value\nconst booleanParam: Parameter<BooleanKey> = k1.set([true])\n\n//storing multiple values\nconst paramWithShorts1: Parameter<ShortKey> = k2.set([1, 2, 3, 4])\n\n//  default unit is NoUnits\n// booleanParam.units === \"NoUnits\"\n\n//retrieve values from Parameter\nconst allValues: Array<number> = paramWithShorts1.values\n\n// allValues === Array(1, 2, 3, 4))\n// paramWithUnits3.units === \"meter\")\n\n//default unit for UTCTimeKey is second\nconst tParam: Parameter<UTCTimeKey> = utcTimeKey('now').set([\n  new Date().toUTCString()\n])\nconst defaultTimeUnit: Units = tParam.units //is second","title":"Usage Examples"},{"location":"/aas/csw-aas-js.html","text":"","title":"Javascript Adapter (csw-aas-js)"},{"location":"/aas/csw-aas-js.html#javascript-adapter-csw-aas-js-","text":"csw-aas-js is an npm package which provides React components that integrate with the CSW Authentication and Authorization Service. UI applications can use these React components to enable the application to show or hide components based on the authentication and authorization policy. csw-aas-js is written in typescript and it bundles transpiled es6 module along with type declarations.","title":"Javascript Adapter (csw-aas-js)"},{"location":"/aas/csw-aas-js.html#dependencies","text":"To use the esw-ts adapter, run this command from root folder of your application where package.json exists:\nnpm     npm i --save esw-ts@0.1.0-SNAPSHOT\n yarn     yarn add esw-ts@0.1.0-SNAPSHOT","title":"Dependencies"},{"location":"/aas/csw-aas-js.html#application-configuration","text":"Web application needs following configurations in order to get access token from keycloak server. This application specific config object should be passed in AuthContextProvider component. There are two configurations needed for a web application i.e. realm, clientId\nrealm is a mandatory configuration which specified in keycloak server under which client for your application is registered.\nclientId is a mandatory configuration which specifies the client id of the app as per registration in keycloak server.\nJavascript export const AppConfig = {\n  realm: 'TMT',\n  clientId: 'tmt-frontend-app',\n  applicationName: 'test-app'\n}","title":"Application Configuration"},{"location":"/aas/csw-aas-js.html#components","text":"esw-ts exposes the following React components.\nAuthContextProvider Consumer Login Logout CheckLogin RealmRole\nType definition for all components used by services can be found here\nComponents can be imported as shown in code snippet below\nJavascript import { AuthContext, Logout, Login } from '@tmtsoftware/esw-ts'","title":"Components"},{"location":"/aas/csw-aas-js.html#authcontextprovider","text":"AuthContextProvider is wrapper over a React Context.Provider. A JSON configuration file must be passed in that contains the application specific AAS server configuration (e.g. clientId, realm). When a user logs in, an AAS Server is instantiated, with the UI application specific configuration overriding the predefined configuration. Once the AAS sever is instantiated, an auth object is created with the needed attributes and APIs. This auth object is available to other React components; since AuthContextProvider is a Provider, its data can be shared with any of the children React components in its tree in a Consumer component (see below). All Consumers that are descendants of a Provider will re-render whenever the AuthContextProvider’s state changes, e.g. a user authorizes. It is recommended to use AuthContextProvider to wrap the entire application so that data can be shared anywhere in application via a Consumer.\nJavascript <AuthContextProvider config={AppConfig}>\n  <BrowserRouter>\n    <div>\n      <NavComponent />\n      <Route\n        exact\n        path='/secured'\n        render={(_) => (\n          <CheckLogin error={<LoginError />}>\n            <Write />\n          </CheckLogin>\n        )}\n      />\n      <Route exact path='/config' render={(_) => <ConfigApp />} />\n      <Route\n        exact\n        path='/example_admin'\n        render={(_) => (\n          <CheckLogin error={<LoginError />}>\n            <RealmRole\n              realmRole='example-admin-role'\n              error={\n                <RoleError\n                  message={'User do not have role : example-admin-role'}\n                />\n              }>\n              <div>Example admin role specific functionality</div>\n            </RealmRole>\n          </CheckLogin>\n        )}\n      />\n      <Route\n        exact\n        path='/example_user'\n        render={(_) => (\n          <CheckLogin error={<LoginError />}>\n            <RealmRole\n              realmRole='person-role'\n              error={\n                <RoleError\n                  message={'User do not have role : person-role'}\n                />\n              }>\n              <div>Person role specific functionality</div>\n            </RealmRole>\n          </CheckLogin>\n        )}\n      />\n      <Route exact path='/public' component={Read} />\n    </div>\n  </BrowserRouter>\n</AuthContextProvider>","title":"AuthContextProvider"},{"location":"/aas/csw-aas-js.html#source-code-for-authcontextprovider-component","text":"AuthContextProvider Component","title":"Source code for AuthContextProvider component"},{"location":"/aas/csw-aas-js.html#consumer","text":"Consumer is similar to a React Context.Consumer. The shared auth object from the AuthContextProvider can be accessed using a Consumer component\nJavascript const { auth } = useContext(AuthContext)\nreturn (\n  <div className='nav-wrapper'>\n    {auth && auth.isAuthenticated() ? (\n      <div>\n        Hello, you are logged in\n        <div>Open functionality</div>\n      </div>\n    ) : (\n      <div>\n        Hello, you are not logged in\n        <div>Open functionality</div>\n      </div>\n    )}\n  </div>\n)","title":"Consumer"},{"location":"/aas/csw-aas-js.html#source-code-for-consumer-component","text":"Consumer Component","title":"Source code for Consumer component"},{"location":"/aas/csw-aas-js.html#login","text":"The Login component instantiates an AAS server with the configurations provided. It redirects to an AAS server login page for the user to login. After login, the auth object in the context is updated with the appropriate values, e.g. token, realm etc.\nJavascript <Login />","title":"Login"},{"location":"/aas/csw-aas-js.html#source-code-for-login-component","text":"Login Component","title":"Source code for Login component"},{"location":"/aas/csw-aas-js.html#logout","text":"The Logout component logs out the user from the AAS server. It clears the auth object stored in the context.\nJavascript   <Logout />\n) : (","title":"Logout"},{"location":"/aas/csw-aas-js.html#source-code-for-logout-component","text":"Logout Component","title":"Source code for Logout component"},{"location":"/aas/csw-aas-js.html#checklogin","text":"CheckLogin components provide ability to show something only if the user is logged in. In the following code snippet, Write is a react component that is shown only if the user is logged in. The behavior if the user is not logged in can be defined by an HTML element or React component that is passed into the component as an error property, shown as an ExampleError Component in following snippet.\nJavascript <CheckLogin error={<LoginError />}>\n  <Write />\n</CheckLogin>","title":"CheckLogin"},{"location":"/aas/csw-aas-js.html#source-code-for-checklogin-component","text":"CheckLogin Component","title":"Source code for CheckLogin component"},{"location":"/aas/csw-aas-js.html#realmrole","text":"RealmRole components provide the ability to show something only if the user is logged in and has the specified realm role. In the following code snippet, the contents of the div block are shown only if the user is logged in and has the realm role specified in the realmRole prop. Similar to CheckLogin, the behaviour if the user is not logged in can be optionally defined by an HTML element or React component that is passed into the component as an error property, shown as an ExampleError Component in following snippet.\nJavascript <RealmRole\n  realmRole='example-admin-role'\n  error={\n    <RoleError\n      message={'User do not have role : example-admin-role'}\n    />\n  }>\n  <div>Example admin role specific functionality</div>\n</RealmRole>","title":"RealmRole"},{"location":"/aas/csw-aas-js.html#source-code-for-realmrole-component","text":"RealmRole Component","title":"Source code for RealmRole component"},{"location":"/aas/csw-aas-js.html#technical-description","text":"See csw-aas-js Technical Description.","title":"Technical Description"},{"location":"/common/response-handling.html","text":"","title":"Response Handling"},{"location":"/common/response-handling.html#response-handling","text":"This sections helps to understand how responses have been modeled in TMT architecture and, also how they can be handled at UI application side.\nIf you have not gone the Services Section, We Recommend you to check Services out first. Assuming you have read through the Services section and what all types of response can be returned by the Service of your current interest.\nResponse types which are Union types/ADT’s , all of them are tagged by _type field, which provides information at compile time to developers of all possible response variation at runtime for the current response.\nFor example : Command Service’s submit method’s response type is SubmitResponse which can be one of 6 different response.\nDepending on how you would want to use SubmitResponse, you can handle all variations or few of the responses.\n2 ways of response handling have been showcase here:\nTypescript // response handlers\nconst onCancelled = () => {\n  // do something on receiving Cancelled type\n}\nconst onCompleted = () => {\n  // do something on receiving Completed type\n}\nconst onStarted = () => {\n  // do something on receiving Started type\n}\nconst onError = () => {\n  // do something on receiving Error type\n}\nconst onInvalid = () => {\n  // do something on receiving Invalid type\n}\nconst onLocked = () => {\n  // do something on receiving Locked type\n}\n\nconst prefix = new Prefix('ESW', 'component_1')\nconst componentId = new ComponentId(prefix, 'Assembly')\nconst commandService: CommandService = await CommandService(\n  componentId,\n  tokenFactory\n)\n\nconst setup = new Setup(prefix, 'move', [])\nconst submitResponse: SubmitResponse = await commandService.submit(setup)\n\n// Handle all variations (Exhaustive switch pattern)\nswitch (submitResponse._type) {\n  case 'Cancelled':\n    onCancelled()\n    break\n  case 'Completed':\n    onCompleted()\n    break\n  case 'Started':\n    onStarted()\n    break\n  case 'Error':\n    onError()\n    break\n  case 'Invalid':\n    onInvalid()\n    break\n  case 'Locked':\n    onLocked()\n    break\n}\n\n// or handle few types\n\nswitch (submitResponse._type) {\n  case 'Completed':\n    onCompleted()\n    break\n  case 'Started':\n    onStarted()\n    break\n  case 'Error':\n    onError()\n    break\n  default: // !!important!!\n  // do something by default for other cases\n}\nNote All non-ADT or Normal response types (for ex: Done, LogMetadata, etc.) does not require extra effort of handling it with switch cases. because those models does not have any discriminatory field like _type and there will always be one variation, and the information about all fields inside model will be statically known.","title":"Response Handling"},{"location":"/common/error-handling.html","text":"","title":"Error Handling"},{"location":"/common/error-handling.html#error-handling","text":"Errors/Exceptions must be handled in application code because that will help user to make further decisions for controlled user interactions with the UI.\nTo read more on exception handling, refer this document which gives detailed explanation.","title":"Error Handling"},{"location":"/common/error-handling.html#error-types","text":"","title":"Error Types"},{"location":"/common/error-handling.html#service-error","text":"In TMT Architecture, Service error captures all/most of the Service/Network level errors/exceptions. A runtime error which gets thrown after making Service’s API and gets caught in the Service call’s scaffolding snippet falls into this category.\nFor example:\nWhen using CommandService to submit a command for a non-existing component will result into LocationNotFound.\nLocationNotFoundException is a Service Error, and it would contain following fields :\nerrorType: LocationNotFound, message: ‘Could not resolve location matching connection: $non_existent_component_connection’, status: 500, statusText: Internal Server error\nType definition for Service Error can be found here","title":"Service Error"},{"location":"/common/error-handling.html#client-side-error","text":"Any runtime error which gets thrown before making Service’s API call falls into this category. Errors/ Exception caught at validation or at data creation time will be thrown before making api calls. When creating a domain object which has validations for sending it as a payload will throw a runtime exception while performing validations check, and those are not met.\nFor Example: Prefix has a validation that it cannot have - or space in the componentName field.\nFollowing snippet will result into runtime error : it is a native browser’s Error object with the message field and stacktrace. message field will contain the reason for which the validation failed.\nTypescript const prefix = new Prefix('ESW', 'filter-wheel')\nFor the given case it will have the following information.\nmessage: Requirement failed - component name filter-wheel has '-'","title":"Client Side Error"},{"location":"/common/error-handling.html#error-handling-pattern","text":"The following examples shows how to call AgentService api’s and handle the response SpawnResponse and KillResponse.\nThis example also illustrates error handling of service specific exception AgentNotFoundException along with the generic errors like TransportError and ArithmeticException will look like.\nExploiting try-catch is an anti-pattern The example uses try-catch to handle errors and exceptions. Generally those errors/exceptions are handled at UI framework level on boundaries of service calls. This example will be updated once we have frontend framework setup in place.\nA function whose responsibility is to handle errors & exceptions\nTypescript // common function to handle error scenario's\nconst handleError = (err: Error) => {\n  if (err instanceof ServiceError) {\n    // depending on use case, error can be handled on following fields\n    //  - err.status      (5XX, 4XX, 3XX)\n    //  - err.errorType   (AgentNotFoundException, TransportError, ArithmeticException, NullPointerException, etc)\n\n    // Other fields present in error model\n    // err.message : contains the reason which can be used to show on UI\n    // err.statusText :  Forbidden , Unauthorised, BadRequest, Not Found, etc.\n\n    switch (err.errorType) {\n      case 'AgentNotFoundException':\n        console.log(err.message) // Location not found for $agentPrefix\n        console.log('do something on getting AgentNotFoundException')\n        break\n      case 'TransportError':\n        console.log(err.statusText)\n        console.log('do something on getting TransportError (4XX, 3XX, etc))')\n        break\n      case 'ArithmeticException':\n        console.log(err.statusText) // InternalServerError\n        console.log(err.message) // Reason : / by zero\n        break\n      default:\n        throw Error(err.message)\n    }\n  } else {\n    // client side error occurred at validations and operations before making api call to the server\n    // for ex: Prefix can throw runtime error if componentName is invalid.\n  }\n}\nExample for spawnSequenceManager api with error handling looks like following:\nTypescript // setup\nconst agentService: AgentService = await AgentService(tokenFactory)\n\nconst agentPrefix = new Prefix('ESW', 'agent1')\nconst obsModeConfigPath = '/obs-mode.conf'\nconst sequenceManagerVersion = '1.0.0'\n\ntry {\n  const spawnResponse: SpawnResponse = await agentService.spawnSequenceManager(\n    agentPrefix,\n    obsModeConfigPath,\n    false,\n    sequenceManagerVersion\n  )\n\n  // spawn response handling (200 status code)\n  switch (spawnResponse._type) {\n    case 'Spawned':\n      // do something on successful spawn operation\n      break\n    case 'Failed':\n      // do something on failed response\n      break\n  }\n} catch (err) {\n  handleError(err)\n}","title":"Error Handling pattern"},{"location":"/services/index.html","text":"","title":"Services"},{"location":"/services/index.html#services","text":"These are javascript adapters for each of public facing TMT services. They provide a handle to interact with backend server while adhering to the service contract.\nTMT Services are behind ESW Gateway Server except Location and Config Server.\nFollow the instructions in the first step of our quickstart guide to integrate one or more services in the UI application.\nThese are following services available:\nAdmin Service Alarm Service Command Service Config Service Event Service Location Service Logging Service\nType definition for all services can be found here\nAdmin Service : This service provides a handle to admin related APIs which includes logging related APIs Agent Service : The Agent Service is used to spawn a component of machine or kill a running component. To do so, it uses the agent running on that specific machine where component is to be spawned or killed. Command Service : This client side service provides a handle to send commands to a component which is registered in location service. Config Service : The Config Service wraps the low level communication with Configuration Service Server and exposes simple to use methods to access and manage configuration files. Event Service : The Event Service enables users to publish events and subscribe to events which are published by underlying TMT components. Location Service : The Location Service provides access to location information of various components which are currently running the TMT cluster. Sequencer Service : This service provides a handle to send commands to a sequencer which is registered in location service. Sequence Manager Service : The Sequence Manager Service manages all the operation related to the observations. It manages all sequence components and sequencers required for the observations.","title":"Services"},{"location":"/services/admin-service.html","text":"","title":"Admin Service"},{"location":"/services/admin-service.html#admin-service","text":"This service provides a handle to admin related APIs which currently has logging related APIs.","title":"Admin Service"},{"location":"/services/admin-service.html#creation-of-admin-service","text":"","title":"Creation of Admin Service"},{"location":"/services/admin-service.html#to-create-admin-client-","text":"Typescript const adminService: AdminService = await AdminService()","title":"To create Admin client:"},{"location":"/services/admin-service.html#usages-of-admin-service","text":"Type definitions for All Admin Service methods can be found here","title":"Usages of Admin Service"},{"location":"/services/admin-service.html#fetching-logmetadata","text":"There is logging configuration set for all registered components within the TMT cluster. this API gives basic logging configuration values for specific component.\nType definitions for getLogMetadata can be found here\nTypescript const prefix = new Prefix('TCS', 'filter.wheel')\nconst componentId = new ComponentId(prefix, 'HCD')\nconst logMetaData: LogMetadata = await adminService.getLogMetadata(componentId)","title":"Fetching LogMetadata"},{"location":"/services/admin-service.html#setting-loglevel-of-a-component","text":"This method allows setting log level of specific component.\nType definitions for setLogLevel can be found here\nTypescript const actionStatus: Done = await adminService.setLogLevel(componentId, 'WARN')","title":"Setting LogLevel of a component"},{"location":"/services/alarm-service.html","text":"","title":"Alarm Service"},{"location":"/services/alarm-service.html#alarm-service","text":"This service provides an HTTP interface to interact with alarm server.","title":"Alarm Service"},{"location":"/services/alarm-service.html#creation-of-alarm-service","text":"","title":"Creation of Alarm Service"},{"location":"/services/alarm-service.html#pre-requisite","text":"In order to use Logging Service APIs:\nThe Location Service, and Gateway Server needs to be running in the network","title":"Pre-requisite"},{"location":"/services/alarm-service.html#to-create-a-client-for-alarm-service","text":"Typescript const alarmService = await AlarmService()\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"To create a client for Alarm Service"},{"location":"/services/alarm-service.html#usages-of-alarm-service","text":"","title":"Usages of Alarm Service"},{"location":"/services/alarm-service.html#setting-alarm-severity","text":"Alarm service allows you to update the severity of alarms belonging to components.\nType Definitions of setSeverity method can be found here\nTypescript let alarmKey = new AlarmKey(\n  new Prefix('ESW', 'assemblyComponent'),\n  'temperature'\n)\nconst response: Done = await alarmService.setSeverity(alarmKey, 'Critical')","title":"Setting alarm Severity"},{"location":"/services/command-service.html","text":"","title":"Command Service"},{"location":"/services/command-service.html#command-service","text":"Command Service provides a handle to send commands to a component which is registered in location service.","title":"Command Service"},{"location":"/services/command-service.html#creation-of-command-service","text":"","title":"Creation of Command Service"},{"location":"/services/command-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/services/command-service.html#in-order-to-use-command-service-for-a-specific-component-","text":"The component needs to be up and running behind the gateway server. GatewayException(InvalidComponent) will be thrown if the specified component is not found. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.\nFor the given example : Prefix(ESW.Component1) needs to be registered in the location service as any of the component type (HCD, Assembly, etc.).","title":"In order to use command service for a specific component:"},{"location":"/services/command-service.html#to-create-command-service-client-for-a-component","text":"Typescript const tokenFactory = () => auth.token\n\nconst commandService: CommandService = await CommandService(\n  new ComponentId(new Prefix('ESW', 'Component1'), 'HCD'),\n  tokenFactory\n)","title":"To create Command service client for a component"},{"location":"/services/command-service.html#type-of-actions","text":"Whenever a command gets submitted to a component, it results into in either Immediate completion or Long Running action.","title":"Type of Actions"},{"location":"/services/command-service.html#immediate-completion","text":"If the actions of the submit or submitAndWait command take a very short time to complete, it is referred as Immediate completion. the actions are successful, if the Completed SubmitResponse is returned. If there is a result, the Completed is returned with a parameter set of Result type that can be inspected by the caller.","title":"Immediate completion"},{"location":"/services/command-service.html#long-running-actions","text":"When actions take longer than 1 second and the Component returns the Started SubmitResponse. The Started response indicates to the framework that long-running actions have been started.","title":"Long running Actions"},{"location":"/services/command-service.html#control-commands","text":"In order to call following API, one of the control command needs to be sent. Depending on your use case, you will be sending either Setup or Observe Command.\nFollowing examples show how to create control commands:\nTypescript // Definition of control command looks like following\ntype ControlCommand = Setup | Observe\n\n// examples\nconst setupCommand: Setup = new Setup(\n  new Prefix('ESW', 'Component1'),\n  'move-command',\n  paramSet,\n  'obs-id'\n)\n\nconst observeCommand: Observe = new Observe(\n  new Prefix('ESW', 'Component1'),\n  'c1',\n  paramSet,\n  'obs-id'\n)\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"Control Commands"},{"location":"/services/command-service.html#usages-of-command-service","text":"Type definitions of all Command Service methods can be found here","title":"Usages of Command Service"},{"location":"/services/command-service.html#validating-command","text":"A validate message is used to ask a destination component to validate a command and determine if the command can be executed. It does not execute the command and only returns the result of validation. In some scenarios, it may be useful to test to see if a command can be executed prior to trying to execute the command.\nType definitions of validate method can be found here\nTypescript const validateResponse1: ValidateResponse = await commandService.validate(\n  setupCommand\n)\n// or\nconst validateResponse2: ValidateResponse = await commandService.validate(\n  observeCommand\n)","title":"Validating Command"},{"location":"/services/command-service.html#submitting-a-command","text":"A submit message can be used when the sender of a command needs to do additional work before long-running actions are completed. For instance, send another command to execute in parallel. If commands are short, submit and submitAndWait behave the same way. When the actions started by submit are long-running, the caller can wait for the actions to complete if needed using the queryFinal call.\nType definitions of submit method can be found here\nTypescript const submitResponse1: SubmitResponse = await commandService.submit(\n  setupCommand\n)\n// or\nconst submitResponse2: SubmitResponse = await commandService.submit(\n  observeCommand\n)","title":"Submitting a Command"},{"location":"/services/command-service.html#submitandwait","text":"This is a convenience method which sends a submit message and then, if the command is long-running, it waits for final completion. Sending a submit message with a command returns a SubmitResponse as a Future.\nType definitions of submitAndWait method can be found here\nTypescript // Submit a long running command and wait for the result for specific time\n\nconst submitAndWaitResponse: SubmitResponse = await commandService.submitAndWait(\n  setupCommand,\n  10\n)","title":"SubmitAndWait"},{"location":"/services/command-service.html#submitallandwait","text":"Similar to SubmitAndWait, submitAllAndWait can be used to send multiple commands sequentially to the same component. This could be used to send initialization commands to an HCD, for instance. The argument for submitAllAndWait is a list of commands. submitAllAndWait returns a list of SubmitResponses – one for each command in the list.\nType definitions of submitAllAndWait method can be found here\nTypescript // Submit multiple commands and wait for the result of each submitted command for specific time\n\nconst submitAllAndWaitResponse: SubmitResponse[] = await commandService.submitAllAndWait(\n  [setupCommand, observeCommand],\n  10\n)","title":"SubmitAllAndWait"},{"location":"/services/command-service.html#oneway","text":"Oneway is useful when Command Service needs to send commands to an HCD as quickly as possible. The command is validated on the destination and the validation response is returned, but no other responses are provided.\nType definitions of oneway method can be found here\nTypescript const onewayResponse1: OnewayResponse = await commandService.oneway(\n  setupCommand\n)\n// or\nconst onewayResponse2: OnewayResponse = await commandService.oneway(\n  observeCommand\n)","title":"Oneway"},{"location":"/services/command-service.html#query","text":"If a submitted command returns a Started response indicating it has long-running actions, and the caller needs to determine that the actions have started properly, or wishes to poll the destination component for the final response, the query method of CommandService can be used.\nType definitions of query method can be found here\nTypescript // Submit a long running command\nconst res: SubmitResponse = await commandService.submit(setupCommand)\n// .\n// .\n// .\n// Get the current result of long running command as :\nconst queryResponse: SubmitResponse = await commandService.query(res.runId)","title":"Query"},{"location":"/services/command-service.html#queryfinal","text":"Like query, queryFinal uses the Id returned by Started. But in this case, rather than returning immediately like query, it waits and only returns when the final SubmitResponse is sent. queryFinal is used exclusively with submit in the case where some other activity must be done before the actions started by the submit complete.\nType definitions of queryFinal method can be found here\nTypescript // Submit a long running command\nconst result: SubmitResponse = await commandService.submit(setupCommand)\n// .\n// .\n// .\n// Get the final result of long running command within 10 seconds :\nconst queryFinalResponse: SubmitResponse = await commandService.queryFinal(\n  result.runId,\n  10\n)","title":"QueryFinal"},{"location":"/services/command-service.html#subscribecurrentstate","text":"This method can be used to subscribe to the CurrentState of a component by providing a callback that is called with the arrival of every CurrentState item.\nType definitions of subscribeCurrentState method can be found here\nTypescript // subscribe to this set of current states\nconst currentStates = new Set(['stateName1', 'stateName2'])\n\n// this callback gets called whenever the state changes\nconst onStateChangeCallback = (currentState: CurrentState) => {\n  // do something when state changes\n  console.log('changed state:', currentState)\n}\n\n// subscribe call\nconst subscription: Subscription = await commandService.subscribeCurrentState(\n  currentStates\n)(onStateChangeCallback)\n\n// .\n// .\n// .\n// subscription can be cancelled when it is not required any more\nsubscription.cancel()","title":"SubscribeCurrentState"},{"location":"/services/config-service.html","text":"","title":"Config Service"},{"location":"/services/config-service.html#config-service","text":"The Configuration Service provides a centralized persistent store for any configuration file used in the TMT Software System. All versions of configuration files are retained, providing a historical record of each configuration file. This client exposes simple methods to access and manage configuration files.","title":"Config Service"},{"location":"/services/config-service.html#rules-and-checks","text":"The config file path must not contain !#<>$%&’@^``~+,;= or any whitespace character If the input file is > 10MB or has lot of non ASCII characters, then for optimization, server will archive it in annex store. Large and binary files can be forced to go to the ‘annex’ store by using annex=true flag in create operation.","title":"Rules and Checks"},{"location":"/services/config-service.html#model-classes","text":"ConfigData : Represents the contents of the files being managed. It wraps blob object. ConfigFileInfo : Represents information about a config file stored in the Config Service. ConfigFileRevision : Represents information about a specific version of a config file. ConfigId : Represents an identifier associated with a revision of a configuration file, often generated by create or update methods. ConfigMetadata : Represents metadata information about the Config Server. FileType : Represents the type of storage for a configuration file. Currently two types are supported Normal(small, text files) and Annex(Large, Binary files).","title":"Model Classes"},{"location":"/services/config-service.html#example-for-creation-configdata-and-accessing-data-with-helper-function","text":"Typescript const dataArray = ['file-contents']\n\nconst configDataFromBlob: ConfigData = ConfigData.from(new Blob(dataArray))\nconst configDataFromFile: ConfigData = ConfigData.fromFile(\n  new File(dataArray, 'filename')\n)\nconst configDataFromString: ConfigData = ConfigData.fromString(\n  'someFileDataAsString'\n)\n\n//accessing data\nconst dataAsBlobContent: Blob = configDataFromString.toBlob()\n\n// notice use of async-await here. because this is an IO read call\nconst readData = async (configData: ConfigData) => {\n  const dataAsString: string = await configData.fileContentAsString()\n}\nNote: Models other than ConfigData are simple typescript classes and do not have special helper methods unlike ConfigData.","title":"Example for creation ConfigData and accessing data with helper function"},{"location":"/services/config-service.html#creation-of-config-service","text":"","title":"Creation of Config Service"},{"location":"/services/config-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/services/config-service.html#in-order-to-use-config-service-","text":"The Location Service and Configuration Service Server needs to be running in the network The necessary configuration, environment variables or system properties should be defined to point to the correct host and port number(s) for the Location Service nodes. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"In order to use config service:"},{"location":"/services/config-service.html#to-create-a-client-for-config-service","text":"Config service constructor takes TokenFactory as input argument.\nTypescript const tokenFactory = () => auth.token\n\nconst configService: ConfigService = await ConfigService(tokenFactory)\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"To create a client for Config service"},{"location":"/services/config-service.html#usages-of-config-service","text":"Type Definitions of all methods can be found here","title":"Usages of Config Service"},{"location":"/services/config-service.html#create","text":"This method takes path at which configData needs to be saved in the config service along with meta information i.e whether to be saved as annex or normal file and comment. After saving, it returns ConfigId which can be used to access the saved file in future using query APIs.\nType definitions of create method can be found here\nTypescript const path = 'esw/sequencer/obsMode.conf'\nconst comment = 'observation configuration on 21st november 2020'\nconst author = 'OCS-Sequencer admin: Dave'\nconst data = `\nesw-sm {\n  obsModes: {\n    IRIS_Darknight: {\n      resources: [IRIS, TCS, NFIRAOS]\n      sequencers: [IRIS, ESW, TCS]\n    },\n    IRIS_Cal: {\n      resources: [IRIS, NSCU, NFIRAOS]\n      sequencers: [IRIS, ESW, AOESW]\n    },\n    WFOS_Cal: {\n      resources: [WFOS]\n      sequencers: [WFOS, ESW]\n    }\n  }\n}\n`\nconst configData = ConfigData.fromString(data)\n\nconst sequencerConfigId: ConfigId = await configService.create(\n  path,\n  configData,\n  false,\n  comment\n)","title":"create"},{"location":"/services/config-service.html#update","text":"This method takes path at which configData needs to be updated in the config service along with comment. After updating, it returns ConfigId which can be used to access the updated file in future using query APIs.\nType definitions of update method can be found here\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst commentOnUpdate = 'observation configuration on 23rd november 2020'\nconst updatedData = `\nesw-sm {\n  obsModes: {\n    IRIS_Darknight: {\n      resources: [IRIS]\n      sequencers: [IRIS]\n    },\n    IRIS_Cal: {\n      resources: [IRIS, NSCU, NFIRAOS]\n      sequencers: [IRIS, ESW, AOESW]\n    }\n  }\n}\n`\nconst updatedConfigData = ConfigData.fromString(updatedData)\n\nconst newSequencerConfigId: ConfigId = await configService.update(\n  filePath,\n  updatedConfigData,\n  commentOnUpdate\n)","title":"update"},{"location":"/services/config-service.html#getactive","text":"This method takes path from which the active configData needs to be fetched and returns ConfigData if available.\nType definitions of getActive method can be found here\nTypescript const file = 'esw/sequencer/obsMode.conf'\n\nconst maybeActiveConfigData: Option<ConfigData> = await configService.getActive(\n  file\n)","title":"getActive"},{"location":"/services/config-service.html#getlatest","text":"This method takes path from which the latest configData needs to be fetched and returns ConfigData if available.\nType definitions of getLatest method can be found here\nTypescript const filepath = 'esw/sequencer/obsMode.conf'\nconst maybeLatestConfigData: Option<ConfigData> = await configService.getLatest(\n  filepath\n)","title":"getLatest"},{"location":"/services/config-service.html#getbyid","text":"This method takes path and previously created/updated configuration’s configId to be fetched and returns ConfigData if available.\nType definitions of getById method can be found here\nTypescript const configId: ConfigId = await configService.update(\n  filePath,\n  updatedConfigData,\n  commentOnUpdate\n)\n\nconst maybeConfigData: Option<ConfigData> = await configService.getById(\n  filepath,\n  configId\n)","title":"getById"},{"location":"/services/config-service.html#getbytime","text":"This method gets the file at the given path as it existed at a given time-instance. Note: -If time-instance is before the file was created, the initial version is returned. -If time-instance is after the last change, the most recent version is returned.\nType definitions of getByTime method can be found here\nTypescript const configId1: ConfigId = await configService.create(\n  filePath,\n  updatedConfigData,\n  false,\n  commentOnUpdate\n)\n\nconst beforeUpdate = new Date()\n\nconst configId2: ConfigId = await configService.update(\n  filePath,\n  configData,\n  commentOnUpdate\n)\nconst afterUpdate = new Date()\n\nconst maybeConfigData: Option<ConfigData> = await configService.getByTime(\n  filepath,\n  beforeUpdate\n)\n// maybeConfigData == updatedConfigData (i.e Initial revision of config)\n\nconst newlyUpdatedData: Option<ConfigData> = await configService.getByTime(\n  filepath,\n  afterUpdate\n)\n// newlyUpdatedData == configData (i.e Latest revision of config)","title":"getByTime"},{"location":"/services/config-service.html#exists","text":"This method checks whether file exists at the given path and optional specific configId in the repository and returns true if it does exist or else false.\nType definitions of exists method can be found here\nTypescript const exists: boolean = await configService.exists(filePath)\n\nconst exist: boolean = await configService.exists(filePath, configId)","title":"exists"},{"location":"/services/config-service.html#delete","text":"This method deletes a file located at specified path in the repository.\nType definitions of delete method can be found here\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\n\nawait configService.delete(filePath, 'deleting the invalid config entry')","title":"delete"},{"location":"/services/config-service.html#list","text":"This method list all the files for a given FileType (Annex or Normal) and an optional pattern string, it will list all files whose path matches the given pattern.\nSome pattern examples are: “/path/hcd/*.*”, “a/b/c/d.*”, “.*.conf”, “.*hcd.*”\nType definitions of list method can be found here\nTypescript const allAnnexFilesInfo: ConfigFileInfo[] = await configService.list('Annex')\nconst allNormalFilesInfo: ConfigFileInfo[] = await configService.list('Normal')\nconst allHcdAnnexFilesInfo: ConfigFileInfo[] = await configService.list(\n  'Annex',\n  '.*hcd.*'\n)\nconst allConfNormalFilesInfo: ConfigFileInfo[] = await configService.list(\n  'Normal',\n  '.*conf'\n)","title":"list"},{"location":"/services/config-service.html#history","text":"This method returns the history of revisions of the file at the given path for a range of period specified by from and to.\nThe size of the list can be restricted using maxResults.\nType definitions of history method can be found here\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst from = new Date(2019, 12, 31)\nconst to = new Date(2020, 12, 31)\n\n// upto 200 file revisions from 31st dec 2019 - 31st dec 2020 will be fetched\nconst fileRevisions: ConfigFileRevision[] = await configService.history(\n  filePath,\n  from,\n  to,\n  200\n)","title":"history"},{"location":"/services/config-service.html#getmetadata","text":"This method used to get metadata information about the Config Service. It includes:\nrepository directory annex directory min annex file size max config file size\nType definitions of getMetadata method can be found here\nTypescript const metadata: ConfigMetadata = await configService.getMetadata()","title":"getMetadata"},{"location":"/services/config-service.html#managing-active-versions","text":"In its lifetime, a config file undergoes many revisions. An active version is a specific revision from a file’s history and it is set by administrators.","title":"Managing active versions"},{"location":"/services/config-service.html#historyactive","text":"This method returns the history of active revisions of the file at the given path for a range of period specified by from and to. The size of the list can be restricted using maxResults.\nType definitions of historyActive method can be found here\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst from = new Date(2019, 12, 31)\nconst to = new Date(2020, 12, 31)\n\n// upto 200 active file revisions from 31st dec 2019 - 31st dec 2020 will be fetched\nconst activeFileRevisions: ConfigFileRevision[] = await configService.historyActive(\n  filePath,\n  from,\n  to,\n  200\n)","title":"historyActive"},{"location":"/services/config-service.html#setactiveversion","text":"This method sets the “active version” to be the version provided for the file at the given path. If this method is never called in a config’s lifetime, the active version will always be the version returned by create function.\nType definitions of setActiveVersion method can be found here\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst id: ConfigId = await configService.create(\n  path,\n  configData,\n  false,\n  comment\n)\nconst commentWhileSetting = `Making ${id} active on 1st dec 2020`\n\nawait configService.setActiveVersion(filePath, id, commentWhileSetting)","title":"setActiveVersion"},{"location":"/services/config-service.html#resetactiveversion","text":"This method resets the “active version” of the file at the given path to the latest version.\nType definitions of resetActiveVersion method can be found here\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst id: ConfigId = await configService.create(\n  path,\n  configData,\n  false,\n  comment\n)\nconst commentWhileResetting = `Making ${id} active version to latest as of 1st dec 2020`\n\nawait configService.resetActiveVersion(filePath, commentWhileResetting)","title":"resetActiveVersion"},{"location":"/services/config-service.html#getactiveversion","text":"This method returns the revision ID which represents the “active version” of the file at the given path.\nType definitions of getActiveVersion method can be found here\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\n\nconst maybeConfigId: Option<ConfigId> = await configService.getActiveVersion(\n  filePath\n)","title":"getActiveVersion"},{"location":"/services/config-service.html#getactivebytime","text":"This method returns the content of active version of the file existed at given instant of Time\nType definitions of getActiveByTime method can be found here\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst at = new Date(2019, 12, 31)\n\nconst maybeConfigData: Option<ConfigData> = await configService.getActiveByTime(\n  filePath,\n  at\n)","title":"getActiveByTime"},{"location":"/services/event-service.html","text":"","title":"Event Service"},{"location":"/services/event-service.html#event-service","text":"Event service provides methods to interact with the event server which implements the publish/subscribe messaging paradigm where one component publishes an event and all clients that have subscribed receive the event.","title":"Event Service"},{"location":"/services/event-service.html#creation-of-event-service","text":"","title":"Creation of Event Service"},{"location":"/services/event-service.html#pre-requisite","text":"The Location Service, Event Service and Gateway Server needs to be running in the network The necessary configuration, environment variables or system properties should be defined to point to the correct host and port number(s) for the Location Service nodes.","title":"Pre-requisite"},{"location":"/services/event-service.html#examples-to-create-a-client-for-event-service","text":"Typescript const eventService: EventService = await EventService()","title":"Examples to create a client for Event service"},{"location":"/services/event-service.html#usages-of-event-service","text":"Type definitions for All Event Service methods can be found here.","title":"Usages of Event Service"},{"location":"/services/event-service.html#publishing-an-event","text":"Event service allows you to publish an Event to the event server.\nType definitions for publish method can be found here.\nTypescript const sourcePrefix = new Prefix('IRIS', 'component')\nconst eventName = new EventName('move-event')\nconst positionParameter = intKey('positions', 'centimeter').set([10, 20, 30])\nconst paramSet: Parameter<IntKey>[] = [positionParameter]\n\nconst event = ObserveEvent.make(sourcePrefix, eventName, paramSet)\n\nconst done: Done = await eventService.publish(event)","title":"Publishing an Event"},{"location":"/services/event-service.html#get-events","text":"The get method is used to get events for set of EventKeys. This is different from subscribing event. Use this API when occurred events are required. If you want to consume live events, use subscription APIs.\nType definitions for get method can be found here.\nExample for getting events:\nTypescript const sourcePrefix = new Prefix('IRIS', 'component')\n\nconst eventKey1 = new EventKey(sourcePrefix, new EventName('eventKey1'))\nconst eventKey2 = new EventKey(sourcePrefix, new EventName('eventKey2'))\n\nconst eventKeys = new Set([eventKey1, eventKey2])\nconst events: Event[] = await eventService.get(eventKeys)","title":"Get events"},{"location":"/services/event-service.html#subscribe-to-the-events","text":"Subscribing Event can be done via two ways. User can subscribe to -\nMultiple EventKeys. All the EventKeys of specific subsystem and pattern.\nWhen events are subscribed for given EventKeys, events are received at every frequency. The method take callback function which gets triggered whenever the events are received.\nType definitions of both methods can be found by below links :\nsubscribe. pSubscribe.\nExample for subscribing events with given EventKeys:\nTypescript const sourcePrefix = new Prefix('IRIS', 'component')\n\nconst eventKey1 = new EventKey(sourcePrefix, new EventName('eventKey1'))\nconst eventKey2 = new EventKey(sourcePrefix, new EventName('eventKey2'))\n\nconst onEventCallback = (event: Event) => {\n  console.log(event)\n  // make use of ${event} inside this callback function\n}\nconst eventKeys = new Set([eventKey1, eventKey2])\n\nconst subscription: Subscription = eventService.subscribe(\n  eventKeys,\n  10\n)(onEventCallback)\n\n//To cancel the subscription\nsubscription.cancel()\nExample for subscribing events with given subsystem:\nTypescript const onEventCallback = (event: Event) => {\n  // make use of ${event} inside this callback function\n  console.log(event)\n}\n\n// subscribe to all ESW subsystem's event\nconst subscription: Subscription = eventService.pSubscribe(\n  'ESW',\n  10,\n  '.*'\n)(onEventCallback)\n\n// subscribe to specific events having hcd in the event name\nconst specificSubscription: Subscription = eventService.pSubscribe(\n  'ESW',\n  10,\n  '(hcd)'\n)(onEventCallback)\n\n//To cancel the subscription\nsubscription.cancel()","title":"Subscribe to the events"},{"location":"/services/location-service.html","text":"","title":"Location Service"},{"location":"/services/location-service.html#location-service","text":"The Location Service handles component (i.e. Applications, Sequencers, Assemblies, HCDs, and Services) discovery in the distributed TMT software system.\nA component’s location information can be used by other components and services to connect to it and use it.\nType definition for location model can be found here.","title":"Location Service"},{"location":"/services/location-service.html#creation-of-location-service","text":"","title":"Creation of Location Service"},{"location":"/services/location-service.html#pre-requisite","text":"Access token is not necessary for using Location Service query APIs.\nIf You are using Location Service to unregister a component, you would need to have the authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"Pre-requisite"},{"location":"/services/location-service.html#examples-to-create-a-client-for-location-service","text":"Location Service constructor takes optional tokenFactory and optional location server configuration(host/port pair).\nTypescript const tokenFactory = () => auth.token\n\nconst locationServiceWithToken: LocationService = await LocationService(\n  tokenFactory\n)\n\nconst locationService: LocationService = await LocationService()\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"Examples to create a client for Location Service"},{"location":"/services/location-service.html#usages-of-location-service","text":"Type definitions for all methods can be found here.","title":"Usages of Location Service"},{"location":"/services/location-service.html#listing-filtering-locations","text":"Location Service provides multiple ways to get list of locations registered in the TMT cluster.\nType definitions for relevant listings methods can be found by following links:\nlist. listByPrefix. listByHostname. listByComponentType. listByConnectionType.\nFollowing example showcases the listByComponentType api usage\nTypescript // valid Component types : HCD, Assembly, Service, Container, Sequencer, SequenceComponent and Machine\n\nconst sequencerLocations: Location[] = await locationService.listByComponentType(\n  'Sequencer'\n)\n\nconst hcdLocations: Location[] = await locationService.listByComponentType(\n  'HCD'\n)\n\nconst assemblyLocations: Location[] = await locationService.listByComponentType(\n  'Assembly'\n)","title":"Listing & Filtering Locations"},{"location":"/services/location-service.html#resolving-connection","text":"There are two ways to get/fetch a location information of a connection:\nUsing resolve API Using find API\nLocation Service’s resolve API uses Connection a component to resolve the location within some timeout duration. However, find API does not wait to resolve location. If the location is not present, it returns undefined.\nType definitions for both methods can be found by following links:\nfind. resolve.\nTypescript // ConnectionTypes : HttpConnection, AkkaConnection & TcpConnection\n// Time unit : seconds, milliseconds, nanoseconds, microseconds, minutes, hours, days\n\nconst connection = HttpConnection(new Prefix('ESW', 'component'), 'HCD')\n\nconst maybeLocation1: Option<Location> = await locationService.resolve(\n  connection,\n  10,\n  'seconds'\n)\nif (maybeLocation1) {\n  // use maybeLocation inside here\n} else {\n  // location did not resolved in 10 seconds\n}","title":"Resolving Connection"},{"location":"/services/location-service.html#unregister-a-connection","text":"This is a secure API and takes a type of Connection as an input argument to be unregistered from the Location Service and returns Done once unregistered.\nType definitions for unregister method can be found here\nThe following example shows unregister method can be called:\nTypescript // ConnectionTypes : HttpConnection, AkkaConnection & TcpConnection\nconst done: Done = await locationServiceWithToken.unregister(\n  HttpConnection(new Prefix('ESW', 'component'), 'HCD')\n)","title":"Unregister a Connection"},{"location":"/services/location-service.html#tracking-connection","text":"The lifecycle of a connection of interest can be followed using either the track API. The connection update events will be received by the callback provided to this method. This method returns a subscription which can be used to cancel the tracking subscription.\nType definitions for track method can be found here\nThe following example shows track method can be called:\nTypescript // a callback function\nconst onTrackingEvent = (event: TrackingEvent) => {\n  if (event._type === 'LocationRemoved') {\n    // do something when connection's location is removed from the location service\n  } else if (event._type === 'LocationUpdated') {\n    // do something when connection's location is updated from the location service\n  }\n}\n// connection to be tracked\nconst httpConnection = HttpConnection(new Prefix('ESW', 'component'), 'HCD')\n\nlocationService.track(httpConnection)(onTrackingEvent)","title":"Tracking Connection"},{"location":"/services/logging-service.html","text":"","title":"Logging Service"},{"location":"/services/logging-service.html#logging-service","text":"Logging Service provides the Http Interface to be able to log into a component.\nType definition for the logging Service interface can be found here","title":"Logging Service"},{"location":"/services/logging-service.html#creation-of-logging-service","text":"","title":"Creation of Logging Service"},{"location":"/services/logging-service.html#pre-requisite","text":"In order to use Logging Service APIs:\nThe Location Service, and Gateway Server needs to be running in the network","title":"Pre-requisite"},{"location":"/services/logging-service.html#to-create-logging-service","text":"Typescript const loggingService: LoggingService = await LoggingService()\nconst locationService: LocationService = await LocationService()","title":"To create Logging Service"},{"location":"/services/logging-service.html#apis","text":"Async-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"APIs"},{"location":"/services/logging-service.html#usages-of-logging-service","text":"","title":"Usages of Logging service"},{"location":"/services/logging-service.html#creating-log-for-an-incident","text":"This method will be used for to create a log entry for a component with a specific log Level.\nFor ex: when a user submits a setup command for a component using command service.\nuser may want to create explicit log entry based on success or failure scenario.\nType definition can be found - here.\nTypescript let prefix = new Prefix('ESW', 'comp1')\nconst commandService: CommandService = await CommandService(\n  new ComponentId(prefix, 'Assembly')\n)\nconst intParam = intKey('positions').set([1, 2, 3])\nconst setup = new Setup(prefix, 'move', [intParam])\nconst response = await commandService.submit(setup)\nswitch (response._type) {\n  case 'Completed':\n    await loggingService.log(\n      prefix,\n      'INFO',\n      'Successfully submitted move command',\n      { params: [intParam] }\n    )\n    break\n  default:\n    await loggingService.log(\n      prefix,\n      'ERROR',\n      'Failed to submit move command',\n      { params: [intParam] }\n    )\n}","title":"Creating Log for an incident"},{"location":"/technical/index.html","text":"","title":"Technical Design Documentation"},{"location":"/technical/index.html#technical-design-documentation","text":"","title":"Technical Design Documentation"},{"location":"/technical/index.html#architectural-overview","text":"Following diagram explains UI application flow for making request to TMT backend component and explains where does the ESW-TS service fits in the whole TMT architecture.\nFor example: A web app specifically created for sending control command to a HCD component.\nUser clicks on submit button. Command Service of ESW-TS creates appropriate payload adhering to service contract exposed by GatewayServer ESW-TS service uses fetch api of browser to make request. Gateway Server on receiving correct payload, process it and sends the Control command to the destined HCD component. On successfully handling of command by HCD component, GatewayServer returns a SuccessResponse. ESW-TS handles the response and returns it, as it was received to the caller web-ui component or in case of error throw’s ServiceError.","title":"Architectural overview"},{"location":"/services/agent-service.html","text":"","title":"Agent Service"},{"location":"/services/agent-service.html#agent-service","text":"Agent service provides HTTP interface to interact with all agent machines uniquely located using agent prefix. APIs to spawn components takes agent prefix as parameter. Agent prefix is used to locate agent machine using location service.\nAgent service provides APIs to spawn sequence manager, sequence components and to kill spawned components.","title":"Agent Service"},{"location":"/services/agent-service.html#creation-of-agent-service","text":"","title":"Creation of Agent Service"},{"location":"/services/agent-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/services/agent-service.html#in-order-to-use-agent-service-apis-","text":"Agent machines should be up and running. Locations of agent machines should be registered in Location Service. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"In order to use agent service APIs:"},{"location":"/services/agent-service.html#to-create-agent-client-","text":"Typescript const tokenFactory = () => auth.token\n\nconst agentService: AgentService = await AgentService(tokenFactory)\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"To create Agent client:"},{"location":"/services/agent-service.html#usages-of-agent-service","text":"Type definitions for All Agent Service methods can be found here","title":"Usages of Agent Service"},{"location":"/services/agent-service.html#spawning-a-sequence-manager","text":"Agent Service requires agent(a component of type :Machine) to be able to process requests. once it locates an agent using location service with the help of agent prefix, it sends a spawn sequence manager command to the agent machine. The corresponding api call fails If the Sequence Manager is already running, or the underlying agent fails to spawn it.\nType definitions for spawnSequenceManager can be found here\nTypescript const agentPrefix = new Prefix('ESW', 'agent1')\nconst obsModeConfigPath = '/obs-mode.conf'\nconst sequenceManagerVersion = '1.0.0'\n\nconst spawnResponse1: SpawnResponse = await agentService.spawnSequenceManager(\n  agentPrefix,\n  obsModeConfigPath,\n  false,\n  sequenceManagerVersion\n)","title":"Spawning a Sequence Manager"},{"location":"/services/agent-service.html#spawning-a-sequence-component","text":"Similar to spawning a Sequence Manager, Agent service locates an agent then it sends a spawn sequence component command to the agent machine. the corresponding api call fails If the Sequence Component is already running, or the underlying agent fails to spawn it.\nType definitions for spawnSequenceComponent can be found here\nTypescript const ocsAppVersion = '1.2.1'\nconst spawnResponse2: SpawnResponse = await agentService.spawnSequenceComponent(\n  agentPrefix,\n  'component1',\n  ocsAppVersion\n)","title":"Spawning a Sequence Component"},{"location":"/services/agent-service.html#kill-component","text":"Agent service kills any process running on the agent machine using the process id (pid) of that component. it uses location service to find the process id from the metadata field of location information.\nType definitions for killComponent can be found here\nTypescript const compPrefix = new Prefix('ESW', 'SomeComponent')\nconst componentToBeKilled = new ComponentId(compPrefix, 'Service')\nconst killResponse: KillResponse = await agentService.killComponent(\n  componentToBeKilled\n)","title":"Kill Component"},{"location":"/technical/sequencer-service.html","text":"","title":"Sequencer Service"},{"location":"/technical/sequencer-service.html#sequencer-service","text":"This service provides a handle to send commands to a sequencer which is registered in location service.","title":"Sequencer Service"},{"location":"/technical/sequencer-service.html#creation-of-sequencer-service","text":"","title":"Creation of Sequencer Service"},{"location":"/technical/sequencer-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/technical/sequencer-service.html#in-order-to-use-sequencer-service-client-for-a-specific-sequencer-","text":"The sequencer and gateway server should be running. GatewayException(InvalidComponent) will be thrown if the specified sequencer not found in the location service. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"In order to use sequencer service client for a specific sequencer:"},{"location":"/technical/sequencer-service.html#to-create-sequencer-service","text":"Typescript const tokenFactory = () => auth.token\n\nconst sequencerService: SequencerService = await SequencerService(\n  new ComponentId(new Prefix('ESW', 'darknight'), 'Sequencer'),\n  tokenFactory\n)","title":"To create Sequencer Service"},{"location":"/technical/sequencer-service.html#creating-sequencecommands","text":"Typescript const eswTestPrefix = Prefix.fromString('TCS.darknight')\n\nconst setupCommand1 = new Setup(eswTestPrefix, 'setup-command1')\nconst setupCommand2 = new Setup(eswTestPrefix, 'setup-command2')\n\nconst observeCommand1 = new Observe(eswTestPrefix, 'observe-command1')\nconst observeCommand2 = new Observe(eswTestPrefix, 'observe-command2')","title":"Creating SequenceCommands"},{"location":"/technical/sequencer-service.html#creating-a-sequence","text":"A sequence is a list of sequence commands:\nTypescript //sequence is a list of SequenceCommand\nconst sequence = [setupCommand1, observeCommand1]","title":"Creating a Sequence"},{"location":"/technical/sequencer-service.html#usages-of-sequencer-service","text":"Async-Await Note that the examples are using async/await which makes handling of promises more readable.\nType Definitions for Sequencer Service can be found here","title":"Usages of Sequencer Service"},{"location":"/technical/sequencer-service.html#loading-and-starting-a-sequence-into-a-sequencer","text":"To load a sequence into a sequencer, SequencerService provides loadSequence API which takes a Sequence and returns a Promise<OkOrUnhandledResponse>. If sequencer is in Idle state, provided sequence gets loaded in the sequencer and an Ok response gets returned otherwise an Unhandled response gets returned.\nTo start a loaded sequence, SequencerService provides startSequence API which starts the sequence in the sequencer which is loaded by loadSequence API and returns a Promise<SubmitResponse>. If sequencer is in Loaded state, loaded sequence’s execution gets started in the sequencer and a Started response gets returned otherwise a negative SubmitResponse gets returned.\nType definitions for methods used in the given example are :\nloadSequence startSequence query queryFinal\nTypescript const okOrUnhandledResponse: OkOrUnhandledResponse = await sequencerService.loadSequence(\n  sequence\n)\nconst initialResponse: SubmitResponse = await sequencerService.startSequence()\n\nconst queryResponse: SubmitResponse = await sequencerService.query(\n  initialResponse.runId\n)\nconst queryFinalResponse: SubmitResponse = await sequencerService.queryFinal(\n  initialResponse.runId,\n  5\n)","title":"Loading and Starting a Sequence into a Sequencer"},{"location":"/technical/sequencer-service.html#adding-commands-into-the-sequence-after-all-the-pending-steps","text":"To add commands into the sequence after all the pending steps, SequencerService provides add API which takes list of SequenceCommands and returns Promise<OkOrUnhandledResponses>. If sequencer is still in execution, then given list of SequenceCommands gets added into the sequence after all the pending steps and a Ok response gets returned otherwise an Unhandled response gets returned.\nType definitions for add method used can be found here\nTypescript const addResponse: OkOrUnhandledResponse = await sequencerService.add([\n  observeCommand2,\n  setupCommand2\n])","title":"Adding commands into the sequence after all the pending steps"},{"location":"/technical/sequencer-service.html#prepending-commands-into-the-sequence-before-all-the-pending-steps","text":"To add commands into the sequence before all the pending steps, SequencerService provides add API which takes list of SequenceCommands and returns Promise<OkOrUnhandledResponses>. If sequencer is still in execution, then given list of SequenceCommands gets added into the sequence before all the pending steps and a Ok response gets returned. Otherwise, an Unhandled response gets returned.\nType definitions for prepend method used can be found here\nTypescript const prependResponse: OkOrUnhandledResponse = await sequencerService.prepend([\n  observeCommand2,\n  setupCommand2\n])","title":"Prepending commands into the sequence before all the pending steps"},{"location":"/technical/sequencer-service.html#replacing-a-command-with-a-list-of-commands","text":"To replace a command with a list of commands, SequencerService provides replace API which takes the Id of the command which to be replaced and list of SequenceCommands and returns Promise<GenericResponse>. In case, if the command of the given Id is not present in sequence, then IdDoesNotExist response gets returned. Or if the command is already finished or in flight, then a CannotOperateOnAnInFlightOrFinishedStep response gets returned. In case, if the command is still pending, then it gets replaced with the given list of SequenceCommands Otherwise, an Unhandled response gets returned.\nType definitions for replace method used can be found here\nTypescript const replaceResponse: GenericResponse = await sequencerService.replace(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9',\n  [observeCommand2, setupCommand2]\n)","title":"Replacing a command with a list of commands"},{"location":"/technical/sequencer-service.html#inserting-a-list-of-commands-after-a-command","text":"To insert a list of commands after a command, SequencerService provides insertAfter API which takes the Id of the command after which commands to be inserted and list of SequenceCommands and returns Promise<GenericResponse>. In case, if the command of the given Id is not present in sequence, then IdDoesNotExist response gets returned. Or if the command is already finished or in flight, then a CannotOperateOnAnInFlightOrFinishedStep response gets returned. In case, if the command is still pending, then the given list of SequenceCommands gets inserted after it Otherwise, an Unhandled response gets returned.\nType definitions for insertAfter method used can be found here\nTypescript const insertAfterResponse: GenericResponse = await sequencerService.insertAfter(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9',\n  [observeCommand2, setupCommand2]\n)","title":"Inserting a list of commands after a command"},{"location":"/technical/sequencer-service.html#deleting-a-command-from-the-sequence","text":"To delete a command from the sequence, SequencerService provides delete API which takes the Id of the command which to be deleted and returns Promise<GenericResponse>. If sequencer is not in Inprogress state, then Unhandled response gets returned. Or if the command of the given Id, is not present in sequence, then IdDoesNotExist response gets returned. Or if it is still pending, then it gets deleted and Ok response gets returned. Otherwise, a CannotOperateOnAnInFlightOrFinishedStep response gets returned.\nType definitions for delete method used can be found here\nTypescript const deleteResponse: GenericResponse = await sequencerService.delete(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9'\n)","title":"Deleting a command from the sequence"},{"location":"/technical/sequencer-service.html#adding-a-breakpoint-to-a-step","text":"To add a breakpoint to a Step, SequencerService provides addBreakpoint API which takes the Id of the command where breakpoint to be added and returns Promise<GenericResponse>. If sequencer is not in Inprogress state, then Unhandled response gets returned. Or if the command of the given Id, is not present in sequence, then IdDoesNotExist response gets returned. Or if it is still pending, then breakpoint gets added and Ok response gets returned. Otherwise, a CannotOperateOnAnInFlightOrFinishedStep response gets returned.\nType definitions for addBreakpoint method used can be found here\nTypescript const addBreakpointResponse: GenericResponse = await sequencerService.addBreakpoint(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9'\n)","title":"Adding a breakpoint to a Step"},{"location":"/technical/sequencer-service.html#removing-a-breakpoint-from-a-step","text":"To remove a breakpoint from a Step, SequencerService provides removeBreakpoint API which takes the Id of the command from where breakpoint to be removed and returns Promise<RemoveBreakpointResponse>. If sequencer is not in Inprogress state, then Unhandled response gets returned. Or if the command of the given Id, is not present in sequence, then IdDoesNotExist response gets returned. Otherwise, breakpoint gets removed and Ok response gets returned.\nType definitions for removeBreakpoint method used can be found here\nTypescript const removeBreakpointResponse: RemoveBreakpointResponse = await sequencerService.removeBreakpoint(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9'\n)","title":"Removing a breakpoint from a Step"},{"location":"/technical/sequencer-service.html#pausing-the-sequence","text":"To pause the sequence, SequencerService provides pause API which returns Promise<PauseResponse>. If sequencer is in Inprogress state, then an Ok response gets returned if there is a Step pending, otherwise, a CannotOperateOnAnInFlightOrFinishedStep response gets returned. Or if sequencer is not in Inprogress state, then Unhandled response gets returned.\nType definitions for pause method used can be found here\nTypescript const pauseResponse: PauseResponse = await sequencerService.pause()","title":"Pausing the sequence"},{"location":"/technical/sequencer-service.html#resuming-a-paused-sequence","text":"To resume a paused the sequence, SequencerService provides resume API which returns Promise<PauseResponse>. If sequencer is in Inprogress state, an Ok response gets returned. Otherwise, an Unhandled response gets returned.\nType definitions for resume method used can be found here\nTypescript const resumeResponse: OkOrUnhandledResponse = await sequencerService.resume()","title":"Resuming a paused sequence"},{"location":"/technical/sequencer-service.html#getting-the-sequence-from-the-sequencer","text":"To get the sequence from the sequencer, SequencerService provides getSequence API which returns the StepList(runtime representation of the sequence) if there is a sequence executing in the sequencer else returns undefined.\nType definitions for getSequence method used can be found here\nTypescript const getSequenceRes: Option<StepList> = await sequencerService.getSequence()","title":"Getting the sequence from the sequencer"},{"location":"/technical/sequencer-service.html#checking-if-sequencer-is-available","text":"To check if Sequencer is available, SequencerService provides isAvailable API which returns Promise<boolean>. If sequencer is in Idle state, true get returned otherwise false gets returned.\nType definitions for isAvailable method used can be found here\nTypescript const isAvailable: boolean = await sequencerService.isAvailable()","title":"Checking if Sequencer is available"},{"location":"/technical/sequencer-service.html#checking-if-sequencer-is-online","text":"To check if Sequencer is online, SequencerService provides isOnline API which returns Promise<boolean>. If sequencer is in Idle state, true get returned otherwise false gets returned.\nType definitions for isOnline method used can be found here\nTypescript const isOnline: boolean = await sequencerService.isOnline()","title":"Checking if Sequencer is online"},{"location":"/technical/sequencer-service.html#discarding-all-the-pending-steps","text":"To discard all the pending Steps, SequencerService provides a reset API which returns Promise<OkOrUnhandledResponse>. If sequencer is in InProgress state, then an Ok response gets returned. Otherwise, an Unhandled response gets returned.\nType definitions for reset method used can be found here\nTypescript const resetResponse: OkOrUnhandledResponse = await sequencerService.reset()","title":"Discarding all the pending Steps"},{"location":"/technical/sequencer-service.html#discarding-all-the-pending-steps-and-calling-the-onabortsequence-handler-of-the-script","text":"To discard all the pending Steps and call the onAbortSequence handler of the script, SequencerService provides a abortSequence API which returns Promise<OkOrUnhandledResponse>. If sequencer is in InProgress state, then an Ok response gets returned. Otherwise, an Unhandled response gets returned.\nType definitions for abortSequence method used can be found here\nTypescript const abortResponse: OkOrUnhandledResponse = await sequencerService.abortSequence()","title":"Discarding all the pending Steps and calling the onAbortSequence handler of the script"},{"location":"/technical/sequencer-service.html#discarding-all-the-pending-steps-and-calling-the-onstop-handler-of-the-script","text":"To discard all the pending Steps and call the onStop handler of the script, SequencerService provides a stop API which returns Promise<OkOrUnhandledResponse>. If sequencer is in InProgress state, then an Ok response gets returned. Otherwise, an Unhandled response gets returned.\nType definitions for stop method used can be found here\nTypescript const stopResponse: OkOrUnhandledResponse = await sequencerService.stop()","title":"Discarding all the pending Steps and calling the onStop handler of the script"},{"location":"/technical/sequencer-service.html#changing-sequencer-state-to-online","text":"To change sequencer state to Online, SequencerService provides goOnline API which returns Promise<GoOnlineResponse>. If sequencer is in any State but InProgress, then an Ok response get returned if goOnline handler gets executed successfully, otherwise a GoOnlineHookFailed response gets returned. Although, if sequencer is in InProgress state then an Unhandled response gets returned.\nType definitions for goOnline method used can be found here\nTypescript const goOnlineResponse: GoOnlineResponse = await sequencerService.goOnline()","title":"Changing sequencer state to Online"},{"location":"/technical/sequencer-service.html#changing-sequencer-state-to-offline","text":"To change sequencer state to Offline, SequencerService provides goOffline API which returns Promise<GoOfflineResponse>. If sequencer is in any State but InProgress, then an Ok response get returned if goOffline handler gets executed successfully, otherwise a GoOfflineHookFailed response gets returned. Although, if sequencer is in InProgress state then an Unhandled response gets returned.\nType definitions for goOffline method used can be found here\nTypescript const goOfflineResponse: GoOfflineResponse = await sequencerService.goOffline()","title":"Changing sequencer state to Offline"},{"location":"/technical/sequencer-service.html#running-diagnosticmode","text":"To run diagnosticMode handler, SequencerService provides diagnosticMode API which returns Promise<DiagnosticModeResponse>. If diagnosticMode handler of the script successfully executes, then an Ok response gets returned. Otherwise, a DiagnosticHookFailed gets returned.\nType definitions for diagnosticMode method used can be found here\nTypescript const diagnosticResponse: DiagnosticModeResponse = await sequencerService.diagnosticMode(\n  new Date(),\n  'engineering'\n)","title":"Running diagnosticMode"},{"location":"/technical/sequencer-service.html#running-operationsmode","text":"To run operationsMode handler, SequencerService provides operationsMode API which returns Promise<OperationsModeResponse>. If operationsMode handler of the script successfully executes, then an Ok response gets returned. Otherwise, a OperationsHookFailed gets returned.\nType definitions for operationsMode method used can be found here\nTypescript const operationsModeResponse: OperationsModeResponse = await sequencerService.operationsMode()","title":"Running operationsMode"},{"location":"/technical/sequencer-service.html#submitting-sequence-to-a-sequencer","text":"To submit a Sequence to a Sequencer, SequencerCommandService provides a submit API which takes a Sequence and returns a Promise<SubmitResponse>.\nIf the sequencer is idle, the provided sequence is loaded in the sequencer and execution of the sequence starts immediately, and a Started response is returned. If the sequencer is already running another sequence, an Invalid response is returned.\nTypescript const initialRes: SubmitResponse = await sequencerService.submit(sequence)\n\nconst queryRes: SubmitResponse = await sequencerService.query(initialRes.runId)\n\nconst queryFinalRes: SubmitResponse = await sequencerService.queryFinal(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9',\n  10\n)\nquery or queryFinal Apis, as shown above, could be used to query for the sequence result after the sequence is submitted. query returns the current response which could be either final response (eg. Completed) or intermediate response (eg. Started). Whereas queryFinal will wait for the final response of the sequence for the given timeout. This method will never return an intermediate response.\nIf you are not interested in initial/intermediate response but only in final response, you can use the submitAndWait api which submits the sequence and waits for the final response if the sequence was successfully Started.\nTypescript const submitAndWaitResponse: SubmitResponse = await sequencerService.submitAndWait(\n  sequence,\n  10\n)\nType definitions for APIs used in the given example are :\nsubmit submitAndWait query queryFinal","title":"Submitting Sequence to a Sequencer"},{"location":"/services/sequence-manager-service.html","text":"","title":"Sequence Manager Service"},{"location":"/services/sequence-manager-service.html#sequence-manager-service","text":"The Sequence Manager Service manages all the operation related to the observations. It manages all sequence components and sequencers required for the observations.\nSequence Manager service has following APIs:\nAPI Input args Returns configure obsMode ConfigureResponse provision config ProvisionResponse getRunningObsModes GetRunningObsModesResponse startSequencer subsystem, obsMode StartSequencerResponse restartSequencer subsystem, obsMode RestartSequencerResponse shutdownSequencer subsystem, obsMode ShutdownSequencersResponse shutdownSubsystemSequencers subsystem ShutdownSequencersResponse shutdownObsModeSequencers obsMode ShutdownSequencersResponse shutdownAllSequencers ShutdownSequencersResponse shutdownSequenceComponent prefix ShutdownSequenceComponentResponse shutdownAllSequenceComponents ShutdownSequenceComponentResponse getAgentStatus AgentStatusResponse","title":"Sequence Manager Service"},{"location":"/services/sequence-manager-service.html#creation-of-sequence-manager-service","text":"","title":"Creation of Sequence Manager Service"},{"location":"/services/sequence-manager-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/services/sequence-manager-service.html#in-order-to-create-sequence-manager-service-apis-","text":"Subsystem’s agent machines should be up and running. Sequence Manager should be spawned. Documentation on how to spawn sequence manager could be found here. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"In order to create sequence manager service APIs:"},{"location":"/services/sequence-manager-service.html#to-create-sequence-manager-client-","text":"Typescript const tokenFactory = () => auth.token\nconst sequenceManagerService: SequenceManagerService = await SequenceManagerService(\n  tokenFactory\n)","title":"To create Sequence Manager client:"},{"location":"/services/sequence-manager-service.html#apis","text":"","title":"APIs"},{"location":"/services/sequence-manager-service.html#configure","text":"It starts sequencers needed for an observation mode. Before starting sequencer, it checks for resource conflict between requested observation mode and running observation mode. The required sequencers and resources are listed in obsModeConfig file provided at boot up time of sequence manager. It returns ConflictingResourcesWithRunningObsMode if required resources are not available. This API returns response containing Success as ConfigureResponse after successful start of all required sequencers.\nThe following example shows how to call configure API. Here machines will be setup for ‘IRIS_DarkNight’ observation mode.\nTypescript const obsMode = new ObsMode('IRIS_DarkNight')\nconst configureResponse: ConfigureResponse = await sequenceManagerService.configure(\n  obsMode\n)","title":"configure"},{"location":"/services/sequence-manager-service.html#provision","text":"This API shutdowns all the running sequence components and provisions the new sequence components in accordance with the provided configuration. The configuration specifies number of sequence components needed to be spawned on a particular agent. It returns Success as ProvisionResponse after successful spawning of components.\nIn following example, three sequence components will be spawned on ‘ESW.agent-machine’ agent machine and two sequence component will be spawned on ‘IRIS.agent-machine’ agent machine.\nTypescript const eswAgentPrefix = new Prefix('ESW', 'agent-machine')\nconst irisAgentPrefix = new Prefix('IRIS', 'agent-machine')\nconst eswAgentProvisionConfig = new AgentProvisionConfig(eswAgentPrefix, 3)\nconst irisAgentProvisionConfig = new AgentProvisionConfig(irisAgentPrefix, 2)\nconst provisionConfig = new ProvisionConfig([\n  eswAgentProvisionConfig,\n  irisAgentProvisionConfig\n])\n\nconst provision: ProvisionResponse = await sequenceManagerService.provision(\n  provisionConfig\n)","title":"provision"},{"location":"/services/sequence-manager-service.html#getrunningobsmodes","text":"This API returns all the running observation modes.\nThe following example shows how to call getRunningObsModes API :\nTypescript const obsModes: GetRunningObsModesResponse = await sequenceManagerService.getRunningObsModes()","title":"getRunningObsModes"},{"location":"/services/sequence-manager-service.html#startsequencer","text":"This API starts the sequencer for given subsystem and observation mode. It uses the subsystem’s sequence component, if not available, fallbacks to ESW sequence component.\nThe following example shows how to call startSequencer API :\nTypescript const startSequencerResponse: StartSequencerResponse = await sequenceManagerService.startSequencer(\n  'IRIS',\n  obsMode\n)","title":"startSequencer"},{"location":"/services/sequence-manager-service.html#restartsequencer","text":"It restarts the existing running sequencer of given subsystem and observing mode.\nThe following example shows how to call restartSequencer API :\nTypescript const restartSequencerResponse: RestartSequencerResponse = await sequenceManagerService.restartSequencer(\n  'IRIS',\n  obsMode\n)","title":"restartSequencer"},{"location":"/services/sequence-manager-service.html#shutdownsequencer","text":"This API shutdowns the running sequencer of given subsystem and observation mode.\nThe following example shows how to call shutdownSequencer API :\nTypescript const shutdownSequencerResponse: ShutdownSequencersResponse = await sequenceManagerService.shutdownSequencer(\n  'IRIS',\n  obsMode\n)","title":"shutdownSequencer"},{"location":"/services/sequence-manager-service.html#shutdownsubsystemsequencers","text":"This API shutdowns all the running sequencers of given subsystem.\nThe following example shows how to call shutdownSubsystemSequencers API :\nTypescript const shutdownSubsystemSeqResponse: ShutdownSequencersResponse = await sequenceManagerService.shutdownSubsystemSequencers(\n  'IRIS'\n)","title":"shutdownSubsystemSequencers"},{"location":"/services/sequence-manager-service.html#shutdownobsmodesequencers","text":"This API shutdowns all the running sequencers of given observation mode.\nThe following example shows how to call shutdownObsModeSequencers API :\nTypescript const shutdownObsModeSeqResponse: ShutdownSequencersResponse = await sequenceManagerService.shutdownObsModeSequencers(\n  obsMode\n)","title":"shutdownObsModeSequencers"},{"location":"/services/sequence-manager-service.html#shutdownallsequencers","text":"This API shutdowns all the running sequencers.\nThe following example shows how to call shutdownAllSequencers API :\nTypescript const shutdownAllSequencersResponse: ShutdownSequencersResponse = await sequenceManagerService.shutdownAllSequencers()","title":"shutdownAllSequencers"},{"location":"/services/sequence-manager-service.html#shutdownsequencecomponent","text":"This API shutdowns sequence component with provided prefix.\nThe following example shows how to call shutdownSequenceComponent API :\nTypescript const seqCompPrefix = new Prefix('ESW', 'ESW.ESW_1')\nconst shutdownSeqCompResponse: ShutdownSequenceComponentResponse = await sequenceManagerService.shutdownSequenceComponent(\n  seqCompPrefix\n)","title":"shutdownSequenceComponent"},{"location":"/services/sequence-manager-service.html#shutdownallsequencecomponents","text":"This API shutdowns all the sequence components.\nThe following example shows how to call shutdownAllSequenceComponents API :\nTypescript const shutdownAllSeqCompResponse: ShutdownSequenceComponentResponse = await sequenceManagerService.shutdownAllSequenceComponents()","title":"shutdownAllSequenceComponents"},{"location":"/services/sequence-manager-service.html#getagentstatus","text":"This API allows showing status of TMT ecosystem components (agents, sequence components and sequencers). It returns all agents that are up and running, sequence components running on those agents and sequencer script loaded on sequence component.\nThe following example shows how to call getAgentStatus API :\nTypescript const agentStatus: AgentStatusResponse = await sequenceManagerService.getAgentStatus()","title":"getAgentStatus"},{"location":"/technical/csw-aas-js.html","text":"","title":"csw-aas-js - Javascript adapter"},{"location":"/technical/csw-aas-js.html#csw-aas-js-javascript-adapter","text":"csw-aas-js is a npm package which exposes react components to enable authentication and authorization. csw-aas-js is built in typescript on top of keycloak-js which is javascript adapter provided by keycloak.","title":"csw-aas-js - Javascript adapter"},{"location":"/technical/csw-aas-js.html#csw-aas-js-implementation","text":"Core implementation of csw-aas-js uses\nkeycloak-js - keycloak javascript adapter React - JavaScript library for building user interfaces Typescript - Types superset of JavaScript which compiles to JavaScript csw-location-service - resolve keycloak using location service HTTP endpoint","title":"csw-aas-js Implementation"},{"location":"/technical/csw-aas-js.html#project-setup","text":"csw-aas-js is a library written in Typescript. tsc is a command line compiler of Typescript which compiles typescrit files to JavaScript. tsc picks up configurations from tsconfig.json file which is at root level of project. tsconfig.json allows to configure multiple compiler options. Please refer this for details of compiler options. npm run build command will run tsc which will produce outputs (.js and .d.ts). .d.ts files are the type declaration files which provide typings for react components exported by library. package.json points to index.ts as a entry point for library and index.d.ts as types. This will help csw-aas-js library users to know type signatures of components. e.g. type signature for react component props, api signatures. csw-aas-js can be seamlessly consumed by applications written ES6 or Typescript.","title":"Project setup"},{"location":"/technical/csw-aas-js.html#keycloak","text":"In order for web application utilize keycloak following steps are needed:\nRegistered web application as a public keycloak client Please refer to keycloak documentation for details. Create new Keycloak client instance This instantiation expects config which includes keycloak server URL and some application specific config like realm and clientId. csw-aas-js uses CSW Location Service to resolve keycloak server.\nJavascript export const AppConfig = {\n  realm: 'TMT',\n  clientId: 'tmt-frontend-app',\n  applicationName: 'test-app'\n}\nInitialize javascript adapter To call secure end point, web application first needs to be authenticated using keycloak server. There are two options to make this adapter automatically authenticate - login-required and check-sso. login-required will automatically authenticate if the user is already logged-in, otherwise it will display keycloak login page. check-sso will only authenticate if the user is already logged-in. If the user is not logged-in the browser will be redirected back to the application and remain unauthenticated.\ncsw-aas-js use check-sso to instantiate keycloak. It shows secure components if user is already logged in. If user is not authenticated Login component is rendered. If user clicks on login button it instantiates keyclock use login-required. This redirects user to keycloak login page. As access token has very short life span, at time of keycloak instantiation csw-aas-js also adds hooks to refresh token. This gives seamless user experience as user need not to login again.\nKeycloak adapter supports three authorization flows e.g. authorization code flow, implicit flow and hybrid flow. csw-aas-js has chosen hybrid flow as it has better performance than authorization code flow and unlike implicit flow, hybrid flow makes refresh token available to application. For more information please refer keyclok documentaion for authorization flows","title":"Keycloak"},{"location":"/technical/csw-aas-js.html#working-of-csw-aas-js","text":"When user opens web application in browser, AuthContextProvider component is mounted. Which does instantiation of keycloak client and initialize keycloak javascript adapter with check-sso and hybrid authorization flow. It also creates hooks for refreshing token when token is expired which silently refresh token resulting seamless user experience once logged in. After authentication is done via keycloak javascript adapter, AuthContext is extracted in domain model and this data is passed down the component tree using react context api. AuthContext gives handle to token, realm and resource roles, userInfo. Any component which want to use this information can become consumer of AuthContext. For example\nJavascript const { auth } = useContext(authContext)\nAccess token can be extracted from auth and it can be sent in Authorization header for calling secure api\nFor example -\nconst SampleComponent = () => {\n\n    const url = 'http://localhost:8080/secure-restful-service';\n    const auth = useContext(AuthContext) //AuthContext from csw-aas-js\n\n    const req = new XMLHttpRequest();\n    req.open('GET', url, true);\n    req.setRequestHeader('Accept', 'application/json');\n\n    //extract token from auth context and set Authorization header\n    req.setRequestHeader('Authorization', 'Bearer ' + auth.token);\n\n    req.onreadystatechange = function () {\n        if (req.readyState == 4) {\n            if (req.status == 200) {\n                alert('Success');\n            } else if (req.status == 403) {\n                alert('Forbidden');\n            }\n        }\n    }\n\n    req.send();\n};\nFollowing diagram explains javascript application flow for making request to secure HTTP api\nWhen user opens web application in browser, csw-aas-js checks if user is already logged in using check-sso mode. If user is not logged in then Login button is shown. When user clicks on login, user will be redirected to keyclok login page. This completes authentication process. Once authentication is done, AuthContextProvider extract AuthContext domain model and make it available to consumers of AuthContext. Protected react components can be shown based on information in AuthContext. For example, CreateConfig component can be shown only to users having config admin role. After the user is authenticated the application can make requests to RESTful services secured by Keycloak by including the bearer token in the Authorization header. This completed workflow for web application calling secure HTTP endpoint.","title":"Working of csw-aas-js"},{"location":"/common/contract.html","text":"","title":"Service Contract"},{"location":"/common/contract.html#service-contract","text":"All ESW-TS services adhere to contract which is defined by ESW and CSW services.\nThe following are the links for each of the backend service contract.\nESW Services Contract Event Service Admin Service Alarm Service Logging Service Sequencer Service Agent Service Sequence Manager Service CSW Services Contract Location Service Command Service Config Service\nNote Event, Admin, Alarm, Logging will be accessed via gateway server. therefore, the links are pointing to gateway service contract.","title":"Service Contract"},{"location":"/common/ts-docs.html","text":"","title":"Type Definitions"},{"location":"/common/ts-docs.html#type-definitions","text":"Type definitions for following can be found by their corresponding links:\nAll Services React Components App Configurations Models","title":"Type Definitions"}]}