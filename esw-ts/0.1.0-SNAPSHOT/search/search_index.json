{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/clients/location/location-service.html","text":"","title":"Location Service"},{"location":"/clients/location/location-service.html#location-service","text":"The Location Service handles component (i.e., Applications, Sequencers, Assemblies, HCDs, and Services) discovery in the distributed TMT software system.\nA component’s location information can be used by other components and services to connect to it and use it. An example of location information is:\nHost address/port pairs URL/URIs paths Connection protocols Metadata if available (process_id, agent_id, etc).\nLocation service has following APIs:\nAPI Input args Returns list Location[ ] listByComponentType ComponentType Location[ ] listByHostname hostname Location[ ] listByConnectionType ConnectionType Location[ ] listByPrefix prefix Location[ ] find Connection Option< Location > unregister Connection Done resolve Connection, within, TimeUnit Option< Location > track Connection, onTrackingEventCallback Subscription","title":"Location Service"},{"location":"/clients/location/location-service.html#creation-of-location-service","text":"","title":"Creation of Location Service"},{"location":"/clients/location/location-service.html#pre-requisite","text":"Access token is not neccessarily needed for creating location service.\nIf You are using location service to unregister a component, you would need to have the access token with specific permissions :\nAuthorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"Pre-requisite"},{"location":"/clients/location/location-service.html#examples-to-create-client-for-location-service","text":"Location service constructor takes optional tokenFactory and optional location server configuration(host/port pair).\nTypescript const tokenFactory = () => auth.token\n\nconst locationServiceWithToken: LocationService = await LocationService(\n  tokenFactory\n)\n\nconst locationService: LocationService = await LocationService()","title":"Examples to create client for Location service"},{"location":"/clients/location/location-service.html#apis","text":"Async-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"APIs"},{"location":"/clients/location/location-service.html#list","text":"This API returns a list of Locations of components that are registered in the location service.\nThe following example shows how to call list API :\nTypescript const locations: Location[] = await locationService.list()\n// \n// iterate over locations to do further computation\n// . \n// .","title":"list"},{"location":"/clients/location/location-service.html#listbycomponenttype","text":"This API takes a component type as an argument and returns a list of Locations for that specific component type which are registered in the location service.\nThe following examples shows various ways listByComponentType API can be called\nTypescript // valid Component type's : \"HCD\" | \"Assembly\" | \"Service\" | \"Container\" | \"Sequencer\" | \"SequenceComponent\" | \"Machine\"\n\nconst sequencerLocations: Location[] = await locationService.listByComponentType(\"Sequencer\")\n\nconst hcdLocations: Location[] = await locationService.listByComponentType(\"HCD\")\n\nconst assemblyLocations: Location[] = await locationService.listByComponentType(\"Assembly\")","title":"listByComponentType"},{"location":"/clients/location/location-service.html#listbyconnectiontype","text":"This API takes a connection type as an argument and returns a list of Locations for that specific connection type which are registered in the location service.\nThe following examples shows various ways listByConnectionType API can be called:\nTypescript // valid Connection types: \"akka\" | \"http\" | \"tcp\"\nconst akkaLocations: Location[] = await locationService.listByConnectionType(\"akka\")\n\nconst httpLocations: Location[] = await locationService.listByConnectionType(\"http\")\n\nconst tcpLocations: Location[] = await locationService.listByConnectionType(\"tcp\")","title":"listByConnectionType"},{"location":"/clients/location/location-service.html#listbyhostname","text":"This API takes a hostname as an argument and returns a list of Locations registered with that host in the location service.\nThe following examples shows various ways listByHostname API can be called:\nTypescript const remoteLocations: Location[] = await locationService.listByHostname(\"192.0.162.178\")\n\nconst locationRegisteredWithDomain: Location[] = await locationService.listByHostname(\"tmt.org.com\")\n\nconst localLocations: Location[] = await locationService.listByHostname(\"localhost\")","title":"listByHostname"},{"location":"/clients/location/location-service.html#listbyprefix","text":"This API takes a prefix of a component as an argument and returns a list of Locations registered with that prefix in the location service.\nThe following example shows listByPrefix API can be called:\nTypescript const eswComponentLocations: Option<Location> = await locationService.find(HttpConnection(new Prefix(\"ESW\",\"component\"), \"HCD\"))","title":"listByPrefix"},{"location":"/clients/location/location-service.html#find","text":"This API takes a type of Connection as an argument to be located and returns a Option of Location.\nThe following example shows find API can be called:\nTypescript // Find the location of Hcd with esw.component-1 prefix\n// ConnectionType's : HttpConnection , AkkaConnection & TCPConnection\nconst maybeLocation: Option<Location> = await locationService.find(HttpConnection(new Prefix(\"ESW\",\"component\"), \"HCD\"))\nif(maybeLocation) {\n    // use maybeLocation from here \n}else {\n    // location not resolved\n}","title":"find"},{"location":"/clients/location/location-service.html#unregister","text":"This is a secure API and takes a type of Connection as an input argument to be unregistered from the location service and returns Done once unregistered.\nThe following example shows unregister API can be called:\nTypescript // ConnectionType's : HttpConnection , AkkaConnection & TCPConnection\nconst done: Done = await locationServiceWithToken.unregister(HttpConnection(new Prefix(\"ESW\",\"component\"), \"HCD\"))","title":"unregister"},{"location":"/clients/location/location-service.html#resolve","text":"This API takes a type of Connection along with the timeout value(within) and the timeout unit(TimeUnit) as arguments to resolve connection and it returns the option of location.\nThe following example shows resolve API can be called:\nTypescript // ConnectionType's : HttpConnection , AkkaConnection & TCPConnection\n// Time unit : seconds, milliseconds, nanoseconds, microseconds, minutes, hours, days\n\nconst connection = HttpConnection(new Prefix(\"ESW\", \"component\"), \"HCD\")\n\nconst maybeLocation1: Option<Location> = await locationService.resolve(connection, 10, 'seconds')\nif(maybeLocation1) {\n    // use maybeLocation inside here \n}else {\n    // location did not resolved in 10 seconds\n}","title":"resolve"},{"location":"/clients/location/location-service.html#track","text":"This API takes a type of Connection to be tracked and the calback function for that connection which will be called when the connection’s location is updated or removed.\nThe following example shows track API can be called:\nTypescript // a callback function\nconst onTrackingEvent = (event: TrackingEvent) => {\n    if(event._type === 'LocationRemoved') {\n        // do something when connection's location is removed from the location service\n    }else if (event._type === 'LocationUpdated') {\n        // do something when connection's location is update from the location service\n    }\n    \n}\n// connection to be tracked\nconst httpConnection = HttpConnection(new Prefix(\"ESW\", \"component\"), \"HCD\")\n\nlocationService.track(httpConnection)(onTrackingEvent)","title":"track"},{"location":"/clients/agent/agent-service.html","text":"","title":"Agent Service"},{"location":"/clients/agent/agent-service.html#agent-service","text":"Agent service provides HTTP interface to interact with all agent machines uniquely located using agent prefix. APIs to spawn components takes agent prefix as parameter. Agent prefix is used to locate agent machine using location service. After agent is located, command like spawn sequence manager or spwan sequence component is forwarded to that agent machine. Agent service provides APIs to spawn sequence manager, sequence components and to kill spawned components.\nAgent service has following APIs:\nAPI Input args Returns spawnSequenceManager agentPrefix, obsModeConfigPath, isConfigLocal, version SpawnResponse spawnSequenceComponent agentPrefix, componentName, version SpawnResponse killComponent connection KillResponse","title":"Agent Service"},{"location":"/clients/agent/agent-service.html#creation-of-agent-service","text":"","title":"Creation of Agent Service"},{"location":"/clients/agent/agent-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/clients/agent/agent-service.html#in-order-to-use-agent-service-apis-","text":"Agent machines should be up and running. Locations of agent machines should be registered in Location Service. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"In order to use agent service APIs:"},{"location":"/clients/agent/agent-service.html#to-create-agent-client-","text":"Typescript const tokenFactory = () => auth.token\n\nconst agentService: AgentService = await AgentService(tokenFactory)","title":"To create Agent client:"},{"location":"/clients/agent/agent-service.html#apis","text":"Async-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"APIs"},{"location":"/clients/agent/agent-service.html#spawnsequencemanager","text":"This API spawns new sequence manager on given agent machine.\nIt takes a prefix of the agent machine on which sequence manager needs to be spawned. Observation mode config file can be present on local(agent machine) or on config server. In case of local file, absolute path should be provided. Sequence manager version is an optional field. When version isn’t specified, default version gets picked up.\nAPI returns Spawned as a response when sequence manager has spawned successfully. API returns Failed as a response if a sequence manager is already present.\nThe following example shows how to call spawnSequenceManager API :\nTypescript const agentPrefix = new Prefix('ESW', 'agent1')\nconst obsModeConfigPath = '/obs-mode.conf'\nconst sequenceManagerVersion = '1.0.0'\n\nconst spawnResponse1: SpawnResponse = await agentService.spawnSequenceManager(\n  agentPrefix,\n  obsModeConfigPath,\n  false,\n  sequenceManagerVersion\n)","title":"spawnSequenceManager"},{"location":"/clients/agent/agent-service.html#spawnsequencecomponent","text":"This API spawns new sequence component on agent machine which is located using agent prefix provided.\nIt takes a prefix of the agent machine, component name and ocs-app library version. Version is an optional field. When version isn’t specified, default version gets picked up.\nAPI returns Spawned as a response when sequence component has spawned successfully. API returns Failed as a response if a sequence component with given component name and agent’s subsystem is already present on any agent machine.\nThe following example shows how to call spawnSequenceComponent API :\nTypescript const ocsAppVersion = '1.2.1'\nconst spawnResponse2: SpawnResponse = await agentService.spawnSequenceComponent(\n  agentPrefix,\n  'component1',\n  ocsAppVersion\n)","title":"spawnSequenceComponent"},{"location":"/clients/agent/agent-service.html#killcomponent","text":"This API allows to kill any component registered with location service. It takes Connection as a input which can be either of following: AkkaConnection, HttpConnection, TcpConnection.\nAPI returns Killed as a response if component is killed successfully. API returns Failed as a response if it fails to kill the component.\nThe following example shows how to call killComponent API :\nTypescript const componentPrefix = new Prefix('ESW', 'component1')\nconst httpConnection: HttpConnection = HttpConnection(\n  componentPrefix,\n  'SequenceComponent'\n)\nconst killResponse: KillResponse = await agentService.killComponent(httpConnection)","title":"killComponent"},{"location":"/clients/sequencer/sequencer-service.html","text":"","title":"Sequencer Service"},{"location":"/clients/sequencer/sequencer-service.html#sequencer-service","text":"This service provides a handle to send commands to a sequencer which is registered in location service.\nSequencer service has following APIs:\nAPI Input args Returns loadSequence sequence OkOrUnhandledResponse startSequence SubmitResponse add commands OkOrUnhandledResponse prepend commands OkOrUnhandledResponse replace id, commands GenericResponse insertAfter id, commands GenericResponse delete id GenericResponse addBreakpoint id GenericResponse removeBreakpoint id RemoveBreakpointResponse reset OkOrUnhandledResponse resume OkOrUnhandledResponse pause PauseResponse getSequence StepList or undefined isAvailable boolean isOnline boolean goOnline GoOnlineResponse goOffline GoOfflineResponse abortSequence OkOrUnhandledResponse stop OkOrUnhandledResponse diagnosticMode startTime, hint DiagnosticModeResponse operationsMode OperationsModeResponse query runId SubmitResponse queryFinal runId, timeoutInSeconds SubmitResponse submit sequence SubmitResponse submitAndWait sequence, timeoutInSeconds SubmitResponse","title":"Sequencer Service"},{"location":"/clients/sequencer/sequencer-service.html#creation-of-sequencer-service","text":"","title":"Creation of Sequencer Service"},{"location":"/clients/sequencer/sequencer-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/clients/sequencer/sequencer-service.html#in-order-to-use-sequencer-service-client-for-a-specific-sequencer-","text":"The sequencer and gateway server should be running. GatewayException(InvalidComponent) will be thrown if the specified sequencer not found in the location service. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"In order to use sequencer service client for a specific sequencer:"},{"location":"/clients/sequencer/sequencer-service.html#here-is-an-example-","text":"Typescript const tokenFactory = () => auth.token\n\nconst sequencerService: SequencerService = await SequencerService(\n  new ComponentId(new Prefix('ESW', 'darknight'), 'Sequencer'),\n  tokenFactory\n)","title":"Here is an example:"},{"location":"/clients/sequencer/sequencer-service.html#creating-sequencecommands","text":"Typescript const eswTestPrefix = Prefix.fromString('TCS.darknight')\n\nconst setupCommand1 = new Setup(eswTestPrefix, 'setup-command1')\nconst setupCommand2 = new Setup(eswTestPrefix, 'setup-command2')\n\nconst observeCommand1 = new Observe(eswTestPrefix, 'observe-command1')\nconst observeCommand2 = new Observe(eswTestPrefix, 'observe-command2')","title":"Creating SequenceCommands"},{"location":"/clients/sequencer/sequencer-service.html#creating-a-sequence","text":"A sequence is a list of sequence commands:\nTypescript //sequence is a list of SequenceCommand\nconst sequence = [setupCommand1, observeCommand1]","title":"Creating a Sequence"},{"location":"/clients/sequencer/sequencer-service.html#apis","text":"Async-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"APIs"},{"location":"/clients/sequencer/sequencer-service.html#loadsequence","text":"This API takes a sequence as a parameter, loads the sequence into the sequencer and returns the OkOrUnhandledResponse as a promise value.\nTypescript const okOrUnhandledResponse: OkOrUnhandledResponse = await sequencerService.loadSequence(\n  sequence\n)","title":"loadSequence"},{"location":"/clients/sequencer/sequencer-service.html#startsequence","text":"This API starts the execution of the sequence which is loaded in the sequencer and returns the SubmitResponse as a promise value.\nTypescript const startSequenceRes: SubmitResponse = await sequencerService.startSequence()","title":"startSequence"},{"location":"/clients/sequencer/sequencer-service.html#add","text":"This API takes a list of SequenceCommands as a parameter, adds that at last of the sequence and returns the OkOrUnhandledResponse as a promise value.\nTypescript const addResponse: OkOrUnhandledResponse = await sequencerService.add([\n  observeCommand2,\n  setupCommand2\n])","title":"add"},{"location":"/clients/sequencer/sequencer-service.html#prepend","text":"This API takes a list of SequenceCommands as a parameter, adds that before all the pending steps of the sequence and returns the OkOrUnhandledResponse as a promise value.\nTypescript const prependResponse: OkOrUnhandledResponse = await sequencerService.prepend([\n  observeCommand2,\n  setupCommand2\n])","title":"prepend"},{"location":"/clients/sequencer/sequencer-service.html#replace","text":"This API takes an Id of a pending step(command) of the sequence and a list of SequenceCommands as parameters, replaces the command of the given Id with the given list of SequenceCommands and returns the GenericResponse as a promise value.\nTypescript const replaceResponse: GenericResponse = await sequencerService.replace(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9',\n  [observeCommand2, setupCommand2]\n)","title":"replace"},{"location":"/clients/sequencer/sequencer-service.html#insertafter","text":"This API takes an Id of a pending step(command) of the sequence and a list of SequenceCommands as parameters, inserts the given list of SequenceCommands after the command of the given Id and returns the GenericResponse as a promise value.\nTypescript const insertAfterResponse: GenericResponse = await sequencerService.insertAfter(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9',\n  [observeCommand2, setupCommand2]\n)","title":"insertAfter"},{"location":"/clients/sequencer/sequencer-service.html#delete","text":"This API takes an Id of a pending step(command) of the sequence as a parameter, deletes the step from the sequencer and returns the GenericResponse as a promise value.\nTypescript const deleteResponse: GenericResponse = await sequencerService.delete(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9'\n)","title":"delete"},{"location":"/clients/sequencer/sequencer-service.html#addbreakpoint","text":"This API takes an Id of a pending step(command) of the sequence as a parameter, adds a breakpoint to the step and returns the GenericResponse as a promise value.\nTypescript const addBreakpointResponse: GenericResponse = await sequencerService.addBreakpoint(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9'\n)","title":"addBreakpoint"},{"location":"/clients/sequencer/sequencer-service.html#removebreakpoint","text":"This API takes an Id of a pending step(command) of the sequence as a parameter, removes the breakpoint from the step and returns the RemoveBreakpointResponse as a promise value.\nTypescript const removeBreakpointResponse: RemoveBreakpointResponse = await sequencerService.removeBreakpoint(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9'\n)","title":"removeBreakpoint"},{"location":"/clients/sequencer/sequencer-service.html#reset","text":"This API discards all the pending steps of the sequence and returns the OkOrUnhandledResponse as a promise value.\nTypescript const resetResponse: OkOrUnhandledResponse = await sequencerService.reset()","title":"reset"},{"location":"/clients/sequencer/sequencer-service.html#resume","text":"This API resumes the execution of the paused sequence and returns the OkOrUnhandledResponse as a promise value.\nTypescript const resumeResponse: OkOrUnhandledResponse = await sequencerService.resume()","title":"resume"},{"location":"/clients/sequencer/sequencer-service.html#pause","text":"This API pauses the execution of the sequence by placing a breakpoint at the next pending step and returns the PauseResponse as promise value.\nTypescript const pauseResponse: PauseResponse = await sequencerService.pause()","title":"pause"},{"location":"/clients/sequencer/sequencer-service.html#getsequence","text":"This API returns the StepList(runtime representation of the sequence) if there is a sequence executing in the sequencer else returns undefined, as a promise value.\nTypescript const getSequenceRes: Option<StepList> = await sequencerService.getSequence()","title":"getSequence"},{"location":"/clients/sequencer/sequencer-service.html#isavailable","text":"This API returns true if sequencer is in Idle state else returns false, as a promise value.\nTypescript const isAvailable: boolean = await sequencerService.isAvailable()","title":"isAvailable"},{"location":"/clients/sequencer/sequencer-service.html#isonline","text":"This API returns true if sequencer is in any state but Offline else returns false, as a promise value.\nTypescript const isOnline: boolean = await sequencerService.isOnline()","title":"isOnline"},{"location":"/clients/sequencer/sequencer-service.html#goonline","text":"This API makes sequencer to go into Online state and returns the GoOnlineResponse as a promise value.\nTypescript const goOnlineResponse: GoOnlineResponse = await sequencerService.goOnline()","title":"goOnline"},{"location":"/clients/sequencer/sequencer-service.html#gooffline","text":"This API makes sequencer to go into Offline state and returns the GoOfflineResponse as a promise value.\nTypescript const goOfflineResponse: GoOfflineResponse = await sequencerService.goOffline()","title":"goOffline"},{"location":"/clients/sequencer/sequencer-service.html#abortsequence","text":"This API discards all the pending steps of the sequence, calls the onAbortSequence handler in the script of the sequencer and returns the OkOrUnhandledResponse as a promise value.\nTypescript const abortResponse: OkOrUnhandledResponse = await sequencerService.abortSequence()","title":"abortSequence"},{"location":"/clients/sequencer/sequencer-service.html#stop","text":"This API discards all the pending steps of the sequence, calls the onStop handler in the script of the sequencer and returns the OkOrUnhandledResponse as a promise value.\nTypescript const stopResponse: OkOrUnhandledResponse = await sequencerService.stop()","title":"stop"},{"location":"/clients/sequencer/sequencer-service.html#diagnosticmode","text":"This API takes Date(an Instant) and string(as hint) as parameters, calls the onDiagnosticMode handler in the script of the sequencer with those parameters and returns the DiagnosticModeResponse as a promise value.\nTypescript const diagnosticResponse: DiagnosticModeResponse = await sequencerService.diagnosticMode(\n  new Date(),\n  'engineering'\n)","title":"diagnosticMode"},{"location":"/clients/sequencer/sequencer-service.html#operationsmode","text":"This API calls the onOperationsMode handler in the script of the sequencer and returns the OperationsModeResponse as a promise value.\nTypescript const operationsModeResponse: OperationsModeResponse = await sequencerService.operationsMode()","title":"operationsMode"},{"location":"/clients/sequencer/sequencer-service.html#submit","text":"This API takes a sequence as a parameter, starts the execution of the sequence and returns the immediate SubmitResponse as a promise value.\nTypescript const submitResponse: SubmitResponse = await sequencerService.submit(sequence)","title":"submit"},{"location":"/clients/sequencer/sequencer-service.html#submitandwait","text":"This API takes a sequence, and a timeout in seconds as parameters, starts the execution of the sequence and returns the final SubmitResponse in that given timeout as a promise value.\nTypescript const submitAndWaitResponse: SubmitResponse = await sequencerService.submitAndWait(\n  sequence,\n  10\n)","title":"submitAndWait"},{"location":"/clients/sequencer/sequencer-service.html#query","text":"This API takes the runId of the sequence as a parameter, and returns the immediate SubmitResponse as a promise value.\nTypescript const queryResponse: SubmitResponse = await sequencerService.query(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9'\n)","title":"query"},{"location":"/clients/sequencer/sequencer-service.html#queryfinal","text":"This API takes the runId of the sequence, and a timeout in seconds as parameters, and returns the final SubmitResponse in that given timeout as a promise value.\nTypescript const queryFinalResponse: SubmitResponse = await sequencerService.queryFinal(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9',\n  10\n)","title":"queryFinal"},{"location":"/clients/config/config-service.html","text":"","title":"Config Service"},{"location":"/clients/config/config-service.html#config-service","text":"The Configuration Service provides a centralized persistent store for any configuration file used in the TMT Software System. All versions of configuration files are retained, providing a historical record of each configuration file. This client exposes simple methods to access and manage configuration files.\nConfig service has following APIs:\nAPI Input args Returns create path, configData, annex, comment ConfigId update path, configData, comment ConfigId getActive path Option< ConfigData > getLatest path Option< ConfigData > getById path, configId Option< ConfigData > getByTime path, time Option< ConfigData > exists path, id boolean delete path, comment void list fileType, pattern ConfigFileInfo[ ] history path, from, to, maxResults ConfigFileRevision[ ] historyActive path, from, to, maxResults ConfigFileRevision[ ] setActiveVersion path, id, comment void resetActiveVersion path, comment void getActiveByTime path, time Option< ConfigData > getActiveVersion path Option< ConfigId > getMetadata ConfigMetadata","title":"Config Service"},{"location":"/clients/config/config-service.html#rules-and-checks","text":"The config file path must not contain !#<>$%&’@^``~+,;= or any whitespace character If the input file is > 10MB or has lot of non ASCII characters, then for optimization, server will archive it in annex store. Large and binary files can be forced to go to the ‘annex’ store by using a annex=true flag in the create operation.","title":"Rules and Checks"},{"location":"/clients/config/config-service.html#model-classes","text":"ConfigData : Represents the contents of the files being managed. It wraps blob object. ConfigFileInfo : Represents information about a config file stored in the Config Service. ConfigFileRevision : Represents information about a specific version of a config file. ConfigId : Represents an identifier associated with a revision of a configuration file, often generated by create or update methods. ConfigMetadata : Represents metadata information about the Config Server. FileType : Represents the type of storage for a configuration file. Currently two types are supported Normal(small, text files) and Annex(Large, Binary files).","title":"Model Classes"},{"location":"/clients/config/config-service.html#example-for-creation-configdata-and-accessing-data-with-helper-function","text":"Typescript const dataArray = ['file-contents']\n\nconst configDataFromBlob: ConfigData = ConfigData.from(new Blob(dataArray))\nconst configDataFromFile: ConfigData = ConfigData.fromFile(new File(dataArray,'filename'))\nconst configDataFromString: ConfigData = ConfigData.fromString('someFileDataAsString')\n\n//accessing data\nconst dataAsBlobContent: Blob = configDataFromString.toBlob()\n\n// notice use of async-await here. because this is an IO read call\nconst readData = async (configData: ConfigData) => {\n  const dataAsString: string = await configData.fileContentAsString()\n}\nNote: Models other than ConfigData are simple typescript classes and do not have special helper methods unlike ConfigData.","title":"Example for creation ConfigData and accessing data with helper function"},{"location":"/clients/config/config-service.html#creation-of-config-service","text":"","title":"Creation of Config Service"},{"location":"/clients/config/config-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/clients/config/config-service.html#in-order-to-use-config-service-","text":"The Location Service and Configuration Service Server needs to be running in the network The necessary configuration, environment variables or system properties should be defined to point to the correct host and port number(s) for the Location Service nodes. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"In order to use config service:"},{"location":"/clients/config/config-service.html#examples-to-create-client-for-config-service","text":"Config service constructor takes TokenFactory as input argument.\nTypescript const tokenFactory = () => auth.token\n\nconst configService: ConfigService = await ConfigService(tokenFactory)","title":"Examples to create client for Config service"},{"location":"/clients/config/config-service.html#apis","text":"Async-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"APIs"},{"location":"/clients/config/config-service.html#create","text":"This API takes path at which configData needs to be saved in the config service along with meta information i.e whether to be saved as annex or normal file and comment. After saving, it returns ConfigId which can be used to access the saved file in future using query APIs.\nExample for create API looks like following:\nTypescript const path = 'esw/sequencer/obsMode.conf'\nconst comment = 'observation configuration on 21st november 2020'\nconst author = 'OCS-Sequencer admin: Dave'\nconst data = `\nesw-sm {\n  obsModes: {\n    IRIS_Darknight: {\n      resources: [IRIS, TCS, NFIRAOS]\n      sequencers: [IRIS, ESW, TCS]\n    },\n    IRIS_Cal: {\n      resources: [IRIS, NSCU, NFIRAOS]\n      sequencers: [IRIS, ESW, AOESW]\n    },\n    WFOS_Cal: {\n      resources: [WFOS]\n      sequencers: [WFOS, ESW]\n    }\n  }\n}\n`\nconst configData = ConfigData.fromString(data)\n\nconst sequencerConfigId: ConfigId = await configService.create(path,configData,false, comment)","title":"create"},{"location":"/clients/config/config-service.html#update","text":"This API takes path at which configData needs to be updated in the config service along with comment. After updating, it returns ConfigId which can be used to access the updated file in future using query APIs.\nExample for update API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst commentOnUpdate = 'observation configuration on 23rd november 2020'\nconst updatedData = `\nesw-sm {\n  obsModes: {\n    IRIS_Darknight: {\n      resources: [IRIS]\n      sequencers: [IRIS]\n    },\n    IRIS_Cal: {\n      resources: [IRIS, NSCU, NFIRAOS]\n      sequencers: [IRIS, ESW, AOESW]\n    }\n  }\n}\n`\nconst updatedConfigData = ConfigData.fromString(updatedData)\n\nconst newSequencerConfigId: ConfigId = await configService.update(filePath, updatedConfigData, commentOnUpdate)","title":"update"},{"location":"/clients/config/config-service.html#getactive","text":"This API takes path from which the active configData needs to be fetched and it returns Option of ConfigData.\nExample for getActive API looks like following:\nTypescript const file = 'esw/sequencer/obsMode.conf'\n\nconst maybeActiveConfigData: Option<ConfigData> = await configService.getActive(file)","title":"getActive"},{"location":"/clients/config/config-service.html#getlatest","text":"This API takes path from which the latest configData needs to be fetched and it returns Option of ConfigData.\nExample for getLatest API looks like following:\nTypescript const filepath = 'esw/sequencer/obsMode.conf'\nconst maybeLatestConfigData: Option<ConfigData> = await configService.getLatest(filepath)","title":"getLatest"},{"location":"/clients/config/config-service.html#getbyid","text":"This API takes path and previously created/updated configuration’s configId to be fetched and it returns Option of ConfigData.\nExample for getById API looks like following:\nTypescript const configId: ConfigId = await configService.update(filePath, updatedConfigData, commentOnUpdate)\n\nconst maybeConfigData: Option<ConfigData> = await configService.getById(filepath, configId)","title":"getById"},{"location":"/clients/config/config-service.html#getbytime","text":"This API gets the file at the given path as it existed at a given time-instance. Note: -If time-instance is before the file was created, the initial version is returned. -If time-instance is after the last change, the most recent version is returned.\nExample for getByTime API looks like following:\nTypescript const configId1: ConfigId = await configService.create(filePath, updatedConfigData, false, commentOnUpdate)\n\nconst beforeUpdate = new Date()\n\nconst configId2: ConfigId = await configService.update(filePath, configData, commentOnUpdate)\nconst afterUpdate = new Date()\n\nconst maybeConfigData: Option<ConfigData> = await configService.getByTime(filepath, beforeUpdate)\n// maybeConfigData == updatedConfigData (i.e Initial revision of config)\n\nconst newlyUpdatedData: Option<ConfigData> = await configService.getByTime(filepath, afterUpdate)\n// newlyUpdatedData == configData (i.e Latest revision of config)","title":"getByTime"},{"location":"/clients/config/config-service.html#exists","text":"This API checks whether file exists at the given path and optional specific configId in the repository or not it returns the promise of boolean\nExample for exists API looks like following:\nTypescript const exists: boolean = await configService.exists(filePath)\n\nconst exist: boolean = await configService.exists(filePath, configId)","title":"exists"},{"location":"/clients/config/config-service.html#delete","text":"This API deletes a file located at specified path in the repository.\nExample for exists API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\n\nawait configService.delete(filePath, 'deleting the invalid config entry')","title":"delete"},{"location":"/clients/config/config-service.html#list","text":"This API list all the files for a given FileType (Annex or Normal) and an optional pattern string, it will list all files whose path matches the given pattern.\nSome pattern examples are: “/path/hcd/*.*”, “a/b/c/d.*”, “.*.conf”, “.*hcd.*”\nExample for list API looks like following:\nTypescript const allAnnexFilesInfo :ConfigFileInfo[] = await configService.list('Annex')\nconst allNormalFilesInfo :ConfigFileInfo[] = await configService.list('Normal')\nconst allHcdAnnexFilesInfo :ConfigFileInfo[] = await configService.list('Annex','.*hcd.*')\nconst allConfNormalFilesInfo :ConfigFileInfo[] = await configService.list('Normal','.*conf')","title":"list"},{"location":"/clients/config/config-service.html#history","text":"This API returns the history of revisions of the file at the given path for a range of period specified by from and to.\nThe size of the list can be restricted using maxResults.\nExample for history API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst from = new Date(2019, 12, 31)\nconst to = new Date(2020, 12, 31)\n\n// upto 200 file revisions from 31st dec 2019 - 31st dec 2020 will be fetched\nconst fileRevisions: ConfigFileRevision[] = await configService.history(filePath,from,to, 200)","title":"history"},{"location":"/clients/config/config-service.html#getmetadata","text":"This API used to get metadata information about the Config Service. It includes:\nrepository directory annex directory min annex file size max config file size\nExample for getMetadata API looks like following:\nTypescript const metadata: ConfigMetadata =await  configService.getMetadata()","title":"getMetadata"},{"location":"/clients/config/config-service.html#managing-active-versions","text":"In its lifetime, a config file undergoes many revisions. An active version is a specific revision from a file’s history and it is set by administrators.","title":"Managing active versions"},{"location":"/clients/config/config-service.html#historyactive","text":"This API returns the history of active revisions of the file at the given path for a range of period specified by from and to. The size of the list can be restricted using maxResults.\nExample for historyActive API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst from = new Date(2019, 12, 31)\nconst to = new Date(2020, 12, 31)\n\n// upto 200 active file revisions from 31st dec 2019 - 31st dec 2020 will be fetched\nconst activeFileRevisions: ConfigFileRevision[] = await configService.historyActive(filePath,from,to, 200)","title":"historyActive"},{"location":"/clients/config/config-service.html#setactiveversion","text":"This API sets the “active version” to be the version provided for the file at the given path. If this method is never called in a config’s lifetime, the active version will always be the version returned by create function.\nExample for setActiveVersion API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst id: ConfigId = await configService.create(path,configData,false, comment)\nconst commentWhileSetting = `Making ${id} active on 1st dec 2020`\n\nawait configService.setActiveVersion(filePath,id,commentWhileSetting)","title":"setActiveVersion"},{"location":"/clients/config/config-service.html#resetactiveversion","text":"This API resets the “active version” of the file at the given path to the latest version.\nExample for resetActiveVersion API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst id: ConfigId = await configService.create(path,configData,false, comment)\nconst commentWhileResetting = `Making ${id} active version to latest as of 1st dec 2020`\n\nawait configService.resetActiveVersion(filePath,commentWhileResetting)","title":"resetActiveVersion"},{"location":"/clients/config/config-service.html#getactiveversion","text":"This API returns the revision ID which represents the “active version” of the file at the given path.\nExample for getActiveVersion API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\n\nconst maybeConfigId:Option<ConfigId> = await configService.getActiveVersion(filePath)","title":"getActiveVersion"},{"location":"/clients/config/config-service.html#getactivebytime","text":"This API returns the content of active version of the file existed at given instant of Time\nExample for getActiveByTime API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst at = new Date(2019, 12, 31)\n\nconst maybeConfigData: Option<ConfigData> = await configService.getActiveByTime(filePath, at)","title":"getActiveByTime"},{"location":"/index.html","text":"","title":"TMT JavaScript/Typescript Library"},{"location":"/index.html#tmt-javascript-typescript-library","text":"esw-ts provides following JavaScript adapters and typescript definitions for esw and csw services.","title":"TMT JavaScript/Typescript Library"},{"location":"/index.html#getting-started","text":"node is mandatory to be installed on machine for using esw-ts.\nesw-ts library is available on npm registry.\nIt is recommended to use giter8 template esw-ui-template.g8 to get started with building web application.\nesw-ts is comes pre-packaged as a dependency in the template. You can skip the installation step and make use of the services directly in the application. Jump to library features","title":"Getting Started"},{"location":"/index.html#installation","text":"To install the latest version node. visit this node’s official website.\nTo install the latest version of esw-ts from npm\nnpm install esw-ts\nTo install a specific version\nnpm install esw-ts@{version}","title":"Installation"},{"location":"/index.html#features","text":"","title":"Features"},{"location":"/index.html#aas-authentication-and-authorization-support-for-web-application-","text":"AAS Javascript Adapter (aas)","title":"AAS (Authentication and Authorization Support for web application)"},{"location":"/index.html#clients-","text":"Admin Client Agent Client Command Service Config Service Location Service Sequencer Service","title":"Clients:"},{"location":"/aas/csw-aas-js.html","text":"","title":"Javascript Adapter (csw-aas-js)"},{"location":"/aas/csw-aas-js.html#javascript-adapter-csw-aas-js-","text":"csw-aas-js is an npm package which provides React components that integrate with the CSW Authentication and Authorization Service. UI applications can use these React components to enable the application to show or hide components based on the authentication and authorization policy. csw-aas-js is written in typescript and it bundles transpiled es6 module along with type declarations.","title":"Javascript Adapter (csw-aas-js)"},{"location":"/aas/csw-aas-js.html#dependencies","text":"To use the esw-ts adapter, run this command from root folder of your application where package.json exists:\nnpm     npm i --save esw-ts@0.1.0-SNAPSHOT\n yarn     yarn add esw-ts@0.1.0-SNAPSHOT","title":"Dependencies"},{"location":"/aas/csw-aas-js.html#application-configuration","text":"Web application needs following configurations in order to get access token from keycloak server. This application specific config object should be passed in AuthContextProvider component. There are two configurations needed for a web application i.e. realm, clientId\nrealm is a mandatory configuration which specified in keycloak server under which client for your application is registered.\nclientId is a mandatory configuration which specifies the client id of the app as per registration in keycloak server.\nJavascript export const AppConfig = {\n  realm: 'TMT',\n  clientId: 'tmt-frontend-app',\n  applicationName: 'test-app'\n}","title":"Application Configuration"},{"location":"/aas/csw-aas-js.html#components","text":"esw-ts exposes the following React components.\nAuthContextProvider Consumer Login Logout CheckLogin RealmRole\nComponents can be imported as shown in code snippet below\nJavascript import { AuthContext, Logout, Login } from 'esw-ts'","title":"Components"},{"location":"/aas/csw-aas-js.html#authcontextprovider","text":"AuthContextProvider is wrapper over a React Context.Provider. A JSON configuration file must be passed in that contains the application specific AAS server configuration (e.g. clientId, realm). When a user logs in, an AAS Server is instantiated, with the UI application specific configuration overriding the predefined configuration. Once the AAS sever is instantiated, an auth object is created with the needed attributes and APIs. This auth object is available to other React components; since AuthContextProvider is a Provider, its data can be shared with any of the children React components in its tree in a Consumer component (see below). All Consumers that are descendants of a Provider will re-render whenever the AuthContextProvider’s state changes, e.g. a user authorizes. It is recommended to use AuthContextProvider to wrap the entire application so that data can be shared anywhere in application via a Consumer.\nJavascript <AuthContextProvider config={AppConfig}>\n  <BrowserRouter>\n    <div>\n      <NavComponent />\n      <Route\n        exact\n        path='/secured'\n        render={(_) => (\n          <CheckLogin error={<LoginError />}>\n            <Write />\n          </CheckLogin>\n        )}\n      />\n      <Route exact path='/config' render={(_) => <ConfigApp />} />\n      <Route\n        exact\n        path='/example_admin'\n        render={(_) => (\n          <CheckLogin error={<LoginError />}>\n            <RealmRole\n              realmRole='example-admin-role'\n              error={\n                <RoleError\n                  message={'User do not have role : example-admin-role'}\n                />\n              }>\n              <div>Example admin role specific functionality</div>\n            </RealmRole>\n          </CheckLogin>\n        )}\n      />\n      <Route\n        exact\n        path='/example_user'\n        render={(_) => (\n          <CheckLogin error={<LoginError />}>\n            <RealmRole\n              realmRole='person-role'\n              error={\n                <RoleError\n                  message={'User do not have role : person-role'}\n                />\n              }>\n              <div>Person role specific functionality</div>\n            </RealmRole>\n          </CheckLogin>\n        )}\n      />\n      <Route exact path='/public' component={Read} />\n    </div>\n  </BrowserRouter>\n</AuthContextProvider>","title":"AuthContextProvider"},{"location":"/aas/csw-aas-js.html#source-code-for-authcontextprovider-component","text":"AuthContextProvider Component","title":"Source code for AuthContextProvider component"},{"location":"/aas/csw-aas-js.html#consumer","text":"Consumer is similar to a React Context.Consumer. The shared auth object from the AuthContextProvider can be accessed using a Consumer component\nJavascript const { auth } = useContext(AuthContext)\nreturn (\n  <div className='nav-wrapper'>\n    {auth && auth.isAuthenticated() ? (\n      <div>\n        Hello, you are logged in\n        <div>Open functionality</div>\n      </div>\n    ) : (\n      <div>\n        Hello, you are not logged in\n        <div>Open functionality</div>\n      </div>\n    )}\n  </div>\n)","title":"Consumer"},{"location":"/aas/csw-aas-js.html#source-code-for-consumer-component","text":"Consumer Component","title":"Source code for Consumer component"},{"location":"/aas/csw-aas-js.html#login","text":"The Login component instantiates an AAS server with the configurations provided. It redirects to an AAS server login page for the user to login. After login, the auth object in the context is updated with the appropriate values, e.g. token, realm etc.\nJavascript <Login />","title":"Login"},{"location":"/aas/csw-aas-js.html#source-code-for-login-component","text":"Login Component","title":"Source code for Login component"},{"location":"/aas/csw-aas-js.html#logout","text":"The Logout component logs out the user from the AAS server. It clears the auth object stored in the context.\nJavascript   <Logout />\n) : (","title":"Logout"},{"location":"/aas/csw-aas-js.html#source-code-for-logout-component","text":"Logout Component","title":"Source code for Logout component"},{"location":"/aas/csw-aas-js.html#checklogin","text":"CheckLogin components provide ability to show something only if the user is logged in. In the following code snippet, Write is a react component that is shown only if the user is logged in. The behavior if the user is not logged in can be defined by an HTML element or React component that is passed into the component as an error property, shown as an ExampleError Component in following snippet.\nJavascript <CheckLogin error={<LoginError />}>\n  <Write />\n</CheckLogin>","title":"CheckLogin"},{"location":"/aas/csw-aas-js.html#source-code-for-checklogin-component","text":"CheckLogin Component","title":"Source code for CheckLogin component"},{"location":"/aas/csw-aas-js.html#realmrole","text":"RealmRole components provide the ability to show something only if the user is logged in and has the specified realm role. In the following code snippet, the contents of the div block are shown only if the user is logged in and has the realm role specified in the realmRole prop. Similar to CheckLogin, the behaviour if the user is not logged in can be optionally defined by an HTML element or React component that is passed into the component as an error property, shown as an ExampleError Component in following snippet.\nJavascript <RealmRole\n  realmRole='example-admin-role'\n  error={\n    <RoleError\n      message={'User do not have role : example-admin-role'}\n    />\n  }>\n  <div>Example admin role specific functionality</div>\n</RealmRole>","title":"RealmRole"},{"location":"/aas/csw-aas-js.html#source-code-for-realmrole-component","text":"RealmRole Component","title":"Source code for RealmRole component"},{"location":"/aas/csw-aas-js.html#technical-description","text":"See csw-aas-js Technical Description.","title":"Technical Description"},{"location":"/clients/admin/admin-service.html","text":"","title":"Admin Service"},{"location":"/clients/admin/admin-service.html#admin-service","text":"This service provides a handle to admin related APIs which includes logging related APIs\nAdmin service has following APIs:\nAPI Input args Returns getLogMetadata componentId LogMetadata setLogLevel componentId, level Done","title":"Admin Service"},{"location":"/clients/admin/admin-service.html#creation-of-admin-service","text":"","title":"Creation of Admin Service"},{"location":"/clients/admin/admin-service.html#to-create-admin-client-","text":"Typescript const adminService: AdminService = await AdminService()","title":"To create Admin client:"},{"location":"/clients/admin/admin-service.html#apis","text":"","title":"APIs"},{"location":"/clients/admin/admin-service.html#getlogmetadata","text":"This API gives basic logging configuration values for specific component.\nThe following example shows how to call getLogMetadata API :\nTypescript const prefix = new Prefix('TCS', 'filter.wheel')\nconst componentId = new ComponentId(prefix, 'HCD')\nconst logMetaData: LogMetadata = await adminService.getLogMetadata(componentId)","title":"getLogMetadata"},{"location":"/clients/admin/admin-service.html#setloglevel","text":"This API allows setting log level of specific component.\nThe following example shows how to call setLogLevel API :\nTypescript const actionStatus: Done = await adminService.setLogLevel(componentId, 'WARN')","title":"setLogLevel"},{"location":"/clients/command/command-service.html","text":"","title":"Command Service"},{"location":"/clients/command/command-service.html#command-service","text":"This client side service provides a handle to send commands to a component which is registered in location service.\nCommand service has following APIs:\nAPI Input args Returns validate ControlCommand ValidateResponse submit ControlCommand SubmitResponse oneway ControlCommand OnewayResponse query runId SubmitResponse queryFinal runId, timeoutInSeconds SubmitResponse subscribeCurrentState stateNames, onStateChangeCallback Subscription submitAndWait ControlCommand, timeoutInSeconds SubmitResponse submitAllAndWait ControlCommand [ ], timeoutInSeconds SubmitResponse[ ]","title":"Command Service"},{"location":"/clients/command/command-service.html#creation-of-command-service","text":"","title":"Creation of Command Service"},{"location":"/clients/command/command-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/clients/command/command-service.html#in-order-to-use-command-service-for-a-specific-component-","text":"The component needs to be up and running behind the gateway server. GatewayException(InvalidComponent) will be thrown if the specified component is not found. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.\nFor the given example : Prefix(ESW.Component1) needs to be registered in the location service as any of the component type (HCD, Assembly, etc.).","title":"In order to use command service for a specific component:"},{"location":"/clients/command/command-service.html#to-create-command-service-client-for-a-component","text":"Typescript const tokenFactory = () => auth.token\n\nconst commandService: CommandService = await CommandService(\n  new ComponentId(new Prefix('ESW', 'Component1'), 'HCD'),\n  tokenFactory\n)","title":"To create Command service client for a component"},{"location":"/clients/command/command-service.html#control-commands","text":"In order to call following API, one of the control command needs to be sent. Depending on your use case, you will be sending either Setup or Observe Command.\nFollowing examples show how to create control commands:\nTypescript // Definition of control command looks like following\ntype ControlCommand = Setup | Observe\n\n// examples\nconst setupCommand: Setup = new Setup(\n  new Prefix('ESW', 'Component1'),\n  'move-command',\n  paramSet,\n  'obs-id'\n)\n\nconst observeCommand: Observe = new Observe(\n  new Prefix('ESW', 'Component1'),\n  'c1',\n  paramSet,\n  'obs-id'\n)","title":"Control Commands"},{"location":"/clients/command/command-service.html#apis","text":"Async-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"APIs"},{"location":"/clients/command/command-service.html#validate","text":"This API takes Control command as input parameter and return a promise of ValidateResponse.\nThe following example shows how to call validate API :\nTypescript const validateResponse1: ValidateResponse = await commandService.validate(\n  setupCommand\n)\n// or\nconst validateResponse2: ValidateResponse = await commandService.validate(\n  observeCommand\n)","title":"Validate"},{"location":"/clients/command/command-service.html#submit","text":"This API takes Control command as input parameter and return a promise of SubmitResponse.\nThe following example shows how to call submit API :\nTypescript const submitResponse1: SubmitResponse = await commandService.submit(\n  setupCommand\n)\n// or\nconst submitResponse2: SubmitResponse = await commandService.submit(\n  observeCommand\n)","title":"Submit"},{"location":"/clients/command/command-service.html#oneway","text":"This API takes Control command as input parameter and return a promise of OnewayResponse.\nThe following example shows how to call oneway API :\nTypescript const onewayResponse1: OnewayResponse = await commandService.oneway(\n  setupCommand\n)\n// or\nconst onewayResponse2: OnewayResponse = await commandService.oneway(\n  observeCommand\n)","title":"Oneway"},{"location":"/clients/command/command-service.html#query","text":"This API takes runId of already submitted command as input parameter and return a promise of SubmitResponse.\nThe following example shows how to call query API :\nTypescript // Submit a long running command\nconst res: SubmitResponse = await commandService.submit(setupCommand)\n// .\n// .\n// .\n// Get the current result of long running command as :\nconst queryResponse: SubmitResponse = await commandService.query(res.runId)","title":"Query"},{"location":"/clients/command/command-service.html#queryfinal","text":"This API is same as query , only difference is takes time-out (seconds) along with runId of already submitted command as input parameter and return a promise of SubmitResponse.\nThe following example shows how to call query final API :\nTypescript // Submit a long running command\nconst result: SubmitResponse = await commandService.submit(setupCommand)\n// .\n// .\n// .\n// Get the final result of long running command within 10 seconds :\nconst queryFinalResponse: SubmitResponse = await commandService.queryFinal(\n  result.runId,\n  10\n)","title":"QueryFinal"},{"location":"/clients/command/command-service.html#subscribecurrentstate","text":"This API takes set of current states to be subscribed along with a callback which will get triggered on change of the mentioned states.(stateName1,stateName2)\nThe following example shows how subscribeCurrentState API call would look like :\nTypescript // subscribe to this set of current states\nconst currentStates = new Set(['stateName1', 'stateName2'])\n\n// this callback gets called whenever the state changes\nconst onStateChangeCallback = (currentState: CurrentState) => {\n  // do something when state changes\n  console.log('changed state:', currentState)\n}\n\n// subscribe call\nconst subscription: Subscription = await commandService.subscribeCurrentState(\n  currentStates\n)(onStateChangeCallback)\n\n// .\n// .\n// .\n// subscription can be cancelled when it is not required any more\nsubscription.cancel()","title":"SubscribeCurrentState"},{"location":"/clients/command/command-service.html#submitandwait","text":"This API takes Control command as input parameter along with time-out(seconds) and return a promise of SubmitResponse after waiting for a specified amount of time.\nThe following example shows how submitAndWait API call would look like :\nTypescript // Submit a long running command and wait for the result for specific time\n\nconst submitAndWaitResponse: SubmitResponse = await commandService.submitAndWait(\n  setupCommand,\n  10\n)","title":"SubmitAndWait"},{"location":"/clients/command/command-service.html#submitallandwait","text":"This API takes multiple control commands as input parameter along with time-out(seconds) and return a promise of SubmitResponse[] after waiting for a specified amount of time.\nThe following example shows how submitAllAndWait API call would look like :\nTypescript // Submit multiple commands and wait for the result of each submitted command for specific time\n\nconst submitAllAndWaitResponse: SubmitResponse[] = await commandService.submitAllAndWait(\n  [setupCommand, observeCommand],\n  10\n)","title":"SubmitAllAndWait"},{"location":"/clients/command/command-service.html#error-handling","text":"Reference","title":"Error Handling"},{"location":"/technical/csw-aas-js.html","text":"","title":"csw-aas-js - Javascript adapter"},{"location":"/technical/csw-aas-js.html#csw-aas-js-javascript-adapter","text":"csw-aas-js is a npm package which exposes react components to enable authentication and authorization. csw-aas-js is built in typescript on top of keycloak-js which is javascript adapter provided by keycloak.","title":"csw-aas-js - Javascript adapter"},{"location":"/technical/csw-aas-js.html#csw-aas-js-implementation","text":"Core implementation of csw-aas-js uses\nkeycloak-js - keycloak javascript adapter React - JavaScript library for building user interfaces Typescript - Types superset of JavaScript which compiles to JavaScript csw-location-service - resolve keycloak using location service http endpoint","title":"csw-aas-js Implementation"},{"location":"/technical/csw-aas-js.html#project-setup","text":"csw-aas-js is a library written in Typescript. tsc is a command line compiler of Typescript which compiles typescrit files to JavaScript. tsc picks up configurations from tsconfig.json file which is at root level of project. tsconfig.json allows to configure multiple compiler options. Please refer this for details of compiler options. npm run build command will run tsc which will produce outputs (.js and .d.ts). .d.ts files are the type declaration files which provide typings for react components exported by library. package.json points to index.ts as a entry point for library and index.d.ts as types. This will help csw-aas-js library users to know type signatures of components. e.g. type signature for react component props, api signatures. csw-aas-js can be seamlessly consumed by applications written ES6 or Typescript.","title":"Project setup"},{"location":"/technical/csw-aas-js.html#keycloak","text":"In order for web application utilize keycloak following steps are needed:\nRegistered web application as a public keycloak client Please refer to keycloak documentation for details. Create new Keycloak client instance This instantiation expects config which includes keycloak server url and some application specific config like realm and clientId. csw-aas-js uses csw location service to resolve keycloak server.\nJavascript export const AppConfig = {\n  realm: 'TMT',\n  clientId: 'tmt-frontend-app',\n  applicationName: 'test-app'\n}\nInitialize javascript adapter To call secure end point, web application first needs to be authenticated using keycloak server. There are two options to make this adapter automatically authenticate - login-required and check-sso. login-required will automatically authenticate if the user is already logged-in, otherwise it will display keycloak login page. check-sso will only authenticate if the user is already logged-in. If the user is not logged-in the browser will be redirected back to the application and remain unauthenticated.\ncsw-aas-js use check-sso to instantiate keycloak. It shows secure components if user is already logged in. If user is not authenticated Login component is rendered. If user clicks on login button it instantiates keyclock use login-required. This redirects user to keycloak login page. As access token has very short life span, at time of keycloak instantiation csw-aas-js also adds hooks to refresh token. This gives seamless user experience as user need not to login again.\nKeycloak adapter supports three authorization flows e.g. authorization code flow, implicit flow and hybrid flow. csw-aas-js has chosen hybrid flow as it has better performance than authorization code flow and unlike implicit flow, hybrid flow makes refresh token available to application. For more information please refer keyclok documentaion for authorization flows","title":"Keycloak"},{"location":"/technical/csw-aas-js.html#working-of-csw-aas-js","text":"When user opens web application in browser, AuthContextProvider component is mounted. Which does instantiation of keycloak client and initialize keycloak javascript adapter with check-sso and hybrid authorization flow. It also creates hooks for refreshing token when token is expired which silently refresh token resulting seamless user experience once logged in. After authentication is done via keycloak javascript adapter, AuthContext is extracted in domain model and this data is passed down the component tree using react context api. AuthContext gives handle to token, realm and resource roles, userInfo. Any component which want to use this information can become consumer of AuthContext. For example\nJavascript const { auth } = useContext(authContext)\nAccess token can be extracted from auth and it can be sent in Authorization header for calling secure api\nFor example -\nconst SampleComponent = () => {\n\n    const url = 'http://localhost:8080/secure-restful-service';\n    const auth = useContext(AuthContext) //AuthContext from csw-aas-js\n\n    const req = new XMLHttpRequest();\n    req.open('GET', url, true);\n    req.setRequestHeader('Accept', 'application/json');\n\n    //extract token from auth context and set Authorization header\n    req.setRequestHeader('Authorization', 'Bearer ' + auth.token);\n\n    req.onreadystatechange = function () {\n        if (req.readyState == 4) {\n            if (req.status == 200) {\n                alert('Success');\n            } else if (req.status == 403) {\n                alert('Forbidden');\n            }\n        }\n    }\n\n    req.send();\n};\nFollowing diagram explains javascript application flow for making request to secure http api\nWhen user opens web application in browser, csw-aas-js checks if user is already logged in using check-sso mode. If user is not logged in then Login button is shown. When user clicks on login, user will be redirected to keyclok login page. This completes authentication process. Once authentication is done, AuthContextProvider extract AuthContext domain model and make it available to consumers of AuthContext. Protected react components can be shown based on information in AuthContext. For example, CreateConfig component can be shown only to users having config admin role. After the user is authenticated the application can make requests to RESTful services secured by Keycloak by including the bearer token in the Authorization header. This completed workflow for web application calling secure http endpoint.","title":"Working of csw-aas-js"},{"location":"/common/error-handling.html","text":"","title":"Error Handling"},{"location":"/common/error-handling.html#error-handling","text":"// various examples showing how to handle generic error","title":"Error Handling"}]}