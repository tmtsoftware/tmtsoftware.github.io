{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"TMT JavaScript/Typescript Library"},{"location":"/index.html#tmt-javascript-typescript-library","text":"","title":"TMT JavaScript/Typescript Library"},{"location":"/common/getting-started.html","text":"","title":"Getting Started"},{"location":"/common/getting-started.html#getting-started","text":"node is mandatory to be installed on machine for using esw-ts.\nesw-ts library is available on npm registry.\nIt is recommended to use giter8 template esw-ui-template.g8 to get started with building web application.\nesw-ts comes pre-packaged as a dependency in the template. You can skip the installation step and make use of the services directly in the application. Jump to library features","title":"Getting Started"},{"location":"/common/getting-started.html#installation","text":"To install the latest version node. visit this node’s official website.\nTo install the latest version of esw-ts from npm\nnpm install @tmtsoftware/esw-ts\nTo install a specific version\nnpm install @tmtsoftware/esw-ts@{version}","title":"Installation"},{"location":"/common/getting-started.html#features","text":"AAS Services Params Type definations","title":"Features"},{"location":"/services/index.html","text":"","title":"Services"},{"location":"/services/index.html#services","text":"These are javascript adapters for each of public facing TMT services. They provide a handle to interact with backend server while adhering to the service contract.\nTMT Services are behind ESW Gateway Server except Location and Config Server.\nFollow the instructions in the first step of our quickstart guide to integrate one or more services in the UI application.\nThese are following services available:\nAdmin Service Alarm Service Command Service Config Service Event Service Location Service Logging Service Sequencer Service\nType definition for all services can be found here\nAdmin Service : This service provides a handle to admin related APIs which includes logging related APIs Agent Service : The Agent Service is used to spawn a component of machine or kill a running component. To do so, it uses the agent running on that specific machine where component is to be spawned or killed. Command Service : This client side service provides a handle to send commands to a component which is registered in location service. Config Service : The Config Service wraps the low level communication with Configuration Service Server and exposes simple to use methods to access and manage configuration files. Event Service : The Event Service enables users to publish events and subscribe to events which are published by underlying TMT components. Location Service : The Location Service provides access to location information of various components which are currently running the TMT cluster. Sequencer Service : This service provides a handle to send commands to a sequencer which is registered in location service. Sequence Manager Service : The Sequence Manager Service manages all the operation related to the observations. It manages all sequence components and sequencers required for the observations.","title":"Services"},{"location":"/services/admin/admin-service.html","text":"","title":"Admin Service"},{"location":"/services/admin/admin-service.html#admin-service","text":"This service provides a handle to admin related APIs which currently has logging related APIs.","title":"Admin Service"},{"location":"/services/admin/admin-service.html#creation-of-admin-service","text":"","title":"Creation of Admin Service"},{"location":"/services/admin/admin-service.html#to-create-admin-client-","text":"Typescript const adminService: AdminService = await AdminService()","title":"To create Admin client:"},{"location":"/services/admin/admin-service.html#usages-of-admin-service","text":"Type definitions for All Admin Service APIs can be found here","title":"Usages of Admin Service"},{"location":"/services/admin/admin-service.html#fetching-logmetadata","text":"There is logging configuration set for all registered components within the TMT cluster. this API gives basic logging configuration values for specific component.\nTypescript const prefix = new Prefix('TCS', 'filter.wheel')\nconst componentId = new ComponentId(prefix, 'HCD')\nconst logMetaData: LogMetadata = await adminService.getLogMetadata(componentId)","title":"Fetching LogMetadata"},{"location":"/services/admin/admin-service.html#setting-loglevel-of-a-component","text":"This API allows setting log level of specific component.\nTypescript const actionStatus: Done = await adminService.setLogLevel(componentId, 'WARN')","title":"Setting LogLevel of a component"},{"location":"/services/alarm/alarm-service.html","text":"","title":"Alarm Service"},{"location":"/services/alarm/alarm-service.html#alarm-service","text":"This service provide a http interface to interact with alarm server.","title":"Alarm Service"},{"location":"/services/alarm/alarm-service.html#creation-of-alarm-service","text":"","title":"Creation of Alarm Service"},{"location":"/services/alarm/alarm-service.html#pre-requisite","text":"In order to use Logging Service APIs:\nThe Location Service, and Gateway Server needs to be running in the network","title":"Pre-requisite"},{"location":"/services/alarm/alarm-service.html#to-create-alarm-service","text":"Typescript const alarmService = await AlarmService()\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"To create Alarm Service"},{"location":"/services/alarm/alarm-service.html#usages-of-alarm-service","text":"","title":"Usages of Alarm Service"},{"location":"/services/alarm/alarm-service.html#setting-alarm-severity","text":"Alarm service allows you to update the severity of alarms belonging to components.\nType Definitions of setSeverity API can be found here\nTypescript let alarmKey = new AlarmKey(new Prefix('ESW', 'assemblyComponent'), 'temperature');\nconst response: Done = await alarmService.setSeverity(alarmKey, 'Critical')","title":"Setting alarm Severity"},{"location":"/services/command/command-service.html","text":"","title":"Command Service"},{"location":"/services/command/command-service.html#command-service","text":"Command Service provides a handle to send commands to a component which is registered in location service.","title":"Command Service"},{"location":"/services/command/command-service.html#creation-of-command-service","text":"","title":"Creation of Command Service"},{"location":"/services/command/command-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/services/command/command-service.html#in-order-to-use-command-service-for-a-specific-component-","text":"The component needs to be up and running behind the gateway server. GatewayException(InvalidComponent) will be thrown if the specified component is not found. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.\nFor the given example : Prefix(ESW.Component1) needs to be registered in the location service as any of the component type (HCD, Assembly, etc.).","title":"In order to use command service for a specific component:"},{"location":"/services/command/command-service.html#to-create-command-service-client-for-a-component","text":"Typescript const tokenFactory = () => auth.token\n\nconst commandService: CommandService = await CommandService(\n  new ComponentId(new Prefix('ESW', 'Component1'), 'HCD'),\n  tokenFactory\n)","title":"To create Command service client for a component"},{"location":"/services/command/command-service.html#type-of-actions","text":"Whenever a command gets submitted to a component, it results into in either Immediate completion or Long Running action.","title":"Type of Actions"},{"location":"/services/command/command-service.html#immediate-completion","text":"If the actions of the submit or submitAndWait command take a very short time to complete, it is referred as Immediate completion. the actions are successful, if the Completed SubmitResponse is returned. If there is a result, the Completed is returned with a parameter set of Result type that can be inspected by the caller.","title":"Immediate completion"},{"location":"/services/command/command-service.html#long-running-actions","text":"When actions take longer than 1 second and the Component returns the Started SubmitResponse. The Started response indicates to the framework that long-running actions have been started.","title":"Long running Actions"},{"location":"/services/command/command-service.html#control-commands","text":"In order to call following API, one of the control command needs to be sent. Depending on your use case, you will be sending either Setup or Observe Command.\nFollowing examples show how to create control commands:\nTypescript // Definition of control command looks like following\ntype ControlCommand = Setup | Observe\n\n// examples\nconst setupCommand: Setup = new Setup(\n  new Prefix('ESW', 'Component1'),\n  'move-command',\n  paramSet,\n  'obs-id'\n)\n\nconst observeCommand: Observe = new Observe(\n  new Prefix('ESW', 'Component1'),\n  'c1',\n  paramSet,\n  'obs-id'\n)\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"Control Commands"},{"location":"/services/command/command-service.html#usages-of-command-service","text":"Type definitions of all Command Service APIs can be found here","title":"Usages of Command Service"},{"location":"/services/command/command-service.html#validating-command","text":"A validate message is used to ask a destination component to validate a command and determine if the command can be executed. It does not execute the command and only returns the result of validation. In some scenarios, it may be useful to test to see if a command can be executed prior to trying to execute the command.\nTypescript const validateResponse1: ValidateResponse = await commandService.validate(\n  setupCommand\n)\n// or\nconst validateResponse2: ValidateResponse = await commandService.validate(\n  observeCommand\n)","title":"Validating Command"},{"location":"/services/command/command-service.html#submitting-a-command","text":"A submit message can be used when the sender of a command needs to do additional work before long-running actions are completed. For instance, send another command to execute in parallel. If commands are short, submit and submitAndWait behave the same way. When the actions started by submit are long-running, the caller can wait for the actions to complete if needed using the queryFinal call.\nTypescript const submitResponse1: SubmitResponse = await commandService.submit(\n  setupCommand\n)\n// or\nconst submitResponse2: SubmitResponse = await commandService.submit(\n  observeCommand\n)","title":"Submitting a Command"},{"location":"/services/command/command-service.html#submitandwait","text":"This is a convenience method which sends a submit message and then, if the command is long-running, it waits for final completion. Sending a submit message with a command returns a SubmitResponse as a Future.\nTypescript // Submit a long running command and wait for the result for specific time\n\nconst submitAndWaitResponse: SubmitResponse = await commandService.submitAndWait(\n  setupCommand,\n  10\n)","title":"SubmitAndWait"},{"location":"/services/command/command-service.html#submitallandwait","text":"Similar to SubmitAndWait, submitAllAndWait can be used to send multiple commands sequentially to the same component. This could be used to send initialization commands to an HCD, for instance. The argument for submitAllAndWait is a list of commands. submitAllAndWait returns a list of SubmitResponses – one for each command in the list.\nTypescript // Submit multiple commands and wait for the result of each submitted command for specific time\n\nconst submitAllAndWaitResponse: SubmitResponse[] = await commandService.submitAllAndWait(\n  [setupCommand, observeCommand],\n  10\n)","title":"SubmitAllAndWait"},{"location":"/services/command/command-service.html#oneway","text":"Oneway is useful when Command Service needs to send commands to an HCD as quickly as possible. The command is validated on the destination and the validation response is returned, but no other responses are provided.\nTypescript const onewayResponse1: OnewayResponse = await commandService.oneway(\n  setupCommand\n)\n// or\nconst onewayResponse2: OnewayResponse = await commandService.oneway(\n  observeCommand\n)","title":"Oneway"},{"location":"/services/command/command-service.html#query","text":"If a submitted command returns a Started response indicating it has long-running actions, and the caller needs to determine that the actions have started properly, or wishes to poll the destination component for the final response, the query method of CommandService can be used.\nTypescript // Submit a long running command\nconst res: SubmitResponse = await commandService.submit(setupCommand)\n// .\n// .\n// .\n// Get the current result of long running command as :\nconst queryResponse: SubmitResponse = await commandService.query(res.runId)","title":"Query"},{"location":"/services/command/command-service.html#queryfinal","text":"Like query, queryFinal uses the Id returned by Started. But in this case, rather than returning immediately like query, it waits and only returns when the final SubmitResponse is sent. queryFinal is used exclusively with submit in the case where some other activity must be done before the actions started by the submit complete.\nTypescript // Submit a long running command\nconst result: SubmitResponse = await commandService.submit(setupCommand)\n// .\n// .\n// .\n// Get the final result of long running command within 10 seconds :\nconst queryFinalResponse: SubmitResponse = await commandService.queryFinal(\n  result.runId,\n  10\n)","title":"QueryFinal"},{"location":"/services/command/command-service.html#subscribecurrentstate","text":"This method can be used to subscribe to the CurrentState of a component by providing a callback that is called with the arrival of every CurrentState item.\nTypescript // subscribe to this set of current states\nconst currentStates = new Set(['stateName1', 'stateName2'])\n\n// this callback gets called whenever the state changes\nconst onStateChangeCallback = (currentState: CurrentState) => {\n  // do something when state changes\n  console.log('changed state:', currentState)\n}\n\n// subscribe call\nconst subscription: Subscription = await commandService.subscribeCurrentState(\n  currentStates\n)(onStateChangeCallback)\n\n// .\n// .\n// .\n// subscription can be cancelled when it is not required any more\nsubscription.cancel()","title":"SubscribeCurrentState"},{"location":"/services/config/config-service.html","text":"","title":"Config Service"},{"location":"/services/config/config-service.html#config-service","text":"The Configuration Service provides a centralized persistent store for any configuration file used in the TMT Software System. All versions of configuration files are retained, providing a historical record of each configuration file. This client exposes simple methods to access and manage configuration files.\nConfig service has following APIs:\nAPI Input args Returns create path, configData, annex, comment ConfigId update path, configData, comment ConfigId getActive path Option< ConfigData > getLatest path Option< ConfigData > getById path, configId Option< ConfigData > getByTime path, time Option< ConfigData > exists path, id boolean delete path, comment void list fileType, pattern ConfigFileInfo[ ] history path, from, to, maxResults ConfigFileRevision[ ] historyActive path, from, to, maxResults ConfigFileRevision[ ] setActiveVersion path, id, comment void resetActiveVersion path, comment void getActiveByTime path, time Option< ConfigData > getActiveVersion path Option< ConfigId > getMetadata ConfigMetadata","title":"Config Service"},{"location":"/services/config/config-service.html#rules-and-checks","text":"The config file path must not contain !#<>$%&’@^``~+,;= or any whitespace character If the input file is > 10MB or has lot of non ASCII characters, then for optimization, server will archive it in annex store. Large and binary files can be forced to go to the ‘annex’ store by using a annex=true flag in the create operation.","title":"Rules and Checks"},{"location":"/services/config/config-service.html#model-classes","text":"ConfigData : Represents the contents of the files being managed. It wraps blob object. ConfigFileInfo : Represents information about a config file stored in the Config Service. ConfigFileRevision : Represents information about a specific version of a config file. ConfigId : Represents an identifier associated with a revision of a configuration file, often generated by create or update methods. ConfigMetadata : Represents metadata information about the Config Server. FileType : Represents the type of storage for a configuration file. Currently two types are supported Normal(small, text files) and Annex(Large, Binary files).","title":"Model Classes"},{"location":"/services/config/config-service.html#example-for-creation-configdata-and-accessing-data-with-helper-function","text":"Typescript const dataArray = ['file-contents']\n\nconst configDataFromBlob: ConfigData = ConfigData.from(new Blob(dataArray))\nconst configDataFromFile: ConfigData = ConfigData.fromFile(\n  new File(dataArray, 'filename')\n)\nconst configDataFromString: ConfigData = ConfigData.fromString(\n  'someFileDataAsString'\n)\n\n//accessing data\nconst dataAsBlobContent: Blob = configDataFromString.toBlob()\n\n// notice use of async-await here. because this is an IO read call\nconst readData = async (configData: ConfigData) => {\n  const dataAsString: string = await configData.fileContentAsString()\n}\nNote: Models other than ConfigData are simple typescript classes and do not have special helper methods unlike ConfigData.","title":"Example for creation ConfigData and accessing data with helper function"},{"location":"/services/config/config-service.html#creation-of-config-service","text":"","title":"Creation of Config Service"},{"location":"/services/config/config-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/services/config/config-service.html#in-order-to-use-config-service-","text":"The Location Service and Configuration Service Server needs to be running in the network The necessary configuration, environment variables or system properties should be defined to point to the correct host and port number(s) for the Location Service nodes. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"In order to use config service:"},{"location":"/services/config/config-service.html#examples-to-create-client-for-config-service","text":"Config service constructor takes TokenFactory as input argument.\nTypescript const tokenFactory = () => auth.token\n\nconst configService: ConfigService = await ConfigService(tokenFactory)","title":"Examples to create client for Config service"},{"location":"/services/config/config-service.html#apis","text":"Async-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"APIs"},{"location":"/services/config/config-service.html#create","text":"This API takes path at which configData needs to be saved in the config service along with meta information i.e whether to be saved as annex or normal file and comment. After saving, it returns ConfigId which can be used to access the saved file in future using query APIs.\nExample for create API looks like following:\nTypescript const path = 'esw/sequencer/obsMode.conf'\nconst comment = 'observation configuration on 21st november 2020'\nconst author = 'OCS-Sequencer admin: Dave'\nconst data = `\nesw-sm {\n  obsModes: {\n    IRIS_Darknight: {\n      resources: [IRIS, TCS, NFIRAOS]\n      sequencers: [IRIS, ESW, TCS]\n    },\n    IRIS_Cal: {\n      resources: [IRIS, NSCU, NFIRAOS]\n      sequencers: [IRIS, ESW, AOESW]\n    },\n    WFOS_Cal: {\n      resources: [WFOS]\n      sequencers: [WFOS, ESW]\n    }\n  }\n}\n`\nconst configData = ConfigData.fromString(data)\n\nconst sequencerConfigId: ConfigId = await configService.create(\n  path,\n  configData,\n  false,\n  comment\n)","title":"create"},{"location":"/services/config/config-service.html#update","text":"This API takes path at which configData needs to be updated in the config service along with comment. After updating, it returns ConfigId which can be used to access the updated file in future using query APIs.\nExample for update API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst commentOnUpdate = 'observation configuration on 23rd november 2020'\nconst updatedData = `\nesw-sm {\n  obsModes: {\n    IRIS_Darknight: {\n      resources: [IRIS]\n      sequencers: [IRIS]\n    },\n    IRIS_Cal: {\n      resources: [IRIS, NSCU, NFIRAOS]\n      sequencers: [IRIS, ESW, AOESW]\n    }\n  }\n}\n`\nconst updatedConfigData = ConfigData.fromString(updatedData)\n\nconst newSequencerConfigId: ConfigId = await configService.update(\n  filePath,\n  updatedConfigData,\n  commentOnUpdate\n)","title":"update"},{"location":"/services/config/config-service.html#getactive","text":"This API takes path from which the active configData needs to be fetched and it returns Option of ConfigData.\nExample for getActive API looks like following:\nTypescript const file = 'esw/sequencer/obsMode.conf'\n\nconst maybeActiveConfigData: Option<ConfigData> = await configService.getActive(\n  file\n)","title":"getActive"},{"location":"/services/config/config-service.html#getlatest","text":"This API takes path from which the latest configData needs to be fetched and it returns Option of ConfigData.\nExample for getLatest API looks like following:\nTypescript const filepath = 'esw/sequencer/obsMode.conf'\nconst maybeLatestConfigData: Option<ConfigData> = await configService.getLatest(\n  filepath\n)","title":"getLatest"},{"location":"/services/config/config-service.html#getbyid","text":"This API takes path and previously created/updated configuration’s configId to be fetched and it returns Option of ConfigData.\nExample for getById API looks like following:\nTypescript const configId: ConfigId = await configService.update(\n  filePath,\n  updatedConfigData,\n  commentOnUpdate\n)\n\nconst maybeConfigData: Option<ConfigData> = await configService.getById(\n  filepath,\n  configId\n)","title":"getById"},{"location":"/services/config/config-service.html#getbytime","text":"This API gets the file at the given path as it existed at a given time-instance. Note: -If time-instance is before the file was created, the initial version is returned. -If time-instance is after the last change, the most recent version is returned.\nExample for getByTime API looks like following:\nTypescript const configId1: ConfigId = await configService.create(\n  filePath,\n  updatedConfigData,\n  false,\n  commentOnUpdate\n)\n\nconst beforeUpdate = new Date()\n\nconst configId2: ConfigId = await configService.update(\n  filePath,\n  configData,\n  commentOnUpdate\n)\nconst afterUpdate = new Date()\n\nconst maybeConfigData: Option<ConfigData> = await configService.getByTime(\n  filepath,\n  beforeUpdate\n)\n// maybeConfigData == updatedConfigData (i.e Initial revision of config)\n\nconst newlyUpdatedData: Option<ConfigData> = await configService.getByTime(\n  filepath,\n  afterUpdate\n)\n// newlyUpdatedData == configData (i.e Latest revision of config)","title":"getByTime"},{"location":"/services/config/config-service.html#exists","text":"This API checks whether file exists at the given path and optional specific configId in the repository or not it returns the promise of boolean\nExample for exists API looks like following:\nTypescript const exists: boolean = await configService.exists(filePath)\n\nconst exist: boolean = await configService.exists(filePath, configId)","title":"exists"},{"location":"/services/config/config-service.html#delete","text":"This API deletes a file located at specified path in the repository.\nExample for exists API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\n\nawait configService.delete(filePath, 'deleting the invalid config entry')","title":"delete"},{"location":"/services/config/config-service.html#list","text":"This API list all the files for a given FileType (Annex or Normal) and an optional pattern string, it will list all files whose path matches the given pattern.\nSome pattern examples are: “/path/hcd/*.*”, “a/b/c/d.*”, “.*.conf”, “.*hcd.*”\nExample for list API looks like following:\nTypescript const allAnnexFilesInfo: ConfigFileInfo[] = await configService.list('Annex')\nconst allNormalFilesInfo: ConfigFileInfo[] = await configService.list('Normal')\nconst allHcdAnnexFilesInfo: ConfigFileInfo[] = await configService.list(\n  'Annex',\n  '.*hcd.*'\n)\nconst allConfNormalFilesInfo: ConfigFileInfo[] = await configService.list(\n  'Normal',\n  '.*conf'\n)","title":"list"},{"location":"/services/config/config-service.html#history","text":"This API returns the history of revisions of the file at the given path for a range of period specified by from and to.\nThe size of the list can be restricted using maxResults.\nExample for history API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst from = new Date(2019, 12, 31)\nconst to = new Date(2020, 12, 31)\n\n// upto 200 file revisions from 31st dec 2019 - 31st dec 2020 will be fetched\nconst fileRevisions: ConfigFileRevision[] = await configService.history(\n  filePath,\n  from,\n  to,\n  200\n)","title":"history"},{"location":"/services/config/config-service.html#getmetadata","text":"This API used to get metadata information about the Config Service. It includes:\nrepository directory annex directory min annex file size max config file size\nExample for getMetadata API looks like following:\nTypescript const metadata: ConfigMetadata = await configService.getMetadata()","title":"getMetadata"},{"location":"/services/config/config-service.html#managing-active-versions","text":"In its lifetime, a config file undergoes many revisions. An active version is a specific revision from a file’s history and it is set by administrators.","title":"Managing active versions"},{"location":"/services/config/config-service.html#historyactive","text":"This API returns the history of active revisions of the file at the given path for a range of period specified by from and to. The size of the list can be restricted using maxResults.\nExample for historyActive API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst from = new Date(2019, 12, 31)\nconst to = new Date(2020, 12, 31)\n\n// upto 200 active file revisions from 31st dec 2019 - 31st dec 2020 will be fetched\nconst activeFileRevisions: ConfigFileRevision[] = await configService.historyActive(\n  filePath,\n  from,\n  to,\n  200\n)","title":"historyActive"},{"location":"/services/config/config-service.html#setactiveversion","text":"This API sets the “active version” to be the version provided for the file at the given path. If this method is never called in a config’s lifetime, the active version will always be the version returned by create function.\nExample for setActiveVersion API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst id: ConfigId = await configService.create(\n  path,\n  configData,\n  false,\n  comment\n)\nconst commentWhileSetting = `Making ${id} active on 1st dec 2020`\n\nawait configService.setActiveVersion(filePath, id, commentWhileSetting)","title":"setActiveVersion"},{"location":"/services/config/config-service.html#resetactiveversion","text":"This API resets the “active version” of the file at the given path to the latest version.\nExample for resetActiveVersion API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst id: ConfigId = await configService.create(\n  path,\n  configData,\n  false,\n  comment\n)\nconst commentWhileResetting = `Making ${id} active version to latest as of 1st dec 2020`\n\nawait configService.resetActiveVersion(filePath, commentWhileResetting)","title":"resetActiveVersion"},{"location":"/services/config/config-service.html#getactiveversion","text":"This API returns the revision ID which represents the “active version” of the file at the given path.\nExample for getActiveVersion API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\n\nconst maybeConfigId: Option<ConfigId> = await configService.getActiveVersion(\n  filePath\n)","title":"getActiveVersion"},{"location":"/services/config/config-service.html#getactivebytime","text":"This API returns the content of active version of the file existed at given instant of Time\nExample for getActiveByTime API looks like following:\nTypescript const filePath = 'esw/sequencer/obsMode.conf'\nconst at = new Date(2019, 12, 31)\n\nconst maybeConfigData: Option<ConfigData> = await configService.getActiveByTime(\n  filePath,\n  at\n)","title":"getActiveByTime"},{"location":"/services/event/event-service.html","text":"","title":"Event Service"},{"location":"/services/event/event-service.html#event-service","text":"Event service provides methods to interact with the event server which implements the publish/subscribe messaging paradigm where one component publishes an event and all clients that have subscribed receive the event.","title":"Event Service"},{"location":"/services/event/event-service.html#creation-of-event-service","text":"","title":"Creation of Event Service"},{"location":"/services/event/event-service.html#pre-requisite","text":"The Location Service, Event Service and Gateway Server needs to be running in the network The necessary configuration, environment variables or system properties should be defined to point to the correct host and port number(s) for the Location Service nodes.","title":"Pre-requisite"},{"location":"/services/event/event-service.html#examples-to-create-a-client-for-event-service","text":"Typescript const eventService: EventService = await EventService()","title":"Examples to create a client for Event service"},{"location":"/services/event/event-service.html#event-model","text":"Type definition of Event models can be found here.","title":"Event Model"},{"location":"/services/event/event-service.html#usages-of-event-service","text":"","title":"Usages of Event Service"},{"location":"/services/event/event-service.html#publishing-an-event","text":"Event service allows you to publish an Event to the event server. Type Definitions of publish API can be found here.\nTypescript const sourcePrefix = new Prefix('IRIS', 'component')\nconst eventName = new EventName('move-event')\nconst positionParameter = intKey('positions', 'centimeter').set([10, 20, 30])\nconst paramSet: Parameter<IntKey>[] = [positionParameter]\n\nconst event = ObserveEvent.make(sourcePrefix, eventName, paramSet)\n\nconst done: Done = await eventService.publish(event)","title":"Publishing an Event"},{"location":"/services/event/event-service.html#get-events","text":"The get API is used to get events for set of EventKeys.\nExample for getting events:\nTypescript const sourcePrefix = new Prefix('IRIS', 'component')\n\nconst eventKey1 = new EventKey(sourcePrefix, new EventName('eventKey1'))\nconst eventKey2 = new EventKey(sourcePrefix, new EventName('eventKey2'))\n\nconst eventKeys = new Set([eventKey1, eventKey2])\nconst events: Event[] = await eventService.get(eventKeys)","title":"Get events"},{"location":"/services/event/event-service.html#subscribe-to-the-events","text":"Subscribing Event can be done via two ways. User can subscribe to -\nMultiple EventKeys. All the EventKeys of specific subsystem and pattern.\nWhen events are subscribed for given EventKeys, events are received at every frequency. The APIs take callback function which gets triggered whenever the events are received.\nBelow example uses subscribe and pSubscribe APIs.\nExample for subscribing events with given EventKeys:\nTypescript const sourcePrefix = new Prefix('IRIS', 'component')\n\nconst eventKey1 = new EventKey(sourcePrefix, new EventName('eventKey1'))\nconst eventKey2 = new EventKey(sourcePrefix, new EventName('eventKey2'))\n\nconst onEventCallback = (event: Event) => {\n  console.log(event)\n  // make use of ${event} inside this callback function\n}\nconst eventKeys = new Set([eventKey1, eventKey2])\n\nconst subscription: Subscription = eventService.subscribe(\n  eventKeys,\n  10\n)(onEventCallback)\n\n//To cancel the subscription\nsubscription.cancel()\nExample for subscribing events with given subsystem:\nTypescript const onEventCallback = (event: Event) => {\n  // make use of ${event} inside this callback function\n  console.log(event)\n}\n\n// subscribe to all esw subsystem's event\nconst subscription: Subscription = eventService.pSubscribe(\n  'ESW',\n  10,\n  '.*'\n)(onEventCallback)\n\n// subscribe to specific events having hcd in the event name\nconst specificSubscription: Subscription = eventService.pSubscribe(\n  'ESW',\n  10,\n  '(hcd)'\n)(onEventCallback)\n\n//To cancel the subscription\nsubscription.cancel()","title":"Subscribe to the events"},{"location":"/services/location/location-service.html","text":"","title":"Location Service"},{"location":"/services/location/location-service.html#location-service","text":"The Location Service handles component (i.e., Applications, Sequencers, Assemblies, HCDs, and Services) discovery in the distributed TMT software system.\nA component’s location information can be used by other components and services to connect to it and use it.\nType definition for location information can be found here.","title":"Location Service"},{"location":"/services/location/location-service.html#creation-of-location-service","text":"","title":"Creation of Location Service"},{"location":"/services/location/location-service.html#pre-requisite","text":"Access token is not necessary for using location service query APIs.\nIf You are using location service to unregister a component, you would need to have the access token with specific permissions :\nAuthorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"Pre-requisite"},{"location":"/services/location/location-service.html#examples-to-create-client-for-location-service","text":"Location service constructor takes optional tokenFactory and optional location server configuration(host/port pair).\nTypescript const tokenFactory = () => auth.token\n\nconst locationServiceWithToken: LocationService = await LocationService(\n  tokenFactory\n)\n\nconst locationService: LocationService = await LocationService()\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.\nType definitions for all APIs can be found here.","title":"Examples to create client for Location service"},{"location":"/services/location/location-service.html#usages-of-location-service","text":"","title":"Usages of Location Service"},{"location":"/services/location/location-service.html#listing-filtering-locations","text":"Location service provides multiple ways to get list of locations registered in the TMT cluster.\nTypescript // valid Component type's : \"HCD\" | \"Assembly\" | \"Service\" | \"Container\" | \"Sequencer\" | \"SequenceComponent\" | \"Machine\"\n\nconst sequencerLocations: Location[] = await locationService.listByComponentType(\n  'Sequencer'\n)\n\nconst hcdLocations: Location[] = await locationService.listByComponentType(\n  'HCD'\n)\n\nconst assemblyLocations: Location[] = await locationService.listByComponentType(\n  'Assembly'\n)\nType Definitions for all flavours of listing apis are as follows:\nlist listByComponentType listByConnectionType listByHostname listByPrefix","title":"Listing & Filtering Locations"},{"location":"/services/location/location-service.html#resolving-connection","text":"There are two ways to get/fetch a location information of a connection:\nUsing resolve API Using find API\nLocation service’s resolve api uses Connection a component to resolve the location within some timeout duration. However, find api does not wait to resolve location. if the location is not present, it returns undefined.\nTypescript // ConnectionType's : HttpConnection , AkkaConnection & TCPConnection\n// Time unit : seconds, milliseconds, nanoseconds, microseconds, minutes, hours, days\n\nconst connection = HttpConnection(new Prefix('ESW', 'component'), 'HCD')\n\nconst maybeLocation1: Option<Location> = await locationService.resolve(\n  connection,\n  10,\n  'seconds'\n)\nif (maybeLocation1) {\n  // use maybeLocation inside here\n} else {\n  // location did not resolved in 10 seconds\n}","title":"Resolving Connection"},{"location":"/services/location/location-service.html#unregister-a-connection","text":"This is a secure API and takes a type of Connection as an input argument to be unregistered from the location service and returns Done once unregistered.\nThe following example shows unregister API can be called:\nTypescript // ConnectionType's : HttpConnection , AkkaConnection & TCPConnection\nconst done: Done = await locationServiceWithToken.unregister(\n  HttpConnection(new Prefix('ESW', 'component'), 'HCD')\n)","title":"Unregister a Connection"},{"location":"/services/location/location-service.html#tracking-connection","text":"The lifecycle of a connection of interest can be followed using either the track API. The connection update events will be received by the callback provided to this api. This api returns a subscription which can be used to cancel the tracking subscription.\nThe following example shows track API can be called:\nTypescript // a callback function\nconst onTrackingEvent = (event: TrackingEvent) => {\n  if (event._type === 'LocationRemoved') {\n    // do something when connection's location is removed from the location service\n  } else if (event._type === 'LocationUpdated') {\n    // do something when connection's location is update from the location service\n  }\n}\n// connection to be tracked\nconst httpConnection = HttpConnection(new Prefix('ESW', 'component'), 'HCD')\n\nlocationService.track(httpConnection)(onTrackingEvent)","title":"Tracking Connection"},{"location":"/services/logging-service/logging-service.html","text":"","title":"Logging Service"},{"location":"/services/logging-service/logging-service.html#logging-service","text":"Logging Service provides the Http Interface to be able to log into a component.\nType definition for the logging Service interface can be found here","title":"Logging Service"},{"location":"/services/logging-service/logging-service.html#creation-of-logging-service","text":"","title":"Creation of Logging Service"},{"location":"/services/logging-service/logging-service.html#pre-requisite","text":"In order to use Logging Service APIs:\nThe Location Service, and Gateway Server needs to be running in the network","title":"Pre-requisite"},{"location":"/services/logging-service/logging-service.html#to-create-logging-service","text":"Typescript const loggingService: LoggingService = await LoggingService()\nconst locationService: LocationService = await LocationService()","title":"To create Logging Service"},{"location":"/services/logging-service/logging-service.html#apis","text":"Async-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"APIs"},{"location":"/services/logging-service/logging-service.html#usages-of-logging-service","text":"","title":"Usages of Logging service"},{"location":"/services/logging-service/logging-service.html#creating-log-for-an-incident","text":"This api will be used for to create a log entry for a component with a specific log Level.\nFor ex: when a user submits a setup command for a component using command service.\nuser may want to create explicit log entry based on success or failure scenario.\nType definition can be found - here.\nTypescript let prefix = new Prefix('ESW', 'comp1')\nconst commandService: CommandService = await CommandService(\n  new ComponentId(prefix, 'Assembly')\n)\nconst intParam = intKey('positions').set([1, 2, 3])\nconst setup = new Setup(prefix, 'move', [intParam])\nconst response = await commandService.submit(setup)\nswitch (response._type) {\n  case 'Completed':\n    await loggingService.log(\n      prefix,\n      'INFO',\n      'Successfully submitted move command',\n      { params: [intParam] }\n    )\n    break\n  default:\n    await loggingService.log(\n      prefix,\n      'ERROR',\n      'Failed to submit move command',\n      { params: [intParam] }\n    )\n}","title":"Creating Log for an incident"},{"location":"/services/sequencer/sequencer-service.html","text":"","title":"Sequencer Service"},{"location":"/services/sequencer/sequencer-service.html#sequencer-service","text":"This service provides a handle to send commands to a sequencer which is registered in location service.","title":"Sequencer Service"},{"location":"/services/sequencer/sequencer-service.html#creation-of-sequencer-service","text":"","title":"Creation of Sequencer Service"},{"location":"/services/sequencer/sequencer-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/services/sequencer/sequencer-service.html#in-order-to-use-sequencer-service-client-for-a-specific-sequencer-","text":"The sequencer and gateway server should be running. GatewayException(InvalidComponent) will be thrown if the specified sequencer not found in the location service. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"In order to use sequencer service client for a specific sequencer:"},{"location":"/services/sequencer/sequencer-service.html#to-create-sequencer-service","text":"Typescript const tokenFactory = () => auth.token\n\nconst sequencerService: SequencerService = await SequencerService(\n  new ComponentId(new Prefix('ESW', 'darknight'), 'Sequencer'),\n  tokenFactory\n)","title":"To create Sequencer Service"},{"location":"/services/sequencer/sequencer-service.html#apis","text":"Async-Await Note that the examples are using async/await which makes handling of promises more readable.\nSequencer service has following APIs:\nloadSequence startSequence add prepend replace insertAfter delete addBreakpoint removeBreakpoint reset resume pause getSequence isAvailable isOnline goOnline goOffline abortSequence stop diagnosticMode operationsMode query queryFinal submit submitAndWait","title":"APIs"},{"location":"/params/index.html","text":"","title":"Params"},{"location":"/params/index.html#params","text":"In the distributed environment of TMT observatory, Components communicate with each other by sending asynchronous Messages. These messages have a Command payload, which flows down through the Sequencer components to the Assemblies, HCDs and finally to the hardware. At each hop Commands are validated, interpreted and further propagated making their journey to its destination. Commands provide flexible placeholders to store values to convey precise intent of the sender component.\nParams module plays a significant role as it caters to the diverse communication requirements. Consumer of this module will be able to create Commands, Events, States to store ParameterSets.\nParams has following models :\nCommands ObsId Prefix CommandName Setup Command Observe Command Wait Command Unique Key constraint Events EventTime System Event Observe Event Unique Key Constraint Keys and Parameters How to create a Parameter using the helper functions Primitive Datatypes Array Datatypes Matrix Datatypes Domain Specific Types Coordinate Types Result Subsystem List of Subsystems Usage Examples State variables CurrentState Units Default Units for Keys SI Units CGS Units Astrophysical Units Imperial Units Others - Engineering Usage Examples\nType definition for all common models used by services can be found here","title":"Params"},{"location":"/params/commands.html","text":"","title":"Commands"},{"location":"/params/commands.html#commands","text":"Commands are parameter sets called Setup, Observe, and Wait. A command is created with the source of the command, given by a prefix, the name of the command, and an optional ObsId. Parameters are added to the command as needed.","title":"Commands"},{"location":"/params/commands.html#obsid","text":"An ObsID, or observation ID, indicates the observation the command is associated with. It is a simple string.\nTypescript const obsId: string = 'Obs001'","title":"ObsId"},{"location":"/params/commands.html#prefix","text":"The source of the command is given by the prefix, which should be the full name of the component sending the command. A prefix can be constructed with a string, but must start with a valid subsystem as in Subsystem. A component developer should supply a valid prefix string and the subsystem will be automatically parsed from it. An example of a valid string prefix is “nfiraos.ncc.trombone”.\nSee below examples:\nTypescript const prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')","title":"Prefix"},{"location":"/params/commands.html#commandname","text":"Each command has a name given as a string. The string should be continuous with no spaces.","title":"CommandName"},{"location":"/params/commands.html#setup-command","text":"This command is used to describe a goal that a system should match. The component developer is required to supply following arguments to create a Setup command.\nPrefix: the source of the command as described above CommandName: a simple string name for the command (no spaces) ObsId: an optional observation id. paramSet: Optional Set of Parameters. Default is empty.\nTypescript const obsId: string = 'Obs001'\nconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')\nconst commandName = 'move'\nconst filterKey = intArrayKey('filter')\nconst filterParam: Parameter<IntArrayKey> = filterKey.set([\n  [1, 2, 3],\n  [4, 5, 6]\n])\n\nconst setup: Setup = new Setup(prefix, commandName, [filterParam], obsId)","title":"Setup Command"},{"location":"/params/commands.html#observe-command","text":"This command describes a science observation. It is intended to only be sent to Science Detector Assemblies and Sequencers.\nTypescript const obsId: string = 'Obs001'\nconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')\nconst commandName = 'move'\nconst filterKey = intArrayKey('filter')\nconst filterParam: Parameter<IntArrayKey> = filterKey.set([\n  [1, 2, 3],\n  [4, 5, 6]\n])\n\nconst observe: Observe = new Observe(\n  prefix,\n  commandName,\n  [filterParam],\n  obsId\n)","title":"Observe Command"},{"location":"/params/commands.html#wait-command","text":"This command causes a Sequencer to wait until notified. It can only be sent to Sequencers.\nTypescript const obsId: string = 'Obs001'\nconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')\nconst commandName = 'move'\nconst filterKey = intArrayKey('filter')\nconst filterParam: Parameter<IntArrayKey> = filterKey.set([\n  [1, 2, 3],\n  [4, 5, 6]\n])\n\nconst wait: Wait = new Wait(prefix, commandName, [filterParam], obsId)","title":"Wait Command"},{"location":"/params/commands.html#unique-key-constraint","text":"By design, a ParameterSet in a Setup, Observe, or Wait command is optimized to store only unique keys. When using add or madd methods on commands to add new parameters, if the parameter being added has a key which is already present in the paramSet, the already stored parameter will be replaced by the given parameter.\nNote If the Set is created by component developers and given directly while creating a command, then it will be the responsibility of component developers to maintain uniqueness with parameters based on key.\nHere are some examples that illustrate this point:\nTypescript const obsId: string = 'Obs001'\nconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')\nconst commandName = 'move'\nconst filterKey = intArrayKey('filter')\nconst randomKey = stringKey('directions')\nconst filterParam: Parameter<IntArrayKey> = filterKey.set([[1, 2, 3]])\nconst param1 = randomKey.set(['east', 'west'])\nconst param2 = randomKey.set(['north', 'south'])\n\nconst wait: Wait = new Wait(prefix, commandName, [filterParam], obsId)\nwait.madd([param1, param2])\n\n//duplicate keys will not be added. Should contain one randomKey and one Filter key\nwait.paramSet.forEach((x) => console.log(x.keyName))","title":"Unique Key constraint"},{"location":"/params/events.html","text":"","title":"Events"},{"location":"/params/events.html#events","text":"Events are the most basic type of asynchronous notification in TMT when an activity occurs somewhere in the TMT system and other components need to be notified. Each type of event has a unique purpose and unique information, but they all share same structural features. All events have EventInfo and a ParameterSet.","title":"Events"},{"location":"/params/events.html#eventtime","text":"Each event includes its time of creation in UTC format. You can access that eventTime as follows:\nTypescript const source = new Prefix('IRIS', 'filter.wheel')\nconst eventName = new EventName('temperatures')\nconst event = SystemEvent.make(source, eventName)\n\n// accessing eventTime\nconst eventTime = event.eventTime","title":"EventTime"},{"location":"/params/events.html#system-event","text":"SystemEvent is the type used to describe the majority of events in the system. An example is a demand that is the output of an algorithm in one component that is used as an input to another. SystemEvent is also used to publish internal state or status values of a component that may be of interest to other components in the system.","title":"System Event"},{"location":"/params/events.html#example-snippets-for-creation-of-system-event-","text":"Typescript //keys\nconst k1 = intKey('encoder')\nconst k2 = intKey('speed')\nconst k3 = stringKey('filter')\nconst k4 = intKey('notUsed')\n\n//prefixes\nconst ck1 = Prefix.fromString('wfos.red.filter')\nconst name1 = new EventName('filterWheel')\nconst ck3 = Prefix.fromString('iris.imager.filter')\nconst name3 = new EventName('status')\n\n//parameters\nconst p1: Parameter<IntKey> = k1.set([22])\nconst p2: Parameter<IntKey> = k2.set([44])\nconst p3: Parameter<StringKey> = k3.set(['A', 'B', 'C', 'D'])\n\n//Create SystemEvent using madd\nconst se1: SystemEvent = SystemEvent.make(ck1, name1).madd([p1, p2])\n//Create SystemEvent using make\nconst se2: SystemEvent = SystemEvent.make(ck3, name3, [p1, p2])\n//Create SystemEvent and use add\nconst se3: SystemEvent = SystemEvent.make(ck3, name3).add(p1).add(p2).add(p3)\n\n//access keys\nconst k1Exists: Boolean = se1.exists(k1) //true\n\n//access Parameters\nconst p4: Option<Parameter<IntKey>> = se1.get(k1)\n\n//access values\nconst v1: Option<number[]> = se1.get(k1)?.values\nconst v2: Option<number[]> = se2.get(k2)?.values\n\n//remove keys\nconst se4: SystemEvent = se3.remove(k3)\n\n//add more than one parameters, using madd\nconst se5: SystemEvent = se4.madd([k3.set(['X', 'Y', 'Z']), k4.set([99, 100])])\nconst paramSize: number = se5.size()\n\n//update existing key with set\nconst se6: SystemEvent = se5.add(k2.set([5, 6, 7, 8]))","title":"Example snippets for creation of system event :"},{"location":"/params/events.html#observe-event","text":"ObserveEvent are standardized events used to describe an activities within the data acquisition process. These events are typically published by Science Detector Assemblies, which emit ObserveEvents during their exposures to signal the occurrence of specific activities/actions during the acquisition of data.","title":"Observe Event"},{"location":"/params/events.html#example-snippets-for-creation-of-observe-event-","text":"Typescript //keys\nconst k1 = intKey('readoutsCompleted')\nconst k2 = intKey('coaddsCompleted')\nconst k3 = stringKey('fileID')\nconst k4 = intKey('notUsed')\n\n//prefixes\nconst ck1 = Prefix.fromString('iris.ifu.detectorAssembly')\nconst name1 = new EventName('readoutEnd')\nconst ck3 = Prefix.fromString('wfos.red.detector')\nconst name3 = new EventName('exposureStarted')\n\n//parameters\nconst p1: Parameter<IntKey> = k1.set([4])\nconst p2: Parameter<IntKey> = k2.set([2])\nconst p3: Parameter<StringKey> = k3.set(['WFOS-RED-0001'])\n\n//Create ObserveEvent using madd\nconst se1: ObserveEvent = ObserveEvent.make(ck1, name1).madd([p1, p2])\n//Create ObserveEvent using apply\nconst se2: ObserveEvent = ObserveEvent.make(ck3, name3, [p1, p2])\n//Create ObserveEvent and use add\nconst se3: ObserveEvent = ObserveEvent.make(ck3, name3)\n  .add(p1)\n  .add(p2)\n  .add(p3)\n\n//access keys\nconst k1Exists: Boolean = se1.exists(k1) //true\n\n//access Parameters\nconst p4: Option<Parameter<IntKey>> = se1.get(k1)\n\n//access values\nconst v1: Option<number[]> = se1.get(k1)?.values\nconst v2: Option<number[]> = se2.get(k2)?.values\n\n//remove keys\nconst se4: ObserveEvent = se3.remove(k3)","title":"Example snippets for creation of observe event :"},{"location":"/params/events.html#unique-key-constraint","text":"By choice, a ParameterSet in either ObserveEvent or SystemEvent event will be optimized to store only unique keys. When using add or madd methods on events to add new parameters, if the parameter being added has a key which is already present in the paramSet, the already stored parameter will be replaced by the given parameter.\nNote If the Set is created by component developers and given directly while creating an event, then it will be the responsibility of component developers to maintain uniqueness with parameters based on key.","title":"Unique Key Constraint"},{"location":"/params/events.html#here-are-some-examples-that-illustrate-this-point-","text":"Typescript //keys\nconst encoderKey = intKey('encoder')\nconst filterKey = intKey('filter')\nconst miscKey = intKey('misc')\n\n//prefix\nconst prefix = Prefix.fromString('wfos.blue.filter')\n\nconst name1 = new EventName('filterWheel')\n\n//params\nconst encParam1 = encoderKey.set([1])\nconst encParam2 = encoderKey.set([2])\n\nconst encParam3 = encoderKey.set([3])\nconst filterParam1 = filterKey.set([1])\nconst filterParam2 = filterKey.set([2])\n\nconst filterParam3 = filterKey.set([3])\n\nconst miscParam1 = miscKey.set([100])\n//StatusEvent with duplicate key via constructor\nconst systemEvent = SystemEvent.make(prefix, name1, [\n  encParam1,\n  encParam2,\n  encParam3,\n  filterParam1,\n  filterParam2,\n  filterParam3\n])\n\n//try adding duplicate keys via add + madd\nconst changedStatusEvent = systemEvent\n  .add(encParam3)\n  .madd([filterParam1, filterParam2, filterParam3])\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nconst uniqueKeys2 = changedStatusEvent.paramSet.map((x) => x.keyName)\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nconst finalStatusEvent = systemEvent.madd([miscParam1, encParam1])\n//now contains encoderKey, filterKey, miscKey\nconst uniqueKeys3 = finalStatusEvent.paramSet.map((x) => x.keyName)","title":"Here are some examples that illustrate this point:"},{"location":"/params/keys-and-parameters.html","text":"","title":"Keys and Parameters"},{"location":"/params/keys-and-parameters.html#keys-and-parameters","text":"The library offers a flexible and typesafe means to create Parameters to store values like primitive types, collection types or domain specific types.\nA Parameter is a Key and Value where the Value must be from a set of defined primitive types including binary data. The Value of a Parameter is always considered to be an Array of the type (i.e. if a single value is stored it is at array location 0). A Parameter is immutable; a modification to an existing Parameter will return a new instance.\nA Value can also have Units, which must be of the defined types. See Units for more information. At this time Units are informational only–no calculation or conversion support is provided. Some systems may provide a key value with different units, and receiver can inspect the Units to make a decision on how to handle the value.\nA ParameterSet is a Set of Parameter. Various other message types include a ParameterSet (e.g. Setup, Event). A key is unique in a ParameterSet since it is a Set.","title":"Keys and Parameters"},{"location":"/params/keys-and-parameters.html#how-to-create-a-parameter-using-the-helper-functions","text":"Choose an appropriate KeyType from the tables below. Calling the set method on KeyType helper and supplying a string keyName will return a suitably typed parameter instance.","title":"How to create a Parameter using the helper functions"},{"location":"/params/keys-and-parameters.html#example-snippets-for-creating-parameter-of-simple-array-and-matrix-type-","text":"Typescript // primitives\nconst booleanParam: Parameter<BooleanKey> = booleanKey('flag').set([false])\n\nconst intParam: Parameter<IntKey> = intKey('RandomKeyName').set([123, 12432])\n// intParam.keyName === 'RandomKeyName'\n// intParam.keyTag === 'IntKey'\n// intParam.values === [123, 12432]\n// intParam.units === 'NoUnits' // default unit is `NoUnits`\n// -------------\n\n// arrays\nconst filterkey = intArrayKey('filter')\nconst filterParam: Parameter<IntArrayKey> = filterkey.set([\n  [1, 2, 3],\n  [4, 5, 6]\n])\n// -------------\n\n// matrices\nconst positionMatrixKey = byteMatrixKey('positions', 'meter')\nconst positions: Parameter<ByteMatrixKey> = positionMatrixKey.set([\n  [\n    [1, 2],\n    [3, 4]\n  ],\n  [\n    [5, 6],\n    [7, 8]\n  ]\n])","title":"Example snippets for creating parameter of simple, array and matrix type."},{"location":"/params/keys-and-parameters.html#primitive-datatypes","text":"Primitive Typescript Key Type Helper functions Int IntKey intKey Long LongKey longKey Short ShortKey shortKey Float FloatKey floatKey Double DoubleKey doubleKey Byte ByteKey byteKey String StringKey stringKey Char CharKey charKey Boolean BooleanKey booleanKey UTCTime UTCTimeKey utcTimeKey TAITime TAITimeKey taiTimeKey","title":"Primitive Datatypes"},{"location":"/params/keys-and-parameters.html#array-datatypes","text":"Primitive Typescript Key Type Helper functions IntArray IntArrayKey intArrayKey LongArray LongArrayKey longArrayKey ShortArray ShortArrayKey shortArrayKey FloatArray FloatArrayKey floatArrayKey DoubleArray DoubleArrayKey doubleArrayKey ByteArray ByteArrayKey byteArrayKey","title":"Array Datatypes"},{"location":"/params/keys-and-parameters.html#matrix-datatypes","text":"Primitive Typescript Key Type Helper functions IntMatrix IntMatrixKey intMatrixKey LongMatrix LongMatrixKey longMatrixKey ShortMatrix ShortMatrixKey shortMatrixKey FloatMatrix FloatMatrixKey floatMatrixKey DoubleMatrix DoubleMatrixKey doubleMatrixKey ByteMatrix ByteMatrixKey byteMatrixKey","title":"Matrix Datatypes"},{"location":"/params/keys-and-parameters.html#domain-specific-types","text":"choice : A key for a choice item similar to an enumeration struct : Structs can be used to create a hierarchy of parameters\nPrimitive Typescript Key Type Helper functions Choice ChoiceKey choiceKey Struct StructKey Struct","title":"Domain Specific Types"},{"location":"/params/keys-and-parameters.html#example-snippets-for-creating-choice-and-struct-parameters","text":"Typescript // choice key\n\nconst choices = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] as const\n\nconst weekDaysKey = choiceKey('weekDaysKey', choices)\nconst weekDayParam = weekDaysKey.set('Mon', 'Wed')\n// weekDayParam === Parameter('weekDaysKey', 'ChoiceKey', ['Mon', 'Wed'], 'NoUnits')\n\n// -------------\n\n// example for struct key\n// leaf parameters\nconst ra: Parameter<StringKey> = stringKey('ra').set(['12:13:14.1'])\nconst dec = stringKey('dec').set(['32:33:34.4'])\nconst epoch = doubleKey('epoch').set([1970.0])\n\n// initialise struct key\nconst struct = new Struct().add(ra)\nstruct.madd([dec, epoch])\n\n// create struct Parameter using structKey\nconst structParameter = structKey('my struct').set([struct])","title":"Example snippets for creating choice and struct parameters"},{"location":"/params/keys-and-parameters.html#coordinate-types","text":"Primitive Typescript Key Type Helper functions RaDec RaDecKey raDecKey EqCoord EqCoordKey eqCoordKey SolarSystemCoord SolarSystemCoordKey solarSystemCoordKey MinorPlanetCoord MinorPlanetCoordKey minorPlanetCoordKey CometCoord CometCoordKey cometCoordKey AltAzCoord AltAzCoordKey altAzCoordKey Coord (*) CoordKey coordKey","title":"Coordinate Types"},{"location":"/params/keys-and-parameters.html#example-snippet-for-creating-coordinate-parameters","text":"Typescript const cometCoord = new CometCoord(\n  'BASE',\n  2000,\n  324000000000,\n  7200000000,\n  360000000000,\n  1.4,\n  0.234\n)\nconst cometParam: Parameter<CometCoordKey> = cometCoordKey(\n  'comet key',\n  'degree'\n).set([cometCoord])\n\n//coord key is base trait of all coordinate key types.\nconst coordParam: Parameter<CoordKey> = coordKey('base coordinate').set([\n  cometCoord\n])\nNote Note that since Coord is the base trait of the other coordinate types, you can use it as the key for any of the coordinate types.","title":"Example snippet for creating coordinate parameters"},{"location":"/params/result.html","text":"","title":"Result"},{"location":"/params/result.html#result","text":"Components use Results to return results of a command in the form of a ParameterSet. Result is the value that is returned as an argument to the Completed SubmitResponse.\nFollowing snippet shows how to create a Result :\nTypescript //keys\n\nconst k1 = intKey('encoder')\nconst k2 = intKey('windspeed')\nconst k3 = stringKey('filter')\nconst k4 = intKey('notUsed')\n\n//prefixes\nconst prefix = Prefix.fromString('wfos.prog.cloudcover')\n\n//parameters\nconst p1: Parameter<IntKey> = k1.set([22])\nconst p2: Parameter<IntKey> = k2.set([44])\nconst p3: Parameter<StringKey> = k3.set(['A', 'B', 'C', 'D'])\n\n//Create Result using madd\nconst r1: Result = new Result().madd([p1, p2])\n//Create Result using apply\nconst r2: Result = new Result([p1, p2])\n//Create Result and use add\nconst r3: Result = new Result().add(p1).add(p2).add(p3)\n\n//access keys\nconst k1Exists: Boolean = r1.exists(k1) //true\n\n//access Parameters\nconst p4: Option<Parameter<IntKey>> = r1.get(k1)\n\n//access values\nconst v1: Option<number[]> = r1.get(k1)?.values\nconst v2: Option<number[]> = r2.get(k2)?.values\n\n//remove keys\nconst r4: Result = r3.remove(k3)","title":"Result"},{"location":"/params/subsystem.html","text":"","title":"Subsystem"},{"location":"/params/subsystem.html#subsystem","text":"TMT Observatory system is composed of many subsystems. The subsystems that are known participants in the TMT Software System are predefined and the list is covered under the Subsystem enumeration. They are identified using an abbreviation typically of 3 or 4 letters.\nSusbsystem values are used to construct Prefix and are used in communication vehicles such as Commands, Events and States.","title":"Subsystem"},{"location":"/params/subsystem.html#list-of-subsystems","text":"Abbreviation Susbsystem name AOESW AO Executive Software APS Alignment and Phasing System CIS Communications and Information Systems CLN Mirror Cleaning System CRYO Cryogenic Cooling System CSW Common Software DMS Data Management System DPS Data Processing System ESEN Engineering Sensor System ESW Executive Software System FMCS Facility Management Control System GMS Global Metrology System Controls IRIS InfraRed Imaging Spectrometer LGSF Lasert Guide Star Facility M1CS M1 Control System MODHIS Multi-Object Diffraction-limited High-resolution Infrared Spectrograph NFIRAOS Narrow Field Infrared AO System NSCU NFIRAOS Science Calibration Unit OSS Observatory Safety System PFCS Prime Focus Camera Controls PSFR NFIRAOS AO PSF Reconstructor REFR Refrigeration Control System RTC NFIRAOS Real-time Controller RPG NFIRAOS AO Reconstructor Parameter Generator SCMS Site Conditions Monitoring System SOSS Science Operations Support System TCS Telescope Control System WFOS Wide Field Optical Spectrometer Container Container subsystem","title":"List of Subsystems"},{"location":"/params/subsystem.html#usage-examples","text":"The usage examples can be found in Events, Commands, States","title":"Usage Examples"},{"location":"/params/state-variables.html","text":"","title":"State variables"},{"location":"/params/state-variables.html#state-variables","text":"State variables are used when an UI for Assembly wants to track the status of a command sent to an HCD using a matcher.\nA state represents some aspect of a component’s internal state which is captured in CurrentState. All state variables have Prefix and ParameterSet.\nThe PubSub feature of the HCD provides CurrentState values to the PubSub subscriber.","title":"State variables"},{"location":"/params/state-variables.html#currentstate","text":"A state variable that is published by a component that describes its internal state. Used by Assemblies to determine command completion in Command Service.\nTypescript //prefix\n\nconst prefix = Prefix.fromString('wfos.prog.cloudcover')\n\n//key\nconst charKey1 = charKey('charKey')\nconst intKey1 = intKey('intKey', 'meter')\nconst booleanKey1 = booleanKey('booleanKey')\nconst utcTimeKey1 = utcTimeKey('utcTimeKey')\nconst notUsedKey = stringKey('notUsed')\n\n//parameters\nconst charParam = charKey1.set(['A', 'B', 'C'])\nconst intParam = intKey1.set([1, 2, 3])\nconst booleanParam = booleanKey1.set([true, false])\nconst utcTime = utcTimeKey1.set([new Date().toUTCString()])\n\n//create CurrentState and use sequential add\nconst cs1 = new CurrentState(prefix, 'testStateName')\n  .add(charParam)\n  .add(intParam)\n//create CurrentState and add more than one Parameters using madd\nconst cs2 = new CurrentState(prefix, 'testStateName').madd([\n  intParam,\n  booleanParam\n])\n//create CurrentState using apply\nconst cs3 = new CurrentState(prefix, 'testStateName', [utcTime])\n\n//access keys\nconst charKeyExists = cs1.exists(charKey1) //true\n\n//access Parameters\nconst p1: Option<Parameter<IntKey>> = cs1.get(intKey1)\n\n//access values\nconst v1: Option<string[]> = cs1.get(charKey1)?.values\nconst v2: Option<boolean[]> = cs2.get(booleanKey1)?.values\n\n//remove keys\nconst cs4 = cs3.remove(utcTimeKey1)\n\n//update existing keys - set it back by an hour\nvar today = new Date()\ntoday.setHours(today.getHours() - 1)\nconst cs5 = cs3.add(utcTimeKey1.set([today.toUTCString()]))","title":"CurrentState"},{"location":"/params/units.html","text":"","title":"Units"},{"location":"/params/units.html#units","text":"Listed below are Units of Measurement, supported by TMT observatory framework and are available as Enumerated values. Units are optionally attached to Parameter Keys.\nNote The set of supported Units will be modified as more required Units will be discovered.","title":"Units"},{"location":"/params/units.html#default-units-for-keys","text":"The default unit for UTCTimeKey and TAITimeKey is second. For all the remaining keys, default unit is NoUnits.","title":"Default Units for Keys"},{"location":"/params/units.html#si-units","text":"Name Abbreviation Description angstrom Angstrom 10 -1 nm arcmin arcmin arc minute; angular measurement arcsec arcsec arc second: angular measurement day d day - 24 hours degree deg degree: agular measurement 1/360 of full rotation elvolt eV electron volt 1.6022x10-19 J gram g gram 10-3 kg hour h hour 3.6x10+3 s hertz Hz frequency joule J Joule: energy N m kelvin K Kelvin: temperature with a null point at absolute zero kilogram kg kilogram, base unit of mass in SI kilometer km kilometers - 10+3 m liter l liter, metric unit of volume 10+3 cm+3 meter m meter: base unit of length in SI marcsec mas milli arc second: angular measurement 10-3 arcsec millimeter mm millimeters - 10-3 m millisecond ms milliseconds - 10-3 s micron µm micron: alias for micrometer micrometer µm micron: 10-6 m minute min minute 6x10+1 s newton N Newton: force pascal Pa Pascal: pressure radian rad radian: angular measurement of the ratio between the length of an arc and its radius second s second: base unit of time in SI sday sday sidereal day is the time of one rotation of the Earth: 8.6164x10+4 s steradian sr steradian: unit of solid angle in SI - rad+2 microarcsec µas micro arcsec: angular measurement volt V Volt: electric potential or electromotive force watt W Watt: power week wk week - 7 d year yr year - 3.6525x10+2 d","title":"SI Units"},{"location":"/params/units.html#cgs-units","text":"Name Abbreviation Description coulomb C coulomb: electric charge centimeter cm centimeter erg erg erg: CGS unit of energy","title":"CGS Units"},{"location":"/params/units.html#astrophysical-units","text":"Name Abbreviation Description au AU astronomical unit: approximately the mean Earth-Sun distance jansky Jy Jansky: spectral flux density - 10-26 W/Hz m+2 lightyear lyr light year - 9.4607x10+15 m mag mag stellar magnitude","title":"Astrophysical Units"},{"location":"/params/units.html#imperial-units","text":"Name Abbreviation Description cal cal thermochemical calorie: pre-SI metric unit of energy foot ft international foot - 1.2x10+1 inch inch inch international inch - 2.54 cm pound lb international avoirdupois pound - 1.6x10+1 oz mile mi international mile - 5.28x10+3 ft ounce oz international avoirdupois ounce yard yd international yard - 3 ft","title":"Imperial Units"},{"location":"/params/units.html#others-engineering","text":"Name Abbreviation Description NoUnits none scalar - no units specified encoder enc encoder counts count ct counts as for an encoder or detector pix pix pixel","title":"Others - Engineering"},{"location":"/params/units.html#usage-examples","text":"Typescript //declare keyName\nconst s1: string = 'encoder'\n\n//making 2 keys\nconst k1 = booleanKey(s1)\nconst k2 = shortKey('RandomKeyName', 'meter')\n\n//storing a single value\nconst booleanParam: Parameter<BooleanKey> = k1.set([true])\n\n//storing multiple values\nconst paramWithShorts1: Parameter<ShortKey> = k2.set([1, 2, 3, 4])\n\n//  default unit is NoUnits\n// booleanParam.units === \"NoUnits\"\n\n//retrieve values from Parameter\nconst allValues: Array<number> = paramWithShorts1.values\n\n// allValues === Array(1, 2, 3, 4))\n// paramWithUnits3.units === \"meter\")\n\n//default unit for UTCTimeKey is second\nconst tParam: Parameter<UTCTimeKey> = utcTimeKey('now').set([\n  new Date().toUTCString()\n])\nconst defaultTimeUnit: Units = tParam.units //is second","title":"Usage Examples"},{"location":"/aas/csw-aas-js.html","text":"","title":"Javascript Adapter (csw-aas-js)"},{"location":"/aas/csw-aas-js.html#javascript-adapter-csw-aas-js-","text":"csw-aas-js is an npm package which provides React components that integrate with the CSW Authentication and Authorization Service. UI applications can use these React components to enable the application to show or hide components based on the authentication and authorization policy. csw-aas-js is written in typescript and it bundles transpiled es6 module along with type declarations.","title":"Javascript Adapter (csw-aas-js)"},{"location":"/aas/csw-aas-js.html#dependencies","text":"To use the esw-ts adapter, run this command from root folder of your application where package.json exists:\nnpm     npm i --save esw-ts@0.1.0-SNAPSHOT\n yarn     yarn add esw-ts@0.1.0-SNAPSHOT","title":"Dependencies"},{"location":"/aas/csw-aas-js.html#application-configuration","text":"Web application needs following configurations in order to get access token from keycloak server. This application specific config object should be passed in AuthContextProvider component. There are two configurations needed for a web application i.e. realm, clientId\nrealm is a mandatory configuration which specified in keycloak server under which client for your application is registered.\nclientId is a mandatory configuration which specifies the client id of the app as per registration in keycloak server.\nJavascript export const AppConfig = {\n  realm: 'TMT',\n  clientId: 'tmt-frontend-app',\n  applicationName: 'test-app'\n}","title":"Application Configuration"},{"location":"/aas/csw-aas-js.html#components","text":"esw-ts exposes the following React components.\nAuthContextProvider Consumer Login Logout CheckLogin RealmRole\nType definition for all components used by services can be found here\nComponents can be imported as shown in code snippet below\nJavascript import { AuthContext, Logout, Login } from '@tmtsoftware/esw-ts'","title":"Components"},{"location":"/aas/csw-aas-js.html#authcontextprovider","text":"AuthContextProvider is wrapper over a React Context.Provider. A JSON configuration file must be passed in that contains the application specific AAS server configuration (e.g. clientId, realm). When a user logs in, an AAS Server is instantiated, with the UI application specific configuration overriding the predefined configuration. Once the AAS sever is instantiated, an auth object is created with the needed attributes and APIs. This auth object is available to other React components; since AuthContextProvider is a Provider, its data can be shared with any of the children React components in its tree in a Consumer component (see below). All Consumers that are descendants of a Provider will re-render whenever the AuthContextProvider’s state changes, e.g. a user authorizes. It is recommended to use AuthContextProvider to wrap the entire application so that data can be shared anywhere in application via a Consumer.\nJavascript <AuthContextProvider config={AppConfig}>\n  <BrowserRouter>\n    <div>\n      <NavComponent />\n      <Route\n        exact\n        path='/secured'\n        render={(_) => (\n          <CheckLogin error={<LoginError />}>\n            <Write />\n          </CheckLogin>\n        )}\n      />\n      <Route exact path='/config' render={(_) => <ConfigApp />} />\n      <Route\n        exact\n        path='/example_admin'\n        render={(_) => (\n          <CheckLogin error={<LoginError />}>\n            <RealmRole\n              realmRole='example-admin-role'\n              error={\n                <RoleError\n                  message={'User do not have role : example-admin-role'}\n                />\n              }>\n              <div>Example admin role specific functionality</div>\n            </RealmRole>\n          </CheckLogin>\n        )}\n      />\n      <Route\n        exact\n        path='/example_user'\n        render={(_) => (\n          <CheckLogin error={<LoginError />}>\n            <RealmRole\n              realmRole='person-role'\n              error={\n                <RoleError\n                  message={'User do not have role : person-role'}\n                />\n              }>\n              <div>Person role specific functionality</div>\n            </RealmRole>\n          </CheckLogin>\n        )}\n      />\n      <Route exact path='/public' component={Read} />\n    </div>\n  </BrowserRouter>\n</AuthContextProvider>","title":"AuthContextProvider"},{"location":"/aas/csw-aas-js.html#source-code-for-authcontextprovider-component","text":"AuthContextProvider Component","title":"Source code for AuthContextProvider component"},{"location":"/aas/csw-aas-js.html#consumer","text":"Consumer is similar to a React Context.Consumer. The shared auth object from the AuthContextProvider can be accessed using a Consumer component\nJavascript const { auth } = useContext(AuthContext)\nreturn (\n  <div className='nav-wrapper'>\n    {auth && auth.isAuthenticated() ? (\n      <div>\n        Hello, you are logged in\n        <div>Open functionality</div>\n      </div>\n    ) : (\n      <div>\n        Hello, you are not logged in\n        <div>Open functionality</div>\n      </div>\n    )}\n  </div>\n)","title":"Consumer"},{"location":"/aas/csw-aas-js.html#source-code-for-consumer-component","text":"Consumer Component","title":"Source code for Consumer component"},{"location":"/aas/csw-aas-js.html#login","text":"The Login component instantiates an AAS server with the configurations provided. It redirects to an AAS server login page for the user to login. After login, the auth object in the context is updated with the appropriate values, e.g. token, realm etc.\nJavascript <Login />","title":"Login"},{"location":"/aas/csw-aas-js.html#source-code-for-login-component","text":"Login Component","title":"Source code for Login component"},{"location":"/aas/csw-aas-js.html#logout","text":"The Logout component logs out the user from the AAS server. It clears the auth object stored in the context.\nJavascript   <Logout />\n) : (","title":"Logout"},{"location":"/aas/csw-aas-js.html#source-code-for-logout-component","text":"Logout Component","title":"Source code for Logout component"},{"location":"/aas/csw-aas-js.html#checklogin","text":"CheckLogin components provide ability to show something only if the user is logged in. In the following code snippet, Write is a react component that is shown only if the user is logged in. The behavior if the user is not logged in can be defined by an HTML element or React component that is passed into the component as an error property, shown as an ExampleError Component in following snippet.\nJavascript <CheckLogin error={<LoginError />}>\n  <Write />\n</CheckLogin>","title":"CheckLogin"},{"location":"/aas/csw-aas-js.html#source-code-for-checklogin-component","text":"CheckLogin Component","title":"Source code for CheckLogin component"},{"location":"/aas/csw-aas-js.html#realmrole","text":"RealmRole components provide the ability to show something only if the user is logged in and has the specified realm role. In the following code snippet, the contents of the div block are shown only if the user is logged in and has the realm role specified in the realmRole prop. Similar to CheckLogin, the behaviour if the user is not logged in can be optionally defined by an HTML element or React component that is passed into the component as an error property, shown as an ExampleError Component in following snippet.\nJavascript <RealmRole\n  realmRole='example-admin-role'\n  error={\n    <RoleError\n      message={'User do not have role : example-admin-role'}\n    />\n  }>\n  <div>Example admin role specific functionality</div>\n</RealmRole>","title":"RealmRole"},{"location":"/aas/csw-aas-js.html#source-code-for-realmrole-component","text":"RealmRole Component","title":"Source code for RealmRole component"},{"location":"/aas/csw-aas-js.html#technical-description","text":"See csw-aas-js Technical Description.","title":"Technical Description"},{"location":"/common/contract.html","text":"","title":"Service Contract"},{"location":"/common/contract.html#service-contract","text":"ESW Services Contract Event service Admin service Alarm service Logging service Sequencer service Agent service Sequence Manager Service CSW Services Contract Location service Command service Config service","title":"Service Contract"},{"location":"/common/response-handling.html","text":"","title":"Response Handling"},{"location":"/common/response-handling.html#response-handling","text":"","title":"Response Handling"},{"location":"/common/response-handling.html#patterns","text":"","title":"Patterns"},{"location":"/common/response-handling.html#how-to-handle-adt","text":"","title":"How to handle ADT"},{"location":"/common/response-handling.html#how-to-handle-normal-type-tbd-","text":"","title":"How to handle normal type (TBD)"},{"location":"/common/error-handling.html","text":"","title":"Error Handling"},{"location":"/common/error-handling.html#error-handling","text":"Most of the errors received from backend will be contained a defined shape ( Service error) that helps developer to build application based on the defined fields rather than depending on base browser’s Error type. Service’s api calls will be returning promise based results and network calls may go wrong for many reasons like server not found, some invalid configuration while setting up application, etc. all these cases are supposed to be handled at some places. For ex: some errors can be silently logged and redirect user to error page. At application level, error/exceptions must be handled in application code because that will help user to make further decisions. In TMT Arhcitecture, Service error captures all/most of the application level errors/exceptions.\nTo read more on exception handling, refer this document which gives detailed explanation.","title":"Error Handling"},{"location":"/common/error-handling.html#error-types","text":"","title":"Error Types"},{"location":"/common/error-handling.html#service-error","text":"TODO explaination\nType defination for Service Error here","title":"Service Error"},{"location":"/common/error-handling.html#client-side-error","text":"TODO explaination","title":"Client Side Error"},{"location":"/common/error-handling.html#handling-error-pattern","text":"The following examples shows how to call AgentService api’s and handle the response SpawnResponse and KillResponse.\nThis example also illustrates error handling of service specific exception AgentNotFoundException along with the generic errors like TransportError and ArithmeticException will look like.\nExploiting try-catch is an anti-pattern The example uses try-catch to handle errors and exceptions. Generally those errors/exceptions are handled at UI framework level on boundaries of service calls. This example will be updated once we have frontend framework setup in place.\nA function whose responsibility is to handle errors & exceptions\nTypescript // common function to handle error scenario's\nconst handleError = (err: Error) => {\n  if (err instanceof ServiceError) {\n    // depending on use case, error can be handled on following fields\n    //  - err.status      (5XX, 4XX, 3XX)\n    //  - err.errorType   (AgentNotFoundException, TransportError, ArithmeticException, NullPointerException, etc)\n\n    // Other fields present in error model\n    // err.message : contains the reason which can be used to show on UI\n    // err.statusText :  Forbidden , Unauthorised, BadRequest, Not Found, etc.\n\n    switch (err.errorType) {\n      case 'AgentNotFoundException':\n        console.log(err.message) // Location not found for $agentPrefix\n        console.log('do something on getting AgentNotFoundException')\n        break\n      case 'TransportError':\n        console.log(err.statusText)\n        console.log('do something on getting TransportError (4XX, 3XX, etc))')\n        break\n      case 'ArithmeticException':\n        console.log(err.statusText) // InternalServerError\n        console.log(err.message) // Reason : / by zero\n        break\n      default:\n        throw Error(err.message)\n    }\n  } else {\n    // client side error occurred at validations and operations before making api call to the server\n    // for ex: Prefix can throw runtime error if componentName is invalid.\n  }\n}\nExample for spawnSequenceManager api with error handling looks like following:\nTypescript // setup\nconst agentPrefix = new Prefix('ESW', 'agent1')\nconst obsModeConfigPath = '/obs-mode.conf'\nconst sequenceManagerVersion = '1.0.0'\n\ntry {\n  const spawnResponse: SpawnResponse = await agentService.spawnSequenceManager(\n    agentPrefix,\n    obsModeConfigPath,\n    false,\n    sequenceManagerVersion\n  )\n\n  // spawn response handling (200 status code)\n  switch (spawnResponse._type) {\n    case 'Spawned':\n      // do something on successful spawn operation\n      break\n    case 'Failed':\n      // do something on failed response\n      break\n  }\n} catch (err) {\n  handleError(err)\n}","title":"Handling Error pattern"},{"location":"/technical/index.html","text":"","title":"Technical Design Documentation"},{"location":"/technical/index.html#technical-design-documentation","text":"","title":"Technical Design Documentation"},{"location":"/technical/index.html#architectural-overview","text":"Following diagram explains UI application flow for making request to TMT backend component and explains where does the ESW-TS service fits in the whole TMT architecture.\nFor example: A web app specifically created for sending control command to a HCD component.\nUser clicks on submit button. Command Service of ESW-TS creates appropriate payload adhering to service contract exposed by GatewayServer ESW-TS service uses fetch api of browser to make request. Gateway Server on receiving correct payload, process it and sends the Control command to the destined HCD component. On successfully handling of command by HCD component, GatewayServer returns a SuccessResponse. esw-ts handles the response and returns it, as it was received to the caller web-ui component or in case of error throw’s ServiceError.","title":"Architectural overview"},{"location":"/services/agent-service/agent-service.html","text":"","title":"Agent Service"},{"location":"/services/agent-service/agent-service.html#agent-service","text":"Agent service provides HTTP interface to interact with all agent machines uniquely located using agent prefix. APIs to spawn components takes agent prefix as parameter. Agent prefix is used to locate agent machine using location service.\nAgent service provides APIs to spawn sequence manager, sequence components and to kill spawned components.","title":"Agent Service"},{"location":"/services/agent-service/agent-service.html#creation-of-agent-service","text":"","title":"Creation of Agent Service"},{"location":"/services/agent-service/agent-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/services/agent-service/agent-service.html#in-order-to-use-agent-service-apis-","text":"Agent machines should be up and running. Locations of agent machines should be registered in Location Service. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"In order to use agent service APIs:"},{"location":"/services/agent-service/agent-service.html#to-create-agent-client-","text":"Typescript const tokenFactory = () => auth.token\n\nconst agentService: AgentService = await AgentService(tokenFactory)\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"To create Agent client:"},{"location":"/services/agent-service/agent-service.html#usages-of-agent-service","text":"Type definitions for All Agent Service APIs can be found here","title":"Usages of Agent Service"},{"location":"/services/agent-service/agent-service.html#spawning-a-sequence-manager","text":"Agent Service requires agent(a component of type :Machine) to be able to process requests. once it locates an agent using location service with the help of agent prefix, it sends a spawn sequence manager command to the agent machine. The corresponding api call fails If the Sequence Manager is already running, or the underlying agent fails to spawn it.\nTypescript const agentPrefix = new Prefix('ESW', 'agent1')\nconst obsModeConfigPath = '/obs-mode.conf'\nconst sequenceManagerVersion = '1.0.0'\n\nconst spawnResponse1: SpawnResponse = await agentService.spawnSequenceManager(\n  agentPrefix,\n  obsModeConfigPath,\n  false,\n  sequenceManagerVersion\n)","title":"Spawning a Sequence Manager"},{"location":"/services/agent-service/agent-service.html#spawning-a-sequence-component","text":"Similar to spawning a Sequence Manager, Agent service locates an agent then it sends a spawn sequence component command to the agent machine. the corresponding api call fails If the Sequence Component is already running, or the underlying agent fails to spawn it.\nTypescript const ocsAppVersion = '1.2.1'\nconst spawnResponse2: SpawnResponse = await agentService.spawnSequenceComponent(\n  agentPrefix,\n  'component1',\n  ocsAppVersion\n)","title":"Spawning a Sequence Component"},{"location":"/services/agent-service/agent-service.html#kill-component","text":"Agent service kills any process running on the agent machine using the process id (pid) of that component. it uses location service to find the process id from the metadata field of location information.\nTypescript const compPrefix = new Prefix('ESW', 'SomeComponent')\nconst componentToBeKilled = new ComponentId(compPrefix, 'Service')\nconst killResponse: KillResponse = await agentService.killComponent(\n  componentToBeKilled\n)","title":"Kill Component"},{"location":"/services/sequence-manager/sequence-manager-service.html","text":"","title":"Sequence Manager Service"},{"location":"/services/sequence-manager/sequence-manager-service.html#sequence-manager-service","text":"The Sequence Manager Service manages all the operation related to the observations. It manages all sequence components and sequencers required for the observations.\nSequence Manager service has following APIs:\nAPI Input args Returns configure obsMode ConfigureResponse provision config ProvisionResponse getRunningObsModes GetRunningObsModesResponse startSequencer subsystem, obsMode StartSequencerResponse restartSequencer subsystem, obsMode RestartSequencerResponse shutdownSequencer subsystem, obsMode ShutdownSequencersResponse shutdownSubsystemSequencers subsystem ShutdownSequencersResponse shutdownObsModeSequencers obsMode ShutdownSequencersResponse shutdownAllSequencers ShutdownSequencersResponse shutdownSequenceComponent prefix ShutdownSequenceComponentResponse shutdownAllSequenceComponents ShutdownSequenceComponentResponse getAgentStatus AgentStatusResponse","title":"Sequence Manager Service"},{"location":"/services/sequence-manager/sequence-manager-service.html#creation-of-sequence-manager-service","text":"","title":"Creation of Sequence Manager Service"},{"location":"/services/sequence-manager/sequence-manager-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/services/sequence-manager/sequence-manager-service.html#in-order-to-create-sequence-manager-service-apis-","text":"Subsystem’s agent machines should be up and running. Sequence Manager should be spawned. Documentation on how to spawn sequence manager could be found here. Authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"In order to create sequence manager service APIs:"},{"location":"/services/sequence-manager/sequence-manager-service.html#to-create-sequence-manager-client-","text":"Typescript const tokenFactory = () => auth.token\nconst sequenceManagerService: SequenceManagerService = await SequenceManagerService(\n  tokenFactory\n)","title":"To create Sequence Manager client:"},{"location":"/services/sequence-manager/sequence-manager-service.html#apis","text":"","title":"APIs"},{"location":"/services/sequence-manager/sequence-manager-service.html#configure","text":"It starts sequencers needed for an observation mode. Before starting sequencer, it checks for resource conflict between requested observation mode and running observation mode. The required sequencers and resources are listed in obsModeConfig file provided at boot up time of sequence manager. It returns ConflictingResourcesWithRunningObsMode if required resources are not available. This API returns response containing Success as ConfigureResponse after successful start of all required sequencers.\nThe following example shows how to call configure API. Here machines will be setup for ‘IRIS_DarkNight’ observation mode.\nTypescript const obsMode = new ObsMode('IRIS_DarkNight')\nconst configureResponse: ConfigureResponse = await sequenceManagerService.configure(\n  obsMode\n)","title":"configure"},{"location":"/services/sequence-manager/sequence-manager-service.html#provision","text":"This API shutdowns all the running sequence components and provisions the new sequence components in accordance with the provided configuration. The configuration specifies number of sequence components needed to be spawned on a particular agent. It returns Success as ProvisionResponse after successful spawning of components.\nIn following example, three sequence components will be spawned on ‘ESW.agent-machine’ agent machine and two sequence component will be spawned on ‘IRIS.agent-machine’ agent machine.\nTypescript const eswAgentPrefix = new Prefix('ESW', 'agent-machine')\nconst irisAgentPrefix = new Prefix('IRIS', 'agent-machine')\nconst eswAgentProvisionConfig = new AgentProvisionConfig(eswAgentPrefix, 3)\nconst irisAgentProvisionConfig = new AgentProvisionConfig(irisAgentPrefix, 2)\nconst provisionConfig = new ProvisionConfig([\n  eswAgentProvisionConfig,\n  irisAgentProvisionConfig\n])\n\nconst provision: ProvisionResponse = await sequenceManagerService.provision(\n  provisionConfig\n)","title":"provision"},{"location":"/services/sequence-manager/sequence-manager-service.html#getrunningobsmodes","text":"This API returns all the running observation modes.\nThe following example shows how to call getRunningObsModes API :\nTypescript const obsModes: GetRunningObsModesResponse = await sequenceManagerService.getRunningObsModes()","title":"getRunningObsModes"},{"location":"/services/sequence-manager/sequence-manager-service.html#startsequencer","text":"This API starts the sequencer for given subsystem and observation mode. It uses the subsystem’s sequence component, if not available, fallbacks to ESW sequence component.\nThe following example shows how to call startSequencer API :\nTypescript const startSequencerResponse: StartSequencerResponse = await sequenceManagerService.startSequencer(\n  'IRIS',\n  obsMode\n)","title":"startSequencer"},{"location":"/services/sequence-manager/sequence-manager-service.html#restartsequencer","text":"It restarts the existing running sequencer of given subsystem and observing mode.\nThe following example shows how to call restartSequencer API :\nTypescript const restartSequencerResponse: RestartSequencerResponse = await sequenceManagerService.restartSequencer(\n  'IRIS',\n  obsMode\n)","title":"restartSequencer"},{"location":"/services/sequence-manager/sequence-manager-service.html#shutdownsequencer","text":"This API shutdowns the running sequencer of given subsystem and observation mode.\nThe following example shows how to call shutdownSequencer API :\nTypescript const shutdownSequencerResponse: ShutdownSequencersResponse = await sequenceManagerService.shutdownSequencer(\n  'IRIS',\n  obsMode\n)","title":"shutdownSequencer"},{"location":"/services/sequence-manager/sequence-manager-service.html#shutdownsubsystemsequencers","text":"This API shutdowns all the running sequencers of given subsystem.\nThe following example shows how to call shutdownSubsystemSequencers API :\nTypescript const shutdownSubsystemSeqResponse: ShutdownSequencersResponse = await sequenceManagerService.shutdownSubsystemSequencers(\n  'IRIS'\n)","title":"shutdownSubsystemSequencers"},{"location":"/services/sequence-manager/sequence-manager-service.html#shutdownobsmodesequencers","text":"This API shutdowns all the running sequencers of given observation mode.\nThe following example shows how to call shutdownObsModeSequencers API :\nTypescript const shutdownObsModeSeqResponse: ShutdownSequencersResponse = await sequenceManagerService.shutdownObsModeSequencers(\n  obsMode\n)","title":"shutdownObsModeSequencers"},{"location":"/services/sequence-manager/sequence-manager-service.html#shutdownallsequencers","text":"This API shutdowns all the running sequencers.\nThe following example shows how to call shutdownAllSequencers API :\nTypescript const shutdownAllSequencersResponse: ShutdownSequencersResponse = await sequenceManagerService.shutdownAllSequencers()","title":"shutdownAllSequencers"},{"location":"/services/sequence-manager/sequence-manager-service.html#shutdownsequencecomponent","text":"This API shutdowns sequence component with provided prefix.\nThe following example shows how to call shutdownSequenceComponent API :\nTypescript const seqCompPrefix = new Prefix('ESW', 'ESW.ESW_1')\nconst shutdownSeqCompResponse: ShutdownSequenceComponentResponse = await sequenceManagerService.shutdownSequenceComponent(\n  seqCompPrefix\n)","title":"shutdownSequenceComponent"},{"location":"/services/sequence-manager/sequence-manager-service.html#shutdownallsequencecomponents","text":"This API shutdowns all the sequence components.\nThe following example shows how to call shutdownAllSequenceComponents API :\nTypescript const shutdownAllSeqCompResponse: ShutdownSequenceComponentResponse = await sequenceManagerService.shutdownAllSequenceComponents()","title":"shutdownAllSequenceComponents"},{"location":"/services/sequence-manager/sequence-manager-service.html#getagentstatus","text":"This API allows showing status of TMT ecosystem components (agents, sequence components and sequencers). It returns all agents that are up and running, sequence components running on those agents and sequencer script loaded on sequence component.\nThe following example shows how to call getAgentStatus API :\nTypescript const agentStatus: AgentStatusResponse = await sequenceManagerService.getAgentStatus()","title":"getAgentStatus"},{"location":"/technical/csw-aas-js.html","text":"","title":"csw-aas-js - Javascript adapter"},{"location":"/technical/csw-aas-js.html#csw-aas-js-javascript-adapter","text":"csw-aas-js is a npm package which exposes react components to enable authentication and authorization. csw-aas-js is built in typescript on top of keycloak-js which is javascript adapter provided by keycloak.","title":"csw-aas-js - Javascript adapter"},{"location":"/technical/csw-aas-js.html#csw-aas-js-implementation","text":"Core implementation of csw-aas-js uses\nkeycloak-js - keycloak javascript adapter React - JavaScript library for building user interfaces Typescript - Types superset of JavaScript which compiles to JavaScript csw-location-service - resolve keycloak using location service http endpoint","title":"csw-aas-js Implementation"},{"location":"/technical/csw-aas-js.html#project-setup","text":"csw-aas-js is a library written in Typescript. tsc is a command line compiler of Typescript which compiles typescrit files to JavaScript. tsc picks up configurations from tsconfig.json file which is at root level of project. tsconfig.json allows to configure multiple compiler options. Please refer this for details of compiler options. npm run build command will run tsc which will produce outputs (.js and .d.ts). .d.ts files are the type declaration files which provide typings for react components exported by library. package.json points to index.ts as a entry point for library and index.d.ts as types. This will help csw-aas-js library users to know type signatures of components. e.g. type signature for react component props, api signatures. csw-aas-js can be seamlessly consumed by applications written ES6 or Typescript.","title":"Project setup"},{"location":"/technical/csw-aas-js.html#keycloak","text":"In order for web application utilize keycloak following steps are needed:\nRegistered web application as a public keycloak client Please refer to keycloak documentation for details. Create new Keycloak client instance This instantiation expects config which includes keycloak server url and some application specific config like realm and clientId. csw-aas-js uses csw location service to resolve keycloak server.\nJavascript export const AppConfig = {\n  realm: 'TMT',\n  clientId: 'tmt-frontend-app',\n  applicationName: 'test-app'\n}\nInitialize javascript adapter To call secure end point, web application first needs to be authenticated using keycloak server. There are two options to make this adapter automatically authenticate - login-required and check-sso. login-required will automatically authenticate if the user is already logged-in, otherwise it will display keycloak login page. check-sso will only authenticate if the user is already logged-in. If the user is not logged-in the browser will be redirected back to the application and remain unauthenticated.\ncsw-aas-js use check-sso to instantiate keycloak. It shows secure components if user is already logged in. If user is not authenticated Login component is rendered. If user clicks on login button it instantiates keyclock use login-required. This redirects user to keycloak login page. As access token has very short life span, at time of keycloak instantiation csw-aas-js also adds hooks to refresh token. This gives seamless user experience as user need not to login again.\nKeycloak adapter supports three authorization flows e.g. authorization code flow, implicit flow and hybrid flow. csw-aas-js has chosen hybrid flow as it has better performance than authorization code flow and unlike implicit flow, hybrid flow makes refresh token available to application. For more information please refer keyclok documentaion for authorization flows","title":"Keycloak"},{"location":"/technical/csw-aas-js.html#working-of-csw-aas-js","text":"When user opens web application in browser, AuthContextProvider component is mounted. Which does instantiation of keycloak client and initialize keycloak javascript adapter with check-sso and hybrid authorization flow. It also creates hooks for refreshing token when token is expired which silently refresh token resulting seamless user experience once logged in. After authentication is done via keycloak javascript adapter, AuthContext is extracted in domain model and this data is passed down the component tree using react context api. AuthContext gives handle to token, realm and resource roles, userInfo. Any component which want to use this information can become consumer of AuthContext. For example\nJavascript const { auth } = useContext(authContext)\nAccess token can be extracted from auth and it can be sent in Authorization header for calling secure api\nFor example -\nconst SampleComponent = () => {\n\n    const url = 'http://localhost:8080/secure-restful-service';\n    const auth = useContext(AuthContext) //AuthContext from csw-aas-js\n\n    const req = new XMLHttpRequest();\n    req.open('GET', url, true);\n    req.setRequestHeader('Accept', 'application/json');\n\n    //extract token from auth context and set Authorization header\n    req.setRequestHeader('Authorization', 'Bearer ' + auth.token);\n\n    req.onreadystatechange = function () {\n        if (req.readyState == 4) {\n            if (req.status == 200) {\n                alert('Success');\n            } else if (req.status == 403) {\n                alert('Forbidden');\n            }\n        }\n    }\n\n    req.send();\n};\nFollowing diagram explains javascript application flow for making request to secure http api\nWhen user opens web application in browser, csw-aas-js checks if user is already logged in using check-sso mode. If user is not logged in then Login button is shown. When user clicks on login, user will be redirected to keyclok login page. This completes authentication process. Once authentication is done, AuthContextProvider extract AuthContext domain model and make it available to consumers of AuthContext. Protected react components can be shown based on information in AuthContext. For example, CreateConfig component can be shown only to users having config admin role. After the user is authenticated the application can make requests to RESTful services secured by Keycloak by including the bearer token in the Authorization header. This completed workflow for web application calling secure http endpoint.","title":"Working of csw-aas-js"},{"location":"/common/ts-docs.html","text":"","title":"Type Definations"},{"location":"/common/ts-docs.html#type-definations","text":"Type definations for following can be found by their corresponding links:\nAll Services React Components App Configurations Models","title":"Type Definations"}]}