{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"TMT JavaScript/Typescript Library"},{"location":"/index.html#tmt-javascript-typescript-library","text":"ESW-TS is a Javascript/Typescript library for building web applications for TMT Observatory that use CSW Services.","title":"TMT JavaScript/Typescript Library"},{"location":"/index.html#library-contents","text":"User Interfaces in ESW and TMT ESW.UISTD and ESW.HCMS User Interface Support in ESW Phase 1 User Interface Responsibilities of ESW Motivation Behind ESW-TS How to use ESW-TS Getting Started with ESW-TS Installation Create a Starter Project UI App Configuration for ESW-TS UI App Deployment for ESW-TS Params Commands ObsId Prefix CommandName Setup Command Observe Command Wait Command Unique Key constraint Events EventTime System Event Observe Event Unique Key Constraint Keys and Parameters How to create a Parameter using the helper functions Result Subsystem List of Subsystems Usage Examples State variables CurrentState Units Default Units for Keys SI Units CGS Units Astrophysical Units Imperial Units Others - Engineering Time units Usage Examples Auth Components Application Configuration Components AuthContextProvider Consumer Login Logout CheckLogin RealmRole Example Technical Description Response Handling in ESW-TS Asynchronous Programming Error Handling in ESW-TS Error Types Service Error Client Side Error Error Handling pattern Services Admin Service Creation of Admin Service Usages of Admin Service Fetching LogMetadata & Setting log level Component & Container level actions Querying lifecycle states of Component & Container Alarm Service Creation of Alarm Service Usages of Alarm Service Setting alarm Severity Command Service Creation of Command Service Type of Actions Control Commands Usages of Command Service Validating command Submitting commands Submit And Wait for Response Submit Multiple commands and Wait Sending Oneway Command Querying Result Querying for Final result SubscribeCurrentState Config Service Rules and Checks Model Classes Pre-requisite Creation of Config Service Usages of Config Service Creating File Updating File Fetching Files Checking file existence Deleting File Listing files Fetching revision history of a file Getting Config Service Metadata Managing active versions Event Service Pre-requisite Creation of Event Service Usages of Event Service Publishing an Event Get Events Subscribe to the Events Location Service Creation of Location Service Usages of Location Service Listing & Filtering Locations Resolving Connection Unregister a Connection Tracking Connection Logging Service Pre-requisite Creation of Logging Service APIs Usages of Logging Service Creating Log for an incident Technical Design Documentation Architectural overview Agent Service Creation of Agent Service Usages of Agent Service Spawning a Sequence Manager Spawning a Sequence Component Kill a Sequence Component Getting Agent Status Sequencer Service Creation of Sequencer Service Creating SequenceCommands Creating a Sequence Usages of Sequencer Service Sequence Manager Service Creation of Sequence Manager Service Usages of Sequence Manager Service Configuring Resources Provisioning Getting ObsModes Details Starting a Sequencer Shutting down Sequencers Shutting down Sequence Components Getting Resources Status Auth Components Implementation Keycloak Working of Auth Components Service Contract Type Definitions","title":"Library Contents"},{"location":"/UIOverview.html","text":"","title":"User Interfaces in ESW and TMT"},{"location":"/UIOverview.html#user-interfaces-in-esw-and-tmt","text":"TMT has an OAD requirement for graphical user interfaces as the standard style for user interfaces. The CSW technical choice for graphical user interfaces is the web platform consisting of the web browser as the host for the user interface and web technologies based on JavaScript along with HTTP, and CSS, etc. Most UI innovation and development at this time is based on these technologies and there is no apparent change in sight, so this decision continues to make sense. One other big advantage of the browser-based UI is that it can provide an easy solution for remote access in many situations. The entire reason for web technologies is to provide remote access to systems and services.","title":"User Interfaces in ESW and TMT"},{"location":"/UIOverview.html#esw-uistd-and-esw-hcms","text":"TMT Observatory will use many web applications to observe and manage the observatory instruments and telescope systems. User interfaces can be grouped into two categories: observing user interfaces and engineering user interfaces. High-level Control and Monitoring (HCMS) is the ESW subsystem that provides the observing user interfaces to be used by the staff and visitors to control the telescope and other systems, monitor their status and behavior, and to perform observations that generate science data. Engineering user interfaces are the responsibility of the subsystem teams, but these user interfaces also use the technology choices and support provided by ESW.\nESW’s User Interface Standards (UISTD) subsystem provides the architectural solution for this technical problem. UISTD also provides glue code for the JavaScript-based environment that is used by UI builders to access CSW services along with examples. UISTD provides style and layout guidelines and standards (look-and-feel) with examples that demonstrate the guidelines. UISTD also provides UI components that demonstrate common usage of CSW glue code (TBD as needed).","title":"ESW.UISTD and ESW.HCMS"},{"location":"/UIOverview.html#user-interface-support-in-esw-phase-1","text":"The development of ESW was split into two phases called Phase 1 and Phase 2. Phase 1, which is currently in development, delivers products and features that other subsystems need from ESW. ESW Phase 2 will execute in the future covering the rest of ESW at a more leisurely pace.","title":"User Interface Support in ESW Phase 1"},{"location":"/UIOverview.html#user-interface-responsibilities-of-esw","text":"The following bullet items summarize the responsibilities of UISTD and HCMS and whether they are part of Phase 1 or Phase 2.\nProvide JavaScript-based glue code running in the browser providing access to CSW services needed by user interfaces (UISTD–ESW-TS) (Phase 1). Provide a gateway/bridge infrastructure that connects the browser-based user interfaces to the JVM-based services and components (UISTD) (Phase 1). Provide examples of glue code and user interface standards (UISTD) (Phase 2). Provide style and layout guidelines for standardized user interface look and feel (UISTD) (Phase 2) Provide browser-based user interfaces required by the support staff for control and monitoring of the telescope and instrument systems (HCMS) (Phase 2).\nESW-TS is the glue library that satisfies the first bullet in the list above. ESW-TS is one part of the solution for TMT user interfaces, but it is an important part that provides a way for teams to get started now making browser-based user interfaces that access TMT control system Assemblies, HCDs, and even Sequencers.","title":"User Interface Responsibilities of ESW"},{"location":"/UIOverview.html#motivation-behind-esw-ts","text":"The first step is to provide access from the browser to the components in the control system. ESW-TS provides this access as a set of APIs that are closely tied to the CSW service APIs using similar names and concepts.\nESW-TS is a TypeScript-based library. TypeScript is a very popular library that extends JavaScript by adding types. Types in TypeScript help to make JavaScript a bit more reliable by providing type-checking without adding new features or extending the language.\nThe ESW-TS library can be used to create front-end user interfaces that use the User Interface Application Gateway (UIAG) to access control system components. See UIAG in ESW for more information. ESW-TS can also be used with hybrid user interfaces. See here for the more information. two user interface types.\nThe ESW-TS library manages the complexity associated with interfacing the CSW service calls to the browser environment. All the issues related to HTTP, serialization of objects, and interacting with the protocols of CSW are managed by the ESW-TS library. These services provided by the ESW-TS library make it easier for UI developers to develop a web app without having to worry about programming details of the TMT backend UIAG.\nESW-TS provides APIs for CSW services from a user interface. Not all CSW services are included in ESW-TS. For most provided CSW services, the APIs have been limited to methods that make sense for a UI.\nESW-TS library is available on npm registry.","title":"Motivation Behind ESW-TS"},{"location":"/UIOverview.html#how-to-use-esw-ts","text":"For using ESW-TS library, you will need to have some kind of model which determines the flow of creating the web application in the first place and which TMT backend services the application will be using in its lifetime.\nDefine your application features / components. Depending on those features, decide which services will be required to build them from the available services. Develop & build application components on top of the service.\nWhile using many of the services, you will be required to use some ESW-TS models for making API requests and CSW domain models like (Prefix, ComponentId, etc) that are provided in the ESW-TS to ease the development of a web application.\nAt this point in UISTD development, some choices must be made to create a complete UI. At this time we recommend using the following additional tools and libraries to make a TypeScript based UI.\nReact Ant Design Snowpack Jest React Testing Library","title":"How to use ESW-TS"},{"location":"/common/getting-started.html","text":"","title":"Getting Started with ESW-TS"},{"location":"/common/getting-started.html#getting-started-with-esw-ts","text":"In this tutorial, you’ll see how to create a UI starter project using a giter8 template which uses ESW-TS library. You can use this as a starting point for your own UI applications.","title":"Getting Started with ESW-TS"},{"location":"/common/getting-started.html#installation","text":"node is mandatory to be installed on a machine for using ESW-TS. To install the latest version of node, visit the official website.","title":"Installation"},{"location":"/common/getting-started.html#create-a-starter-project","text":"It is recommended to use Giter8 template esw-ui-template.g8 to get started with building web application. Follow readme.md for more details on how to use the template to create starter project. ESW-TS comes pre-packaged as a dependency in the template.\nIf you already have a UI application and want to add ESW-TS dependency, then\nTo install the latest version of ESW-TS from npm\nnpm install @tmtsoftware/esw-ts\nOr, to install a specific version\nnpm install @tmtsoftware/esw-ts@{version}","title":"Create a Starter Project"},{"location":"/common/getting-started.html#ui-app-configuration-for-esw-ts","text":"If you have used esw-ui-template.g8 template for generating the application source code. Template generates a AppConfig.js file in src/config/AppConfig.js. It has applicationName that you provided while creating template. if you wish to change your application name this is the place where you can change it. Note that this change effects metrics & the deployment time folder name.\nNote: ESW-TS library will try to load this applicationName before making any backend service calls. AppConfig.\nTypescript copysource// inside App.tsx\n\nsetAppName('ocs-application')\n\nexport default () => <div>{/* children components */}</div>","title":"UI App Configuration for ESW-TS"},{"location":"/common/getting-started.html#ui-app-deployment-for-esw-ts","text":"Applications that are built using ui-template.g8 are meant to be deployed under one common folder /apps. this folder will contain all tmt ui applications which can be together deployed using any static server(nginx, python http server, s3 static server, etc).\nESW-TS assumes that static server contains a config.js file which has configuration related to all applications.\nAs of now, ESW-TS loads locationUrl using this file to create LocationService instance. In future if needed, other configuration can be added here which are applicable to all tmt applications.\nconfig.js file looks like this.\nexport const config = { locationUrl: 'https://locationService.tmt.org' }\nNote:\nWithout this file, Application won’t be able to communicate to tmt backend service’s. Folder name of the application which is getting copied at the static server should have exactly same name as it is in the AppConfig.js’s applicationName field. (g8 template by default takes care of this, only if you wish to change your application name, Make a note of this configuration).","title":"UI App Deployment for ESW-TS"},{"location":"/params/index.html","text":"","title":"Params"},{"location":"/params/index.html#params","text":"In the distributed environment of TMT observatory, Components communicate with each other by sending asynchronous Messages. These messages have a Command payload, which flows down through the Sequencer components to the Assemblies, HCDs and finally to the hardware. At each hop Commands are validated, interpreted and further propagated making their journey to its destination. Commands provide flexible placeholders to store values to convey precise intent of the sender component.\nParams module plays a significant role as it caters to the diverse communication requirements. Consumer of this module will be able to create Commands, Events, States to store ParameterSets.\nParams has following models :\nCommands ObsId Prefix CommandName Setup Command Observe Command Wait Command Unique Key constraint Events EventTime System Event Observe Event Unique Key Constraint Keys and Parameters How to create a Parameter using the helper functions Result Subsystem List of Subsystems Usage Examples State variables CurrentState Units Default Units for Keys SI Units CGS Units Astrophysical Units Imperial Units Others - Engineering Time units Usage Examples\nType definition for all common models used by services can be found here","title":"Params"},{"location":"/params/commands.html","text":"","title":"Commands"},{"location":"/params/commands.html#commands","text":"Commands are parameter sets called Setup, Observe, and Wait. A command is created with the source of the command, given by a prefix, the name of the command, and an optional ObsId. Parameters are added to the command as needed.","title":"Commands"},{"location":"/params/commands.html#obsid","text":"An ObsID, or observation ID, indicates the observation the command is associated with. It is a simple string.\nTypescript copysourceconst obsId: string = 'Obs001'","title":"ObsId"},{"location":"/params/commands.html#prefix","text":"The source of the command is given by the prefix, which should be the full name of the component sending the command. A prefix can be constructed with a string, but must start with a valid subsystem as in Subsystem. A component developer should supply a valid prefix string and the subsystem will be automatically parsed from it. An example of a valid string prefix is “nfiraos.ncc.trombone”.\nType definition can be found @here\nSee below examples:\nTypescript copysourceconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')","title":"Prefix"},{"location":"/params/commands.html#commandname","text":"Each command has a name given as a string. The string should be continuous with no spaces.","title":"CommandName"},{"location":"/params/commands.html#setup-command","text":"This command is used to describe a goal that a system should match. The component developer is required to supply following arguments to create a Setup command.\nPrefix: the source of the command as described above CommandName: a simple string name for the command (no spaces) ObsId: an optional observation id. paramSet: Optional Set of Parameters. Default is empty.\nType definition for Setup Command can be found here\nTypescript copysourceconst obsId: string = 'Obs001'\nconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')\nconst commandName = 'move'\nconst filterKey = intArrayKey('filter')\nconst filterParam: Parameter<IntArrayKey> = filterKey.set([\n  [1, 2, 3],\n  [4, 5, 6]\n])\n\nconst setup: Setup = new Setup(prefix, commandName, [filterParam], obsId)","title":"Setup Command"},{"location":"/params/commands.html#observe-command","text":"This command describes a science observation. It is intended to be sent only to Science Detector Assemblies and Sequencers.\nType definition for Observe Command can be found here\nTypescript copysourceconst obsId: string = 'Obs001'\nconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')\nconst commandName = 'move'\nconst filterKey = intArrayKey('filter')\nconst filterParam: Parameter<IntArrayKey> = filterKey.set([\n  [1, 2, 3],\n  [4, 5, 6]\n])\n\nconst observe: Observe = new Observe(prefix, commandName, [filterParam], obsId)","title":"Observe Command"},{"location":"/params/commands.html#wait-command","text":"This command causes a Sequencer to wait until notified. It can only be sent to Sequencers.\nType definition for Wait Command can be found here\nTypescript copysourceconst obsId: string = 'Obs001'\nconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')\nconst commandName = 'move'\nconst filterKey = intArrayKey('filter')\nconst filterParam: Parameter<IntArrayKey> = filterKey.set([\n  [1, 2, 3],\n  [4, 5, 6]\n])\n\nconst wait: Wait = new Wait(prefix, commandName, [filterParam], obsId)","title":"Wait Command"},{"location":"/params/commands.html#unique-key-constraint","text":"By design, a ParameterSet in a Setup, Observe, or Wait command is optimized to store only unique keys. When using add or madd methods on commands to add new parameters, if the parameter being added has a key which is already present in the paramSet, the already stored parameter will be replaced by the given parameter.\nNote If the Set is created by component developers and given directly while creating a command, then it will be the responsibility of component developers to maintain uniqueness with parameters based on key.\nHere are some examples that illustrate this point:\nTypescript copysourceconst obsId: string = 'Obs001'\nconst prefix: Prefix = new Prefix('NFIRAOS', 'ncc.trombone')\nconst commandName = 'move'\nconst filterKey = intArrayKey('filter')\nconst randomKey = stringKey('directions')\nconst filterParam: Parameter<IntArrayKey> = filterKey.set([[1, 2, 3]])\nconst param1 = randomKey.set(['east', 'west'])\nconst param2 = randomKey.set(['north', 'south'])\n\nconst wait: Wait = new Wait(prefix, commandName, [filterParam], obsId)\nwait.madd([param1, param2])\n\n//duplicate keys will not be added. Should contain one randomKey and one Filter key\nwait.paramSet.forEach((x) => console.log(x.keyName))","title":"Unique Key constraint"},{"location":"/params/events.html","text":"","title":"Events"},{"location":"/params/events.html#events","text":"Events are the most basic type of asynchronous notification in TMT when an activity occurs somewhere in the TMT system and other components need to be notified. Each type of event has a unique purpose and unique information, but they all share the same structural features. All events have EventInfo and a ParameterSet.\nType definition for Event can be found here","title":"Events"},{"location":"/params/events.html#eventtime","text":"Each event includes its time of creation in UTC format. You can access that eventTime as follows:\nTypescript copysourceconst source = new Prefix('IRIS', 'filter.wheel')\nconst eventName = new EventName('temperatures')\nconst event = SystemEvent.make(source, eventName)\n\n// accessing eventTime\nconst eventTime = event.eventTime","title":"EventTime"},{"location":"/params/events.html#system-event","text":"SystemEvent is the type used to describe the majority of events in the system. An example is a demand that is the output of an algorithm in one component that is used as an input to another. SystemEvent is also used to publish internal state or status values of a component that may be of interest to other components in the system.","title":"System Event"},{"location":"/params/events.html#example-snippets-for-creation-of-system-event","text":"Typescript copysource//keys\nconst k1 = intKey('encoder')\nconst k2 = intKey('speed')\nconst k3 = stringKey('filter')\nconst k4 = intKey('notUsed')\n\n//prefixes\nconst ck1 = Prefix.fromString('wfos.red.filter')\nconst name1 = new EventName('filterWheel')\nconst ck3 = Prefix.fromString('iris.imager.filter')\nconst name3 = new EventName('status')\n\n//parameters\nconst p1: Parameter<IntKey> = k1.set([22])\nconst p2: Parameter<IntKey> = k2.set([44])\nconst p3: Parameter<StringKey> = k3.set(['A', 'B', 'C', 'D'])\n\n//Create SystemEvent using madd\nconst se1: SystemEvent = SystemEvent.make(ck1, name1).madd([p1, p2])\n//Create SystemEvent using make\nconst se2: SystemEvent = SystemEvent.make(ck3, name3, [p1, p2])\n//Create SystemEvent and use add\nconst se3: SystemEvent = SystemEvent.make(ck3, name3).add(p1).add(p2).add(p3)\n\n//access keys\nconst k1Exists: Boolean = se1.exists(k1) //true\n\n//access Parameters\nconst p4: Option<Parameter<IntKey>> = se1.get(k1)\n\n//access values\nconst v1: Option<number[]> = se1.get(k1)?.values\nconst v2: Option<number[]> = se2.get(k2)?.values\n\n//remove keys\nconst se4: SystemEvent = se3.remove(k3)\n\n//add more than one parameters, using madd\nconst se5: SystemEvent = se4.madd([k3.set(['X', 'Y', 'Z']), k4.set([99, 100])])\nconst paramSize: number = se5.size()\n\n//update existing key with set\nconst se6: SystemEvent = se5.add(k2.set([5, 6, 7, 8]))","title":"Example snippets for creation of System Event"},{"location":"/params/events.html#observe-event","text":"ObserveEvent are standardized events used to describe the activities within the data acquisition process. These events are typically published by Science Detector Assemblies, which emit ObserveEvents during their exposures to signal the occurrence of specific activities/actions during the acquisition of data.","title":"Observe Event"},{"location":"/params/events.html#example-snippets-for-creation-of-observe-event","text":"Typescript copysource //keys\nconst k1 = intKey('readoutsCompleted')\nconst k2 = intKey('coaddsCompleted')\nconst k3 = stringKey('fileID')\nconst k4 = intKey('notUsed')\n\n//prefixes\nconst ck1 = Prefix.fromString('iris.ifu.detectorAssembly')\nconst name1 = new EventName('readoutEnd')\nconst ck3 = Prefix.fromString('wfos.red.detector')\nconst name3 = new EventName('exposureStarted')\n\n//parameters\nconst p1: Parameter<IntKey> = k1.set([4])\nconst p2: Parameter<IntKey> = k2.set([2])\nconst p3: Parameter<StringKey> = k3.set(['WFOS-RED-0001'])\n\n//Create ObserveEvent using madd\nconst se1: ObserveEvent = ObserveEvent.make(ck1, name1).madd([p1, p2])\n//Create ObserveEvent using apply\nconst se2: ObserveEvent = ObserveEvent.make(ck3, name3, [p1, p2])\n//Create ObserveEvent and use add\nconst se3: ObserveEvent = ObserveEvent.make(ck3, name3).add(p1).add(p2).add(p3)\n\n//access keys\nconst k1Exists: Boolean = se1.exists(k1) //true\n\n//access Parameters\nconst p4: Option<Parameter<IntKey>> = se1.get(k1)\n\n//access values\nconst v1: Option<number[]> = se1.get(k1)?.values\nconst v2: Option<number[]> = se2.get(k2)?.values\n\n//remove keys\nconst se4: ObserveEvent = se3.remove(k3)","title":"Example snippets for creation of Observe Event"},{"location":"/params/events.html#unique-key-constraint","text":"By choice, a ParameterSet in either ObserveEvent or SystemEvent event will be optimized to store only unique keys. When using add or madd methods on events to add new parameters, if the parameter being added has a key which is already present in the paramSet, the already stored parameter will be replaced by the given parameter.\nNote If the Set is created by component developers and given directly while creating an event, then it will be the responsibility of component developers to maintain uniqueness with parameters based on key.","title":"Unique Key Constraint"},{"location":"/params/events.html#here-are-some-examples-that-illustrate-this-point","text":"Typescript copysource//keys\nconst encoderKey = intKey('encoder')\nconst filterKey = intKey('filter')\nconst miscKey = intKey('misc')\n\n//prefix\nconst prefix = Prefix.fromString('wfos.blue.filter')\n\nconst name1 = new EventName('filterWheel')\n\n//params\nconst encParam1 = encoderKey.set([1])\nconst encParam2 = encoderKey.set([2])\n\nconst encParam3 = encoderKey.set([3])\nconst filterParam1 = filterKey.set([1])\nconst filterParam2 = filterKey.set([2])\n\nconst filterParam3 = filterKey.set([3])\n\nconst miscParam1 = miscKey.set([100])\n//StatusEvent with duplicate key via constructor\nconst systemEvent = SystemEvent.make(prefix, name1, [\n  encParam1,\n  encParam2,\n  encParam3,\n  filterParam1,\n  filterParam2,\n  filterParam3\n])\n\n//try adding duplicate keys via add + madd\nconst changedStatusEvent = systemEvent.add(encParam3).madd([filterParam1, filterParam2, filterParam3])\n//duplicate keys will not be added. Should contain one Encoder and one Filter key\nconst uniqueKeys2 = changedStatusEvent.paramSet.map((x) => x.keyName)\n\n//miscKey(unique) will be added; encoderKey(duplicate) will not be added\nconst finalStatusEvent = systemEvent.madd([miscParam1, encParam1])\n//now contains encoderKey, filterKey, miscKey\nconst uniqueKeys3 = finalStatusEvent.paramSet.map((x) => x.keyName)","title":"Here are some examples that illustrate this point"},{"location":"/params/keys-and-parameters.html","text":"","title":"Keys and Parameters"},{"location":"/params/keys-and-parameters.html#keys-and-parameters","text":"The library offers a flexible and typesafe means to create Parameters to store values like primitive types, collection types or domain specific types.\nA Parameter is a Key and Value where the Value must be from a set of defined primitive types including binary data. The Value of a Parameter is always considered to be an Array of the type (i.e. if a single value is stored it is at array location 0). A Parameter is immutable; a modification to an existing Parameter will return a new instance.\nA Value can also have Units, which must be of the defined types. See Units for more information. At this time Units are informational only – no calculation or conversion support is provided. Some systems may provide a key value with different units, and receiver can inspect the Units to make a decision on how to handle the value.\nA ParameterSet is a Set of Parameter. Various other message types include a ParameterSet (e.g. Setup, Event). A key is unique in a ParameterSet since it is a Set.","title":"Keys and Parameters"},{"location":"/params/keys-and-parameters.html#how-to-create-a-parameter-using-the-helper-functions","text":"Choose an appropriate KeyType from the tables below. Calling the set method on KeyType helper and supplying a string keyName will return a suitably typed parameter instance.","title":"How to create a Parameter using the helper functions"},{"location":"/params/keys-and-parameters.html#example-snippets-for-creating-parameter-of-simple-array-and-matrix-type","text":"Typescript copysource // primitives\nconst booleanParam: Parameter<BooleanKey> = booleanKey('flag').set([false])\n\nconst intParam: Parameter<IntKey> = intKey('RandomKeyName').set([123, 12432])\n// intParam.keyName === 'RandomKeyName'\n// intParam.keyTag === 'IntKey'\n// intParam.values === [123, 12432]\n// intParam.units === 'NoUnits' // default unit is `NoUnits`\n// -------------\n\n// arrays\nconst filterkey = intArrayKey('filter')\nconst filterParam: Parameter<IntArrayKey> = filterkey.set([\n  [1, 2, 3],\n  [4, 5, 6]\n])\n// -------------\n\n// matrices\nconst positionMatrixKey = byteMatrixKey('positions', Units.meter)\nconst positions: Parameter<ByteMatrixKey> = positionMatrixKey.set([\n  [\n    [1, 2],\n    [3, 4]\n  ],\n  [\n    [5, 6],\n    [7, 8]\n  ]\n])","title":"Example snippets for creating parameter of simple, array and matrix type"},{"location":"/params/keys-and-parameters.html#primitive-data-types","text":"Primitive Typescript Key Type Helper functions Int IntKey intKey Long LongKey longKey Short ShortKey shortKey Float FloatKey floatKey Double DoubleKey doubleKey Byte ByteKey byteKey String StringKey stringKey Char CharKey charKey Boolean BooleanKey booleanKey UTCTime UTCTimeKey utcTimeKey TAITime TAITimeKey taiTimeKey","title":"Primitive Data types"},{"location":"/params/keys-and-parameters.html#array-data-types","text":"Primitive Typescript Key Type Helper functions IntArray IntArrayKey intArrayKey LongArray LongArrayKey longArrayKey ShortArray ShortArrayKey shortArrayKey FloatArray FloatArrayKey floatArrayKey DoubleArray DoubleArrayKey doubleArrayKey ByteArray ByteArrayKey byteArrayKey","title":"Array Data types"},{"location":"/params/keys-and-parameters.html#matrix-data-types","text":"Primitive Typescript Key Type Helper functions IntMatrix IntMatrixKey intMatrixKey LongMatrix LongMatrixKey longMatrixKey ShortMatrix ShortMatrixKey shortMatrixKey FloatMatrix FloatMatrixKey floatMatrixKey DoubleMatrix DoubleMatrixKey doubleMatrixKey ByteMatrix ByteMatrixKey byteMatrixKey","title":"Matrix Data types"},{"location":"/params/keys-and-parameters.html#domain-specific-types","text":"choice : A key for a choice item similar to an enumeration\nPrimitive Typescript Key Type Helper functions Choice ChoiceKey choiceKey","title":"Domain Specific Types"},{"location":"/params/keys-and-parameters.html#example-snippets-for-creating-choice-parameters","text":"Typescript copysource // choice key\n\nconst choices = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] as const\n\nconst weekDaysKey = choiceKey('weekDaysKey', choices)\nconst weekDayParam = weekDaysKey.set('Mon', 'Wed')\n// weekDayParam === Parameter('weekDaysKey', 'ChoiceKey', ['Mon', 'Wed'], 'NoUnits')\n\n// -------------","title":"Example snippets for creating choice parameters"},{"location":"/params/keys-and-parameters.html#coordinate-types","text":"Primitive Typescript Key Type Helper functions EqCoord EqCoordKey eqCoordKey SolarSystemCoord SolarSystemCoordKey solarSystemCoordKey MinorPlanetCoord MinorPlanetCoordKey minorPlanetCoordKey CometCoord CometCoordKey cometCoordKey AltAzCoord AltAzCoordKey altAzCoordKey Coord (*) CoordKey coordKey","title":"Coordinate Types"},{"location":"/params/keys-and-parameters.html#example-snippet-for-creating-coordinate-parameters","text":"Typescript copysource const cometCoord = new CometCoord(\n  new Tag('BASE'),\n  2000,\n  new Angle(324000000000),\n  new Angle(7200000000),\n  new Angle(360000000000),\n  1.4,\n  0.234\n)\nconst cometParam: Parameter<CometCoordKey> = cometCoordKey('comet key', Units.degree).set([cometCoord])\n\n//coord key is base trait of all coordinate key types.\nconst coordParam: Parameter<CoordKey> = coordKey('base coordinate').set([cometCoord])\nNote Note that since Coord is the base trait of the other coordinate types, you can use it as the key for any of the coordinate types.","title":"Example snippet for creating coordinate parameters"},{"location":"/params/result.html","text":"","title":"Result"},{"location":"/params/result.html#result","text":"Components use Results to return results of a command in the form of a ParameterSet. Result is the value that is returned as an argument to the Completed SubmitResponse.\nType definition for Result can be found here\nFollowing snippet shows how to create a Result :\nTypescript copysource//keys\n\nconst k1 = intKey('encoder')\nconst k2 = intKey('windspeed')\nconst k3 = stringKey('filter')\nconst k4 = intKey('notUsed')\n\n//prefixes\nconst prefix = Prefix.fromString('wfos.prog.cloudcover')\n\n//parameters\nconst p1: Parameter<IntKey> = k1.set([22])\nconst p2: Parameter<IntKey> = k2.set([44])\nconst p3: Parameter<StringKey> = k3.set(['A', 'B', 'C', 'D'])\n\n//Create Result using madd\nconst r1: Result = new Result().madd([p1, p2])\n//Create Result using apply\nconst r2: Result = new Result([p1, p2])\n//Create Result and use add\nconst r3: Result = new Result().add(p1).add(p2).add(p3)\n\n//access keys\nconst k1Exists: Boolean = r1.exists(k1) //true\n\n//access Parameters\nconst p4: Option<Parameter<IntKey>> = r1.get(k1)\n\n//access values\nconst v1: Option<number[]> = r1.get(k1)?.values\nconst v2: Option<number[]> = r2.get(k2)?.values\n\n//remove keys\nconst r4: Result = r3.remove(k3)","title":"Result"},{"location":"/params/subsystem.html","text":"","title":"Subsystem"},{"location":"/params/subsystem.html#subsystem","text":"TMT Observatory system is composed of many subsystems. The subsystems that are known participants in the TMT Software System are predefined and the list is covered under the Subsystem enumeration. They are identified using an abbreviation typically of 3 or 4 letters.\nSubsystem values are used to construct Prefix and are used in communication vehicles such as Commands, Events and States.\nType definition for Subsystem can be found here","title":"Subsystem"},{"location":"/params/subsystem.html#list-of-subsystems","text":"Abbreviation Subsystem name AOESW AO Executive Software APS Alignment and Phasing System CIS Communications and Information Systems CLN Mirror Cleaning System CRYO Cryogenic Cooling System CSW Common Software DMS Data Management System DPS Data Processing System ESEN Engineering Sensor System ESW Executive Software System FMCS Facility Management Control System GMS Global Metrology System Controls IRIS InfraRed Imaging Spectrometer LGSF Laser Guide Star Facility M1CS M1 Control System MODHIS Multi-Object Diffraction-limited High-resolution Infrared Spectrograph NFIRAOS Narrow Field Infrared AO System NSCU NFIRAOS Science Calibration Unit OSS Observatory Safety System PFCS Prime Focus Camera Controls PSFR NFIRAOS AO PSF Reconstructor REFR Refrigeration Control System RTC NFIRAOS Real-time Controller RPG NFIRAOS AO Reconstructor Parameter Generator SCMS Site Conditions Monitoring System SOSS Science Operations Support System TCS Telescope Control System WFOS Wide Field Optical Spectrometer Container Container subsystem","title":"List of Subsystems"},{"location":"/params/subsystem.html#usage-examples","text":"The usage examples can be found in Events, Commands, States","title":"Usage Examples"},{"location":"/params/state-variables.html","text":"","title":"State variables"},{"location":"/params/state-variables.html#state-variables","text":"State variables are used when a UI for Assembly wants to track the status of a command sent to an HCD using a matcher.\nA state represents some aspect of a Component’s internal state which is captured in CurrentState. All state variables have Prefix and ParameterSet.\nThe PubSub feature of the HCD provides CurrentState values to the PubSub subscriber.","title":"State variables"},{"location":"/params/state-variables.html#currentstate","text":"A state variable that is published by a component that describes its internal state. Used by Assemblies to determine command completion in Command Service.\nType definition for CurrentState can be found here\nTypescript copysource//prefix\n\nconst prefix = Prefix.fromString('wfos.prog.cloudcover')\n\n//key\nconst charKey1 = charKey('charKey')\nconst intKey1 = intKey('intKey', Units.meter)\nconst booleanKey1 = booleanKey('booleanKey')\nconst utcTimeKey1 = utcTimeKey('utcTimeKey')\nconst notUsedKey = stringKey('notUsed')\n\n//parameters\nconst charParam = charKey1.set(['A', 'B', 'C'])\nconst intParam = intKey1.set([1, 2, 3])\nconst booleanParam = booleanKey1.set([true, false])\nconst utcTime = utcTimeKey1.set([new Date().toUTCString()])\n\n//create CurrentState and use sequential add\nconst cs1 = new CurrentState(prefix, 'testStateName').add(charParam).add(intParam)\n//create CurrentState and add more than one Parameters using madd\nconst cs2 = new CurrentState(prefix, 'testStateName').madd([intParam, booleanParam])\n//create CurrentState using apply\nconst cs3 = new CurrentState(prefix, 'testStateName', [utcTime])\n\n//access keys\nconst charKeyExists = cs1.exists(charKey1) //true\n\n//access Parameters\nconst p1: Option<Parameter<IntKey>> = cs1.get(intKey1)\n\n//access values\nconst v1: Option<string[]> = cs1.get(charKey1)?.values\nconst v2: Option<boolean[]> = cs2.get(booleanKey1)?.values\n\n//remove keys\nconst cs4 = cs3.remove(utcTimeKey1)\n\n//update existing keys - set it back by an hour\nvar today = new Date()\ntoday.setHours(today.getHours() - 1)\nconst cs5 = cs3.add(utcTimeKey1.set([today.toUTCString()]))","title":"CurrentState"},{"location":"/params/units.html","text":"","title":"Units"},{"location":"/params/units.html#units","text":"Listed below are Units of Measurement, supported by TMT observatory framework and are available as Enumerated values. Units are optionally attached to Parameter Keys.\nType definition for Units can be found here\nNote The set of supported Units will be modified as more required Units will be discovered.","title":"Units"},{"location":"/params/units.html#default-units-for-keys","text":"The default unit for UTCTimeKey and TAITimeKey is second. For all the remaining keys, default unit is NoUnits.","title":"Default Units for Keys"},{"location":"/params/units.html#si-units","text":"Name Abbreviation Description angstrom Angstrom 10 -1 nm arcmin arcmin arc minute; angular measurement arcsec arcsec arc second: angular measurement day d day - 24 hours degree deg degree: angular measurement 1/360 of full rotation elvolt eV electron volt 1.6022x10-19 J gram g gram 10-3 kg hour h hour 3.6x10+3 s hertz Hz frequency joule J Joule: energy N m kelvin K Kelvin: temperature with a null point at absolute zero kilogram kg kilogram, base unit of mass in SI kilometer km kilometers - 10+3 m liter l liter, metric unit of volume 10+3 cm+3 meter m meter: base unit of length in SI marcsec mas milli arc second: angular measurement 10-3 arcsec millimeter mm millimeters - 10-3 m millisecond ms milliseconds - 10-3 s micron µm micron: alias for micrometer micrometer µm micron: 10-6 m minute min minute 6x10+1 s newton N Newton: force pascal Pa Pascal: pressure radian rad radian: angular measurement of the ratio between the length of an arc and its radius second s second: base unit of time in SI sday sday sidereal day is the time of one rotation of the Earth: 8.6164x10+4 s steradian sr steradian: unit of solid angle in SI - rad+2 microarcsec µas micro arcsec: angular measurement volt V Volt: electric potential or electromotive force watt W Watt: power week wk week - 7 d year yr year - 3.6525x10+2 d","title":"SI Units"},{"location":"/params/units.html#cgs-units","text":"Name Abbreviation Description coulomb C coulomb: electric charge centimeter cm centimeter erg erg erg: CGS unit of energy","title":"CGS Units"},{"location":"/params/units.html#astrophysical-units","text":"Name Abbreviation Description au AU astronomical unit: approximately the mean Earth-Sun distance jansky Jy Jansky: spectral flux density - 10-26 W/Hz m+2 lightyear lyr light year - 9.4607x10+15 m mag mag stellar magnitude","title":"Astrophysical Units"},{"location":"/params/units.html#imperial-units","text":"Name Abbreviation Description cal cal thermochemical calorie: pre-SI metric unit of energy foot ft international foot - 1.2x10+1 inch inch inch international inch - 2.54 cm pound lb international avoirdupois pound - 1.6x10+1 oz mile mi international mile - 5.28x10+3 ft ounce oz international avoirdupois ounce yard yd international yard - 3 ft","title":"Imperial Units"},{"location":"/params/units.html#others-engineering","text":"Name Abbreviation Description NoUnits none scalar - no units specified encoder enc encoder counts count ct counts as for an encoder or detector pix pix pixel","title":"Others - Engineering"},{"location":"/params/units.html#time-units","text":"Name Abbreviation Description tai tai TAI Time unit utc utc UTC Time unit","title":"Time units"},{"location":"/params/units.html#usage-examples","text":"Typescript copysource//declare keyName\nconst s1: string = 'encoder'\n\n//making 2 keys\nconst k1 = booleanKey(s1)\nconst k2 = shortKey('RandomKeyName', Units.meter)\n\n//storing a single value\nconst booleanParam: Parameter<BooleanKey> = k1.set([true])\n\n//storing multiple values\nconst paramWithShorts1: Parameter<ShortKey> = k2.set([1, 2, 3, 4])\n\n//  default unit is NoUnits\n// booleanParam.units === \"NoUnits\"\n\n//retrieve values from Parameter\nconst allValues: Array<number> = paramWithShorts1.values\n\n// allValues === Array(1, 2, 3, 4))\n// paramWithUnits3.units === \"meter\")\n\n//default unit for UTCTimeKey is utc\nconst tParam: Parameter<UTCTimeKey> = utcTimeKey('now').set([new Date().toUTCString()])\nconst defaultTimeUnit: Units = tParam.units //is utc","title":"Usage Examples"},{"location":"/aas/auth-components.html","text":"","title":"Auth Components"},{"location":"/aas/auth-components.html#auth-components","text":"ESW-TS provides React components that integrate with the CSW Authentication and Authorization Service. UI applications can use these React components to enable the application to show or hide components based on the authentication and authorization policy.","title":"Auth Components"},{"location":"/aas/auth-components.html#application-configuration","text":"Web application needs following configurations in order to get access token from keycloak server. This application specific config object should be passed in AuthContextProvider component. There are two configurations needed for a web application i.e. realm, clientId\nrealm is a mandatory configuration which specifies in keycloak server under which client your application is registered.\nclientId is a mandatory configuration which specifies the client id of the app as per registration in keycloak server.\nSee, how to configure realm & client-id here","title":"Application Configuration"},{"location":"/aas/auth-components.html#components","text":"ESW-TS exposes the following React components.\nAuth Components Application Configuration Components AuthContextProvider Consumer Login Logout CheckLogin RealmRole Example Technical Description\nType definition for all components used by services can be found here\nComponents can be imported as shown in code snippet below\nTypescript copysourceimport { AuthContext, Logout, Login } from '@tmtsoftware/esw-ts'","title":"Components"},{"location":"/aas/auth-components.html#authcontextprovider","text":"AuthContextProvider is wrapper over a React Context.Provider. A JSON configuration must be passed in that contains the application specific AAS server configuration (e.g. clientId, realm). When a user logs in, an AAS Server is instantiated, with the UI application specific configuration overriding the predefined configuration. Once the AAS sever is instantiated, an auth object is created with the needed attributes and APIs. This auth object is available to other React components; since AuthContextProvider is a Provider, its data can be shared with any of the children React components in its tree in a Consumer component (see below). All Consumers that are descendants of a Provider will re-render whenever the AuthContextProvider’s state changes, e.g. a user authorizes. It is recommended to use AuthContextProvider to wrap the entire application so that data can be shared anywhere in application via a Consumer.\nTypescript copysource<AuthContextProvider config={{ realm: 'TMT', clientId: 'tmt-frontend-app' }}>\n  <BrowserRouter basename={basename}>\n    <div>\n      <NavComponent />\n      <Route\n        exact\n        path='/secured'\n        render={() => (\n          <CheckLogin error={<LoginError />}>\n            <Write />\n          </CheckLogin>\n        )}\n      />\n      <Route exact path='/config' render={() => <ConfigApp />} />\n      <Route\n        exact\n        path='/example_admin'\n        render={() => (\n          <CheckLogin error={<LoginError />}>\n            <RealmRole\n              realmRole='example-admin-role'\n              error={<RoleError message={'User do not have role : example-admin-role'} />}>\n              <div>Example admin role specific functionality</div>\n            </RealmRole>\n          </CheckLogin>\n        )}\n      />\n      <Route\n        exact\n        path='/example_user'\n        render={() => (\n          <CheckLogin error={<LoginError />}>\n            <RealmRole\n              realmRole='person-role'\n              error={<RoleError message={'User do not have role : person-role'} />}>\n              <div>Person role specific functionality</div>\n            </RealmRole>\n          </CheckLogin>\n        )}\n      />\n      <Route exact path='/public' component={Read} />\n    </div>\n  </BrowserRouter>\n</AuthContextProvider>","title":"AuthContextProvider"},{"location":"/aas/auth-components.html#consumer","text":"Consumer is similar to a React Context.Consumer. The shared auth object from the AuthContextProvider can be accessed using a Consumer component.\nTypescript copysourceconst { auth } = useContext(AuthContext)\nreturn (\n  <div className='nav-wrapper'>\n    {auth && auth.isAuthenticated() ? (\n      <div>\n        Hello, you are logged in\n        <div>Open functionality</div>\n      </div>\n    ) : (\n      <div>\n        Hello, you are not logged in\n        <div>Open functionality</div>\n      </div>\n    )}\n  </div>\n)","title":"Consumer"},{"location":"/aas/auth-components.html#login","text":"The Login component instantiates an AAS server with the configurations provided. It redirects to an AAS server login page for the user to login. After login, the auth object in the context is updated with the appropriate values, e.g. token, realm etc.\nTypescript copysource<Login />","title":"Login"},{"location":"/aas/auth-components.html#logout","text":"The Logout component logs out the user from the AAS server. It clears the auth object stored in the context.\nTypescript copysource  <Logout />\n) : (","title":"Logout"},{"location":"/aas/auth-components.html#checklogin","text":"CheckLogin component provides ability to show something only if the user is logged in. In the following code snippet, Write is a React component that is shown only if the user is logged in. The behavior if the user is not logged in can be defined by an HTML element or React component that is passed into the component as an error property, shown as an ExampleError Component in following snippet.\nTypescript copysource<CheckLogin error={<LoginError />}>\n  <Write />\n</CheckLogin>","title":"CheckLogin"},{"location":"/aas/auth-components.html#realmrole","text":"RealmRole component provides the ability to show something only if the user is logged in and has the specified realm role. In the following code snippet, the contents of the div block are shown only if the user is logged in and has the realm role specified in the realmRole prop. Similar to CheckLogin, the behaviour if the user is not logged in can be optionally defined by an HTML element or React component that is passed into the component as an error property, shown as an ExampleError Component in following snippet.\nTypescript copysource<RealmRole\n  realmRole='example-admin-role'\n  error={<RoleError message={'User do not have role : example-admin-role'} />}>\n  <div>Example admin role specific functionality</div>\n</RealmRole>","title":"RealmRole"},{"location":"/aas/auth-components.html#example","text":"Here is an example of a Config App(React App) which uses ConfigService client and Auth components in order to authorize ConfigService\nTypescript copysourceconst ExampleApp = () => {\n  return (\n    <div className='row card col s12 m7'>\n      {\n        <AuthContextProvider config={{ realm: 'TMT', clientId: 'tmt-frontend-app' }}>\n          <BrowserRouter basename={basename}>\n            <div>\n              <NavComponent />\n              <Route\n                exact\n                path='/secured'\n                render={() => (\n                  <CheckLogin error={<LoginError />}>\n                    <Write />\n                  </CheckLogin>\n                )}\n              />\n              <Route exact path='/config' render={() => <ConfigApp />} />\n              <Route\n                exact\n                path='/example_admin'\n                render={() => (\n                  <CheckLogin error={<LoginError />}>\n                    <RealmRole\n                      realmRole='example-admin-role'\n                      error={<RoleError message={'User do not have role : example-admin-role'} />}>\n                      <div>Example admin role specific functionality</div>\n                    </RealmRole>\n                  </CheckLogin>\n                )}\n              />\n              <Route\n                exact\n                path='/example_user'\n                render={() => (\n                  <CheckLogin error={<LoginError />}>\n                    <RealmRole\n                      realmRole='person-role'\n                      error={<RoleError message={'User do not have role : person-role'} />}>\n                      <div>Person role specific functionality</div>\n                    </RealmRole>\n                  </CheckLogin>\n                )}\n              />\n              <Route exact path='/public' component={Read} />\n            </div>\n          </BrowserRouter>\n        </AuthContextProvider>\n      }\n    </div>\n  )\n}\nConfigApp component which uses Config Service APIs:\nTypescript copysourceconst ConfigApp = () => {\n  return (\n    <div className='row card col s12 m7'>\n      <ConfigServiceProvider authContext={AuthContext}>\n        <ListConfig />\n        <GetConfig />\n        {\n          <CheckLogin error={<LoginError />}>\n            {/*// #create-config-component*/}\n            <RealmRole\n              realmRole='config-admin'\n              error={<RoleError message={\"User do not have role 'config-admin' to create config\"} />}>\n              <CreateConfig />\n            </RealmRole>\n            {/*// #create-config-component*/}\n          </CheckLogin>\n        }\n      </ConfigServiceProvider>\n    </div>\n  )\n}\nConfigServiceProvider is the component where instance of Config Service gets created:\nTypescript copysourceexport interface ConfigServiceProps {\n  authContext: typeof AuthContext\n  children: React.ReactNode\n}\n\nconst ConfigServiceProvider = (props: ConfigServiceProps) => {\n  const { authContext, children } = props\n\n  const [configService, setConfigService] = useState<ConfigService>(defaultConfigServiceState)\n  const { auth } = useContext(authContext)\n\n  const resetConfigService = async () => {\n    //Authenticating config service\n    const service = await ConfigService(auth ? auth.token : () => '')\n    setConfigService(service)\n  }\n\n  useEffect(() => {\n    resetConfigService().catch(() => window.alert('config server is not available'))\n  }, [auth])\n\n  return <ConfigContext.Provider value={configService}>{children}</ConfigContext.Provider>\n}\nSource code for the full example can be found here","title":"Example"},{"location":"/aas/auth-components.html#technical-description","text":"See Auth Components Technical Description.","title":"Technical Description"},{"location":"/common/response-handling.html","text":"","title":"Response Handling in ESW-TS"},{"location":"/common/response-handling.html#response-handling-in-esw-ts","text":"This section helps to understand how responses have been modeled in TMT architecture and, also how they can be handled at UI application side.\nIf you have not gone the Services Section, we recommend you to check Services out first. Assuming you have read through the Services section and what all types of response can be returned by the Service of your current interest.\nThe Response types are Union types/ADT’s. All of them are tagged by _type field, this field provides information at compile time to developers of all possible response variation at runtime for the current response.\nTypescript copysource// response handlers\nconst onCancelled = () => {\n  // do something on receiving Cancelled type\n}\nconst onCompleted = () => {\n  // do something on receiving Completed type\n}\nconst onStarted = () => {\n  // do something on receiving Started type\n}\nconst onError = () => {\n  // do something on receiving Error type\n}\nconst onInvalid = () => {\n  // do something on receiving Invalid type\n}\nconst onLocked = () => {\n  // do something on receiving Locked type\n}\n\nconst prefix = new Prefix('ESW', 'component_1')\nconst componentId = new ComponentId(prefix, 'Assembly')\nconst commandService: CommandService = await CommandService(componentId, {\n  tokenFactory\n})\n\nconst setup = new Setup(prefix, 'move', [])\nconst submitResponse: SubmitResponse = await commandService.submit(setup)\n\n// Handle all variations (Exhaustive switch pattern)\nswitch (submitResponse._type) {\n  case 'Cancelled':\n    onCancelled()\n    break\n  case 'Completed':\n    onCompleted()\n    break\n  case 'Started':\n    onStarted()\n    break\n  case 'Error':\n    onError()\n    break\n  case 'Invalid':\n    onInvalid()\n    break\n  case 'Locked':\n    onLocked()\n    break\n}\n\n// or handle few types\n\nswitch (submitResponse._type) {\n  case 'Completed':\n    onCompleted()\n    break\n  case 'Started':\n    onStarted()\n    break\n  case 'Error':\n    onError()\n    break\n  default: // !!important!!\n  // do something by default for other cases\n}\nNormal response All non-ADT or Normal response types (for ex: Done, LogMetadata, etc.) does not require extra effort of handling it with switch cases. Those models do not have any discriminatory field like _type and there will always be one variation, and the information about all fields inside model will be statically known.","title":"Response Handling in ESW-TS"},{"location":"/common/response-handling.html#asynchronous-programming","text":"You may have notice that we have used async-await syntax in all examples provided in the different pages of this documentation. However, one may still want to write using combinators provided by Promise, since most of the ESW-TS service methods are Promise based.\nPromise is provided by Javascript language,Using which we can write asynchronous programs in a more manageable way. Using Async/Await syntax, a promise-based asynchronous code can be written in a synchronous format which saves a lot of time and code becomes scalable. We recommend using async-await syntax for writing asynchronous code as it increases readability of the code. When using callbacks or combinators on top of Promise, issues like callback hell emerges over time.\nFor instance, following example showcases two scenarios without async-await syntax and how it would look like\nSending submit commands using CommandService in sequence Sending submit commands using CommandService in parallel\nTypescript copysource const prefix = new Prefix('ESW', 'component_1')\nconst componentId = new ComponentId(prefix, 'HCD')\n\nCommandService(componentId)\n  .then((commandService) => {\n    const setup1 = new Setup(prefix, 'move', [])\n    const setup2 = new Setup(prefix, 'rotate', [])\n    const setup3 = new Setup(prefix, 'set', [])\n\n    const responsePromise = commandService.submit(setup1)\n\n    //sequential way to handle multiple submit calls\n    responsePromise\n      .then((submitResponse1) => {\n        handleResponse(submitResponse1)\n        commandService.submit(setup2).then((submitResponse2) => {\n          handleResponse(submitResponse2)\n          commandService.query(submitResponse2.runId).then(fetchNewESWState)\n        })\n      })\n      .catch(handleError)\n\n    // parallel way to handle multiple promises\n    const responsePromise3 = commandService.submit(setup3)\n\n    Promise.all([responsePromise, responsePromise3]).then((submitResponses) => {\n      submitResponses.forEach(handleResponse)\n      const lastResponse = submitResponses.pop()\n      if (lastResponse) {\n        commandService.query(lastResponse.runId).then(fetchNewESWState)\n      }\n    })\n  })\n  .catch((err) => {\n    handleError(err)\n  })\n\nconst handleError = (error: Error) => {\n  // See Error handling section for in general details\n  throw new Error(error.message)\n}\nconst handleResponse = (response: SubmitResponse) => {\n  // See Response handling section for in general details\n  console.log(response)\n}\n\nconst fetchNewESWState = () => {\n  // fetch new state from backend\n}\nThe following example showcases the same above scenarios with async-await syntax.\nSending multiple submit commands with async-await syntax\nTypescript copysource const handleError = (error: Error) => {\n  // See Error handling section for details\n  throw new Error(error.message)\n}\nconst handleResponse = (response: SubmitResponse) => {\n  // See Response handling section for more details\n  console.log(response)\n}\n\nconst prefix = new Prefix('ESW', 'component_1')\nconst componentId = new ComponentId(prefix, 'HCD')\ntry {\n  const commandService = await CommandService(componentId)\n  const setup1 = new Setup(prefix, 'move', [])\n  const setup2 = new Setup(prefix, 'rotate', [])\n  const setup3 = new Setup(prefix, 'set', [])\n\n  //sequential way to handle multiple submit calls\n  await commandService.submit(setup1)\n  const responsePromise2 = await commandService.submit(setup2)\n  const queryResponse = await commandService.query(responsePromise2.runId)\n  handleResponse(queryResponse)\n\n  // parallel way to handle multiple promises\n  const responsePromise3 = commandService.submit(setup3)\n  const responsePromise4 = commandService.submit(setup1)\n\n  const submitResponses = await Promise.all([responsePromise3, responsePromise4])\n\n  submitResponses.forEach(handleResponse)\n  const lastResponse = submitResponses.pop()\n  if (lastResponse) {\n    const queryRes = commandService.query(lastResponse.runId)\n  }\n} catch (err) {\n  handleError(err)\n}\nasync-await We strongly recommend to use async-await while writing asynchronous code in Javascript.","title":"Asynchronous Programming"},{"location":"/common/error-handling.html","text":"","title":"Error Handling in ESW-TS"},{"location":"/common/error-handling.html#error-handling-in-esw-ts","text":"Errors/Exceptions must be handled in application code because that will help user to make further decisions for controlled user interactions with the UI.\nTo read more on exception handling, refer this document which gives detailed explanation.","title":"Error Handling in ESW-TS"},{"location":"/common/error-handling.html#error-types","text":"","title":"Error Types"},{"location":"/common/error-handling.html#service-error","text":"In TMT Architecture, Service error captures all/most of the Service/Network level errors and exceptions. A runtime error which gets thrown after making Service’s API and gets caught in the Service call’s scaffolding snippet falls into this category.\nFor example:\nUsing CommandService to submit a command for a non-existing component will result into LocationNotFound.\nLocationNotFoundException is a Service Error, and it would contain following fields:\nerrorType: LocationNotFound message: ‘Could not resolve location matching connection: $non_existent_component_connection’ status: 500 statusText: Internal Server error\nType definition for Service Error can be found here","title":"Service Error"},{"location":"/common/error-handling.html#client-side-error","text":"Any runtime error which gets thrown before making Service’s API call falls into this category. The Errors and Exception caught at validation or at data creation time will be thrown before making API calls.\nFor Example: Prefix has a validation that it cannot have - or space in the componentName field.\nFollowing snippet will result into runtime error : it is a native browser’s Error object with the message field and stacktrace. message field will contain the reason for which the validation failed.\nTypescript copysourceconst prefix = new Prefix('ESW', 'filter-wheel')\nFor the given case it will have the following information.\nmessage: Requirement failed - component name filter-wheel has '-'","title":"Client Side Error"},{"location":"/common/error-handling.html#error-handling-pattern","text":"The following examples shows how to call Agent Service methods and handle the response SpawnResponse and KillResponse.\nThis example also illustrates error handling of service specific exception AgentNotFoundException along with the generic errors like TransportError and ArithmeticException.\nExploiting try-catch is an anti-pattern The example uses try-catch to handle errors and exceptions. Generally those errors/exceptions are handled at UI framework level on boundaries of service calls. This example will be updated once we have frontend framework setup in place.\nA function whose responsibility is to handle errors and exceptions:\nTypescript copysource// common function to handle error scenario's\nconst handleError = (err: Error) => {\n  if (err instanceof ServiceError) {\n    // depending on use case, error can be handled on following fields\n    //  - err.status      (5XX, 4XX, 3XX)\n    //  - err.errorType   (AgentNotFoundException, TransportError, ArithmeticException, NullPointerException, etc)\n\n    // Other fields present in error model\n    // err.message : contains the reason which can be used to show on UI\n    // err.statusText :  Forbidden , Unauthorised, BadRequest, Not Found, etc.\n\n    switch (err.errorType) {\n      case 'AgentNotFoundException':\n        console.log(err.message) // Location not found for $agentPrefix\n        console.log('do something on getting AgentNotFoundException')\n        break\n      case 'TransportError':\n        console.log(err.statusText)\n        console.log('do something on getting TransportError (4XX, 3XX, etc))')\n        break\n      case 'ArithmeticException':\n        console.log(err.statusText) // InternalServerError\n        console.log(err.message) // Reason : / by zero\n        break\n      default:\n        throw Error(err.message)\n    }\n  } else {\n    // client side error occurred at validations and operations before making api call to the server\n    // for ex: Prefix can throw runtime error if componentName is invalid.\n  }\n}\nExample for spawnSequenceManager method call with error handling looks like following:\nTypescript copysource// setup\nconst agentService: AgentService = await AgentService({ tokenFactory })\n\nconst agentPrefix = new Prefix('ESW', 'agent1')\nconst obsModeConfigPath = '/obs-mode.conf'\nconst sequenceManagerVersion = '1.0.0'\n\ntry {\n  const spawnResponse: SpawnResponse = await agentService.spawnSequenceManager(\n    agentPrefix,\n    obsModeConfigPath,\n    false,\n    sequenceManagerVersion\n  )\n\n  // spawn response handling (200 status code)\n  switch (spawnResponse._type) {\n    case 'Spawned':\n      // do something on successful spawn operation\n      break\n    case 'Failed':\n      // do something on failed response\n      break\n  }\n} catch (err) {\n  handleError(err)\n}","title":"Error Handling pattern"},{"location":"/services/index.html","text":"","title":"Services"},{"location":"/services/index.html#services","text":"These are javascript adapters for each of public facing TMT services. They provide a handle to interact with backend server while adhering to the service contract.\nTMT Services are behind ESW Gateway Server except Location and Config Server.\nFollow the instructions in the first step of our quickstart guide to integrate one or more services in the UI application.\nThese are following services available:\nAdmin Service Alarm Service Command Service Config Service Event Service Location Service Logging Service\nType definition for all services can be found here\nAdmin Service : This service provides a handle to admin related APIs which includes logging related APIs Agent Service : The Agent Service is used to spawn a component of machine or kill a running component. To do so, it uses the agent running on that specific machine where component is to be spawned or killed. Command Service : This client side service provides a handle to send commands to a component which is registered in location service. Config Service : The Config Service wraps the low level communication with Configuration Service Server and exposes simple to use methods to access and manage configuration files. Event Service : The Event Service enables users to publish events and subscribe to events which are published by underlying TMT components. Location Service : The Location Service provides access to location information of various components which are currently running the TMT cluster. Sequencer Service : This service provides a handle to send commands to a sequencer which is registered in location service. Sequence Manager Service : The Sequence Manager Service manages all the operation related to the observations. It manages all sequence components and sequencers required for the observations.","title":"Services"},{"location":"/services/admin-service.html","text":"","title":"Admin Service"},{"location":"/services/admin-service.html#admin-service","text":"This service provides a handle to admin related APIs which currently has logging related APIs.","title":"Admin Service"},{"location":"/services/admin-service.html#creation-of-admin-service","text":"","title":"Creation of Admin Service"},{"location":"/services/admin-service.html#to-create-admin-client","text":"Typescript copysourceconst adminService: AdminService = await AdminService()","title":"To create Admin client"},{"location":"/services/admin-service.html#usages-of-admin-service","text":"Type definitions for all Admin Service methods can be found here.","title":"Usages of Admin Service"},{"location":"/services/admin-service.html#fetching-logmetadata-setting-log-level","text":"For instance, we need logging configuration to be known before setting log level of a component if it is not set to desired log level.\nType definitions for getLogMetadata can be found here. Type definitions for setLogLevel can be found here.\nIn the given example, we want to set ERROR log level for the component if it’s not already set to ERROR.\nTypescript copysourceconst prefix = new Prefix('TCS', 'filter.wheel')\nconst componentId = new ComponentId(prefix, 'HCD')\n\nconst logMetaData: LogMetadata = await adminService.getLogMetadata(componentId)\n\nif (logMetaData.componentLevel !== 'ERROR') {\n  const actionStatus: Done = await adminService.setLogLevel(componentId, 'ERROR')\n}","title":"Fetching LogMetadata & Setting log level"},{"location":"/services/admin-service.html#component-container-level-actions","text":"Admin actions like restarting, shutting down or making component(HCD, Assembly) or container to go online/offline are provided in Admin Service. Following examples represents admin actions provided on Admin Service.\nType definitions for restart can be found here. Type definitions for shutdown can be found here. Type definitions for goOffline can be found here. Type definitions for goOnline can be found here.\nTypescript copysourceconst restartResponse: Done = await adminService.restart(componentId)\n\nconst shutdownResponse: Done = await adminService.shutdown(componentId)\n\nconst goOfflineResponse: Done = await adminService.goOffline(componentId)\n\nconst goOnlineResponse: Done = await adminService.goOnline(componentId)","title":"Component & Container level actions"},{"location":"/services/admin-service.html#querying-lifecycle-states-of-component-container","text":"Component(HCD, Assembly) lifecycle states are queried using getComponentLifecycleState API Method.\nContainer lifecycle state is queried using getContainerLifecycleState API Method.\nFollowing examples shows how to make use of these API’s.\nType definitions for getContainerLifecycleState can be found here Type definitions for getComponentLifecycleState can be found here\nTypescript copysource// component lifecycle state\nconst response: Done = await adminService.goOnline(componentId)\nif (response === 'Done') {\n  const state: SupervisorLifecycleState = await adminService.getComponentLifecycleState(componentId)\n\n  switch (state) {\n    case 'Idle':\n      break\n    case 'Running':\n      break\n    case 'Shutdown':\n      break\n    default:\n      console.log('unhandled state')\n  }\n}\n\n// container lifecycle state\nconst containerPrefix = Prefix.fromString('ESW.container1')\nconst state: ContainerLifecycleState = await adminService.getContainerLifecycleState(containerPrefix)\n\nswitch (state) {\n  case 'Idle':\n    break\n  case 'Running':\n    break\n}","title":"Querying lifecycle states of Component & Container"},{"location":"/services/alarm-service.html","text":"","title":"Alarm Service"},{"location":"/services/alarm-service.html#alarm-service","text":"This service provides an HTTP interface to interact with alarm server.","title":"Alarm Service"},{"location":"/services/alarm-service.html#creation-of-alarm-service","text":"","title":"Creation of Alarm Service"},{"location":"/services/alarm-service.html#pre-requisite","text":"In order to use Alarm Service API:\nThe Location Service The Alarm Service Gateway Server needs to be running in the network","title":"Pre-requisite"},{"location":"/services/alarm-service.html#to-create-a-client-for-alarm-service","text":"Typescript copysourceconst alarmService = await AlarmService()\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"To create a client for Alarm Service"},{"location":"/services/alarm-service.html#usages-of-alarm-service","text":"","title":"Usages of Alarm Service"},{"location":"/services/alarm-service.html#setting-alarm-severity","text":"Alarm service allows you to update the severity of alarms belonging to components.\nType Definitions of setSeverity method can be found here\nTypescript copysourcelet alarmKey = new AlarmKey(new Prefix('ESW', 'assemblyComponent'), 'temperature')\nconst response: Done = await alarmService.setSeverity(alarmKey, 'Critical')","title":"Setting alarm Severity"},{"location":"/services/command-service.html","text":"","title":"Command Service"},{"location":"/services/command-service.html#command-service","text":"Command Service provides a handle to send commands to a component which is registered in Location Service.","title":"Command Service"},{"location":"/services/command-service.html#creation-of-command-service","text":"","title":"Creation of Command Service"},{"location":"/services/command-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/services/command-service.html#in-order-to-use-command-service-for-a-specific-component","text":"The component needs to be up and running behind the gateway server. GatewayException(InvalidComponent) will be thrown if the specified component is not found. Authorization Token with correct access role. Documentation on how to fetch authorization token could be found here.\nFor the given example : Prefix(ESW.Component1) needs to be registered in the Location Service as any of the component type (HCD, Assembly, etc.).","title":"In order to use command service for a specific component"},{"location":"/services/command-service.html#to-create-command-service-client-for-a-component","text":"Typescript copysourceconst tokenFactory = () => auth.token\n\nconst commandService: CommandService = await CommandService(new ComponentId(new Prefix('ESW', 'Component1'), 'HCD'), {\n  tokenFactory\n})","title":"To create Command Service client for a component"},{"location":"/services/command-service.html#type-of-actions","text":"Whenever a command gets submitted to a component, it results into in either Immediate completion or Long Running action.","title":"Type of Actions"},{"location":"/services/command-service.html#immediate-completion","text":"If the actions of the submit or submitAndWait command take a very short time to complete, it is referred as Immediate completion. The actions are successful, if the Completed SubmitResponse is returned. If there is a result, the Completed is returned with a parameter set of Result type that can be inspected by the caller.","title":"Immediate completion"},{"location":"/services/command-service.html#long-running-actions","text":"When actions take longer than 1 second the Component returns the Started SubmitResponse. The Started response indicates to the framework that long-running actions have been started.","title":"Long running Actions"},{"location":"/services/command-service.html#control-commands","text":"In order to call the following method, one of the control command needs to be sent. Depending on your use case, you will be sending either Setup or Observe Command.\nFollowing examples show how to create control commands:\nTypescript copysource// Definition of control command looks like following\ntype ControlCommand = Setup | Observe\n\n// examples\nconst setupCommand: Setup = new Setup(new Prefix('ESW', 'Component1'), 'move-command', paramSet, 'obs-id')\n\nconst observeCommand: Observe = new Observe(new Prefix('ESW', 'Component1'), 'c1', paramSet, 'obs-id')\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"Control Commands"},{"location":"/services/command-service.html#usages-of-command-service","text":"Type definitions of all Command Service methods can be found here","title":"Usages of Command Service"},{"location":"/services/command-service.html#validating-command","text":"A validate message is used to ask a destination component to validate a command and determine if the command can be executed. It does not execute the command and only returns the result of validation. In some scenarios, it may be useful to test and see if a command can be executed prior to trying to execute the command.\nType definitions of validate method can be found here\nTypescript copysource const validateResponse1: ValidateResponse = await commandService.validate(setupCommand)\n// or\nconst validateResponse2: ValidateResponse = await commandService.validate(observeCommand)","title":"Validating command"},{"location":"/services/command-service.html#submitting-commands","text":"A submit message can be used when the sender of a command needs to do additional work before long-running actions are completed. For instance, send another command to execute in parallel. If commands are short, submit and submitAndWait behave the same way. When the actions started by submit are long-running, the caller can wait for the actions to complete if needed using the queryFinal call.\nType definitions of submit method can be found here\nTypescript copysourceconst submitResponse1: SubmitResponse = await commandService.submit(setupCommand)\n// or\nconst submitResponse2: SubmitResponse = await commandService.submit(observeCommand)","title":"Submitting commands"},{"location":"/services/command-service.html#submit-and-wait-for-response","text":"This is a convenience method which sends a submit message and if the command is long-running, it waits for final completion. Sending submit message with a command returns a SubmitResponse as a Future.\nType definitions of submitAndWait method can be found here\nTypescript copysource// Submit a long running command and wait for the result for specific time\n\nconst submitAndWaitResponse: SubmitResponse = await commandService.submitAndWait(setupCommand, 10)","title":"Submit And Wait for Response"},{"location":"/services/command-service.html#submit-multiple-commands-and-wait","text":"Similar to SubmitAndWait, submitAllAndWait method can be used to send multiple commands sequentially to the same component. This could be used to send initialization commands to an HCD, for instance.\nType definitions of submitAllAndWait method can be found here\nTypescript copysource// Submit multiple commands and wait for the result of each submitted command for specific time\n\nconst submitAllAndWaitResponse: SubmitResponse[] = await commandService.submitAllAndWait(\n  [setupCommand, observeCommand],\n  10\n)","title":"Submit Multiple commands and Wait"},{"location":"/services/command-service.html#sending-oneway-command","text":"Oneway is useful when Command Service needs to send commands to an HCD as quickly as possible. The command gets validated on the destination and the validation response is returned, but no other responses are provided.\nType definitions of oneway method can be found here\nTypescript copysourceconst onewayResponse1: OnewayResponse = await commandService.oneway(setupCommand)\n// or\nconst onewayResponse2: OnewayResponse = await commandService.oneway(observeCommand)","title":"Sending Oneway Command"},{"location":"/services/command-service.html#querying-result","text":"This method is useful to get the result of a submitted command which returns a Started response if the command has triggered a long-running action, The caller can then determine that the actions have started properly, or wishes to poll the destination component for the final response using queryFinal method.\nType definitions of query method can be found here\nTypescript copysource// Submit a long running command\nconst res: SubmitResponse = await commandService.submit(setupCommand)\n// .\n// .\n// .\n// Get the current result of long running command as :\nconst queryResponse: SubmitResponse = await commandService.query(res.runId)","title":"Querying Result"},{"location":"/services/command-service.html#querying-for-final-result","text":"Similar to query, queryFinal uses the Id returned by Started. However, in this case rather than returning immediately like query, it waits and only returns when the final SubmitResponse is sent. The queryFinal method is useful exclusively with submit in the case where some other activity must be done before the actions started by the submit complete.\nType definitions of queryFinal method can be found here\nTypescript copysource// Submit a long running command\nconst result: SubmitResponse = await commandService.submit(setupCommand)\n// .\n// .\n// .\n// Get the final result of long running command within 10 seconds :\nconst queryFinalResponse: SubmitResponse = await commandService.queryFinal(result.runId, 10)","title":"Querying for Final result"},{"location":"/services/command-service.html#subscribecurrentstate","text":"This method can be used to subscribe to the CurrentState of a component by providing a callback that is called with the arrival of every CurrentState item.\nType definitions of subscribeCurrentState method can be found here\nTypescript copysource// subscribe to this set of current states\nconst currentStates = new Set(['stateName1', 'stateName2'])\n\n// this callback gets called whenever the state changes\nconst onStateChangeCallback = (currentState: CurrentState) => {\n  // do something when state changes\n  console.log('changed state:', currentState)\n}\n//optional\nconst onErrorCallback = (error: ServiceError) => {\n  // do something when error occurs\n  // for ex : close connection / cleanup resources\n  console.log(error)\n}\n//optional\nconst onCloseCallback = () => {\n  // do something when connection is closed\n  // for ex : reset client-side state\n}\n// subscribe call\nconst subscription: Subscription = await commandService.subscribeCurrentState(currentStates)(\n  onStateChangeCallback,\n  onErrorCallback,\n  onCloseCallback\n)\n\n// .\n// .\n// .\n// subscription can be cancelled when it is not required any more\nsubscription.cancel()","title":"SubscribeCurrentState"},{"location":"/services/config-service.html","text":"","title":"Config Service"},{"location":"/services/config-service.html#config-service","text":"The Config Service provides a centralized persistent store for any configuration file used in the TMT Software System. All versions of configuration files are retained, providing a historical record of each configuration file. This client exposes simple methods to access and manage configuration files.","title":"Config Service"},{"location":"/services/config-service.html#rules-and-checks","text":"The config file path must not contain !#<>$%&'@^``~+,;= or any whitespace character If the input file is > 10MB or has lots of non ASCII characters, then for optimization, server will archive it in annex store. Large and binary files can be forced to go to the annex store by using annex=true flag in create operation.","title":"Rules and Checks"},{"location":"/services/config-service.html#model-classes","text":"ConfigData: Represents the contents of the files being managed. It wraps blob object. ConfigFileInfo: Represents information about a config file stored in the Config Service. ConfigFileRevision: Represents information about a specific version of a config file. ConfigId: Represents an identifier associated with a revision of a configuration file, often generated by create or update methods. ConfigMetadata: Represents metadata information about the Config Server. FileType: Represents the type of storage for a configuration file. Currently, two types are supported Normal(small, text files) and Annex(Large, Binary files).","title":"Model Classes"},{"location":"/services/config-service.html#example-for-creation-configdata-and-accessing-data-with-helper-function","text":"Typescript copysource const dataArray = ['file-contents']\n\nconst configDataFromBlob: ConfigData = ConfigData.from(new Blob(dataArray))\nconst configDataFromFile: ConfigData = ConfigData.fromFile(new File(dataArray, 'filename'))\nconst configDataFromString: ConfigData = ConfigData.fromString('someFileDataAsString')\n\n//accessing data\nconst dataAsBlobContent: Blob = configDataFromString.toBlob()\n\n// notice use of async-await here. because this is an IO read call\nconst readData = async (configData: ConfigData) => {\n  const dataAsString: string = await configData.fileContentAsString()\n}\nNote: Models other than ConfigData are simple TypeScript classes and do not have special helper methods unlike ConfigData.","title":"Example for creation ConfigData and accessing data with helper function"},{"location":"/services/config-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/services/config-service.html#in-order-to-use-config-service","text":"The Location Service and Config Service Server needs to be running in the network The necessary configuration, environment variables or system properties should be defined to point to the correct host and port number(s) for the Location Service nodes. Authorization Token with correct access role. Documentation on how to fetch authorization token could be found here.","title":"In order to use config service"},{"location":"/services/config-service.html#creation-of-config-service","text":"","title":"Creation of Config Service"},{"location":"/services/config-service.html#to-create-a-client-for-config-service","text":"Config Service constructor takes TokenFactory as an input argument.\nTypescript copysourceconst tokenFactory = () => auth.token\n\nconst configService: ConfigService = await ConfigService(tokenFactory)\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"To create a client for Config service"},{"location":"/services/config-service.html#usages-of-config-service","text":"Type Definitions of all methods can be found here","title":"Usages of Config Service"},{"location":"/services/config-service.html#creating-file","text":"This method takes path at which configData needs to be saved in the Config Service along with meta information i.e whether to be saved as annex or normal file and comment. After saving, it returns ConfigId which can be used to access the saved file in the future using query methods.\nType definitions of create method can be found here\nTypescript copysourceconst path = 'esw/sequencer/obsMode.conf'\nconst comment = 'observation configuration on 21st november 2020'\nconst author = 'OCS-Sequencer admin: Dave'\nconst data = `\nesw-sm {\n  obsModes: {\n    IRIS_Darknight: {\n      resources: [IRIS, TCS, NFIRAOS]\n      sequencers: [IRIS, ESW, TCS]\n    },\n    IRIS_Cal: {\n      resources: [IRIS, NSCU, NFIRAOS]\n      sequencers: [IRIS, ESW, AOESW]\n    },\n    WFOS_Cal: {\n      resources: [WFOS]\n      sequencers: [WFOS, ESW]\n    }\n  }\n}\n`\nconst configData = ConfigData.fromString(data)\n\nconst sequencerConfigId: ConfigId = await configService.create(path, configData, false, comment)","title":"Creating File"},{"location":"/services/config-service.html#updating-file","text":"This method takes path at which configData needs to be updated in the Config Service along with comment. After updating, it returns ConfigId which can be used to access the updated file in future using query methods.\nType definitions of update method can be found here\nTypescript copysourceconst filePath = 'esw/sequencer/obsMode.conf'\nconst commentOnUpdate = 'observation configuration on 23rd november 2020'\nconst updatedData = `\nesw-sm {\n  obsModes: {\n    IRIS_Darknight: {\n      resources: [IRIS]\n      sequencers: [IRIS]\n    },\n    IRIS_Cal: {\n      resources: [IRIS, NSCU, NFIRAOS]\n      sequencers: [IRIS, ESW, AOESW]\n    }\n  }\n}\n`\nconst updatedConfigData = ConfigData.fromString(updatedData)\n\nconst newSequencerConfigId: ConfigId = await configService.update(filePath, updatedConfigData, commentOnUpdate)","title":"Updating File"},{"location":"/services/config-service.html#fetching-files","text":"The Config Service provides multiple ways to fetch a file from the svn repository based on Time, ConfigId,Active, and Latest Revision.\nFollowing are the methods available to fetch files:\ngetActive getById getByTime getLatest\nExamples for each of the methods are as follows:\ngetActive : This method return the ConfigData of the active version for that file if it exists otherwise returns undefined.\nType definitions of getActive method can be found here\nTypescript copysourceconst file = 'esw/sequencer/obsMode.conf'\n\nconst maybeActiveConfigData: Option<ConfigData> = await configService.getActive(file)\ngetLatest : This method returns the ConfigData of the latest revision for that file if it exists otherwise returns undefined.\nType definitions of getLatest method can be found here\nTypescript copysourceconst filepath = 'esw/sequencer/obsMode.conf'\nconst maybeLatestConfigData: Option<ConfigData> = await configService.getLatest(filepath)\ngetById : This method returns ConfigData based on the given ConfigId if it exists otherwise returns undefined.\nType definitions of getById method can be found here\nTypescript copysourceconst configId: ConfigId = await configService.update(filePath, updatedConfigData, commentOnUpdate)\n\nconst maybeConfigData: Option<ConfigData> = await configService.getById(filepath, configId)\ngetByTime : This method gets the ConfigData at the given path as it existed at a given time-instance.\nNote: -If time-instance is before the file was created, the initial version is returned. -If time-instance is after the last change, the most recent version is returned.\nType definitions of getByTime method can be found here\nTypescript copysourceconst configId1: ConfigId = await configService.create(filePath, updatedConfigData, false, commentOnUpdate)\n\nconst beforeUpdate = new Date()\n\nconst configId2: ConfigId = await configService.update(filePath, configData, commentOnUpdate)\nconst afterUpdate = new Date()\n\nconst maybeConfigData: Option<ConfigData> = await configService.getByTime(filepath, beforeUpdate)\n// maybeConfigData == updatedConfigData (i.e Initial revision of config)\n\nconst newlyUpdatedData: Option<ConfigData> = await configService.getByTime(filepath, afterUpdate)\n// newlyUpdatedData == configData (i.e Latest revision of config)","title":"Fetching Files"},{"location":"/services/config-service.html#checking-file-existence","text":"This method checks whether file exists at the given path and optional specific configId in the repository and returns true if it does exist or else false.\nType definitions of exists method can be found here\nTypescript copysourceconst exists: boolean = await configService.exists(filePath)\n\nconst exist: boolean = await configService.exists(filePath, configId)","title":"Checking file existence"},{"location":"/services/config-service.html#deleting-file","text":"This method deletes a file located at specified path in the repository.\nType definitions of delete method can be found here\nTypescript copysourceconst filePath = 'esw/sequencer/obsMode.conf'\n\nawait configService.delete(filePath, 'deleting the invalid config entry')","title":"Deleting File"},{"location":"/services/config-service.html#listing-files","text":"This method list all the files for a given FileType (Annex or Normal) and an optional pattern string, it will list all files with the file path matching the given pattern.\nSome pattern examples are: “/path/hcd/*.*”, “a/b/c/d.*”, “.*.conf”, “.*hcd.*”\nType definitions of list method can be found here\nTypescript copysourceconst allAnnexFilesInfo: ConfigFileInfo[] = await configService.list({\n  type: 'Annex'\n})\nconst allNormalFilesInfo: ConfigFileInfo[] = await configService.list({\n  type: 'Normal'\n})\nconst allHcdAnnexFilesInfo: ConfigFileInfo[] = await configService.list({\n  type: 'Annex',\n  pattern: '.*hcd.*'\n})\nconst allConfNormalFilesInfo: ConfigFileInfo[] = await configService.list({\n  type: 'Normal',\n  pattern: '.*conf'\n})","title":"Listing files"},{"location":"/services/config-service.html#fetching-revision-history-of-a-file","text":"This method returns the history of revisions of the file at the given path for a range of period specified by from and to.\nThe size of the list can be restricted using maxResults.\nType definitions of history method can be found here\nTypescript copysourceconst filePath = 'esw/sequencer/obsMode.conf'\nconst from = new Date(2019, 12, 31)\nconst to = new Date(2020, 12, 31)\n\n// upto 200 file revisions from 31st dec 2019 - 31st dec 2020 will be fetched\nconst fileRevisions: ConfigFileRevision[] = await configService.history(filePath, from, to, 200)","title":"Fetching revision history of a file"},{"location":"/services/config-service.html#getting-config-service-metadata","text":"This method returns metadata information about the Config Service. It includes:\nrepository directory annex directory min annex file size max config file size\nType definitions of getMetadata method can be found here\nTypescript copysourceconst metadata: ConfigMetadata = await configService.getMetadata()","title":"Getting Config Service Metadata"},{"location":"/services/config-service.html#managing-active-versions","text":"In its lifetime, a config file undergoes many revisions. An active version is a specific revision from a file’s history, and it is set by administrators.","title":"Managing active versions"},{"location":"/services/config-service.html#historyactive","text":"This method returns the history of active revisions of the file at the given path for a range of period specified by from and to. The size of the list can be restricted using maxResults.\nType definitions of historyActive method can be found here\nTypescript copysourceconst filePath = 'esw/sequencer/obsMode.conf'\nconst from = new Date(2019, 12, 31)\nconst to = new Date(2020, 12, 31)\n\n// upto 200 active file revisions from 31st dec 2019 - 31st dec 2020 will be fetched\nconst activeFileRevisions: ConfigFileRevision[] = await configService.historyActive(filePath, from, to, 200)","title":"historyActive"},{"location":"/services/config-service.html#setactiveversion","text":"This method sets the “active version” to be the version provided for the file at the given path. If this method is never called in a Config’s lifetime, the active version will always be the version returned by create function.\nType definitions of setActiveVersion method can be found here\nTypescript copysourceconst filePath = 'esw/sequencer/obsMode.conf'\nconst id: ConfigId = await configService.create(path, configData, false, comment)\nconst commentWhileSetting = `Making ${id} active on 1st dec 2020`\n\nawait configService.setActiveVersion(filePath, id, commentWhileSetting)","title":"setActiveVersion"},{"location":"/services/config-service.html#resetactiveversion","text":"This method resets the “active version” of the file at the given path to the latest version.\nType definitions of resetActiveVersion method can be found here\nTypescript copysourceconst filePath = 'esw/sequencer/obsMode.conf'\nconst id: ConfigId = await configService.create(path, configData, false, comment)\nconst commentWhileResetting = `Making ${id} active version to latest as of 1st dec 2020`\n\nawait configService.resetActiveVersion(filePath, commentWhileResetting)","title":"resetActiveVersion"},{"location":"/services/config-service.html#getactiveversion","text":"This method returns the revision ID which represents the “active version” of the file at the given path.\nType definitions of getActiveVersion method can be found here\nTypescript copysourceconst filePath = 'esw/sequencer/obsMode.conf'\n\nconst maybeConfigId: Option<ConfigId> = await configService.getActiveVersion(filePath)","title":"getActiveVersion"},{"location":"/services/config-service.html#getactivebytime","text":"This method returns the content of active version of the file existed at given instant of Time\nType definitions of getActiveByTime method can be found here\nTypescript copysourceconst filePath = 'esw/sequencer/obsMode.conf'\nconst at = new Date(2019, 12, 31)\n\nconst maybeConfigData: Option<ConfigData> = await configService.getActiveByTime(filePath, at)","title":"getActiveByTime"},{"location":"/services/event-service.html","text":"","title":"Event Service"},{"location":"/services/event-service.html#event-service","text":"Event Service provides methods to interact with the event server which implements the publish/subscribe messaging paradigm where one component publishes an event and all clients that have subscribed receive the event.","title":"Event Service"},{"location":"/services/event-service.html#pre-requisite","text":"The Location Service, Event Service and Gateway Server needs to be running in the network The necessary configuration, environment variables or system properties should be defined to point to the correct host and port number(s) for the Location Service nodes.","title":"Pre-requisite"},{"location":"/services/event-service.html#creation-of-event-service","text":"","title":"Creation of Event Service"},{"location":"/services/event-service.html#examples-to-create-a-client-for-event-service","text":"Typescript copysourceconst eventService: EventService = await EventService()","title":"Examples to create a client for Event Service"},{"location":"/services/event-service.html#usages-of-event-service","text":"Type definitions for all Event Service methods can be found here.","title":"Usages of Event Service"},{"location":"/services/event-service.html#publishing-an-event","text":"Event Service allows you to publish an Event to the event server.\nType definitions for publish method can be found here.\nTypescript copysourceconst sourcePrefix = new Prefix('IRIS', 'component')\nconst eventName = new EventName('move-event')\nconst positionParameter = intKey('positions', Units.centimeter).set([10, 20, 30])\nconst paramSet: Parameter<IntKey>[] = [positionParameter]\n\nconst event = ObserveEvent.make(sourcePrefix, eventName, paramSet)\n\nconst done: Done = await eventService.publish(event)","title":"Publishing an Event"},{"location":"/services/event-service.html#get-events","text":"This method is used to get events for set of EventKeys. This is different from subscribing to event. Use this method to get occurred events. If you want to consume live events, use subscription methods.\nType definitions for get method can be found here.\nExample for getting events:\nTypescript copysourceconst sourcePrefix = new Prefix('IRIS', 'component')\n\nconst eventKey1 = new EventKey(sourcePrefix, new EventName('eventKey1'))\nconst eventKey2 = new EventKey(sourcePrefix, new EventName('eventKey2'))\n\nconst eventKeys = new Set([eventKey1, eventKey2])\nconst events: Event[] = await eventService.get(eventKeys)","title":"Get Events"},{"location":"/services/event-service.html#subscribe-to-the-events","text":"Subscribing to Event can be done via two ways. User can subscribe to -\nMultiple EventKeys. All the EventKeys of specific subsystem and pattern.\nWhen you subscribe for the given EventKeys, events are received at every frequency. The methods take callback function which gets triggered whenever the events are received.\nType definitions of both methods can be found by below links :\nsubscribe. pSubscribe.\nExample for subscribing events with given EventKeys:\nTypescript copysourceconst sourcePrefix = new Prefix('IRIS', 'component')\n\nconst eventKey1 = new EventKey(sourcePrefix, new EventName('eventKey1'))\nconst eventKey2 = new EventKey(sourcePrefix, new EventName('eventKey2'))\n\nconst onEventCallback = (event: Event) => {\n  console.log(event)\n  // make use of ${event} inside this callback function\n}\nconst eventKeys = new Set([eventKey1, eventKey2])\n//optional\nconst onErrorCallback = (error: ServiceError) => {\n  // do something when error occurs\n  // for ex : close connection / cleanup resources\n  console.log(error)\n}\n//optional\nconst onCloseCallback = () => {\n  // do something when connection is closed\n  // for ex : reset client-side state\n}\nconst subscription: Subscription = eventService.subscribe(eventKeys, 10)(\n  onEventCallback,\n  onErrorCallback,\n  onCloseCallback\n)\n\n//To cancel the subscription\nsubscription.cancel()\nExample for subscribing events with given subsystem:\nTypescript copysourceconst onEventCallback = (event: Event) => {\n  // make use of ${event} inside this callback function\n  console.log(event)\n}\n//optional\nconst onErrorCallback = (error: ServiceError) => {\n  // do something when error occurs\n  // for ex : close connection / cleanup resources\n  console.log(error)\n}\n//optional\nconst onCloseCallback = () => {\n  // do something when connection is closed\n  // for ex : reset client-side state\n}\n// subscribe to all ESW subsystem's event\nconst subscription: Subscription = eventService.pSubscribe('ESW', 10, '.*')(\n  onEventCallback,\n  onErrorCallback,\n  onCloseCallback\n)\n\n// subscribe to specific events having hcd in the event name\nconst specificSubscription: Subscription = eventService.pSubscribe('ESW', 10, '(hcd)')(onEventCallback)\n\n//To cancel the subscription\nsubscription.cancel()","title":"Subscribe to the Events"},{"location":"/services/location-service.html","text":"","title":"Location Service"},{"location":"/services/location-service.html#location-service","text":"The Location Service handles component (i.e. Applications, Sequencers, Assemblies, HCDs, and Services) discovery in the distributed TMT software system.\nA component’s location information can be used by other components and services to connect to it and use it.\nType definition for location model can be found here.","title":"Location Service"},{"location":"/services/location-service.html#creation-of-location-service","text":"","title":"Creation of Location Service"},{"location":"/services/location-service.html#pre-requisite","text":"Access token is not necessary for using Location Service query APIs.\nIf You are using Location Service to unregister a component, you would need to have the authorization Token with correct access role. Documentation on how to fetch access token could be found here.","title":"Pre-requisite"},{"location":"/services/location-service.html#examples-to-create-a-client-for-location-service","text":"Location Service constructor takes optional tokenFactory and optional location server configuration(host/port pair).\nTypescript copysourceconst tokenFactory = () => auth.token\n\nconst locationServiceWithToken: LocationService = await LocationService({\n  tokenFactory\n})\n\nconst locationService: LocationService = await LocationService()\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"Examples to create a client for Location Service"},{"location":"/services/location-service.html#usages-of-location-service","text":"Type definitions for all methods can be found here.","title":"Usages of Location Service"},{"location":"/services/location-service.html#listing-filtering-locations","text":"Location Service provides multiple ways to get list of locations registered in the TMT cluster.\nType definitions for relevant listings methods can be found by following links:\nlist. listByPrefix. listByHostname. listByComponentType. listByConnectionType.\nFollowing example showcases the listByComponentType api usage\nTypescript copysource// valid Component types : HCD, Assembly, Service, Container, Sequencer, SequenceComponent and Machine\n\nconst sequencerLocations: Location[] = await locationService.listByComponentType('Sequencer')\n\nconst hcdLocations: Location[] = await locationService.listByComponentType('HCD')\n\nconst assemblyLocations: Location[] = await locationService.listByComponentType('Assembly')","title":"Listing & Filtering Locations"},{"location":"/services/location-service.html#resolving-connection","text":"There are two ways to get/fetch a location information of a connection:\nUsing resolve API Using find API\nLocation Service’s resolve API uses Connection a component to resolve the location within some timeout duration. However, find API does not wait to resolve location. If the location is not present, it returns undefined.\nType definitions for both methods can be found by following links:\nfind. resolve.\nTypescript copysource// ConnectionTypes : HttpConnection, AkkaConnection & TcpConnection\n// Time unit : seconds, milliseconds, nanoseconds, microseconds, minutes, hours, days\n\nconst connection = HttpConnection(new Prefix('ESW', 'component'), 'HCD')\n\nconst maybeLocation1: Option<Location> = await locationService.resolve(connection, 10, 'seconds')\nif (maybeLocation1) {\n  // use maybeLocation inside here\n} else {\n  // location did not resolved in 10 seconds\n}","title":"Resolving Connection"},{"location":"/services/location-service.html#unregister-a-connection","text":"This is a secure API and takes a type of Connection as an input argument to be unregistered from the Location Service and returns Done once unregistered.\nType definitions for unregister method can be found here\nThe following example shows unregister method can be called:\nTypescript copysource// ConnectionTypes : HttpConnection, AkkaConnection & TcpConnection\nconst done: Done = await locationServiceWithToken.unregister(HttpConnection(new Prefix('ESW', 'component'), 'HCD'))","title":"Unregister a Connection"},{"location":"/services/location-service.html#tracking-connection","text":"The lifecycle of a connection of interest can be followed using either the track API. The connection update events will be received by the callback provided to this method. This method returns a subscription which can be used to cancel the tracking subscription.\nType definitions for track method can be found here\nThe following example shows track method can be called:\nTypescript copysource// a optional callback function\nconst onErrorCallback = (error: ServiceError) => {\n  // do something when error occurs\n  // for ex : close connection / cleanup resources\n  console.log(error)\n}\n//optional\nconst onCloseCallback = () => {\n  // do something when connection is closed\n  // for ex : reset client-side state\n}\n\nconst onTrackingEvent = (event: TrackingEvent) => {\n  if (event._type === 'LocationRemoved') {\n    // do something when connection's location is removed from the location service\n  } else if (event._type === 'LocationUpdated') {\n    // do something when connection's location is updated from the location service\n  }\n}\n// connection to be tracked\nconst httpConnection = HttpConnection(new Prefix('ESW', 'component'), 'HCD')\n\nlocationService.track(httpConnection)(onTrackingEvent, onErrorCallback, onCloseCallback)","title":"Tracking Connection"},{"location":"/services/logging-service.html","text":"","title":"Logging Service"},{"location":"/services/logging-service.html#logging-service","text":"Logging Service provides the HTTP Interface to write log-messages for a Component.","title":"Logging Service"},{"location":"/services/logging-service.html#pre-requisite","text":"In order to use Logging Service APIs:\nThe Location Service Gateway Server needs to be running in the network","title":"Pre-requisite"},{"location":"/services/logging-service.html#creation-of-logging-service","text":"","title":"Creation of Logging Service"},{"location":"/services/logging-service.html#to-create-logging-service","text":"Typescript copysourceconst loggingService: LoggingService = await LoggingService()\nconst locationService: LocationService = await LocationService()","title":"To create Logging Service"},{"location":"/services/logging-service.html#apis","text":"Async-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"APIs"},{"location":"/services/logging-service.html#usages-of-logging-service","text":"Type Definition for the Logging Service interface can be found here","title":"Usages of Logging Service"},{"location":"/services/logging-service.html#creating-log-for-an-incident","text":"This method will be used to create a log entry for a component with a specific log Level.\nI.e. when a user submits a setup command for a component using Command Service.\nUser may want to create explicit log entry based on success or failure scenario.\nType definition can be found - here.\nTypescript copysourcelet prefix = new Prefix('ESW', 'comp1')\nconst commandService: CommandService = await CommandService(new ComponentId(prefix, 'Assembly'))\nconst intParam = intKey('positions').set([1, 2, 3])\nconst setup = new Setup(prefix, 'move', [intParam])\nconst response = await commandService.submit(setup)\nswitch (response._type) {\n  case 'Completed':\n    await loggingService.log(prefix, 'INFO', 'Successfully submitted move command', {\n      params: [intParam]\n    })\n    break\n  default:\n    await loggingService.log(prefix, 'ERROR', 'Failed to submit move command', {\n      params: [intParam]\n    })\n}","title":"Creating Log for an incident"},{"location":"/technical/index.html","text":"","title":"Technical Design Documentation"},{"location":"/technical/index.html#technical-design-documentation","text":"","title":"Technical Design Documentation"},{"location":"/technical/index.html#architectural-overview","text":"Following diagram explains UI application flow for making request to TMT backend component and explains where does the ESW-TS service fits in the whole TMT architecture.\nFor example: A Web application specifically created for sending Control Command to a HCD component.\nUser clicks on “submit” button. Command Service of ESW-TS creates appropriate payload adhering to service contract exposed by Gateway Server. ESW-TS service uses fetch API of browser to make request. Gateway Server on receiving correct payload, processes it and sends the Control Command to the destined HCD component. On successfully handling of command by HCD component, Gateway Server returns a SuccessResponse. ESW-TS handles the response and returns it, as it was received to the caller Web-UI component or in case of error throws ServiceError.","title":"Architectural overview"},{"location":"/technical/agent-service.html","text":"","title":"Agent Service"},{"location":"/technical/agent-service.html#agent-service","text":"Agent Service provides HTTP interface to interact with all agent machines uniquely located using agent prefix. APIs to spawn components takes agent prefix as parameter. Agent prefix is used to locate agent machine using Location Service.\nAgent Service provides APIs to spawn Sequence Manager, Sequence Components and to kill spawned components.","title":"Agent Service"},{"location":"/technical/agent-service.html#creation-of-agent-service","text":"","title":"Creation of Agent Service"},{"location":"/technical/agent-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/technical/agent-service.html#in-order-to-use-agent-service-apis","text":"Agent machines should be up and running. Locations of agent machines should be registered in Location Service. Authorization token with correct access role. Documentation on how to fetch authorization token could be found here.","title":"In order to use agent service APIs"},{"location":"/technical/agent-service.html#to-create-agent-service-client","text":"Typescript copysourceconst tokenFactory = () => auth.token\n\nconst agentService: AgentService = await AgentService({ tokenFactory })\nAsync-Await Note that the examples are using async/await which makes handling of promises more readable.","title":"To create Agent Service client"},{"location":"/technical/agent-service.html#usages-of-agent-service","text":"Type definitions for all Agent Service methods can be found here","title":"Usages of Agent Service"},{"location":"/technical/agent-service.html#spawning-a-sequence-manager","text":"Agent Service requires agent (a component of type :Machine) to be able to process requests. Once it locates an agent using Location Service with the help of agent prefix, it sends a spawn Sequence Manager command to the agent machine. The corresponding AP call fails if the Sequence Manager is already running, or the underlying agent fails to spawn it.\nType definitions for spawnSequenceManager can be found here\nTypescript copysourceconst agentPrefix = new Prefix('ESW', 'agent1')\nconst obsModeConfigPath = '/obs-mode.conf'\nconst sequenceManagerVersion = '1.0.0'\n\nconst spawnResponse1: SpawnResponse = await agentService.spawnSequenceManager(\n  agentPrefix,\n  obsModeConfigPath,\n  false,\n  sequenceManagerVersion\n)","title":"Spawning a Sequence Manager"},{"location":"/technical/agent-service.html#spawning-a-sequence-component","text":"Similar to spawning a Sequence Manager, Agent Service locates an agent and then it sends a spawn Sequence Component command to the agent machine. The corresponding API call fails if the Sequence Component is already running, or the underlying agent fails to spawn it.\nType definitions for spawnSequenceComponent can be found here\nTypescript copysourceconst ocsAppVersion = '1.2.1'\nconst spawnResponse2: SpawnResponse = await agentService.spawnSequenceComponent(\n  agentPrefix,\n  'component1',\n  ocsAppVersion\n)","title":"Spawning a Sequence Component"},{"location":"/technical/agent-service.html#kill-a-sequence-component","text":"Agent service kills any process running on the agent machine using the process id (pid) of that component. it uses location service to find the process id from the metadata field of location information.\nType definitions for killComponent can be found here\nTypescript copysourceconst compPrefix = new Prefix('ESW', 'SomeComponent')\nconst componentToBeKilled = new ComponentId(compPrefix, 'Service')\nconst killResponse: KillResponse = await agentService.killComponent(componentToBeKilled)","title":"Kill a Sequence Component"},{"location":"/technical/agent-service.html#getting-agent-status","text":"To get Agent Status for a running Agent, AgentService provides getAgentStatus method. This method allows showing status of TMT ecosystem components (agents, sequence components and sequencers). It returns all agents that are up and running, sequence components running on those agents and sequencer script loaded on sequence component.\nType definitions of getAgentStatus method can be found here\nThe following example shows how to call getAgentStatus method:\nTypescript copysourceconst agentStatus: AgentStatusResponse = await agentService.getAgentStatus()","title":"Getting Agent Status"},{"location":"/technical/sequencer-service.html","text":"","title":"Sequencer Service"},{"location":"/technical/sequencer-service.html#sequencer-service","text":"This service provides a handle to send commands to a Sequencer which is registered in Location Service.","title":"Sequencer Service"},{"location":"/technical/sequencer-service.html#creation-of-sequencer-service","text":"","title":"Creation of Sequencer Service"},{"location":"/technical/sequencer-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/technical/sequencer-service.html#in-order-to-use-sequencer-service-client-for-a-specific-sequencer","text":"The Sequencer and Gateway Server should be running. GatewayException(InvalidComponent) will be thrown if the specified sequencer not found in the Location Service. Authorization token with correct access role. Documentation on how to fetch access token could be found here.","title":"In order to use sequencer service client for a specific sequencer"},{"location":"/technical/sequencer-service.html#to-create-sequencer-service","text":"Typescript copysourceconst tokenFactory = () => auth.token\n\nconst sequencerService: SequencerService = await SequencerService(\n  new ComponentId(new Prefix('ESW', 'darknight'), 'Sequencer'),\n  { tokenFactory }\n)","title":"To create Sequencer Service"},{"location":"/technical/sequencer-service.html#creating-sequencecommands","text":"Typescript copysourceconst eswTestPrefix = Prefix.fromString('TCS.darknight')\n\nconst setupCommand1 = new Setup(eswTestPrefix, 'setup-command1')\nconst setupCommand2 = new Setup(eswTestPrefix, 'setup-command2')\n\nconst observeCommand1 = new Observe(eswTestPrefix, 'observe-command1')\nconst observeCommand2 = new Observe(eswTestPrefix, 'observe-command2')","title":"Creating SequenceCommands"},{"location":"/technical/sequencer-service.html#creating-a-sequence","text":"A sequence is a list of sequence commands:\nTypescript copysource//sequence is a list of SequenceCommand\nconst sequence = new Sequence([setupCommand1, observeCommand1])","title":"Creating a Sequence"},{"location":"/technical/sequencer-service.html#usages-of-sequencer-service","text":"Async-Await Note that the examples are using async/await which makes handling of promises more readable.\nType Definitions for Sequencer Service can be found here","title":"Usages of Sequencer Service"},{"location":"/technical/sequencer-service.html#loading-and-starting-a-sequence-into-a-sequencer","text":"To load a sequence into a Sequencer, SequencerService provides loadSequence method which takes a Sequence and returns a Promise<OkOrUnhandledResponse>. If Sequencer is in Idle state, provided sequence gets loaded into the Sequencer and an Ok response gets returned. Otherwise, an Unhandled response gets returned.\nTo start a loaded sequence, SequencerService provides startSequence method which starts the sequence (which is loaded by loadSequence method) in the Sequencer and returns a Promise<SubmitResponse>. If Sequencer is in Loaded state, loaded sequence’s execution gets started in the Sequencer and a Started response gets returned. Otherwise, a negative SubmitResponse gets returned.\nType definitions for methods used in the given example are :\nloadSequence startSequence query queryFinal\nTypescript copysourceconst okOrUnhandledResponse: OkOrUnhandledResponse = await sequencerService.loadSequence(sequence)\nconst initialResponse: SubmitResponse = await sequencerService.startSequence()\n\nconst queryResponse: SubmitResponse = await sequencerService.query(initialResponse.runId)\nconst queryFinalResponse: SubmitResponse = await sequencerService.queryFinal(initialResponse.runId, 5)","title":"Loading and Starting a Sequence into a Sequencer"},{"location":"/technical/sequencer-service.html#adding-commands-into-the-sequence-after-all-the-pending-steps","text":"To add commands into the sequence after all the pending steps, SequencerService provides add method which takes list of SequenceCommands and returns Promise<OkOrUnhandledResponses>. If Sequencer is still in execution, then given list of SequenceCommands gets added into the sequence after all the pending steps and a Ok response gets returned. Otherwise, an Unhandled response gets returned.\nType definitions for add method used can be found here\nTypescript copysourceconst addResponse: OkOrUnhandledResponse = await sequencerService.add([observeCommand2, setupCommand2])","title":"Adding commands into the sequence after all the pending steps"},{"location":"/technical/sequencer-service.html#prepending-commands-into-the-sequence-before-all-the-pending-steps","text":"To add commands into the sequence before all the pending steps, SequencerService provides add method which takes list of SequenceCommands and returns Promise<OkOrUnhandledResponses>. If Sequencer is still in execution, then given list of SequenceCommands gets added into the sequence before all the pending steps and a Ok response gets returned. Otherwise, an Unhandled response gets returned.\nType definitions for prepend method used can be found here\nTypescript copysourceconst prependResponse: OkOrUnhandledResponse = await sequencerService.prepend([observeCommand2, setupCommand2])","title":"Prepending commands into the sequence before all the pending steps"},{"location":"/technical/sequencer-service.html#replacing-a-command-with-a-list-of-commands","text":"To replace a command with a list of commands, SequencerService provides replace method which takes the Id of the command which to be replaced and list of SequenceCommands and returns Promise<GenericResponse>. In case, if the command of the given Id is not present in sequence, then IdDoesNotExist response gets returned. Or if the command is already finished or in flight, then a CannotOperateOnAnInFlightOrFinishedStep response gets returned. In case, if the command is still pending, then it gets replaced with the given list of SequenceCommands. Otherwise, an Unhandled response gets returned.\nType definitions for replace method used can be found here\nTypescript copysourceconst replaceResponse: GenericResponse = await sequencerService.replace('d99b6cf6-553c-49e9-9089-aaa494f116e9', [\n  observeCommand2,\n  setupCommand2\n])","title":"Replacing a command with a list of commands"},{"location":"/technical/sequencer-service.html#inserting-a-list-of-commands-after-a-command","text":"To insert a list of commands after a command, SequencerService provides insertAfter method which takes the Id of the command after which commands to be inserted and list of SequenceCommands and returns Promise<GenericResponse>. In case, if the command of the given Id is not present in sequence, then IdDoesNotExist response gets returned. Or if the command is already finished or in flight, then a CannotOperateOnAnInFlightOrFinishedStep response gets returned. In case, if the command is still pending, then the given list of SequenceCommands gets inserted after it. Otherwise, an Unhandled response gets returned.\nType definitions for insertAfter method used can be found here\nTypescript copysourceconst insertAfterResponse: GenericResponse = await sequencerService.insertAfter(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9',\n  [observeCommand2, setupCommand2]\n)","title":"Inserting a list of commands after a command"},{"location":"/technical/sequencer-service.html#deleting-a-command-from-the-sequence","text":"To delete a command from the sequence, SequencerService provides delete method which takes the Id of the command to be deleted and returns Promise<GenericResponse>. If sequencer is not in Running state, then Unhandled response gets returned. Or if the command of the given Id, is not present in sequence, then IdDoesNotExist response gets returned. Or if the command is still pending, then it gets deleted and Ok response gets returned. Otherwise, a CannotOperateOnAnInFlightOrFinishedStep response gets returned.\nType definitions for delete method used can be found here\nTypescript copysourceconst deleteResponse: GenericResponse = await sequencerService.delete('d99b6cf6-553c-49e9-9089-aaa494f116e9')","title":"Deleting a command from the sequence"},{"location":"/technical/sequencer-service.html#adding-a-breakpoint-to-a-step","text":"To add a breakpoint to a Step, SequencerService provides addBreakpoint method which takes the Id of the command where breakpoint to be added and returns Promise<GenericResponse>. If sequencer is not in Running state, then Unhandled response gets returned. Or if the command of the given Id, is not present in sequence, then IdDoesNotExist response gets returned. Or if the command is still pending, then breakpoint gets added and Ok response gets returned. Otherwise, a CannotOperateOnAnInFlightOrFinishedStep response gets returned.\nType definitions for addBreakpoint method used can be found here\nTypescript copysourceconst addBreakpointResponse: GenericResponse = await sequencerService.addBreakpoint(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9'\n)","title":"Adding a breakpoint to a Step"},{"location":"/technical/sequencer-service.html#removing-a-breakpoint-from-a-step","text":"To remove a breakpoint from a Step, SequencerService provides removeBreakpoint method which takes the Id of the command from where breakpoint to be removed and returns Promise<RemoveBreakpointResponse>. If sequencer is not in Running state, then Unhandled response gets returned. Or if the command of the given Id, is not present in sequence, then IdDoesNotExist response gets returned. Otherwise, breakpoint gets removed and Ok response gets returned.\nType definitions for removeBreakpoint method used can be found here\nTypescript copysourceconst removeBreakpointResponse: RemoveBreakpointResponse = await sequencerService.removeBreakpoint(\n  'd99b6cf6-553c-49e9-9089-aaa494f116e9'\n)","title":"Removing a breakpoint from a Step"},{"location":"/technical/sequencer-service.html#pausing-the-sequence","text":"To pause the sequence, SequencerService provides pause method which returns Promise<PauseResponse>. If sequencer is in Running state, then an Ok response gets returned if there is a Step pending. Otherwise, a CannotOperateOnAnInFlightOrFinishedStep response gets returned. Or if sequencer is not in Running state, then Unhandled response gets returned.\nType definitions for pause method used can be found here\nTypescript copysourceconst pauseResponse: PauseResponse = await sequencerService.pause()","title":"Pausing the sequence"},{"location":"/technical/sequencer-service.html#resuming-a-paused-sequence","text":"To resume a paused sequence, SequencerService provides resume method which returns Promise<PauseResponse>. If sequencer is in Running state, an Ok response gets returned. Otherwise, an Unhandled response gets returned.\nType definitions for resume method used can be found here\nTypescript copysourceconst resumeResponse: OkOrUnhandledResponse = await sequencerService.resume()","title":"Resuming a paused sequence"},{"location":"/technical/sequencer-service.html#getting-the-sequence-from-the-sequencer","text":"To get the sequence from the Sequencer, SequencerService provides getSequence method which returns the StepList (runtime representation of the sequence). if there is no sequence executing in the Sequencer, an undefined response gets returned.\nType definitions for getSequence method used can be found here\nTypescript copysourceconst getSequenceRes: Option<StepList> = await sequencerService.getSequence()","title":"Getting the sequence from the Sequencer"},{"location":"/technical/sequencer-service.html#checking-if-sequencer-is-available","text":"To check if Sequencer is available, SequencerService provides isAvailable method which returns Promise<boolean>. If Sequencer is in Idle state, then a true gets returned. Otherwise, false response gets returned.\nType definitions for isAvailable method used can be found here\nTypescript copysourceconst isAvailable: boolean = await sequencerService.isAvailable()","title":"Checking if Sequencer is available"},{"location":"/technical/sequencer-service.html#checking-if-sequencer-is-online","text":"To check if Sequencer is online, SequencerService provides isOnline method which returns Promise<boolean>. If Sequencer is in Idle state, then a true gets returned. Otherwise, false gets returned.\nType definitions for isOnline method used can be found here\nTypescript copysourceconst isOnline: boolean = await sequencerService.isOnline()","title":"Checking if Sequencer is online"},{"location":"/technical/sequencer-service.html#discarding-all-the-pending-steps","text":"To discard all the pending Steps, SequencerService provides a reset method which returns Promise<OkOrUnhandledResponse>. If Sequencer is in Running state, then an Ok response gets returned. Otherwise, an Unhandled response gets returned.\nType definitions for reset method used can be found here\nTypescript copysourceconst resetResponse: OkOrUnhandledResponse = await sequencerService.reset()","title":"Discarding all the pending Steps"},{"location":"/technical/sequencer-service.html#discarding-all-the-pending-steps-and-calling-the-onabortsequence-handler-of-the-script","text":"To discard all the pending Steps and call the onAbortSequence handler of the script, SequencerService provides a abortSequence method which returns Promise<OkOrUnhandledResponse>. If Sequencer is in Running state, then an Ok response gets returned. Otherwise, an Unhandled response gets returned.\nType definitions for abortSequence method used can be found here\nTypescript copysourceconst abortResponse: OkOrUnhandledResponse = await sequencerService.abortSequence()","title":"Discarding all the pending Steps and calling the onAbortSequence handler of the script"},{"location":"/technical/sequencer-service.html#discarding-all-the-pending-steps-and-calling-the-onstop-handler-of-the-script","text":"To discard all the pending Steps and call the onStop handler of the script, SequencerService provides a stop method which returns Promise<OkOrUnhandledResponse>. If Sequencer is in Running state, then an Ok response gets returned. Otherwise, an Unhandled response gets returned.\nType definitions for stop method used can be found here\nTypescript copysourceconst stopResponse: OkOrUnhandledResponse = await sequencerService.stop()","title":"Discarding all the pending Steps and calling the onStop handler of the script"},{"location":"/technical/sequencer-service.html#changing-sequencer-state-to-online","text":"To change Sequencer state to Online, SequencerService provides goOnline method which returns Promise<GoOnlineResponse>. If Sequencer is in any state but Running, then an Ok response gets returned (if goOnline handler gets executed successfully). Otherwise, a GoOnlineHookFailed response gets returned. Although, if Sequencer is in Running state, then an Unhandled response gets returned.\nType definitions for goOnline method used can be found here\nTypescript copysourceconst goOnlineResponse: GoOnlineResponse = await sequencerService.goOnline()","title":"Changing Sequencer state to Online"},{"location":"/technical/sequencer-service.html#changing-sequencer-state-to-offline","text":"To change Sequencer state to Offline, SequencerService provides goOffline method which returns Promise<GoOfflineResponse>. If Sequencer is in any State but Running, then an Ok response gets returned (if goOffline handler gets executed successfully). Otherwise, a GoOfflineHookFailed response gets returned. Although, if Sequencer is in Running state, then an Unhandled response gets returned.\nType definitions for goOffline method used can be found here\nTypescript copysourceconst goOfflineResponse: GoOfflineResponse = await sequencerService.goOffline()","title":"Changing Sequencer state to Offline"},{"location":"/technical/sequencer-service.html#running-diagnosticmode","text":"To run diagnosticMode handler, SequencerService provides diagnosticMode method which returns Promise<DiagnosticModeResponse>. If diagnosticMode handler of the script successfully executes, then an Ok response gets returned. Otherwise, a DiagnosticHookFailed gets returned.\nType definitions for diagnosticMode method used can be found here\nTypescript copysourceconst diagnosticResponse: DiagnosticModeResponse = await sequencerService.diagnosticMode(new Date(), 'engineering')","title":"Running diagnosticMode"},{"location":"/technical/sequencer-service.html#running-operationsmode","text":"To run operationsMode handler, SequencerService provides operationsMode method which returns Promise<OperationsModeResponse>. If operationsMode handler of the script successfully executes, then an Ok response gets returned. Otherwise, a OperationsHookFailed gets returned.\nType definitions for operationsMode method used can be found here\nTypescript copysourceconst operationsModeResponse: OperationsModeResponse = await sequencerService.operationsMode()","title":"Running operationsMode"},{"location":"/technical/sequencer-service.html#submitting-sequence-to-a-sequencer","text":"To submit a Sequence to a Sequencer, SequencerCommandService provides a submit method which takes a Sequence and returns a Promise<SubmitResponse>.\nIf the Sequencer is idle, then provided sequence gets loaded in the Sequencer, execution of the sequence starts immediately and a Started response gets returned. If the sequencer is already running another sequence, then an Invalid response gets returned.\nTypescript copysourceconst initialRes: SubmitResponse = await sequencerService.submit(sequence)\n\nconst queryRes: SubmitResponse = await sequencerService.query(initialRes.runId)\n\nconst queryFinalRes: SubmitResponse = await sequencerService.queryFinal('d99b6cf6-553c-49e9-9089-aaa494f116e9', 10)\nThe query or queryFinal methods, as shown above, could be used to query for the sequence result after the sequence is submitted. The query method returns a current response which could be either final response (eg. Completed) or intermediate response (eg. Started). Whereas queryFinal will wait for the final response of the sequence for the given timeout. This method will never return an intermediate response.\nIf you are not interested in initial/intermediate response but only in final response, you can use the submitAndWait method which submits the sequence and waits for the final response (if the sequence was successfully Started).\nTypescript copysourceconst submitAndWaitResponse: SubmitResponse = await sequencerService.submitAndWait(sequence, 10)\nType definitions for APIs used in the given example are :\nsubmit submitAndWait query queryFinal","title":"Submitting Sequence to a Sequencer"},{"location":"/technical/sequencer-service.html#getting-status-of-sequencer","text":"To get Sequencer’s State, SequenceService provides getSequencerState method. This method returns Promise<SequencerState> the state of sequencer can be Idle, Processing, Loaded, Offline, Running\nType definitions for getSequencerState method used can be found here\nTypescript copysourceconst getSequencerState: SequencerState = await sequencerService.getSequencerState()","title":"Getting Status of Sequencer"},{"location":"/technical/sequencer-service.html#subscribing-to-sequencer-state","text":"To subscribe to state of Sequencer, subscribeSequencerState method can be used. This method invokes the given callback on every state change with newly received SequencerStateResponse. SequencerStateResponse contains the current SequencerState and StepList. This method returns a Subscription which can be used to unsubscribe, as shown in example.\nType definitions for subscribeSequencerState method used can be found here\nTypescript copysourceconst callBack = (sequencerStateResponse: SequencerStateResponse) => {\n  console.log(sequencerStateResponse)\n}\n//optional\nconst onErrorCallback = (error: ServiceError) => {\n  // do something when error occurs\n  // for ex : close connection / cleanup resources\n  console.log(error)\n}\n//optional\nconst onCloseCallback = () => {\n  // do something when connection is closed\n  // for ex : reset client-side state\n}\nconst subscription: Subscription = sequencerService.subscribeSequencerState()(\n  callBack,\n  onErrorCallback,\n  onCloseCallback\n)\n//...\nsubscription.cancel() // to unsubscribe","title":"Subscribing to Sequencer State"},{"location":"/technical/sequence-manager-service.html","text":"","title":"Sequence Manager Service"},{"location":"/technical/sequence-manager-service.html#sequence-manager-service","text":"The Sequence Manager Service manages all the operation related to the observations. It manages all sequence components and sequencers required for the observations.","title":"Sequence Manager Service"},{"location":"/technical/sequence-manager-service.html#creation-of-sequence-manager-service","text":"","title":"Creation of Sequence Manager Service"},{"location":"/technical/sequence-manager-service.html#pre-requisite","text":"","title":"Pre-requisite"},{"location":"/technical/sequence-manager-service.html#in-order-to-use-sequence-manager-service-apis","text":"Subsystem’s agent machines should be up and running. Sequence Manager should be spawned. Documentation on how to spawn Sequence Manager could be found here. Authorization Token with correct access role. Documentation on how to fetch authorization token could be found here.","title":"In order to use Sequence Manager Service APIs"},{"location":"/technical/sequence-manager-service.html#to-create-sequence-manager-client","text":"Typescript copysourceconst tokenFactory = () => auth.token\nconst sequenceManagerService: SequenceManagerService = await SequenceManagerService({\n  tokenFactory\n})","title":"To create Sequence Manager client"},{"location":"/technical/sequence-manager-service.html#usages-of-sequence-manager-service","text":"","title":"Usages of Sequence Manager Service"},{"location":"/technical/sequence-manager-service.html#configuring-resources","text":"To configure resources, SequenceManagerService provides configure method. This method starts sequencers needed for an observation mode. Before starting sequencer, it checks for resource conflict between requested observation mode and running observation mode. The required sequencers and resources are listed in obsModeConfig file provided at boot up time of Sequence Manager. It returns ConflictingResourcesWithRunningObsMode if required resources are not available. This method returns response containing Success as ConfigureResponse after successful start of all required sequencers.\nThe following example shows how to call configure method. Here machines will be setup for 'IRIS_DarkNight' observation mode.\nType definitions of configure method can be found here\nTypescript copysourceconst obsMode = new ObsMode('IRIS_DarkNight')\nconst configureResponse: ConfigureResponse = await sequenceManagerService.configure(obsMode)","title":"Configuring Resources"},{"location":"/technical/sequence-manager-service.html#provisioning","text":"To provision resources, SequenceManagerService provides provision method. This method shuts down all the running sequence components and provisions the new sequence components in accordance with the provided configuration. The configuration specifies number of sequence components needed to be spawned on a particular agent. It returns Success as ProvisionResponse after successful spawning of components.\nIn following example, three sequence components will be spawned on 'ESW.agent-machine' agent machine and two sequence component will be spawned on 'IRIS.agent-machine' agent machine.\nType definitions of provision method can be found here\nTypescript copysourceconst eswAgentPrefix = new Prefix('ESW', 'agent-machine')\nconst irisAgentPrefix = new Prefix('IRIS', 'agent-machine')\nconst eswAgentProvisionConfig = new AgentProvisionConfig(eswAgentPrefix, 3)\nconst irisAgentProvisionConfig = new AgentProvisionConfig(irisAgentPrefix, 2)\nconst provisionConfig = new ProvisionConfig([eswAgentProvisionConfig, irisAgentProvisionConfig])\n\nconst provision: ProvisionResponse = await sequenceManagerService.provision(provisionConfig)","title":"Provisioning"},{"location":"/technical/sequence-manager-service.html#getting-obsmodes-details","text":"To get all obsModes details, SequenceManagerService provides getObsModesDetails method. This method returns all the observation modes with their status.\nType definitions of getObsModesDetails method can be found here\nThe following example shows how to call getObsModesDetails method:\nTypescript copysourceconst obsModesDetailsResponse: ObsModesDetailsResponse = await sequenceManagerService.getObsModesDetails()","title":"Getting ObsModes Details"},{"location":"/technical/sequence-manager-service.html#starting-a-sequencer","text":"To start a Sequencer, SequenceManagerService provides startSequencer method. This method starts the sequencer for given subsystem and observation mode. It uses the subsystem’s sequence component, if not available, fallbacks to ESW sequence component.\nType definitions of startSequencer method can be found here\nThe following example shows how to call startSequencer method:\nTypescript copysourceconst startSequencerResponse: StartSequencerResponse = await sequenceManagerService.startSequencer('IRIS', obsMode)","title":"Starting a Sequencer"},{"location":"/technical/sequence-manager-service.html#restarting-a-sequencer","text":"To restart a Sequencer, SequenceManagerService provides restartSequencer method. This method restarts the existing running sequencer of given subsystem and observing mode.\nType definitions of restartSequencer method can be found here\nThe following example shows how to call restartSequencer method:\nTypescript copysourceconst restartSequencerResponse: RestartSequencerResponse = await sequenceManagerService.restartSequencer(\n  'IRIS',\n  obsMode\n)","title":"Restarting a Sequencer"},{"location":"/technical/sequence-manager-service.html#shutting-down-sequencers","text":"To shut down one or more Sequencer, SequenceManagerService provides following methods:\nshutdownSequencer - This method shuts down the running sequencer of given subsystem and observation mode.\nTypescript copysourceconst shutdownSequencerResponse: ShutdownSequencersResponse = await sequenceManagerService.shutdownSequencer(\n  'IRIS',\n  obsMode\n)\nshutdownSubsystemSequencers - This method shuts down all the running sequencers of given subsystem.\nTypescript copysourceconst shutdownSubsystemSeqResponse: ShutdownSequencersResponse =\n  await sequenceManagerService.shutdownSubsystemSequencers('IRIS')\nshutdownObsModeSequencers - This method shuts down all the running sequencers of given observation mode.\nTypescript copysourceconst shutdownObsModeSeqResponse: ShutdownSequencersResponse = await sequenceManagerService.shutdownObsModeSequencers(\n  obsMode\n)\nshutdownAllSequencers - This method shuts down all the running sequencers.\nTypescript copysourceconst shutdownAllSequencersResponse: ShutdownSequencersResponse = await sequenceManagerService.shutdownAllSequencers()\nType definitions of these methods are below:\nshutdownSequencer shutdownSubsystemSequencers shutdownObsModeSequencers shutdownAllSequencers","title":"Shutting down Sequencers"},{"location":"/technical/sequence-manager-service.html#shutting-down-sequence-components","text":"To shut down one or more Sequence Components, SequenceManagerService provides following methods:\nshutdownSequenceComponent - This method shuts down sequence component with provided prefix.\nTypescript copysourceconst seqCompPrefix = new Prefix('ESW', 'ESW.ESW_1')\nconst shutdownSeqCompResponse: ShutdownSequenceComponentResponse =\n  await sequenceManagerService.shutdownSequenceComponent(seqCompPrefix)\nshutdownAllSequenceComponents - This method shuts down all the sequence components.\nTypescript copysourceconst shutdownAllSeqCompResponse: ShutdownSequenceComponentResponse =\n  await sequenceManagerService.shutdownAllSequenceComponents()\nType definitions of these methods are below:\nshutdownSequenceComponent shutdownAllSequenceComponents","title":"Shutting down Sequence Components"},{"location":"/technical/sequence-manager-service.html#getting-resources-status","text":"To get all Resources Status, SequenceManagerService provides getResources method. This method returns all the resources with their status(Available | InUse), if resource is in use it will also send obsMode along with it.\nType definations of getResources method can be found here\nThe following example shows how to call getResources method:\nTypescript copysourceconst resourcesStatus: ResourcesStatusResponse = await sequenceManagerService.getResources()","title":"Getting Resources Status"},{"location":"/technical/auth-components.html","text":"","title":"Auth Components"},{"location":"/technical/auth-components.html#auth-components","text":"esw-ts exposes react components to enable authentication and authorization. It is built in TypeScript on top of keycloak-js which is JavaScript adapter provided by Keycloak.","title":"Auth Components"},{"location":"/technical/auth-components.html#implementation","text":"Core implementation of Auth Components of ESW-TS, uses\nkeycloak-js - keycloak JavaScript adapter React - JavaScript library for building user interfaces Typescript - Types superset of JavaScript which compiles to JavaScript csw-location-service - resolve keycloak using Location Service HTTP endpoint","title":"Implementation"},{"location":"/technical/auth-components.html#keycloak","text":"In order for web application utilize keycloak following steps are needed:\nRegistered web application as a public keycloak client Please refer to keycloak documentation for details. Create new Keycloak client instance This instantiation expects config which includes keycloak server URL and some application specific config like realm and clientId. Auth Service uses CSW Location Service to resolve keycloak server.\nSee, how to configure realm & client-id here\nTo call secure end point, web application first needs to be authenticated using keycloak server. There are two options to make this adapter automatically authenticate - login-required and check-sso. login-required will automatically authenticate if the user is already logged-in, otherwise it will display keycloak login page. check-sso will only authenticate if the user is already logged-in. If the user is not logged-in the browser will be redirected back to the application and remain unauthenticated.\nAuth components of ESW-TS use check-sso to instantiate keycloak. It shows secure components if user is already logged in. If user is not authenticated then Login component gets rendered. If user clicks on login button, it instantiates keycloak using login-required. This redirects user to keycloak login page. As access token has very short life span, at time of keycloak instantiation, these Auth Components also add hooks to refresh token. This gives seamless user experience as user will not have to login again.\nKeycloak adapter supports three authorization flows e.g. authorization code flow, implicit flow and hybrid flow. Auth components in ESW-TS, uses hybrid flow as it has better performance than authorization code flow and unlike implicit flow, hybrid flow makes refresh token available to application. For more information please refer keyclok documentaion for authorization flows.","title":"Keycloak"},{"location":"/technical/auth-components.html#working-of-auth-components","text":"When user opens Web application in the browser:\nAuthContextProvider component gets mounted. Which does instantiation of keycloak client and initialize keycloak JavaScript adapter with check-sso and hybrid authorization flow. It also creates hooks for refreshing token, and when token expires it silently refreshes token resulting seamless user experience once logged in. After authentication is done via keycloak JavaScript adapter, AuthContext is extracted in domain model and this data is passed down the component tree using React Context API. AuthContext gives handle to token, realm and resource roles, userInfo. Any component which want to use this information can become consumer of AuthContext.\nFor example:\nTypescript copysourceconst { auth } = useContext(authContext)\nAccess token can be extracted from auth and it can be sent in Authorization header for calling secure API.\nFor example:\nconst SampleComponent = () => {\n\n    const url = 'http://localhost:8080/secure-restful-service';\n    const auth = useContext(AuthContext) //AuthContext from esw-ts\n\n    const req = new XMLHttpRequest();\n    req.open('GET', url, true);\n    req.setRequestHeader('Accept', 'application/json');\n\n    //extract token from auth context and set Authorization header\n    req.setRequestHeader('Authorization', 'Bearer ' + auth.token);\n\n    req.onreadystatechange = function () {\n        if (req.readyState == 4) {\n            if (req.status == 200) {\n                alert('Success');\n            } else if (req.status == 403) {\n                alert('Forbidden');\n            }\n        }\n    }\n\n    req.send();\n};\nThe following diagram explains JavaScript application flow for making request to secure HTTP API:\nWhen user opens Web application in the browser, csw-aas-js checks if user is already logged in using check-sso mode. If user is not logged in then Login button is shown. When user clicks on “login”, user will be redirected to keyclok login page. This completes authentication process. Once authentication is done, AuthContextProvider extracts AuthContext domain model and make it available to consumers of AuthContext. Protected react components can be shown based on information in AuthContext. For example, CreateConfig component can be shown only to users having config admin role. After the user is authenticated the application can make requests to RESTful services secured by Keycloak by including the bearer token in the Authorization header. This completes workflow for web application calling secure HTTP endpoint.","title":"Working of Auth Components"},{"location":"/common/contract.html","text":"","title":"Service Contract"},{"location":"/common/contract.html#service-contract","text":"All ESW-TS services adhere to contracts which are defined by ESW and CSW services.\nThe following are the links for each of the backend service contract.\nESW Services Contract Event Service Admin Service Alarm Service Logging Service Sequencer Service Agent Service Sequence Manager Service CSW Services Contract Location Service Command Service Config Service\nNote Event, Admin, Alarm, Logging will be accessed via the Gateway Server. therefore, the links are pointing to the Gateway Service contract.","title":"Service Contract"},{"location":"/common/ts-docs.html","text":"","title":"Type Definitions"},{"location":"/common/ts-docs.html#type-definitions","text":"Type definitions for following can be found by their corresponding links:\nAll Services React Components App Configurations Models","title":"Type Definitions"}]}